
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model Coordinate
 * 
 */
export type Coordinate = {
  longitude: number
  latitude: number
}

/**
 * Model Address
 * 
 */
export type Address = {
  provinsi: string
  kabupaten: string
  kecamatan: string
  kelurahan: string
  kodepos: string
  coordinate: Coordinate
}

/**
 * Model Born
 * 
 */
export type Born = {
  place: string
  date: string
}

/**
 * Model Education
 * 
 */
export type Education = {
  instansi: string
  level: LevelEdu
  major: string | null
  year: number
  attachment: string | null
}

/**
 * Model Training
 * 
 */
export type Training = {
  name: string
  instansi: string
  long: number
  year: number
  place: string
  attachment: string | null
}

/**
 * Model Profession
 * 
 */
export type Profession = {
  name: string
  instansi: string
  year: number
  attachment: string | null
}

/**
 * Model Employment
 * 
 */
export type Employment = {
  position: string
  year: number
  place: string
  note: string | null
}

/**
 * Model Overseas
 * 
 */
export type Overseas = {
  country: string
  instansi: string
  objective: string
  long: number
  year: number
  attachment: string | null
}

/**
 * Model Scientific
 * 
 */
export type Scientific = {
  name: string
  instansi: string
  position: string
  place: string
  period: string
  attachment: string | null
}

/**
 * Model Organization
 * 
 */
export type Organization = {
  name: string
  position: string
  period: string
  leader: string
  place: string
}

/**
 * Model Papers
 * 
 */
export type Papers = {
  name: string
  year: number
  published: string
}

/**
 * Model Innovation
 * 
 */
export type Innovation = {
  name: string
  year: number
  patent: boolean
}

/**
 * Model Award
 * 
 */
export type Award = {
  name: string
  year: number
  instansi: string
  attachment: string | null
}

/**
 * Model SourcePerson
 * 
 */
export type SourcePerson = {
  name: string
  date: string
  instansi: string
  note: string | null
  attachment: string | null
}

/**
 * Model Contest
 * 
 */
export type Contest = {
  name: string
  date: string
  instansi: string
  level: string
  attachment: string | null
}

/**
 * Model Documents
 * 
 */
export type Documents = {
  name: string
  date: string
  instansi: string
  note: string | null
  attachment: string | null
}

/**
 * Model Additional
 * 
 */
export type Additional = {
  position: string
  date: string
  instansi: string
  note: string | null
  attachment: string | null
}

/**
 * Model Organizational
 * 
 */
export type Organizational = {
  kepsek: string
  wakasek: string
  wakakur: string
  wakasiw: string
  wakapra: string
  wakahum: string | null
}

/**
 * Model BidangKeahlian
 * 
 */
export type BidangKeahlian = {
  id: string
  code: string
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ProgramKeahlian
 * 
 */
export type ProgramKeahlian = {
  id: string
  code: string
  name: string
  bidangId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model KonsentrasiKeahlian
 * 
 */
export type KonsentrasiKeahlian = {
  id: string
  code: string
  name: string
  programId: string
  tahun: number
  createdAt: Date
  updatedAt: Date
  instansiIds: string[]
}

/**
 * Model Achievement
 * 
 */
export type Achievement = {
  id: string
  fase: Fase
  description: string
  elementId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Element
 * 
 */
export type Element = {
  id: string
  name: string
  description: string
  mapelId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model MataPelajaran
 * 
 */
export type MataPelajaran = {
  id: string
  code: string
  name: string
  religion: Religion | null
  vocational: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Instansi
 * 
 */
export type Instansi = {
  id: string
  npsn: string
  name: string
  isPrivate: boolean
  address: Address
  level: Level
  religion: Religion | null
  major: boolean | null
  majorIds: string[]
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Role
 * 
 */
export type Role = {
  id: string
  key: Roles
  instansiId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model User
 * 
 */
export type User = {
  id: string
  name: string
  picture: string | null
  username: string
  active: boolean
  verify: boolean
  password: string
  passhash: string
  createdAt: Date
  updatedAt: Date
  roleId: string | null
}

/**
 * Model Personal
 * 
 */
export type Personal = {
  id: string
  nik: string | null
  nisn: string | null
  type: TypePersonal
  userId: string | null
  fullname: string
  gender: Gender
  foreign: boolean
  country: string | null
  religion: Religion
  born: Born
  email: string
  belajarId: string | null
  nophone: string
  isLife: boolean | null
  address: Address | null
}

/**
 * Model FamilyTree
 * 
 */
export type FamilyTree = {
  id: string
  nokk: string
  fatherId: string | null
  motherId: string | null
  waliId: string | null
  address: Address
}

/**
 * Model FamilyTreeChild
 * 
 */
export type FamilyTreeChild = {
  id: string
  no: number
  type: ChildType
  kkId: string
  personalId: string
}

/**
 * Model Student
 * 
 */
export type Student = {
  id: string
  userId: string | null
  majorId: string | null
  classRoomIds: string[]
  startYearId: string
  instansiId: string
  eventIds: string[]
}

/**
 * Model Teacher
 * 
 */
export type Teacher = {
  id: string
  userId: string | null
  instansiId: string
  eventIds: string[]
  nip: string | null
  nrg: string | null
  noKarpeg: string | null
  tmtTugas: string | null
  tmtGol: string | null
  position: string | null
  rank: string | null
  period: string | null
  certificate: string | null
  education: Education[]
  training: Training[]
  employment: Employment[]
  profession: Profession[]
  overseas: Overseas[]
  scientific: Scientific[]
  organization: Organization[]
  papers: Papers[]
  innovation: Innovation[]
  award: Award[]
  sourcePerson: SourcePerson[]
  contest: Contest[]
  documents: Documents[]
  additional: Additional[]
}

/**
 * Model ClassRoom
 * 
 */
export type ClassRoom = {
  id: string
  name: string
  yearId: string
  waliId: string
  studentIds: string[]
  eventIds: string[]
}

/**
 * Model SchoolYear
 * 
 */
export type SchoolYear = {
  id: string
  year: number
  instansiId: string
  organizational: Organizational
}

/**
 * Model Calendar
 * 
 */
export type Calendar = {
  id: string
  refId: string
  name: string
  description: string | null
  start: Date
  end: Date | null
  color: string
  classRoomIds: string[]
  studentIds: string[]
  teacherIds: string[]
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const ChildType: {
  KANDUNG: 'KANDUNG',
  TIRI: 'TIRI',
  ANGKAT: 'ANGKAT'
};

export type ChildType = (typeof ChildType)[keyof typeof ChildType]


export const Fase: {
  A: 'A',
  B: 'B',
  C: 'C',
  D: 'D',
  E: 'E',
  F: 'F',
  FP: 'FP'
};

export type Fase = (typeof Fase)[keyof typeof Fase]


export const Gender: {
  L: 'L',
  P: 'P'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const Level: {
  SD: 'SD',
  SMP: 'SMP',
  SMA: 'SMA',
  SMK: 'SMK'
};

export type Level = (typeof Level)[keyof typeof Level]


export const LevelEdu: {
  SD: 'SD',
  SMP: 'SMP',
  SMA: 'SMA',
  D1: 'D1',
  D2: 'D2',
  D3: 'D3',
  D4: 'D4',
  S1: 'S1',
  S2: 'S2',
  S3: 'S3'
};

export type LevelEdu = (typeof LevelEdu)[keyof typeof LevelEdu]


export const Religion: {
  Islam: 'Islam',
  Protestan: 'Protestan',
  Katolik: 'Katolik',
  Hindu: 'Hindu',
  Buddha: 'Buddha',
  Khonghucu: 'Khonghucu'
};

export type Religion = (typeof Religion)[keyof typeof Religion]


export const Roles: {
  SU: 'SU',
  GURU: 'GURU',
  STAF: 'STAF',
  SISWA: 'SISWA'
};

export type Roles = (typeof Roles)[keyof typeof Roles]


export const TypePersonal: {
  ADMIN: 'ADMIN',
  GURU: 'GURU',
  SISWA: 'SISWA',
  IBU: 'IBU',
  AYAH: 'AYAH',
  WALI: 'WALI'
};

export type TypePersonal = (typeof TypePersonal)[keyof typeof TypePersonal]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more BidangKeahlians
 * const bidangKeahlians = await prisma.bidangKeahlian.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more BidangKeahlians
   * const bidangKeahlians = await prisma.bidangKeahlian.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number }): Promise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

      /**
   * `prisma.bidangKeahlian`: Exposes CRUD operations for the **BidangKeahlian** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BidangKeahlians
    * const bidangKeahlians = await prisma.bidangKeahlian.findMany()
    * ```
    */
  get bidangKeahlian(): Prisma.BidangKeahlianDelegate<GlobalReject>;

  /**
   * `prisma.programKeahlian`: Exposes CRUD operations for the **ProgramKeahlian** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgramKeahlians
    * const programKeahlians = await prisma.programKeahlian.findMany()
    * ```
    */
  get programKeahlian(): Prisma.ProgramKeahlianDelegate<GlobalReject>;

  /**
   * `prisma.konsentrasiKeahlian`: Exposes CRUD operations for the **KonsentrasiKeahlian** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KonsentrasiKeahlians
    * const konsentrasiKeahlians = await prisma.konsentrasiKeahlian.findMany()
    * ```
    */
  get konsentrasiKeahlian(): Prisma.KonsentrasiKeahlianDelegate<GlobalReject>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<GlobalReject>;

  /**
   * `prisma.element`: Exposes CRUD operations for the **Element** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Elements
    * const elements = await prisma.element.findMany()
    * ```
    */
  get element(): Prisma.ElementDelegate<GlobalReject>;

  /**
   * `prisma.mataPelajaran`: Exposes CRUD operations for the **MataPelajaran** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MataPelajarans
    * const mataPelajarans = await prisma.mataPelajaran.findMany()
    * ```
    */
  get mataPelajaran(): Prisma.MataPelajaranDelegate<GlobalReject>;

  /**
   * `prisma.instansi`: Exposes CRUD operations for the **Instansi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Instansis
    * const instansis = await prisma.instansi.findMany()
    * ```
    */
  get instansi(): Prisma.InstansiDelegate<GlobalReject>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.personal`: Exposes CRUD operations for the **Personal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Personals
    * const personals = await prisma.personal.findMany()
    * ```
    */
  get personal(): Prisma.PersonalDelegate<GlobalReject>;

  /**
   * `prisma.familyTree`: Exposes CRUD operations for the **FamilyTree** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FamilyTrees
    * const familyTrees = await prisma.familyTree.findMany()
    * ```
    */
  get familyTree(): Prisma.FamilyTreeDelegate<GlobalReject>;

  /**
   * `prisma.familyTreeChild`: Exposes CRUD operations for the **FamilyTreeChild** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FamilyTreeChildren
    * const familyTreeChildren = await prisma.familyTreeChild.findMany()
    * ```
    */
  get familyTreeChild(): Prisma.FamilyTreeChildDelegate<GlobalReject>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<GlobalReject>;

  /**
   * `prisma.teacher`: Exposes CRUD operations for the **Teacher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teacher.findMany()
    * ```
    */
  get teacher(): Prisma.TeacherDelegate<GlobalReject>;

  /**
   * `prisma.classRoom`: Exposes CRUD operations for the **ClassRoom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassRooms
    * const classRooms = await prisma.classRoom.findMany()
    * ```
    */
  get classRoom(): Prisma.ClassRoomDelegate<GlobalReject>;

  /**
   * `prisma.schoolYear`: Exposes CRUD operations for the **SchoolYear** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolYears
    * const schoolYears = await prisma.schoolYear.findMany()
    * ```
    */
  get schoolYear(): Prisma.SchoolYearDelegate<GlobalReject>;

  /**
   * `prisma.calendar`: Exposes CRUD operations for the **Calendar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Calendars
    * const calendars = await prisma.calendar.findMany()
    * ```
    */
  get calendar(): Prisma.CalendarDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.12.0
   * Query Engine version: 659ef412370fa3b41cd7bf6e94587c1dfb7f67e7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    BidangKeahlian: 'BidangKeahlian',
    ProgramKeahlian: 'ProgramKeahlian',
    KonsentrasiKeahlian: 'KonsentrasiKeahlian',
    Achievement: 'Achievement',
    Element: 'Element',
    MataPelajaran: 'MataPelajaran',
    Instansi: 'Instansi',
    Role: 'Role',
    User: 'User',
    Personal: 'Personal',
    FamilyTree: 'FamilyTree',
    FamilyTreeChild: 'FamilyTreeChild',
    Student: 'Student',
    Teacher: 'Teacher',
    ClassRoom: 'ClassRoom',
    SchoolYear: 'SchoolYear',
    Calendar: 'Calendar'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BidangKeahlianCountOutputType
   */


  export type BidangKeahlianCountOutputType = {
    program: number
  }

  export type BidangKeahlianCountOutputTypeSelect = {
    program?: boolean
  }

  export type BidangKeahlianCountOutputTypeGetPayload<S extends boolean | null | undefined | BidangKeahlianCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BidangKeahlianCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BidangKeahlianCountOutputTypeArgs)
    ? BidangKeahlianCountOutputType 
    : S extends { select: any } & (BidangKeahlianCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BidangKeahlianCountOutputType ? BidangKeahlianCountOutputType[P] : never
  } 
      : BidangKeahlianCountOutputType




  // Custom InputTypes

  /**
   * BidangKeahlianCountOutputType without action
   */
  export type BidangKeahlianCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BidangKeahlianCountOutputType
     */
    select?: BidangKeahlianCountOutputTypeSelect | null
  }



  /**
   * Count Type ProgramKeahlianCountOutputType
   */


  export type ProgramKeahlianCountOutputType = {
    konsentrasi: number
  }

  export type ProgramKeahlianCountOutputTypeSelect = {
    konsentrasi?: boolean
  }

  export type ProgramKeahlianCountOutputTypeGetPayload<S extends boolean | null | undefined | ProgramKeahlianCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProgramKeahlianCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProgramKeahlianCountOutputTypeArgs)
    ? ProgramKeahlianCountOutputType 
    : S extends { select: any } & (ProgramKeahlianCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProgramKeahlianCountOutputType ? ProgramKeahlianCountOutputType[P] : never
  } 
      : ProgramKeahlianCountOutputType




  // Custom InputTypes

  /**
   * ProgramKeahlianCountOutputType without action
   */
  export type ProgramKeahlianCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProgramKeahlianCountOutputType
     */
    select?: ProgramKeahlianCountOutputTypeSelect | null
  }



  /**
   * Count Type KonsentrasiKeahlianCountOutputType
   */


  export type KonsentrasiKeahlianCountOutputType = {
    student: number
    instansi: number
  }

  export type KonsentrasiKeahlianCountOutputTypeSelect = {
    student?: boolean
    instansi?: boolean
  }

  export type KonsentrasiKeahlianCountOutputTypeGetPayload<S extends boolean | null | undefined | KonsentrasiKeahlianCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? KonsentrasiKeahlianCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (KonsentrasiKeahlianCountOutputTypeArgs)
    ? KonsentrasiKeahlianCountOutputType 
    : S extends { select: any } & (KonsentrasiKeahlianCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof KonsentrasiKeahlianCountOutputType ? KonsentrasiKeahlianCountOutputType[P] : never
  } 
      : KonsentrasiKeahlianCountOutputType




  // Custom InputTypes

  /**
   * KonsentrasiKeahlianCountOutputType without action
   */
  export type KonsentrasiKeahlianCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlianCountOutputType
     */
    select?: KonsentrasiKeahlianCountOutputTypeSelect | null
  }



  /**
   * Count Type ElementCountOutputType
   */


  export type ElementCountOutputType = {
    achievement: number
  }

  export type ElementCountOutputTypeSelect = {
    achievement?: boolean
  }

  export type ElementCountOutputTypeGetPayload<S extends boolean | null | undefined | ElementCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ElementCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ElementCountOutputTypeArgs)
    ? ElementCountOutputType 
    : S extends { select: any } & (ElementCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ElementCountOutputType ? ElementCountOutputType[P] : never
  } 
      : ElementCountOutputType




  // Custom InputTypes

  /**
   * ElementCountOutputType without action
   */
  export type ElementCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ElementCountOutputType
     */
    select?: ElementCountOutputTypeSelect | null
  }



  /**
   * Count Type MataPelajaranCountOutputType
   */


  export type MataPelajaranCountOutputType = {
    element: number
  }

  export type MataPelajaranCountOutputTypeSelect = {
    element?: boolean
  }

  export type MataPelajaranCountOutputTypeGetPayload<S extends boolean | null | undefined | MataPelajaranCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MataPelajaranCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MataPelajaranCountOutputTypeArgs)
    ? MataPelajaranCountOutputType 
    : S extends { select: any } & (MataPelajaranCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MataPelajaranCountOutputType ? MataPelajaranCountOutputType[P] : never
  } 
      : MataPelajaranCountOutputType




  // Custom InputTypes

  /**
   * MataPelajaranCountOutputType without action
   */
  export type MataPelajaranCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MataPelajaranCountOutputType
     */
    select?: MataPelajaranCountOutputTypeSelect | null
  }



  /**
   * Count Type InstansiCountOutputType
   */


  export type InstansiCountOutputType = {
    majors: number
    role: number
    schoolYear: number
    teacher: number
    student: number
  }

  export type InstansiCountOutputTypeSelect = {
    majors?: boolean
    role?: boolean
    schoolYear?: boolean
    teacher?: boolean
    student?: boolean
  }

  export type InstansiCountOutputTypeGetPayload<S extends boolean | null | undefined | InstansiCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? InstansiCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (InstansiCountOutputTypeArgs)
    ? InstansiCountOutputType 
    : S extends { select: any } & (InstansiCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof InstansiCountOutputType ? InstansiCountOutputType[P] : never
  } 
      : InstansiCountOutputType




  // Custom InputTypes

  /**
   * InstansiCountOutputType without action
   */
  export type InstansiCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the InstansiCountOutputType
     */
    select?: InstansiCountOutputTypeSelect | null
  }



  /**
   * Count Type RoleCountOutputType
   */


  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect = {
    users?: boolean
  }

  export type RoleCountOutputTypeGetPayload<S extends boolean | null | undefined | RoleCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RoleCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RoleCountOutputTypeArgs)
    ? RoleCountOutputType 
    : S extends { select: any } & (RoleCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RoleCountOutputType ? RoleCountOutputType[P] : never
  } 
      : RoleCountOutputType




  // Custom InputTypes

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect | null
  }



  /**
   * Count Type PersonalCountOutputType
   */


  export type PersonalCountOutputType = {
    father: number
    mother: number
    wali: number
  }

  export type PersonalCountOutputTypeSelect = {
    father?: boolean
    mother?: boolean
    wali?: boolean
  }

  export type PersonalCountOutputTypeGetPayload<S extends boolean | null | undefined | PersonalCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PersonalCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PersonalCountOutputTypeArgs)
    ? PersonalCountOutputType 
    : S extends { select: any } & (PersonalCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PersonalCountOutputType ? PersonalCountOutputType[P] : never
  } 
      : PersonalCountOutputType




  // Custom InputTypes

  /**
   * PersonalCountOutputType without action
   */
  export type PersonalCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PersonalCountOutputType
     */
    select?: PersonalCountOutputTypeSelect | null
  }



  /**
   * Count Type FamilyTreeCountOutputType
   */


  export type FamilyTreeCountOutputType = {
    childs: number
  }

  export type FamilyTreeCountOutputTypeSelect = {
    childs?: boolean
  }

  export type FamilyTreeCountOutputTypeGetPayload<S extends boolean | null | undefined | FamilyTreeCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FamilyTreeCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FamilyTreeCountOutputTypeArgs)
    ? FamilyTreeCountOutputType 
    : S extends { select: any } & (FamilyTreeCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FamilyTreeCountOutputType ? FamilyTreeCountOutputType[P] : never
  } 
      : FamilyTreeCountOutputType




  // Custom InputTypes

  /**
   * FamilyTreeCountOutputType without action
   */
  export type FamilyTreeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FamilyTreeCountOutputType
     */
    select?: FamilyTreeCountOutputTypeSelect | null
  }



  /**
   * Count Type StudentCountOutputType
   */


  export type StudentCountOutputType = {
    classRoom: number
    event: number
  }

  export type StudentCountOutputTypeSelect = {
    classRoom?: boolean
    event?: boolean
  }

  export type StudentCountOutputTypeGetPayload<S extends boolean | null | undefined | StudentCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? StudentCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (StudentCountOutputTypeArgs)
    ? StudentCountOutputType 
    : S extends { select: any } & (StudentCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof StudentCountOutputType ? StudentCountOutputType[P] : never
  } 
      : StudentCountOutputType




  // Custom InputTypes

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect | null
  }



  /**
   * Count Type TeacherCountOutputType
   */


  export type TeacherCountOutputType = {
    classRoom: number
    event: number
  }

  export type TeacherCountOutputTypeSelect = {
    classRoom?: boolean
    event?: boolean
  }

  export type TeacherCountOutputTypeGetPayload<S extends boolean | null | undefined | TeacherCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TeacherCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TeacherCountOutputTypeArgs)
    ? TeacherCountOutputType 
    : S extends { select: any } & (TeacherCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TeacherCountOutputType ? TeacherCountOutputType[P] : never
  } 
      : TeacherCountOutputType




  // Custom InputTypes

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TeacherCountOutputType
     */
    select?: TeacherCountOutputTypeSelect | null
  }



  /**
   * Count Type ClassRoomCountOutputType
   */


  export type ClassRoomCountOutputType = {
    students: number
    event: number
  }

  export type ClassRoomCountOutputTypeSelect = {
    students?: boolean
    event?: boolean
  }

  export type ClassRoomCountOutputTypeGetPayload<S extends boolean | null | undefined | ClassRoomCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ClassRoomCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ClassRoomCountOutputTypeArgs)
    ? ClassRoomCountOutputType 
    : S extends { select: any } & (ClassRoomCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ClassRoomCountOutputType ? ClassRoomCountOutputType[P] : never
  } 
      : ClassRoomCountOutputType




  // Custom InputTypes

  /**
   * ClassRoomCountOutputType without action
   */
  export type ClassRoomCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ClassRoomCountOutputType
     */
    select?: ClassRoomCountOutputTypeSelect | null
  }



  /**
   * Count Type SchoolYearCountOutputType
   */


  export type SchoolYearCountOutputType = {
    classRoom: number
    studentsIn: number
    calendar: number
  }

  export type SchoolYearCountOutputTypeSelect = {
    classRoom?: boolean
    studentsIn?: boolean
    calendar?: boolean
  }

  export type SchoolYearCountOutputTypeGetPayload<S extends boolean | null | undefined | SchoolYearCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SchoolYearCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (SchoolYearCountOutputTypeArgs)
    ? SchoolYearCountOutputType 
    : S extends { select: any } & (SchoolYearCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SchoolYearCountOutputType ? SchoolYearCountOutputType[P] : never
  } 
      : SchoolYearCountOutputType




  // Custom InputTypes

  /**
   * SchoolYearCountOutputType without action
   */
  export type SchoolYearCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SchoolYearCountOutputType
     */
    select?: SchoolYearCountOutputTypeSelect | null
  }



  /**
   * Count Type CalendarCountOutputType
   */


  export type CalendarCountOutputType = {
    classRoom: number
    student: number
    teacher: number
  }

  export type CalendarCountOutputTypeSelect = {
    classRoom?: boolean
    student?: boolean
    teacher?: boolean
  }

  export type CalendarCountOutputTypeGetPayload<S extends boolean | null | undefined | CalendarCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CalendarCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CalendarCountOutputTypeArgs)
    ? CalendarCountOutputType 
    : S extends { select: any } & (CalendarCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CalendarCountOutputType ? CalendarCountOutputType[P] : never
  } 
      : CalendarCountOutputType




  // Custom InputTypes

  /**
   * CalendarCountOutputType without action
   */
  export type CalendarCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CalendarCountOutputType
     */
    select?: CalendarCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Coordinate
   */





  export type CoordinateSelect = {
    longitude?: boolean
    latitude?: boolean
  }


  export type CoordinateGetPayload<S extends boolean | null | undefined | CoordinateArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Coordinate :
    S extends undefined ? never :
    S extends { include: any } & (CoordinateArgs)
    ? Coordinate 
    : S extends { select: any } & (CoordinateArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Coordinate ? Coordinate[P] : never
  } 
      : Coordinate



  export interface CoordinateDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Coordinate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CoordinateClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Coordinate without action
   */
  export type CoordinateArgs = {
    /**
     * Select specific fields to fetch from the Coordinate
     */
    select?: CoordinateSelect | null
  }



  /**
   * Model Address
   */





  export type AddressSelect = {
    provinsi?: boolean
    kabupaten?: boolean
    kecamatan?: boolean
    kelurahan?: boolean
    kodepos?: boolean
    coordinate?: boolean | CoordinateArgs
  }


  export type AddressInclude = {}

  export type AddressGetPayload<S extends boolean | null | undefined | AddressArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Address :
    S extends undefined ? never :
    S extends { include: any } & (AddressArgs)
    ? Address 
    : S extends { select: any } & (AddressArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'coordinate' ? CoordinateGetPayload<S['select'][P]> :  P extends keyof Address ? Address[P] : never
  } 
      : Address



  export interface AddressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AddressClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    coordinate<T extends CoordinateArgs= {}>(args?: Subset<T, CoordinateArgs>): Prisma__CoordinateClient<CoordinateGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Address without action
   */
  export type AddressArgs = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude | null
  }



  /**
   * Model Born
   */





  export type BornSelect = {
    place?: boolean
    date?: boolean
  }


  export type BornGetPayload<S extends boolean | null | undefined | BornArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Born :
    S extends undefined ? never :
    S extends { include: any } & (BornArgs)
    ? Born 
    : S extends { select: any } & (BornArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Born ? Born[P] : never
  } 
      : Born



  export interface BornDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Born.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BornClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Born without action
   */
  export type BornArgs = {
    /**
     * Select specific fields to fetch from the Born
     */
    select?: BornSelect | null
  }



  /**
   * Model Education
   */





  export type EducationSelect = {
    instansi?: boolean
    level?: boolean
    major?: boolean
    year?: boolean
    attachment?: boolean
  }


  export type EducationGetPayload<S extends boolean | null | undefined | EducationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Education :
    S extends undefined ? never :
    S extends { include: any } & (EducationArgs)
    ? Education 
    : S extends { select: any } & (EducationArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Education ? Education[P] : never
  } 
      : Education



  export interface EducationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Education.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EducationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Education without action
   */
  export type EducationArgs = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect | null
  }



  /**
   * Model Training
   */





  export type TrainingSelect = {
    name?: boolean
    instansi?: boolean
    long?: boolean
    year?: boolean
    place?: boolean
    attachment?: boolean
  }


  export type TrainingGetPayload<S extends boolean | null | undefined | TrainingArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Training :
    S extends undefined ? never :
    S extends { include: any } & (TrainingArgs)
    ? Training 
    : S extends { select: any } & (TrainingArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Training ? Training[P] : never
  } 
      : Training



  export interface TrainingDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Training.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TrainingClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Training without action
   */
  export type TrainingArgs = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect | null
  }



  /**
   * Model Profession
   */





  export type ProfessionSelect = {
    name?: boolean
    instansi?: boolean
    year?: boolean
    attachment?: boolean
  }


  export type ProfessionGetPayload<S extends boolean | null | undefined | ProfessionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Profession :
    S extends undefined ? never :
    S extends { include: any } & (ProfessionArgs)
    ? Profession 
    : S extends { select: any } & (ProfessionArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Profession ? Profession[P] : never
  } 
      : Profession



  export interface ProfessionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Profession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProfessionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Profession without action
   */
  export type ProfessionArgs = {
    /**
     * Select specific fields to fetch from the Profession
     */
    select?: ProfessionSelect | null
  }



  /**
   * Model Employment
   */





  export type EmploymentSelect = {
    position?: boolean
    year?: boolean
    place?: boolean
    note?: boolean
  }


  export type EmploymentGetPayload<S extends boolean | null | undefined | EmploymentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Employment :
    S extends undefined ? never :
    S extends { include: any } & (EmploymentArgs)
    ? Employment 
    : S extends { select: any } & (EmploymentArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Employment ? Employment[P] : never
  } 
      : Employment



  export interface EmploymentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Employment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EmploymentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Employment without action
   */
  export type EmploymentArgs = {
    /**
     * Select specific fields to fetch from the Employment
     */
    select?: EmploymentSelect | null
  }



  /**
   * Model Overseas
   */





  export type OverseasSelect = {
    country?: boolean
    instansi?: boolean
    objective?: boolean
    long?: boolean
    year?: boolean
    attachment?: boolean
  }


  export type OverseasGetPayload<S extends boolean | null | undefined | OverseasArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Overseas :
    S extends undefined ? never :
    S extends { include: any } & (OverseasArgs)
    ? Overseas 
    : S extends { select: any } & (OverseasArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Overseas ? Overseas[P] : never
  } 
      : Overseas



  export interface OverseasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Overseas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OverseasClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Overseas without action
   */
  export type OverseasArgs = {
    /**
     * Select specific fields to fetch from the Overseas
     */
    select?: OverseasSelect | null
  }



  /**
   * Model Scientific
   */





  export type ScientificSelect = {
    name?: boolean
    instansi?: boolean
    position?: boolean
    place?: boolean
    period?: boolean
    attachment?: boolean
  }


  export type ScientificGetPayload<S extends boolean | null | undefined | ScientificArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Scientific :
    S extends undefined ? never :
    S extends { include: any } & (ScientificArgs)
    ? Scientific 
    : S extends { select: any } & (ScientificArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Scientific ? Scientific[P] : never
  } 
      : Scientific



  export interface ScientificDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Scientific.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ScientificClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Scientific without action
   */
  export type ScientificArgs = {
    /**
     * Select specific fields to fetch from the Scientific
     */
    select?: ScientificSelect | null
  }



  /**
   * Model Organization
   */





  export type OrganizationSelect = {
    name?: boolean
    position?: boolean
    period?: boolean
    leader?: boolean
    place?: boolean
  }


  export type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Organization :
    S extends undefined ? never :
    S extends { include: any } & (OrganizationArgs)
    ? Organization 
    : S extends { select: any } & (OrganizationArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Organization ? Organization[P] : never
  } 
      : Organization



  export interface OrganizationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrganizationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Organization without action
   */
  export type OrganizationArgs = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect | null
  }



  /**
   * Model Papers
   */





  export type PapersSelect = {
    name?: boolean
    year?: boolean
    published?: boolean
  }


  export type PapersGetPayload<S extends boolean | null | undefined | PapersArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Papers :
    S extends undefined ? never :
    S extends { include: any } & (PapersArgs)
    ? Papers 
    : S extends { select: any } & (PapersArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Papers ? Papers[P] : never
  } 
      : Papers



  export interface PapersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Papers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PapersClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Papers without action
   */
  export type PapersArgs = {
    /**
     * Select specific fields to fetch from the Papers
     */
    select?: PapersSelect | null
  }



  /**
   * Model Innovation
   */





  export type InnovationSelect = {
    name?: boolean
    year?: boolean
    patent?: boolean
  }


  export type InnovationGetPayload<S extends boolean | null | undefined | InnovationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Innovation :
    S extends undefined ? never :
    S extends { include: any } & (InnovationArgs)
    ? Innovation 
    : S extends { select: any } & (InnovationArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Innovation ? Innovation[P] : never
  } 
      : Innovation



  export interface InnovationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Innovation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InnovationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Innovation without action
   */
  export type InnovationArgs = {
    /**
     * Select specific fields to fetch from the Innovation
     */
    select?: InnovationSelect | null
  }



  /**
   * Model Award
   */





  export type AwardSelect = {
    name?: boolean
    year?: boolean
    instansi?: boolean
    attachment?: boolean
  }


  export type AwardGetPayload<S extends boolean | null | undefined | AwardArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Award :
    S extends undefined ? never :
    S extends { include: any } & (AwardArgs)
    ? Award 
    : S extends { select: any } & (AwardArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Award ? Award[P] : never
  } 
      : Award



  export interface AwardDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Award.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AwardClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Award without action
   */
  export type AwardArgs = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect | null
  }



  /**
   * Model SourcePerson
   */





  export type SourcePersonSelect = {
    name?: boolean
    date?: boolean
    instansi?: boolean
    note?: boolean
    attachment?: boolean
  }


  export type SourcePersonGetPayload<S extends boolean | null | undefined | SourcePersonArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SourcePerson :
    S extends undefined ? never :
    S extends { include: any } & (SourcePersonArgs)
    ? SourcePerson 
    : S extends { select: any } & (SourcePersonArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SourcePerson ? SourcePerson[P] : never
  } 
      : SourcePerson



  export interface SourcePersonDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for SourcePerson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SourcePersonClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SourcePerson without action
   */
  export type SourcePersonArgs = {
    /**
     * Select specific fields to fetch from the SourcePerson
     */
    select?: SourcePersonSelect | null
  }



  /**
   * Model Contest
   */





  export type ContestSelect = {
    name?: boolean
    date?: boolean
    instansi?: boolean
    level?: boolean
    attachment?: boolean
  }


  export type ContestGetPayload<S extends boolean | null | undefined | ContestArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Contest :
    S extends undefined ? never :
    S extends { include: any } & (ContestArgs)
    ? Contest 
    : S extends { select: any } & (ContestArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Contest ? Contest[P] : never
  } 
      : Contest



  export interface ContestDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Contest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ContestClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Contest without action
   */
  export type ContestArgs = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect | null
  }



  /**
   * Model Documents
   */





  export type DocumentsSelect = {
    name?: boolean
    date?: boolean
    instansi?: boolean
    note?: boolean
    attachment?: boolean
  }


  export type DocumentsGetPayload<S extends boolean | null | undefined | DocumentsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Documents :
    S extends undefined ? never :
    S extends { include: any } & (DocumentsArgs)
    ? Documents 
    : S extends { select: any } & (DocumentsArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Documents ? Documents[P] : never
  } 
      : Documents



  export interface DocumentsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Documents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DocumentsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Documents without action
   */
  export type DocumentsArgs = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect | null
  }



  /**
   * Model Additional
   */





  export type AdditionalSelect = {
    position?: boolean
    date?: boolean
    instansi?: boolean
    note?: boolean
    attachment?: boolean
  }


  export type AdditionalGetPayload<S extends boolean | null | undefined | AdditionalArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Additional :
    S extends undefined ? never :
    S extends { include: any } & (AdditionalArgs)
    ? Additional 
    : S extends { select: any } & (AdditionalArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Additional ? Additional[P] : never
  } 
      : Additional



  export interface AdditionalDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Additional.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AdditionalClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Additional without action
   */
  export type AdditionalArgs = {
    /**
     * Select specific fields to fetch from the Additional
     */
    select?: AdditionalSelect | null
  }



  /**
   * Model Organizational
   */





  export type OrganizationalSelect = {
    kepsek?: boolean
    wakasek?: boolean
    wakakur?: boolean
    wakasiw?: boolean
    wakapra?: boolean
    wakahum?: boolean
  }


  export type OrganizationalGetPayload<S extends boolean | null | undefined | OrganizationalArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Organizational :
    S extends undefined ? never :
    S extends { include: any } & (OrganizationalArgs)
    ? Organizational 
    : S extends { select: any } & (OrganizationalArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Organizational ? Organizational[P] : never
  } 
      : Organizational



  export interface OrganizationalDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Organizational.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrganizationalClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Organizational without action
   */
  export type OrganizationalArgs = {
    /**
     * Select specific fields to fetch from the Organizational
     */
    select?: OrganizationalSelect | null
  }



  /**
   * Model BidangKeahlian
   */


  export type AggregateBidangKeahlian = {
    _count: BidangKeahlianCountAggregateOutputType | null
    _min: BidangKeahlianMinAggregateOutputType | null
    _max: BidangKeahlianMaxAggregateOutputType | null
  }

  export type BidangKeahlianMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BidangKeahlianMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BidangKeahlianCountAggregateOutputType = {
    id: number
    code: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BidangKeahlianMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BidangKeahlianMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BidangKeahlianCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BidangKeahlianAggregateArgs = {
    /**
     * Filter which BidangKeahlian to aggregate.
     */
    where?: BidangKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidangKeahlians to fetch.
     */
    orderBy?: Enumerable<BidangKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BidangKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidangKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidangKeahlians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BidangKeahlians
    **/
    _count?: true | BidangKeahlianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BidangKeahlianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BidangKeahlianMaxAggregateInputType
  }

  export type GetBidangKeahlianAggregateType<T extends BidangKeahlianAggregateArgs> = {
        [P in keyof T & keyof AggregateBidangKeahlian]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBidangKeahlian[P]>
      : GetScalarType<T[P], AggregateBidangKeahlian[P]>
  }




  export type BidangKeahlianGroupByArgs = {
    where?: BidangKeahlianWhereInput
    orderBy?: Enumerable<BidangKeahlianOrderByWithAggregationInput>
    by: BidangKeahlianScalarFieldEnum[]
    having?: BidangKeahlianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BidangKeahlianCountAggregateInputType | true
    _min?: BidangKeahlianMinAggregateInputType
    _max?: BidangKeahlianMaxAggregateInputType
  }


  export type BidangKeahlianGroupByOutputType = {
    id: string
    code: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: BidangKeahlianCountAggregateOutputType | null
    _min: BidangKeahlianMinAggregateOutputType | null
    _max: BidangKeahlianMaxAggregateOutputType | null
  }

  type GetBidangKeahlianGroupByPayload<T extends BidangKeahlianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BidangKeahlianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BidangKeahlianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BidangKeahlianGroupByOutputType[P]>
            : GetScalarType<T[P], BidangKeahlianGroupByOutputType[P]>
        }
      >
    >


  export type BidangKeahlianSelect = {
    id?: boolean
    code?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    program?: boolean | BidangKeahlian$programArgs
    _count?: boolean | BidangKeahlianCountOutputTypeArgs
  }


  export type BidangKeahlianInclude = {
    program?: boolean | BidangKeahlian$programArgs
    _count?: boolean | BidangKeahlianCountOutputTypeArgs
  }

  export type BidangKeahlianGetPayload<S extends boolean | null | undefined | BidangKeahlianArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BidangKeahlian :
    S extends undefined ? never :
    S extends { include: any } & (BidangKeahlianArgs | BidangKeahlianFindManyArgs)
    ? BidangKeahlian  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'program' ? Array < ProgramKeahlianGetPayload<S['include'][P]>>  :
        P extends '_count' ? BidangKeahlianCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BidangKeahlianArgs | BidangKeahlianFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'program' ? Array < ProgramKeahlianGetPayload<S['select'][P]>>  :
        P extends '_count' ? BidangKeahlianCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BidangKeahlian ? BidangKeahlian[P] : never
  } 
      : BidangKeahlian


  type BidangKeahlianCountArgs = 
    Omit<BidangKeahlianFindManyArgs, 'select' | 'include'> & {
      select?: BidangKeahlianCountAggregateInputType | true
    }

  export interface BidangKeahlianDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BidangKeahlian that matches the filter.
     * @param {BidangKeahlianFindUniqueArgs} args - Arguments to find a BidangKeahlian
     * @example
     * // Get one BidangKeahlian
     * const bidangKeahlian = await prisma.bidangKeahlian.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BidangKeahlianFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BidangKeahlianFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BidangKeahlian'> extends True ? Prisma__BidangKeahlianClient<BidangKeahlianGetPayload<T>> : Prisma__BidangKeahlianClient<BidangKeahlianGetPayload<T> | null, null>

    /**
     * Find one BidangKeahlian that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BidangKeahlianFindUniqueOrThrowArgs} args - Arguments to find a BidangKeahlian
     * @example
     * // Get one BidangKeahlian
     * const bidangKeahlian = await prisma.bidangKeahlian.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BidangKeahlianFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BidangKeahlianFindUniqueOrThrowArgs>
    ): Prisma__BidangKeahlianClient<BidangKeahlianGetPayload<T>>

    /**
     * Find the first BidangKeahlian that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidangKeahlianFindFirstArgs} args - Arguments to find a BidangKeahlian
     * @example
     * // Get one BidangKeahlian
     * const bidangKeahlian = await prisma.bidangKeahlian.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BidangKeahlianFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BidangKeahlianFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BidangKeahlian'> extends True ? Prisma__BidangKeahlianClient<BidangKeahlianGetPayload<T>> : Prisma__BidangKeahlianClient<BidangKeahlianGetPayload<T> | null, null>

    /**
     * Find the first BidangKeahlian that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidangKeahlianFindFirstOrThrowArgs} args - Arguments to find a BidangKeahlian
     * @example
     * // Get one BidangKeahlian
     * const bidangKeahlian = await prisma.bidangKeahlian.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BidangKeahlianFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BidangKeahlianFindFirstOrThrowArgs>
    ): Prisma__BidangKeahlianClient<BidangKeahlianGetPayload<T>>

    /**
     * Find zero or more BidangKeahlians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidangKeahlianFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BidangKeahlians
     * const bidangKeahlians = await prisma.bidangKeahlian.findMany()
     * 
     * // Get first 10 BidangKeahlians
     * const bidangKeahlians = await prisma.bidangKeahlian.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bidangKeahlianWithIdOnly = await prisma.bidangKeahlian.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BidangKeahlianFindManyArgs>(
      args?: SelectSubset<T, BidangKeahlianFindManyArgs>
    ): Prisma.PrismaPromise<Array<BidangKeahlianGetPayload<T>>>

    /**
     * Create a BidangKeahlian.
     * @param {BidangKeahlianCreateArgs} args - Arguments to create a BidangKeahlian.
     * @example
     * // Create one BidangKeahlian
     * const BidangKeahlian = await prisma.bidangKeahlian.create({
     *   data: {
     *     // ... data to create a BidangKeahlian
     *   }
     * })
     * 
    **/
    create<T extends BidangKeahlianCreateArgs>(
      args: SelectSubset<T, BidangKeahlianCreateArgs>
    ): Prisma__BidangKeahlianClient<BidangKeahlianGetPayload<T>>

    /**
     * Create many BidangKeahlians.
     *     @param {BidangKeahlianCreateManyArgs} args - Arguments to create many BidangKeahlians.
     *     @example
     *     // Create many BidangKeahlians
     *     const bidangKeahlian = await prisma.bidangKeahlian.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BidangKeahlianCreateManyArgs>(
      args?: SelectSubset<T, BidangKeahlianCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BidangKeahlian.
     * @param {BidangKeahlianDeleteArgs} args - Arguments to delete one BidangKeahlian.
     * @example
     * // Delete one BidangKeahlian
     * const BidangKeahlian = await prisma.bidangKeahlian.delete({
     *   where: {
     *     // ... filter to delete one BidangKeahlian
     *   }
     * })
     * 
    **/
    delete<T extends BidangKeahlianDeleteArgs>(
      args: SelectSubset<T, BidangKeahlianDeleteArgs>
    ): Prisma__BidangKeahlianClient<BidangKeahlianGetPayload<T>>

    /**
     * Update one BidangKeahlian.
     * @param {BidangKeahlianUpdateArgs} args - Arguments to update one BidangKeahlian.
     * @example
     * // Update one BidangKeahlian
     * const bidangKeahlian = await prisma.bidangKeahlian.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BidangKeahlianUpdateArgs>(
      args: SelectSubset<T, BidangKeahlianUpdateArgs>
    ): Prisma__BidangKeahlianClient<BidangKeahlianGetPayload<T>>

    /**
     * Delete zero or more BidangKeahlians.
     * @param {BidangKeahlianDeleteManyArgs} args - Arguments to filter BidangKeahlians to delete.
     * @example
     * // Delete a few BidangKeahlians
     * const { count } = await prisma.bidangKeahlian.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BidangKeahlianDeleteManyArgs>(
      args?: SelectSubset<T, BidangKeahlianDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BidangKeahlians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidangKeahlianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BidangKeahlians
     * const bidangKeahlian = await prisma.bidangKeahlian.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BidangKeahlianUpdateManyArgs>(
      args: SelectSubset<T, BidangKeahlianUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BidangKeahlian.
     * @param {BidangKeahlianUpsertArgs} args - Arguments to update or create a BidangKeahlian.
     * @example
     * // Update or create a BidangKeahlian
     * const bidangKeahlian = await prisma.bidangKeahlian.upsert({
     *   create: {
     *     // ... data to create a BidangKeahlian
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BidangKeahlian we want to update
     *   }
     * })
    **/
    upsert<T extends BidangKeahlianUpsertArgs>(
      args: SelectSubset<T, BidangKeahlianUpsertArgs>
    ): Prisma__BidangKeahlianClient<BidangKeahlianGetPayload<T>>

    /**
     * Find zero or more BidangKeahlians that matches the filter.
     * @param {BidangKeahlianFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const bidangKeahlian = await prisma.bidangKeahlian.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: BidangKeahlianFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a BidangKeahlian.
     * @param {BidangKeahlianAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const bidangKeahlian = await prisma.bidangKeahlian.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: BidangKeahlianAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of BidangKeahlians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidangKeahlianCountArgs} args - Arguments to filter BidangKeahlians to count.
     * @example
     * // Count the number of BidangKeahlians
     * const count = await prisma.bidangKeahlian.count({
     *   where: {
     *     // ... the filter for the BidangKeahlians we want to count
     *   }
     * })
    **/
    count<T extends BidangKeahlianCountArgs>(
      args?: Subset<T, BidangKeahlianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BidangKeahlianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BidangKeahlian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidangKeahlianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BidangKeahlianAggregateArgs>(args: Subset<T, BidangKeahlianAggregateArgs>): Prisma.PrismaPromise<GetBidangKeahlianAggregateType<T>>

    /**
     * Group by BidangKeahlian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidangKeahlianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BidangKeahlianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BidangKeahlianGroupByArgs['orderBy'] }
        : { orderBy?: BidangKeahlianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BidangKeahlianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBidangKeahlianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BidangKeahlian.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BidangKeahlianClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    program<T extends BidangKeahlian$programArgs= {}>(args?: Subset<T, BidangKeahlian$programArgs>): Prisma.PrismaPromise<Array<ProgramKeahlianGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BidangKeahlian base type for findUnique actions
   */
  export type BidangKeahlianFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BidangKeahlian
     */
    select?: BidangKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BidangKeahlianInclude | null
    /**
     * Filter, which BidangKeahlian to fetch.
     */
    where: BidangKeahlianWhereUniqueInput
  }

  /**
   * BidangKeahlian findUnique
   */
  export interface BidangKeahlianFindUniqueArgs extends BidangKeahlianFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BidangKeahlian findUniqueOrThrow
   */
  export type BidangKeahlianFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BidangKeahlian
     */
    select?: BidangKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BidangKeahlianInclude | null
    /**
     * Filter, which BidangKeahlian to fetch.
     */
    where: BidangKeahlianWhereUniqueInput
  }


  /**
   * BidangKeahlian base type for findFirst actions
   */
  export type BidangKeahlianFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BidangKeahlian
     */
    select?: BidangKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BidangKeahlianInclude | null
    /**
     * Filter, which BidangKeahlian to fetch.
     */
    where?: BidangKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidangKeahlians to fetch.
     */
    orderBy?: Enumerable<BidangKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BidangKeahlians.
     */
    cursor?: BidangKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidangKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidangKeahlians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BidangKeahlians.
     */
    distinct?: Enumerable<BidangKeahlianScalarFieldEnum>
  }

  /**
   * BidangKeahlian findFirst
   */
  export interface BidangKeahlianFindFirstArgs extends BidangKeahlianFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BidangKeahlian findFirstOrThrow
   */
  export type BidangKeahlianFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BidangKeahlian
     */
    select?: BidangKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BidangKeahlianInclude | null
    /**
     * Filter, which BidangKeahlian to fetch.
     */
    where?: BidangKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidangKeahlians to fetch.
     */
    orderBy?: Enumerable<BidangKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BidangKeahlians.
     */
    cursor?: BidangKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidangKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidangKeahlians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BidangKeahlians.
     */
    distinct?: Enumerable<BidangKeahlianScalarFieldEnum>
  }


  /**
   * BidangKeahlian findMany
   */
  export type BidangKeahlianFindManyArgs = {
    /**
     * Select specific fields to fetch from the BidangKeahlian
     */
    select?: BidangKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BidangKeahlianInclude | null
    /**
     * Filter, which BidangKeahlians to fetch.
     */
    where?: BidangKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidangKeahlians to fetch.
     */
    orderBy?: Enumerable<BidangKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BidangKeahlians.
     */
    cursor?: BidangKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidangKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidangKeahlians.
     */
    skip?: number
    distinct?: Enumerable<BidangKeahlianScalarFieldEnum>
  }


  /**
   * BidangKeahlian create
   */
  export type BidangKeahlianCreateArgs = {
    /**
     * Select specific fields to fetch from the BidangKeahlian
     */
    select?: BidangKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BidangKeahlianInclude | null
    /**
     * The data needed to create a BidangKeahlian.
     */
    data: XOR<BidangKeahlianCreateInput, BidangKeahlianUncheckedCreateInput>
  }


  /**
   * BidangKeahlian createMany
   */
  export type BidangKeahlianCreateManyArgs = {
    /**
     * The data used to create many BidangKeahlians.
     */
    data: Enumerable<BidangKeahlianCreateManyInput>
  }


  /**
   * BidangKeahlian update
   */
  export type BidangKeahlianUpdateArgs = {
    /**
     * Select specific fields to fetch from the BidangKeahlian
     */
    select?: BidangKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BidangKeahlianInclude | null
    /**
     * The data needed to update a BidangKeahlian.
     */
    data: XOR<BidangKeahlianUpdateInput, BidangKeahlianUncheckedUpdateInput>
    /**
     * Choose, which BidangKeahlian to update.
     */
    where: BidangKeahlianWhereUniqueInput
  }


  /**
   * BidangKeahlian updateMany
   */
  export type BidangKeahlianUpdateManyArgs = {
    /**
     * The data used to update BidangKeahlians.
     */
    data: XOR<BidangKeahlianUpdateManyMutationInput, BidangKeahlianUncheckedUpdateManyInput>
    /**
     * Filter which BidangKeahlians to update
     */
    where?: BidangKeahlianWhereInput
  }


  /**
   * BidangKeahlian upsert
   */
  export type BidangKeahlianUpsertArgs = {
    /**
     * Select specific fields to fetch from the BidangKeahlian
     */
    select?: BidangKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BidangKeahlianInclude | null
    /**
     * The filter to search for the BidangKeahlian to update in case it exists.
     */
    where: BidangKeahlianWhereUniqueInput
    /**
     * In case the BidangKeahlian found by the `where` argument doesn't exist, create a new BidangKeahlian with this data.
     */
    create: XOR<BidangKeahlianCreateInput, BidangKeahlianUncheckedCreateInput>
    /**
     * In case the BidangKeahlian was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BidangKeahlianUpdateInput, BidangKeahlianUncheckedUpdateInput>
  }


  /**
   * BidangKeahlian delete
   */
  export type BidangKeahlianDeleteArgs = {
    /**
     * Select specific fields to fetch from the BidangKeahlian
     */
    select?: BidangKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BidangKeahlianInclude | null
    /**
     * Filter which BidangKeahlian to delete.
     */
    where: BidangKeahlianWhereUniqueInput
  }


  /**
   * BidangKeahlian deleteMany
   */
  export type BidangKeahlianDeleteManyArgs = {
    /**
     * Filter which BidangKeahlians to delete
     */
    where?: BidangKeahlianWhereInput
  }


  /**
   * BidangKeahlian findRaw
   */
  export type BidangKeahlianFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * BidangKeahlian aggregateRaw
   */
  export type BidangKeahlianAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * BidangKeahlian.program
   */
  export type BidangKeahlian$programArgs = {
    /**
     * Select specific fields to fetch from the ProgramKeahlian
     */
    select?: ProgramKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramKeahlianInclude | null
    where?: ProgramKeahlianWhereInput
    orderBy?: Enumerable<ProgramKeahlianOrderByWithRelationInput>
    cursor?: ProgramKeahlianWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProgramKeahlianScalarFieldEnum>
  }


  /**
   * BidangKeahlian without action
   */
  export type BidangKeahlianArgs = {
    /**
     * Select specific fields to fetch from the BidangKeahlian
     */
    select?: BidangKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BidangKeahlianInclude | null
  }



  /**
   * Model ProgramKeahlian
   */


  export type AggregateProgramKeahlian = {
    _count: ProgramKeahlianCountAggregateOutputType | null
    _min: ProgramKeahlianMinAggregateOutputType | null
    _max: ProgramKeahlianMaxAggregateOutputType | null
  }

  export type ProgramKeahlianMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    bidangId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramKeahlianMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    bidangId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramKeahlianCountAggregateOutputType = {
    id: number
    code: number
    name: number
    bidangId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProgramKeahlianMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    bidangId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramKeahlianMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    bidangId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramKeahlianCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    bidangId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProgramKeahlianAggregateArgs = {
    /**
     * Filter which ProgramKeahlian to aggregate.
     */
    where?: ProgramKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramKeahlians to fetch.
     */
    orderBy?: Enumerable<ProgramKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramKeahlians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgramKeahlians
    **/
    _count?: true | ProgramKeahlianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramKeahlianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramKeahlianMaxAggregateInputType
  }

  export type GetProgramKeahlianAggregateType<T extends ProgramKeahlianAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramKeahlian]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramKeahlian[P]>
      : GetScalarType<T[P], AggregateProgramKeahlian[P]>
  }




  export type ProgramKeahlianGroupByArgs = {
    where?: ProgramKeahlianWhereInput
    orderBy?: Enumerable<ProgramKeahlianOrderByWithAggregationInput>
    by: ProgramKeahlianScalarFieldEnum[]
    having?: ProgramKeahlianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramKeahlianCountAggregateInputType | true
    _min?: ProgramKeahlianMinAggregateInputType
    _max?: ProgramKeahlianMaxAggregateInputType
  }


  export type ProgramKeahlianGroupByOutputType = {
    id: string
    code: string
    name: string
    bidangId: string
    createdAt: Date
    updatedAt: Date
    _count: ProgramKeahlianCountAggregateOutputType | null
    _min: ProgramKeahlianMinAggregateOutputType | null
    _max: ProgramKeahlianMaxAggregateOutputType | null
  }

  type GetProgramKeahlianGroupByPayload<T extends ProgramKeahlianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProgramKeahlianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramKeahlianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramKeahlianGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramKeahlianGroupByOutputType[P]>
        }
      >
    >


  export type ProgramKeahlianSelect = {
    id?: boolean
    code?: boolean
    name?: boolean
    bidangId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bidang?: boolean | BidangKeahlianArgs
    konsentrasi?: boolean | ProgramKeahlian$konsentrasiArgs
    _count?: boolean | ProgramKeahlianCountOutputTypeArgs
  }


  export type ProgramKeahlianInclude = {
    bidang?: boolean | BidangKeahlianArgs
    konsentrasi?: boolean | ProgramKeahlian$konsentrasiArgs
    _count?: boolean | ProgramKeahlianCountOutputTypeArgs
  }

  export type ProgramKeahlianGetPayload<S extends boolean | null | undefined | ProgramKeahlianArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProgramKeahlian :
    S extends undefined ? never :
    S extends { include: any } & (ProgramKeahlianArgs | ProgramKeahlianFindManyArgs)
    ? ProgramKeahlian  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'bidang' ? BidangKeahlianGetPayload<S['include'][P]> :
        P extends 'konsentrasi' ? Array < KonsentrasiKeahlianGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProgramKeahlianCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProgramKeahlianArgs | ProgramKeahlianFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'bidang' ? BidangKeahlianGetPayload<S['select'][P]> :
        P extends 'konsentrasi' ? Array < KonsentrasiKeahlianGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProgramKeahlianCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ProgramKeahlian ? ProgramKeahlian[P] : never
  } 
      : ProgramKeahlian


  type ProgramKeahlianCountArgs = 
    Omit<ProgramKeahlianFindManyArgs, 'select' | 'include'> & {
      select?: ProgramKeahlianCountAggregateInputType | true
    }

  export interface ProgramKeahlianDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ProgramKeahlian that matches the filter.
     * @param {ProgramKeahlianFindUniqueArgs} args - Arguments to find a ProgramKeahlian
     * @example
     * // Get one ProgramKeahlian
     * const programKeahlian = await prisma.programKeahlian.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProgramKeahlianFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProgramKeahlianFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProgramKeahlian'> extends True ? Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T>> : Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T> | null, null>

    /**
     * Find one ProgramKeahlian that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProgramKeahlianFindUniqueOrThrowArgs} args - Arguments to find a ProgramKeahlian
     * @example
     * // Get one ProgramKeahlian
     * const programKeahlian = await prisma.programKeahlian.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProgramKeahlianFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProgramKeahlianFindUniqueOrThrowArgs>
    ): Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T>>

    /**
     * Find the first ProgramKeahlian that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramKeahlianFindFirstArgs} args - Arguments to find a ProgramKeahlian
     * @example
     * // Get one ProgramKeahlian
     * const programKeahlian = await prisma.programKeahlian.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProgramKeahlianFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProgramKeahlianFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProgramKeahlian'> extends True ? Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T>> : Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T> | null, null>

    /**
     * Find the first ProgramKeahlian that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramKeahlianFindFirstOrThrowArgs} args - Arguments to find a ProgramKeahlian
     * @example
     * // Get one ProgramKeahlian
     * const programKeahlian = await prisma.programKeahlian.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProgramKeahlianFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProgramKeahlianFindFirstOrThrowArgs>
    ): Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T>>

    /**
     * Find zero or more ProgramKeahlians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramKeahlianFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgramKeahlians
     * const programKeahlians = await prisma.programKeahlian.findMany()
     * 
     * // Get first 10 ProgramKeahlians
     * const programKeahlians = await prisma.programKeahlian.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programKeahlianWithIdOnly = await prisma.programKeahlian.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProgramKeahlianFindManyArgs>(
      args?: SelectSubset<T, ProgramKeahlianFindManyArgs>
    ): Prisma.PrismaPromise<Array<ProgramKeahlianGetPayload<T>>>

    /**
     * Create a ProgramKeahlian.
     * @param {ProgramKeahlianCreateArgs} args - Arguments to create a ProgramKeahlian.
     * @example
     * // Create one ProgramKeahlian
     * const ProgramKeahlian = await prisma.programKeahlian.create({
     *   data: {
     *     // ... data to create a ProgramKeahlian
     *   }
     * })
     * 
    **/
    create<T extends ProgramKeahlianCreateArgs>(
      args: SelectSubset<T, ProgramKeahlianCreateArgs>
    ): Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T>>

    /**
     * Create many ProgramKeahlians.
     *     @param {ProgramKeahlianCreateManyArgs} args - Arguments to create many ProgramKeahlians.
     *     @example
     *     // Create many ProgramKeahlians
     *     const programKeahlian = await prisma.programKeahlian.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProgramKeahlianCreateManyArgs>(
      args?: SelectSubset<T, ProgramKeahlianCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProgramKeahlian.
     * @param {ProgramKeahlianDeleteArgs} args - Arguments to delete one ProgramKeahlian.
     * @example
     * // Delete one ProgramKeahlian
     * const ProgramKeahlian = await prisma.programKeahlian.delete({
     *   where: {
     *     // ... filter to delete one ProgramKeahlian
     *   }
     * })
     * 
    **/
    delete<T extends ProgramKeahlianDeleteArgs>(
      args: SelectSubset<T, ProgramKeahlianDeleteArgs>
    ): Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T>>

    /**
     * Update one ProgramKeahlian.
     * @param {ProgramKeahlianUpdateArgs} args - Arguments to update one ProgramKeahlian.
     * @example
     * // Update one ProgramKeahlian
     * const programKeahlian = await prisma.programKeahlian.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProgramKeahlianUpdateArgs>(
      args: SelectSubset<T, ProgramKeahlianUpdateArgs>
    ): Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T>>

    /**
     * Delete zero or more ProgramKeahlians.
     * @param {ProgramKeahlianDeleteManyArgs} args - Arguments to filter ProgramKeahlians to delete.
     * @example
     * // Delete a few ProgramKeahlians
     * const { count } = await prisma.programKeahlian.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProgramKeahlianDeleteManyArgs>(
      args?: SelectSubset<T, ProgramKeahlianDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramKeahlians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramKeahlianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgramKeahlians
     * const programKeahlian = await prisma.programKeahlian.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProgramKeahlianUpdateManyArgs>(
      args: SelectSubset<T, ProgramKeahlianUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProgramKeahlian.
     * @param {ProgramKeahlianUpsertArgs} args - Arguments to update or create a ProgramKeahlian.
     * @example
     * // Update or create a ProgramKeahlian
     * const programKeahlian = await prisma.programKeahlian.upsert({
     *   create: {
     *     // ... data to create a ProgramKeahlian
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgramKeahlian we want to update
     *   }
     * })
    **/
    upsert<T extends ProgramKeahlianUpsertArgs>(
      args: SelectSubset<T, ProgramKeahlianUpsertArgs>
    ): Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T>>

    /**
     * Find zero or more ProgramKeahlians that matches the filter.
     * @param {ProgramKeahlianFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const programKeahlian = await prisma.programKeahlian.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ProgramKeahlianFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ProgramKeahlian.
     * @param {ProgramKeahlianAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const programKeahlian = await prisma.programKeahlian.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ProgramKeahlianAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of ProgramKeahlians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramKeahlianCountArgs} args - Arguments to filter ProgramKeahlians to count.
     * @example
     * // Count the number of ProgramKeahlians
     * const count = await prisma.programKeahlian.count({
     *   where: {
     *     // ... the filter for the ProgramKeahlians we want to count
     *   }
     * })
    **/
    count<T extends ProgramKeahlianCountArgs>(
      args?: Subset<T, ProgramKeahlianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramKeahlianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgramKeahlian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramKeahlianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramKeahlianAggregateArgs>(args: Subset<T, ProgramKeahlianAggregateArgs>): Prisma.PrismaPromise<GetProgramKeahlianAggregateType<T>>

    /**
     * Group by ProgramKeahlian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramKeahlianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramKeahlianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramKeahlianGroupByArgs['orderBy'] }
        : { orderBy?: ProgramKeahlianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramKeahlianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramKeahlianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgramKeahlian.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProgramKeahlianClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    bidang<T extends BidangKeahlianArgs= {}>(args?: Subset<T, BidangKeahlianArgs>): Prisma__BidangKeahlianClient<BidangKeahlianGetPayload<T> | Null>;

    konsentrasi<T extends ProgramKeahlian$konsentrasiArgs= {}>(args?: Subset<T, ProgramKeahlian$konsentrasiArgs>): Prisma.PrismaPromise<Array<KonsentrasiKeahlianGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProgramKeahlian base type for findUnique actions
   */
  export type ProgramKeahlianFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ProgramKeahlian
     */
    select?: ProgramKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramKeahlianInclude | null
    /**
     * Filter, which ProgramKeahlian to fetch.
     */
    where: ProgramKeahlianWhereUniqueInput
  }

  /**
   * ProgramKeahlian findUnique
   */
  export interface ProgramKeahlianFindUniqueArgs extends ProgramKeahlianFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProgramKeahlian findUniqueOrThrow
   */
  export type ProgramKeahlianFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProgramKeahlian
     */
    select?: ProgramKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramKeahlianInclude | null
    /**
     * Filter, which ProgramKeahlian to fetch.
     */
    where: ProgramKeahlianWhereUniqueInput
  }


  /**
   * ProgramKeahlian base type for findFirst actions
   */
  export type ProgramKeahlianFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ProgramKeahlian
     */
    select?: ProgramKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramKeahlianInclude | null
    /**
     * Filter, which ProgramKeahlian to fetch.
     */
    where?: ProgramKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramKeahlians to fetch.
     */
    orderBy?: Enumerable<ProgramKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramKeahlians.
     */
    cursor?: ProgramKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramKeahlians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramKeahlians.
     */
    distinct?: Enumerable<ProgramKeahlianScalarFieldEnum>
  }

  /**
   * ProgramKeahlian findFirst
   */
  export interface ProgramKeahlianFindFirstArgs extends ProgramKeahlianFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProgramKeahlian findFirstOrThrow
   */
  export type ProgramKeahlianFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProgramKeahlian
     */
    select?: ProgramKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramKeahlianInclude | null
    /**
     * Filter, which ProgramKeahlian to fetch.
     */
    where?: ProgramKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramKeahlians to fetch.
     */
    orderBy?: Enumerable<ProgramKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramKeahlians.
     */
    cursor?: ProgramKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramKeahlians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramKeahlians.
     */
    distinct?: Enumerable<ProgramKeahlianScalarFieldEnum>
  }


  /**
   * ProgramKeahlian findMany
   */
  export type ProgramKeahlianFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProgramKeahlian
     */
    select?: ProgramKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramKeahlianInclude | null
    /**
     * Filter, which ProgramKeahlians to fetch.
     */
    where?: ProgramKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramKeahlians to fetch.
     */
    orderBy?: Enumerable<ProgramKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgramKeahlians.
     */
    cursor?: ProgramKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramKeahlians.
     */
    skip?: number
    distinct?: Enumerable<ProgramKeahlianScalarFieldEnum>
  }


  /**
   * ProgramKeahlian create
   */
  export type ProgramKeahlianCreateArgs = {
    /**
     * Select specific fields to fetch from the ProgramKeahlian
     */
    select?: ProgramKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramKeahlianInclude | null
    /**
     * The data needed to create a ProgramKeahlian.
     */
    data: XOR<ProgramKeahlianCreateInput, ProgramKeahlianUncheckedCreateInput>
  }


  /**
   * ProgramKeahlian createMany
   */
  export type ProgramKeahlianCreateManyArgs = {
    /**
     * The data used to create many ProgramKeahlians.
     */
    data: Enumerable<ProgramKeahlianCreateManyInput>
  }


  /**
   * ProgramKeahlian update
   */
  export type ProgramKeahlianUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProgramKeahlian
     */
    select?: ProgramKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramKeahlianInclude | null
    /**
     * The data needed to update a ProgramKeahlian.
     */
    data: XOR<ProgramKeahlianUpdateInput, ProgramKeahlianUncheckedUpdateInput>
    /**
     * Choose, which ProgramKeahlian to update.
     */
    where: ProgramKeahlianWhereUniqueInput
  }


  /**
   * ProgramKeahlian updateMany
   */
  export type ProgramKeahlianUpdateManyArgs = {
    /**
     * The data used to update ProgramKeahlians.
     */
    data: XOR<ProgramKeahlianUpdateManyMutationInput, ProgramKeahlianUncheckedUpdateManyInput>
    /**
     * Filter which ProgramKeahlians to update
     */
    where?: ProgramKeahlianWhereInput
  }


  /**
   * ProgramKeahlian upsert
   */
  export type ProgramKeahlianUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProgramKeahlian
     */
    select?: ProgramKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramKeahlianInclude | null
    /**
     * The filter to search for the ProgramKeahlian to update in case it exists.
     */
    where: ProgramKeahlianWhereUniqueInput
    /**
     * In case the ProgramKeahlian found by the `where` argument doesn't exist, create a new ProgramKeahlian with this data.
     */
    create: XOR<ProgramKeahlianCreateInput, ProgramKeahlianUncheckedCreateInput>
    /**
     * In case the ProgramKeahlian was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramKeahlianUpdateInput, ProgramKeahlianUncheckedUpdateInput>
  }


  /**
   * ProgramKeahlian delete
   */
  export type ProgramKeahlianDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProgramKeahlian
     */
    select?: ProgramKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramKeahlianInclude | null
    /**
     * Filter which ProgramKeahlian to delete.
     */
    where: ProgramKeahlianWhereUniqueInput
  }


  /**
   * ProgramKeahlian deleteMany
   */
  export type ProgramKeahlianDeleteManyArgs = {
    /**
     * Filter which ProgramKeahlians to delete
     */
    where?: ProgramKeahlianWhereInput
  }


  /**
   * ProgramKeahlian findRaw
   */
  export type ProgramKeahlianFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * ProgramKeahlian aggregateRaw
   */
  export type ProgramKeahlianAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * ProgramKeahlian.konsentrasi
   */
  export type ProgramKeahlian$konsentrasiArgs = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
    where?: KonsentrasiKeahlianWhereInput
    orderBy?: Enumerable<KonsentrasiKeahlianOrderByWithRelationInput>
    cursor?: KonsentrasiKeahlianWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<KonsentrasiKeahlianScalarFieldEnum>
  }


  /**
   * ProgramKeahlian without action
   */
  export type ProgramKeahlianArgs = {
    /**
     * Select specific fields to fetch from the ProgramKeahlian
     */
    select?: ProgramKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramKeahlianInclude | null
  }



  /**
   * Model KonsentrasiKeahlian
   */


  export type AggregateKonsentrasiKeahlian = {
    _count: KonsentrasiKeahlianCountAggregateOutputType | null
    _avg: KonsentrasiKeahlianAvgAggregateOutputType | null
    _sum: KonsentrasiKeahlianSumAggregateOutputType | null
    _min: KonsentrasiKeahlianMinAggregateOutputType | null
    _max: KonsentrasiKeahlianMaxAggregateOutputType | null
  }

  export type KonsentrasiKeahlianAvgAggregateOutputType = {
    tahun: number | null
  }

  export type KonsentrasiKeahlianSumAggregateOutputType = {
    tahun: number | null
  }

  export type KonsentrasiKeahlianMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    programId: string | null
    tahun: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KonsentrasiKeahlianMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    programId: string | null
    tahun: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KonsentrasiKeahlianCountAggregateOutputType = {
    id: number
    code: number
    name: number
    programId: number
    tahun: number
    createdAt: number
    updatedAt: number
    instansiIds: number
    _all: number
  }


  export type KonsentrasiKeahlianAvgAggregateInputType = {
    tahun?: true
  }

  export type KonsentrasiKeahlianSumAggregateInputType = {
    tahun?: true
  }

  export type KonsentrasiKeahlianMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    programId?: true
    tahun?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KonsentrasiKeahlianMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    programId?: true
    tahun?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KonsentrasiKeahlianCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    programId?: true
    tahun?: true
    createdAt?: true
    updatedAt?: true
    instansiIds?: true
    _all?: true
  }

  export type KonsentrasiKeahlianAggregateArgs = {
    /**
     * Filter which KonsentrasiKeahlian to aggregate.
     */
    where?: KonsentrasiKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KonsentrasiKeahlians to fetch.
     */
    orderBy?: Enumerable<KonsentrasiKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KonsentrasiKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KonsentrasiKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KonsentrasiKeahlians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KonsentrasiKeahlians
    **/
    _count?: true | KonsentrasiKeahlianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KonsentrasiKeahlianAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KonsentrasiKeahlianSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KonsentrasiKeahlianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KonsentrasiKeahlianMaxAggregateInputType
  }

  export type GetKonsentrasiKeahlianAggregateType<T extends KonsentrasiKeahlianAggregateArgs> = {
        [P in keyof T & keyof AggregateKonsentrasiKeahlian]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKonsentrasiKeahlian[P]>
      : GetScalarType<T[P], AggregateKonsentrasiKeahlian[P]>
  }




  export type KonsentrasiKeahlianGroupByArgs = {
    where?: KonsentrasiKeahlianWhereInput
    orderBy?: Enumerable<KonsentrasiKeahlianOrderByWithAggregationInput>
    by: KonsentrasiKeahlianScalarFieldEnum[]
    having?: KonsentrasiKeahlianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KonsentrasiKeahlianCountAggregateInputType | true
    _avg?: KonsentrasiKeahlianAvgAggregateInputType
    _sum?: KonsentrasiKeahlianSumAggregateInputType
    _min?: KonsentrasiKeahlianMinAggregateInputType
    _max?: KonsentrasiKeahlianMaxAggregateInputType
  }


  export type KonsentrasiKeahlianGroupByOutputType = {
    id: string
    code: string
    name: string
    programId: string
    tahun: number
    createdAt: Date
    updatedAt: Date
    instansiIds: string[]
    _count: KonsentrasiKeahlianCountAggregateOutputType | null
    _avg: KonsentrasiKeahlianAvgAggregateOutputType | null
    _sum: KonsentrasiKeahlianSumAggregateOutputType | null
    _min: KonsentrasiKeahlianMinAggregateOutputType | null
    _max: KonsentrasiKeahlianMaxAggregateOutputType | null
  }

  type GetKonsentrasiKeahlianGroupByPayload<T extends KonsentrasiKeahlianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<KonsentrasiKeahlianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KonsentrasiKeahlianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KonsentrasiKeahlianGroupByOutputType[P]>
            : GetScalarType<T[P], KonsentrasiKeahlianGroupByOutputType[P]>
        }
      >
    >


  export type KonsentrasiKeahlianSelect = {
    id?: boolean
    code?: boolean
    name?: boolean
    programId?: boolean
    tahun?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instansiIds?: boolean
    program?: boolean | ProgramKeahlianArgs
    student?: boolean | KonsentrasiKeahlian$studentArgs
    instansi?: boolean | KonsentrasiKeahlian$instansiArgs
    _count?: boolean | KonsentrasiKeahlianCountOutputTypeArgs
  }


  export type KonsentrasiKeahlianInclude = {
    program?: boolean | ProgramKeahlianArgs
    student?: boolean | KonsentrasiKeahlian$studentArgs
    instansi?: boolean | KonsentrasiKeahlian$instansiArgs
    _count?: boolean | KonsentrasiKeahlianCountOutputTypeArgs
  }

  export type KonsentrasiKeahlianGetPayload<S extends boolean | null | undefined | KonsentrasiKeahlianArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? KonsentrasiKeahlian :
    S extends undefined ? never :
    S extends { include: any } & (KonsentrasiKeahlianArgs | KonsentrasiKeahlianFindManyArgs)
    ? KonsentrasiKeahlian  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'program' ? ProgramKeahlianGetPayload<S['include'][P]> :
        P extends 'student' ? Array < StudentGetPayload<S['include'][P]>>  :
        P extends 'instansi' ? Array < InstansiGetPayload<S['include'][P]>>  :
        P extends '_count' ? KonsentrasiKeahlianCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (KonsentrasiKeahlianArgs | KonsentrasiKeahlianFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'program' ? ProgramKeahlianGetPayload<S['select'][P]> :
        P extends 'student' ? Array < StudentGetPayload<S['select'][P]>>  :
        P extends 'instansi' ? Array < InstansiGetPayload<S['select'][P]>>  :
        P extends '_count' ? KonsentrasiKeahlianCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof KonsentrasiKeahlian ? KonsentrasiKeahlian[P] : never
  } 
      : KonsentrasiKeahlian


  type KonsentrasiKeahlianCountArgs = 
    Omit<KonsentrasiKeahlianFindManyArgs, 'select' | 'include'> & {
      select?: KonsentrasiKeahlianCountAggregateInputType | true
    }

  export interface KonsentrasiKeahlianDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one KonsentrasiKeahlian that matches the filter.
     * @param {KonsentrasiKeahlianFindUniqueArgs} args - Arguments to find a KonsentrasiKeahlian
     * @example
     * // Get one KonsentrasiKeahlian
     * const konsentrasiKeahlian = await prisma.konsentrasiKeahlian.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends KonsentrasiKeahlianFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, KonsentrasiKeahlianFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'KonsentrasiKeahlian'> extends True ? Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T>> : Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T> | null, null>

    /**
     * Find one KonsentrasiKeahlian that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {KonsentrasiKeahlianFindUniqueOrThrowArgs} args - Arguments to find a KonsentrasiKeahlian
     * @example
     * // Get one KonsentrasiKeahlian
     * const konsentrasiKeahlian = await prisma.konsentrasiKeahlian.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends KonsentrasiKeahlianFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, KonsentrasiKeahlianFindUniqueOrThrowArgs>
    ): Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T>>

    /**
     * Find the first KonsentrasiKeahlian that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KonsentrasiKeahlianFindFirstArgs} args - Arguments to find a KonsentrasiKeahlian
     * @example
     * // Get one KonsentrasiKeahlian
     * const konsentrasiKeahlian = await prisma.konsentrasiKeahlian.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends KonsentrasiKeahlianFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, KonsentrasiKeahlianFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'KonsentrasiKeahlian'> extends True ? Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T>> : Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T> | null, null>

    /**
     * Find the first KonsentrasiKeahlian that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KonsentrasiKeahlianFindFirstOrThrowArgs} args - Arguments to find a KonsentrasiKeahlian
     * @example
     * // Get one KonsentrasiKeahlian
     * const konsentrasiKeahlian = await prisma.konsentrasiKeahlian.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends KonsentrasiKeahlianFindFirstOrThrowArgs>(
      args?: SelectSubset<T, KonsentrasiKeahlianFindFirstOrThrowArgs>
    ): Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T>>

    /**
     * Find zero or more KonsentrasiKeahlians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KonsentrasiKeahlianFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KonsentrasiKeahlians
     * const konsentrasiKeahlians = await prisma.konsentrasiKeahlian.findMany()
     * 
     * // Get first 10 KonsentrasiKeahlians
     * const konsentrasiKeahlians = await prisma.konsentrasiKeahlian.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const konsentrasiKeahlianWithIdOnly = await prisma.konsentrasiKeahlian.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends KonsentrasiKeahlianFindManyArgs>(
      args?: SelectSubset<T, KonsentrasiKeahlianFindManyArgs>
    ): Prisma.PrismaPromise<Array<KonsentrasiKeahlianGetPayload<T>>>

    /**
     * Create a KonsentrasiKeahlian.
     * @param {KonsentrasiKeahlianCreateArgs} args - Arguments to create a KonsentrasiKeahlian.
     * @example
     * // Create one KonsentrasiKeahlian
     * const KonsentrasiKeahlian = await prisma.konsentrasiKeahlian.create({
     *   data: {
     *     // ... data to create a KonsentrasiKeahlian
     *   }
     * })
     * 
    **/
    create<T extends KonsentrasiKeahlianCreateArgs>(
      args: SelectSubset<T, KonsentrasiKeahlianCreateArgs>
    ): Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T>>

    /**
     * Create many KonsentrasiKeahlians.
     *     @param {KonsentrasiKeahlianCreateManyArgs} args - Arguments to create many KonsentrasiKeahlians.
     *     @example
     *     // Create many KonsentrasiKeahlians
     *     const konsentrasiKeahlian = await prisma.konsentrasiKeahlian.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends KonsentrasiKeahlianCreateManyArgs>(
      args?: SelectSubset<T, KonsentrasiKeahlianCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KonsentrasiKeahlian.
     * @param {KonsentrasiKeahlianDeleteArgs} args - Arguments to delete one KonsentrasiKeahlian.
     * @example
     * // Delete one KonsentrasiKeahlian
     * const KonsentrasiKeahlian = await prisma.konsentrasiKeahlian.delete({
     *   where: {
     *     // ... filter to delete one KonsentrasiKeahlian
     *   }
     * })
     * 
    **/
    delete<T extends KonsentrasiKeahlianDeleteArgs>(
      args: SelectSubset<T, KonsentrasiKeahlianDeleteArgs>
    ): Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T>>

    /**
     * Update one KonsentrasiKeahlian.
     * @param {KonsentrasiKeahlianUpdateArgs} args - Arguments to update one KonsentrasiKeahlian.
     * @example
     * // Update one KonsentrasiKeahlian
     * const konsentrasiKeahlian = await prisma.konsentrasiKeahlian.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends KonsentrasiKeahlianUpdateArgs>(
      args: SelectSubset<T, KonsentrasiKeahlianUpdateArgs>
    ): Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T>>

    /**
     * Delete zero or more KonsentrasiKeahlians.
     * @param {KonsentrasiKeahlianDeleteManyArgs} args - Arguments to filter KonsentrasiKeahlians to delete.
     * @example
     * // Delete a few KonsentrasiKeahlians
     * const { count } = await prisma.konsentrasiKeahlian.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends KonsentrasiKeahlianDeleteManyArgs>(
      args?: SelectSubset<T, KonsentrasiKeahlianDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KonsentrasiKeahlians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KonsentrasiKeahlianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KonsentrasiKeahlians
     * const konsentrasiKeahlian = await prisma.konsentrasiKeahlian.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends KonsentrasiKeahlianUpdateManyArgs>(
      args: SelectSubset<T, KonsentrasiKeahlianUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KonsentrasiKeahlian.
     * @param {KonsentrasiKeahlianUpsertArgs} args - Arguments to update or create a KonsentrasiKeahlian.
     * @example
     * // Update or create a KonsentrasiKeahlian
     * const konsentrasiKeahlian = await prisma.konsentrasiKeahlian.upsert({
     *   create: {
     *     // ... data to create a KonsentrasiKeahlian
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KonsentrasiKeahlian we want to update
     *   }
     * })
    **/
    upsert<T extends KonsentrasiKeahlianUpsertArgs>(
      args: SelectSubset<T, KonsentrasiKeahlianUpsertArgs>
    ): Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T>>

    /**
     * Find zero or more KonsentrasiKeahlians that matches the filter.
     * @param {KonsentrasiKeahlianFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const konsentrasiKeahlian = await prisma.konsentrasiKeahlian.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: KonsentrasiKeahlianFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a KonsentrasiKeahlian.
     * @param {KonsentrasiKeahlianAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const konsentrasiKeahlian = await prisma.konsentrasiKeahlian.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: KonsentrasiKeahlianAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of KonsentrasiKeahlians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KonsentrasiKeahlianCountArgs} args - Arguments to filter KonsentrasiKeahlians to count.
     * @example
     * // Count the number of KonsentrasiKeahlians
     * const count = await prisma.konsentrasiKeahlian.count({
     *   where: {
     *     // ... the filter for the KonsentrasiKeahlians we want to count
     *   }
     * })
    **/
    count<T extends KonsentrasiKeahlianCountArgs>(
      args?: Subset<T, KonsentrasiKeahlianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KonsentrasiKeahlianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KonsentrasiKeahlian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KonsentrasiKeahlianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KonsentrasiKeahlianAggregateArgs>(args: Subset<T, KonsentrasiKeahlianAggregateArgs>): Prisma.PrismaPromise<GetKonsentrasiKeahlianAggregateType<T>>

    /**
     * Group by KonsentrasiKeahlian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KonsentrasiKeahlianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KonsentrasiKeahlianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KonsentrasiKeahlianGroupByArgs['orderBy'] }
        : { orderBy?: KonsentrasiKeahlianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KonsentrasiKeahlianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKonsentrasiKeahlianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for KonsentrasiKeahlian.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__KonsentrasiKeahlianClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    program<T extends ProgramKeahlianArgs= {}>(args?: Subset<T, ProgramKeahlianArgs>): Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T> | Null>;

    student<T extends KonsentrasiKeahlian$studentArgs= {}>(args?: Subset<T, KonsentrasiKeahlian$studentArgs>): Prisma.PrismaPromise<Array<StudentGetPayload<T>>| Null>;

    instansi<T extends KonsentrasiKeahlian$instansiArgs= {}>(args?: Subset<T, KonsentrasiKeahlian$instansiArgs>): Prisma.PrismaPromise<Array<InstansiGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * KonsentrasiKeahlian base type for findUnique actions
   */
  export type KonsentrasiKeahlianFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
    /**
     * Filter, which KonsentrasiKeahlian to fetch.
     */
    where: KonsentrasiKeahlianWhereUniqueInput
  }

  /**
   * KonsentrasiKeahlian findUnique
   */
  export interface KonsentrasiKeahlianFindUniqueArgs extends KonsentrasiKeahlianFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * KonsentrasiKeahlian findUniqueOrThrow
   */
  export type KonsentrasiKeahlianFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
    /**
     * Filter, which KonsentrasiKeahlian to fetch.
     */
    where: KonsentrasiKeahlianWhereUniqueInput
  }


  /**
   * KonsentrasiKeahlian base type for findFirst actions
   */
  export type KonsentrasiKeahlianFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
    /**
     * Filter, which KonsentrasiKeahlian to fetch.
     */
    where?: KonsentrasiKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KonsentrasiKeahlians to fetch.
     */
    orderBy?: Enumerable<KonsentrasiKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KonsentrasiKeahlians.
     */
    cursor?: KonsentrasiKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KonsentrasiKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KonsentrasiKeahlians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KonsentrasiKeahlians.
     */
    distinct?: Enumerable<KonsentrasiKeahlianScalarFieldEnum>
  }

  /**
   * KonsentrasiKeahlian findFirst
   */
  export interface KonsentrasiKeahlianFindFirstArgs extends KonsentrasiKeahlianFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * KonsentrasiKeahlian findFirstOrThrow
   */
  export type KonsentrasiKeahlianFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
    /**
     * Filter, which KonsentrasiKeahlian to fetch.
     */
    where?: KonsentrasiKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KonsentrasiKeahlians to fetch.
     */
    orderBy?: Enumerable<KonsentrasiKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KonsentrasiKeahlians.
     */
    cursor?: KonsentrasiKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KonsentrasiKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KonsentrasiKeahlians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KonsentrasiKeahlians.
     */
    distinct?: Enumerable<KonsentrasiKeahlianScalarFieldEnum>
  }


  /**
   * KonsentrasiKeahlian findMany
   */
  export type KonsentrasiKeahlianFindManyArgs = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
    /**
     * Filter, which KonsentrasiKeahlians to fetch.
     */
    where?: KonsentrasiKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KonsentrasiKeahlians to fetch.
     */
    orderBy?: Enumerable<KonsentrasiKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KonsentrasiKeahlians.
     */
    cursor?: KonsentrasiKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KonsentrasiKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KonsentrasiKeahlians.
     */
    skip?: number
    distinct?: Enumerable<KonsentrasiKeahlianScalarFieldEnum>
  }


  /**
   * KonsentrasiKeahlian create
   */
  export type KonsentrasiKeahlianCreateArgs = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
    /**
     * The data needed to create a KonsentrasiKeahlian.
     */
    data: XOR<KonsentrasiKeahlianCreateInput, KonsentrasiKeahlianUncheckedCreateInput>
  }


  /**
   * KonsentrasiKeahlian createMany
   */
  export type KonsentrasiKeahlianCreateManyArgs = {
    /**
     * The data used to create many KonsentrasiKeahlians.
     */
    data: Enumerable<KonsentrasiKeahlianCreateManyInput>
  }


  /**
   * KonsentrasiKeahlian update
   */
  export type KonsentrasiKeahlianUpdateArgs = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
    /**
     * The data needed to update a KonsentrasiKeahlian.
     */
    data: XOR<KonsentrasiKeahlianUpdateInput, KonsentrasiKeahlianUncheckedUpdateInput>
    /**
     * Choose, which KonsentrasiKeahlian to update.
     */
    where: KonsentrasiKeahlianWhereUniqueInput
  }


  /**
   * KonsentrasiKeahlian updateMany
   */
  export type KonsentrasiKeahlianUpdateManyArgs = {
    /**
     * The data used to update KonsentrasiKeahlians.
     */
    data: XOR<KonsentrasiKeahlianUpdateManyMutationInput, KonsentrasiKeahlianUncheckedUpdateManyInput>
    /**
     * Filter which KonsentrasiKeahlians to update
     */
    where?: KonsentrasiKeahlianWhereInput
  }


  /**
   * KonsentrasiKeahlian upsert
   */
  export type KonsentrasiKeahlianUpsertArgs = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
    /**
     * The filter to search for the KonsentrasiKeahlian to update in case it exists.
     */
    where: KonsentrasiKeahlianWhereUniqueInput
    /**
     * In case the KonsentrasiKeahlian found by the `where` argument doesn't exist, create a new KonsentrasiKeahlian with this data.
     */
    create: XOR<KonsentrasiKeahlianCreateInput, KonsentrasiKeahlianUncheckedCreateInput>
    /**
     * In case the KonsentrasiKeahlian was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KonsentrasiKeahlianUpdateInput, KonsentrasiKeahlianUncheckedUpdateInput>
  }


  /**
   * KonsentrasiKeahlian delete
   */
  export type KonsentrasiKeahlianDeleteArgs = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
    /**
     * Filter which KonsentrasiKeahlian to delete.
     */
    where: KonsentrasiKeahlianWhereUniqueInput
  }


  /**
   * KonsentrasiKeahlian deleteMany
   */
  export type KonsentrasiKeahlianDeleteManyArgs = {
    /**
     * Filter which KonsentrasiKeahlians to delete
     */
    where?: KonsentrasiKeahlianWhereInput
  }


  /**
   * KonsentrasiKeahlian findRaw
   */
  export type KonsentrasiKeahlianFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * KonsentrasiKeahlian aggregateRaw
   */
  export type KonsentrasiKeahlianAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * KonsentrasiKeahlian.student
   */
  export type KonsentrasiKeahlian$studentArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    where?: StudentWhereInput
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * KonsentrasiKeahlian.instansi
   */
  export type KonsentrasiKeahlian$instansiArgs = {
    /**
     * Select specific fields to fetch from the Instansi
     */
    select?: InstansiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstansiInclude | null
    where?: InstansiWhereInput
    orderBy?: Enumerable<InstansiOrderByWithRelationInput>
    cursor?: InstansiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InstansiScalarFieldEnum>
  }


  /**
   * KonsentrasiKeahlian without action
   */
  export type KonsentrasiKeahlianArgs = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
  }



  /**
   * Model Achievement
   */


  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    fase: Fase | null
    description: string | null
    elementId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    fase: Fase | null
    description: string | null
    elementId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    fase: number
    description: number
    elementId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AchievementMinAggregateInputType = {
    id?: true
    fase?: true
    description?: true
    elementId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    fase?: true
    description?: true
    elementId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    fase?: true
    description?: true
    elementId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AchievementAggregateArgs = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: Enumerable<AchievementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs = {
    where?: AchievementWhereInput
    orderBy?: Enumerable<AchievementOrderByWithAggregationInput>
    by: AchievementScalarFieldEnum[]
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }


  export type AchievementGroupByOutputType = {
    id: string
    fase: Fase
    description: string
    elementId: string
    createdAt: Date
    updatedAt: Date
    _count: AchievementCountAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect = {
    id?: boolean
    fase?: boolean
    description?: boolean
    elementId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    element?: boolean | ElementArgs
  }


  export type AchievementInclude = {
    element?: boolean | ElementArgs
  }

  export type AchievementGetPayload<S extends boolean | null | undefined | AchievementArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Achievement :
    S extends undefined ? never :
    S extends { include: any } & (AchievementArgs | AchievementFindManyArgs)
    ? Achievement  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'element' ? ElementGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AchievementArgs | AchievementFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'element' ? ElementGetPayload<S['select'][P]> :  P extends keyof Achievement ? Achievement[P] : never
  } 
      : Achievement


  type AchievementCountArgs = 
    Omit<AchievementFindManyArgs, 'select' | 'include'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AchievementFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AchievementFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Achievement'> extends True ? Prisma__AchievementClient<AchievementGetPayload<T>> : Prisma__AchievementClient<AchievementGetPayload<T> | null, null>

    /**
     * Find one Achievement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AchievementFindUniqueOrThrowArgs>
    ): Prisma__AchievementClient<AchievementGetPayload<T>>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AchievementFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AchievementFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Achievement'> extends True ? Prisma__AchievementClient<AchievementGetPayload<T>> : Prisma__AchievementClient<AchievementGetPayload<T> | null, null>

    /**
     * Find the first Achievement that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AchievementFindFirstOrThrowArgs>
    ): Prisma__AchievementClient<AchievementGetPayload<T>>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AchievementFindManyArgs>(
      args?: SelectSubset<T, AchievementFindManyArgs>
    ): Prisma.PrismaPromise<Array<AchievementGetPayload<T>>>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
    **/
    create<T extends AchievementCreateArgs>(
      args: SelectSubset<T, AchievementCreateArgs>
    ): Prisma__AchievementClient<AchievementGetPayload<T>>

    /**
     * Create many Achievements.
     *     @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     *     @example
     *     // Create many Achievements
     *     const achievement = await prisma.achievement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AchievementCreateManyArgs>(
      args?: SelectSubset<T, AchievementCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
    **/
    delete<T extends AchievementDeleteArgs>(
      args: SelectSubset<T, AchievementDeleteArgs>
    ): Prisma__AchievementClient<AchievementGetPayload<T>>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AchievementUpdateArgs>(
      args: SelectSubset<T, AchievementUpdateArgs>
    ): Prisma__AchievementClient<AchievementGetPayload<T>>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AchievementDeleteManyArgs>(
      args?: SelectSubset<T, AchievementDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AchievementUpdateManyArgs>(
      args: SelectSubset<T, AchievementUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
    **/
    upsert<T extends AchievementUpsertArgs>(
      args: SelectSubset<T, AchievementUpsertArgs>
    ): Prisma__AchievementClient<AchievementGetPayload<T>>

    /**
     * Find zero or more Achievements that matches the filter.
     * @param {AchievementFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const achievement = await prisma.achievement.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: AchievementFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Achievement.
     * @param {AchievementAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const achievement = await prisma.achievement.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: AchievementAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AchievementClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    element<T extends ElementArgs= {}>(args?: Subset<T, ElementArgs>): Prisma__ElementClient<ElementGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Achievement base type for findUnique actions
   */
  export type AchievementFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AchievementInclude | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUnique
   */
  export interface AchievementFindUniqueArgs extends AchievementFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AchievementInclude | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }


  /**
   * Achievement base type for findFirst actions
   */
  export type AchievementFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AchievementInclude | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: Enumerable<AchievementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: Enumerable<AchievementScalarFieldEnum>
  }

  /**
   * Achievement findFirst
   */
  export interface AchievementFindFirstArgs extends AchievementFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AchievementInclude | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: Enumerable<AchievementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: Enumerable<AchievementScalarFieldEnum>
  }


  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AchievementInclude | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: Enumerable<AchievementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: Enumerable<AchievementScalarFieldEnum>
  }


  /**
   * Achievement create
   */
  export type AchievementCreateArgs = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AchievementInclude | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }


  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs = {
    /**
     * The data used to create many Achievements.
     */
    data: Enumerable<AchievementCreateManyInput>
  }


  /**
   * Achievement update
   */
  export type AchievementUpdateArgs = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AchievementInclude | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }


  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
  }


  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AchievementInclude | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }


  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AchievementInclude | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }


  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
  }


  /**
   * Achievement findRaw
   */
  export type AchievementFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Achievement aggregateRaw
   */
  export type AchievementAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Achievement without action
   */
  export type AchievementArgs = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AchievementInclude | null
  }



  /**
   * Model Element
   */


  export type AggregateElement = {
    _count: ElementCountAggregateOutputType | null
    _min: ElementMinAggregateOutputType | null
    _max: ElementMaxAggregateOutputType | null
  }

  export type ElementMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    mapelId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ElementMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    mapelId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ElementCountAggregateOutputType = {
    id: number
    name: number
    description: number
    mapelId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ElementMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    mapelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ElementMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    mapelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ElementCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    mapelId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ElementAggregateArgs = {
    /**
     * Filter which Element to aggregate.
     */
    where?: ElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Elements to fetch.
     */
    orderBy?: Enumerable<ElementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Elements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Elements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Elements
    **/
    _count?: true | ElementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ElementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ElementMaxAggregateInputType
  }

  export type GetElementAggregateType<T extends ElementAggregateArgs> = {
        [P in keyof T & keyof AggregateElement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateElement[P]>
      : GetScalarType<T[P], AggregateElement[P]>
  }




  export type ElementGroupByArgs = {
    where?: ElementWhereInput
    orderBy?: Enumerable<ElementOrderByWithAggregationInput>
    by: ElementScalarFieldEnum[]
    having?: ElementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ElementCountAggregateInputType | true
    _min?: ElementMinAggregateInputType
    _max?: ElementMaxAggregateInputType
  }


  export type ElementGroupByOutputType = {
    id: string
    name: string
    description: string
    mapelId: string
    createdAt: Date
    updatedAt: Date
    _count: ElementCountAggregateOutputType | null
    _min: ElementMinAggregateOutputType | null
    _max: ElementMaxAggregateOutputType | null
  }

  type GetElementGroupByPayload<T extends ElementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ElementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ElementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ElementGroupByOutputType[P]>
            : GetScalarType<T[P], ElementGroupByOutputType[P]>
        }
      >
    >


  export type ElementSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    mapelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    achievement?: boolean | Element$achievementArgs
    mapel?: boolean | MataPelajaranArgs
    _count?: boolean | ElementCountOutputTypeArgs
  }


  export type ElementInclude = {
    achievement?: boolean | Element$achievementArgs
    mapel?: boolean | MataPelajaranArgs
    _count?: boolean | ElementCountOutputTypeArgs
  }

  export type ElementGetPayload<S extends boolean | null | undefined | ElementArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Element :
    S extends undefined ? never :
    S extends { include: any } & (ElementArgs | ElementFindManyArgs)
    ? Element  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'achievement' ? Array < AchievementGetPayload<S['include'][P]>>  :
        P extends 'mapel' ? MataPelajaranGetPayload<S['include'][P]> :
        P extends '_count' ? ElementCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ElementArgs | ElementFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'achievement' ? Array < AchievementGetPayload<S['select'][P]>>  :
        P extends 'mapel' ? MataPelajaranGetPayload<S['select'][P]> :
        P extends '_count' ? ElementCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Element ? Element[P] : never
  } 
      : Element


  type ElementCountArgs = 
    Omit<ElementFindManyArgs, 'select' | 'include'> & {
      select?: ElementCountAggregateInputType | true
    }

  export interface ElementDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Element that matches the filter.
     * @param {ElementFindUniqueArgs} args - Arguments to find a Element
     * @example
     * // Get one Element
     * const element = await prisma.element.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ElementFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ElementFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Element'> extends True ? Prisma__ElementClient<ElementGetPayload<T>> : Prisma__ElementClient<ElementGetPayload<T> | null, null>

    /**
     * Find one Element that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ElementFindUniqueOrThrowArgs} args - Arguments to find a Element
     * @example
     * // Get one Element
     * const element = await prisma.element.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ElementFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ElementFindUniqueOrThrowArgs>
    ): Prisma__ElementClient<ElementGetPayload<T>>

    /**
     * Find the first Element that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementFindFirstArgs} args - Arguments to find a Element
     * @example
     * // Get one Element
     * const element = await prisma.element.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ElementFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ElementFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Element'> extends True ? Prisma__ElementClient<ElementGetPayload<T>> : Prisma__ElementClient<ElementGetPayload<T> | null, null>

    /**
     * Find the first Element that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementFindFirstOrThrowArgs} args - Arguments to find a Element
     * @example
     * // Get one Element
     * const element = await prisma.element.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ElementFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ElementFindFirstOrThrowArgs>
    ): Prisma__ElementClient<ElementGetPayload<T>>

    /**
     * Find zero or more Elements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Elements
     * const elements = await prisma.element.findMany()
     * 
     * // Get first 10 Elements
     * const elements = await prisma.element.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const elementWithIdOnly = await prisma.element.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ElementFindManyArgs>(
      args?: SelectSubset<T, ElementFindManyArgs>
    ): Prisma.PrismaPromise<Array<ElementGetPayload<T>>>

    /**
     * Create a Element.
     * @param {ElementCreateArgs} args - Arguments to create a Element.
     * @example
     * // Create one Element
     * const Element = await prisma.element.create({
     *   data: {
     *     // ... data to create a Element
     *   }
     * })
     * 
    **/
    create<T extends ElementCreateArgs>(
      args: SelectSubset<T, ElementCreateArgs>
    ): Prisma__ElementClient<ElementGetPayload<T>>

    /**
     * Create many Elements.
     *     @param {ElementCreateManyArgs} args - Arguments to create many Elements.
     *     @example
     *     // Create many Elements
     *     const element = await prisma.element.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ElementCreateManyArgs>(
      args?: SelectSubset<T, ElementCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Element.
     * @param {ElementDeleteArgs} args - Arguments to delete one Element.
     * @example
     * // Delete one Element
     * const Element = await prisma.element.delete({
     *   where: {
     *     // ... filter to delete one Element
     *   }
     * })
     * 
    **/
    delete<T extends ElementDeleteArgs>(
      args: SelectSubset<T, ElementDeleteArgs>
    ): Prisma__ElementClient<ElementGetPayload<T>>

    /**
     * Update one Element.
     * @param {ElementUpdateArgs} args - Arguments to update one Element.
     * @example
     * // Update one Element
     * const element = await prisma.element.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ElementUpdateArgs>(
      args: SelectSubset<T, ElementUpdateArgs>
    ): Prisma__ElementClient<ElementGetPayload<T>>

    /**
     * Delete zero or more Elements.
     * @param {ElementDeleteManyArgs} args - Arguments to filter Elements to delete.
     * @example
     * // Delete a few Elements
     * const { count } = await prisma.element.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ElementDeleteManyArgs>(
      args?: SelectSubset<T, ElementDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Elements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Elements
     * const element = await prisma.element.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ElementUpdateManyArgs>(
      args: SelectSubset<T, ElementUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Element.
     * @param {ElementUpsertArgs} args - Arguments to update or create a Element.
     * @example
     * // Update or create a Element
     * const element = await prisma.element.upsert({
     *   create: {
     *     // ... data to create a Element
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Element we want to update
     *   }
     * })
    **/
    upsert<T extends ElementUpsertArgs>(
      args: SelectSubset<T, ElementUpsertArgs>
    ): Prisma__ElementClient<ElementGetPayload<T>>

    /**
     * Find zero or more Elements that matches the filter.
     * @param {ElementFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const element = await prisma.element.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ElementFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Element.
     * @param {ElementAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const element = await prisma.element.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ElementAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Elements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementCountArgs} args - Arguments to filter Elements to count.
     * @example
     * // Count the number of Elements
     * const count = await prisma.element.count({
     *   where: {
     *     // ... the filter for the Elements we want to count
     *   }
     * })
    **/
    count<T extends ElementCountArgs>(
      args?: Subset<T, ElementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ElementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Element.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ElementAggregateArgs>(args: Subset<T, ElementAggregateArgs>): Prisma.PrismaPromise<GetElementAggregateType<T>>

    /**
     * Group by Element.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ElementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ElementGroupByArgs['orderBy'] }
        : { orderBy?: ElementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ElementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetElementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Element.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ElementClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    achievement<T extends Element$achievementArgs= {}>(args?: Subset<T, Element$achievementArgs>): Prisma.PrismaPromise<Array<AchievementGetPayload<T>>| Null>;

    mapel<T extends MataPelajaranArgs= {}>(args?: Subset<T, MataPelajaranArgs>): Prisma__MataPelajaranClient<MataPelajaranGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Element base type for findUnique actions
   */
  export type ElementFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ElementInclude | null
    /**
     * Filter, which Element to fetch.
     */
    where: ElementWhereUniqueInput
  }

  /**
   * Element findUnique
   */
  export interface ElementFindUniqueArgs extends ElementFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Element findUniqueOrThrow
   */
  export type ElementFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ElementInclude | null
    /**
     * Filter, which Element to fetch.
     */
    where: ElementWhereUniqueInput
  }


  /**
   * Element base type for findFirst actions
   */
  export type ElementFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ElementInclude | null
    /**
     * Filter, which Element to fetch.
     */
    where?: ElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Elements to fetch.
     */
    orderBy?: Enumerable<ElementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Elements.
     */
    cursor?: ElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Elements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Elements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Elements.
     */
    distinct?: Enumerable<ElementScalarFieldEnum>
  }

  /**
   * Element findFirst
   */
  export interface ElementFindFirstArgs extends ElementFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Element findFirstOrThrow
   */
  export type ElementFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ElementInclude | null
    /**
     * Filter, which Element to fetch.
     */
    where?: ElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Elements to fetch.
     */
    orderBy?: Enumerable<ElementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Elements.
     */
    cursor?: ElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Elements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Elements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Elements.
     */
    distinct?: Enumerable<ElementScalarFieldEnum>
  }


  /**
   * Element findMany
   */
  export type ElementFindManyArgs = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ElementInclude | null
    /**
     * Filter, which Elements to fetch.
     */
    where?: ElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Elements to fetch.
     */
    orderBy?: Enumerable<ElementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Elements.
     */
    cursor?: ElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Elements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Elements.
     */
    skip?: number
    distinct?: Enumerable<ElementScalarFieldEnum>
  }


  /**
   * Element create
   */
  export type ElementCreateArgs = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ElementInclude | null
    /**
     * The data needed to create a Element.
     */
    data: XOR<ElementCreateInput, ElementUncheckedCreateInput>
  }


  /**
   * Element createMany
   */
  export type ElementCreateManyArgs = {
    /**
     * The data used to create many Elements.
     */
    data: Enumerable<ElementCreateManyInput>
  }


  /**
   * Element update
   */
  export type ElementUpdateArgs = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ElementInclude | null
    /**
     * The data needed to update a Element.
     */
    data: XOR<ElementUpdateInput, ElementUncheckedUpdateInput>
    /**
     * Choose, which Element to update.
     */
    where: ElementWhereUniqueInput
  }


  /**
   * Element updateMany
   */
  export type ElementUpdateManyArgs = {
    /**
     * The data used to update Elements.
     */
    data: XOR<ElementUpdateManyMutationInput, ElementUncheckedUpdateManyInput>
    /**
     * Filter which Elements to update
     */
    where?: ElementWhereInput
  }


  /**
   * Element upsert
   */
  export type ElementUpsertArgs = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ElementInclude | null
    /**
     * The filter to search for the Element to update in case it exists.
     */
    where: ElementWhereUniqueInput
    /**
     * In case the Element found by the `where` argument doesn't exist, create a new Element with this data.
     */
    create: XOR<ElementCreateInput, ElementUncheckedCreateInput>
    /**
     * In case the Element was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ElementUpdateInput, ElementUncheckedUpdateInput>
  }


  /**
   * Element delete
   */
  export type ElementDeleteArgs = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ElementInclude | null
    /**
     * Filter which Element to delete.
     */
    where: ElementWhereUniqueInput
  }


  /**
   * Element deleteMany
   */
  export type ElementDeleteManyArgs = {
    /**
     * Filter which Elements to delete
     */
    where?: ElementWhereInput
  }


  /**
   * Element findRaw
   */
  export type ElementFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Element aggregateRaw
   */
  export type ElementAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Element.achievement
   */
  export type Element$achievementArgs = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AchievementInclude | null
    where?: AchievementWhereInput
    orderBy?: Enumerable<AchievementOrderByWithRelationInput>
    cursor?: AchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AchievementScalarFieldEnum>
  }


  /**
   * Element without action
   */
  export type ElementArgs = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ElementInclude | null
  }



  /**
   * Model MataPelajaran
   */


  export type AggregateMataPelajaran = {
    _count: MataPelajaranCountAggregateOutputType | null
    _min: MataPelajaranMinAggregateOutputType | null
    _max: MataPelajaranMaxAggregateOutputType | null
  }

  export type MataPelajaranMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    religion: Religion | null
    vocational: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MataPelajaranMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    religion: Religion | null
    vocational: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MataPelajaranCountAggregateOutputType = {
    id: number
    code: number
    name: number
    religion: number
    vocational: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MataPelajaranMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    religion?: true
    vocational?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MataPelajaranMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    religion?: true
    vocational?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MataPelajaranCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    religion?: true
    vocational?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MataPelajaranAggregateArgs = {
    /**
     * Filter which MataPelajaran to aggregate.
     */
    where?: MataPelajaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MataPelajarans to fetch.
     */
    orderBy?: Enumerable<MataPelajaranOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MataPelajaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MataPelajarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MataPelajarans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MataPelajarans
    **/
    _count?: true | MataPelajaranCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MataPelajaranMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MataPelajaranMaxAggregateInputType
  }

  export type GetMataPelajaranAggregateType<T extends MataPelajaranAggregateArgs> = {
        [P in keyof T & keyof AggregateMataPelajaran]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMataPelajaran[P]>
      : GetScalarType<T[P], AggregateMataPelajaran[P]>
  }




  export type MataPelajaranGroupByArgs = {
    where?: MataPelajaranWhereInput
    orderBy?: Enumerable<MataPelajaranOrderByWithAggregationInput>
    by: MataPelajaranScalarFieldEnum[]
    having?: MataPelajaranScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MataPelajaranCountAggregateInputType | true
    _min?: MataPelajaranMinAggregateInputType
    _max?: MataPelajaranMaxAggregateInputType
  }


  export type MataPelajaranGroupByOutputType = {
    id: string
    code: string
    name: string
    religion: Religion | null
    vocational: boolean
    createdAt: Date
    updatedAt: Date
    _count: MataPelajaranCountAggregateOutputType | null
    _min: MataPelajaranMinAggregateOutputType | null
    _max: MataPelajaranMaxAggregateOutputType | null
  }

  type GetMataPelajaranGroupByPayload<T extends MataPelajaranGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MataPelajaranGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MataPelajaranGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MataPelajaranGroupByOutputType[P]>
            : GetScalarType<T[P], MataPelajaranGroupByOutputType[P]>
        }
      >
    >


  export type MataPelajaranSelect = {
    id?: boolean
    code?: boolean
    name?: boolean
    religion?: boolean
    vocational?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    element?: boolean | MataPelajaran$elementArgs
    _count?: boolean | MataPelajaranCountOutputTypeArgs
  }


  export type MataPelajaranInclude = {
    element?: boolean | MataPelajaran$elementArgs
    _count?: boolean | MataPelajaranCountOutputTypeArgs
  }

  export type MataPelajaranGetPayload<S extends boolean | null | undefined | MataPelajaranArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MataPelajaran :
    S extends undefined ? never :
    S extends { include: any } & (MataPelajaranArgs | MataPelajaranFindManyArgs)
    ? MataPelajaran  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'element' ? Array < ElementGetPayload<S['include'][P]>>  :
        P extends '_count' ? MataPelajaranCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MataPelajaranArgs | MataPelajaranFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'element' ? Array < ElementGetPayload<S['select'][P]>>  :
        P extends '_count' ? MataPelajaranCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof MataPelajaran ? MataPelajaran[P] : never
  } 
      : MataPelajaran


  type MataPelajaranCountArgs = 
    Omit<MataPelajaranFindManyArgs, 'select' | 'include'> & {
      select?: MataPelajaranCountAggregateInputType | true
    }

  export interface MataPelajaranDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MataPelajaran that matches the filter.
     * @param {MataPelajaranFindUniqueArgs} args - Arguments to find a MataPelajaran
     * @example
     * // Get one MataPelajaran
     * const mataPelajaran = await prisma.mataPelajaran.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MataPelajaranFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MataPelajaranFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MataPelajaran'> extends True ? Prisma__MataPelajaranClient<MataPelajaranGetPayload<T>> : Prisma__MataPelajaranClient<MataPelajaranGetPayload<T> | null, null>

    /**
     * Find one MataPelajaran that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MataPelajaranFindUniqueOrThrowArgs} args - Arguments to find a MataPelajaran
     * @example
     * // Get one MataPelajaran
     * const mataPelajaran = await prisma.mataPelajaran.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MataPelajaranFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MataPelajaranFindUniqueOrThrowArgs>
    ): Prisma__MataPelajaranClient<MataPelajaranGetPayload<T>>

    /**
     * Find the first MataPelajaran that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MataPelajaranFindFirstArgs} args - Arguments to find a MataPelajaran
     * @example
     * // Get one MataPelajaran
     * const mataPelajaran = await prisma.mataPelajaran.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MataPelajaranFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MataPelajaranFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MataPelajaran'> extends True ? Prisma__MataPelajaranClient<MataPelajaranGetPayload<T>> : Prisma__MataPelajaranClient<MataPelajaranGetPayload<T> | null, null>

    /**
     * Find the first MataPelajaran that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MataPelajaranFindFirstOrThrowArgs} args - Arguments to find a MataPelajaran
     * @example
     * // Get one MataPelajaran
     * const mataPelajaran = await prisma.mataPelajaran.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MataPelajaranFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MataPelajaranFindFirstOrThrowArgs>
    ): Prisma__MataPelajaranClient<MataPelajaranGetPayload<T>>

    /**
     * Find zero or more MataPelajarans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MataPelajaranFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MataPelajarans
     * const mataPelajarans = await prisma.mataPelajaran.findMany()
     * 
     * // Get first 10 MataPelajarans
     * const mataPelajarans = await prisma.mataPelajaran.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mataPelajaranWithIdOnly = await prisma.mataPelajaran.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MataPelajaranFindManyArgs>(
      args?: SelectSubset<T, MataPelajaranFindManyArgs>
    ): Prisma.PrismaPromise<Array<MataPelajaranGetPayload<T>>>

    /**
     * Create a MataPelajaran.
     * @param {MataPelajaranCreateArgs} args - Arguments to create a MataPelajaran.
     * @example
     * // Create one MataPelajaran
     * const MataPelajaran = await prisma.mataPelajaran.create({
     *   data: {
     *     // ... data to create a MataPelajaran
     *   }
     * })
     * 
    **/
    create<T extends MataPelajaranCreateArgs>(
      args: SelectSubset<T, MataPelajaranCreateArgs>
    ): Prisma__MataPelajaranClient<MataPelajaranGetPayload<T>>

    /**
     * Create many MataPelajarans.
     *     @param {MataPelajaranCreateManyArgs} args - Arguments to create many MataPelajarans.
     *     @example
     *     // Create many MataPelajarans
     *     const mataPelajaran = await prisma.mataPelajaran.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MataPelajaranCreateManyArgs>(
      args?: SelectSubset<T, MataPelajaranCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MataPelajaran.
     * @param {MataPelajaranDeleteArgs} args - Arguments to delete one MataPelajaran.
     * @example
     * // Delete one MataPelajaran
     * const MataPelajaran = await prisma.mataPelajaran.delete({
     *   where: {
     *     // ... filter to delete one MataPelajaran
     *   }
     * })
     * 
    **/
    delete<T extends MataPelajaranDeleteArgs>(
      args: SelectSubset<T, MataPelajaranDeleteArgs>
    ): Prisma__MataPelajaranClient<MataPelajaranGetPayload<T>>

    /**
     * Update one MataPelajaran.
     * @param {MataPelajaranUpdateArgs} args - Arguments to update one MataPelajaran.
     * @example
     * // Update one MataPelajaran
     * const mataPelajaran = await prisma.mataPelajaran.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MataPelajaranUpdateArgs>(
      args: SelectSubset<T, MataPelajaranUpdateArgs>
    ): Prisma__MataPelajaranClient<MataPelajaranGetPayload<T>>

    /**
     * Delete zero or more MataPelajarans.
     * @param {MataPelajaranDeleteManyArgs} args - Arguments to filter MataPelajarans to delete.
     * @example
     * // Delete a few MataPelajarans
     * const { count } = await prisma.mataPelajaran.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MataPelajaranDeleteManyArgs>(
      args?: SelectSubset<T, MataPelajaranDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MataPelajarans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MataPelajaranUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MataPelajarans
     * const mataPelajaran = await prisma.mataPelajaran.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MataPelajaranUpdateManyArgs>(
      args: SelectSubset<T, MataPelajaranUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MataPelajaran.
     * @param {MataPelajaranUpsertArgs} args - Arguments to update or create a MataPelajaran.
     * @example
     * // Update or create a MataPelajaran
     * const mataPelajaran = await prisma.mataPelajaran.upsert({
     *   create: {
     *     // ... data to create a MataPelajaran
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MataPelajaran we want to update
     *   }
     * })
    **/
    upsert<T extends MataPelajaranUpsertArgs>(
      args: SelectSubset<T, MataPelajaranUpsertArgs>
    ): Prisma__MataPelajaranClient<MataPelajaranGetPayload<T>>

    /**
     * Find zero or more MataPelajarans that matches the filter.
     * @param {MataPelajaranFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const mataPelajaran = await prisma.mataPelajaran.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: MataPelajaranFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a MataPelajaran.
     * @param {MataPelajaranAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const mataPelajaran = await prisma.mataPelajaran.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: MataPelajaranAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of MataPelajarans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MataPelajaranCountArgs} args - Arguments to filter MataPelajarans to count.
     * @example
     * // Count the number of MataPelajarans
     * const count = await prisma.mataPelajaran.count({
     *   where: {
     *     // ... the filter for the MataPelajarans we want to count
     *   }
     * })
    **/
    count<T extends MataPelajaranCountArgs>(
      args?: Subset<T, MataPelajaranCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MataPelajaranCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MataPelajaran.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MataPelajaranAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MataPelajaranAggregateArgs>(args: Subset<T, MataPelajaranAggregateArgs>): Prisma.PrismaPromise<GetMataPelajaranAggregateType<T>>

    /**
     * Group by MataPelajaran.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MataPelajaranGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MataPelajaranGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MataPelajaranGroupByArgs['orderBy'] }
        : { orderBy?: MataPelajaranGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MataPelajaranGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMataPelajaranGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MataPelajaran.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MataPelajaranClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    element<T extends MataPelajaran$elementArgs= {}>(args?: Subset<T, MataPelajaran$elementArgs>): Prisma.PrismaPromise<Array<ElementGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MataPelajaran base type for findUnique actions
   */
  export type MataPelajaranFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MataPelajaran
     */
    select?: MataPelajaranSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MataPelajaranInclude | null
    /**
     * Filter, which MataPelajaran to fetch.
     */
    where: MataPelajaranWhereUniqueInput
  }

  /**
   * MataPelajaran findUnique
   */
  export interface MataPelajaranFindUniqueArgs extends MataPelajaranFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MataPelajaran findUniqueOrThrow
   */
  export type MataPelajaranFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MataPelajaran
     */
    select?: MataPelajaranSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MataPelajaranInclude | null
    /**
     * Filter, which MataPelajaran to fetch.
     */
    where: MataPelajaranWhereUniqueInput
  }


  /**
   * MataPelajaran base type for findFirst actions
   */
  export type MataPelajaranFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MataPelajaran
     */
    select?: MataPelajaranSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MataPelajaranInclude | null
    /**
     * Filter, which MataPelajaran to fetch.
     */
    where?: MataPelajaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MataPelajarans to fetch.
     */
    orderBy?: Enumerable<MataPelajaranOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MataPelajarans.
     */
    cursor?: MataPelajaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MataPelajarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MataPelajarans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MataPelajarans.
     */
    distinct?: Enumerable<MataPelajaranScalarFieldEnum>
  }

  /**
   * MataPelajaran findFirst
   */
  export interface MataPelajaranFindFirstArgs extends MataPelajaranFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MataPelajaran findFirstOrThrow
   */
  export type MataPelajaranFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MataPelajaran
     */
    select?: MataPelajaranSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MataPelajaranInclude | null
    /**
     * Filter, which MataPelajaran to fetch.
     */
    where?: MataPelajaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MataPelajarans to fetch.
     */
    orderBy?: Enumerable<MataPelajaranOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MataPelajarans.
     */
    cursor?: MataPelajaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MataPelajarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MataPelajarans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MataPelajarans.
     */
    distinct?: Enumerable<MataPelajaranScalarFieldEnum>
  }


  /**
   * MataPelajaran findMany
   */
  export type MataPelajaranFindManyArgs = {
    /**
     * Select specific fields to fetch from the MataPelajaran
     */
    select?: MataPelajaranSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MataPelajaranInclude | null
    /**
     * Filter, which MataPelajarans to fetch.
     */
    where?: MataPelajaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MataPelajarans to fetch.
     */
    orderBy?: Enumerable<MataPelajaranOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MataPelajarans.
     */
    cursor?: MataPelajaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MataPelajarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MataPelajarans.
     */
    skip?: number
    distinct?: Enumerable<MataPelajaranScalarFieldEnum>
  }


  /**
   * MataPelajaran create
   */
  export type MataPelajaranCreateArgs = {
    /**
     * Select specific fields to fetch from the MataPelajaran
     */
    select?: MataPelajaranSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MataPelajaranInclude | null
    /**
     * The data needed to create a MataPelajaran.
     */
    data: XOR<MataPelajaranCreateInput, MataPelajaranUncheckedCreateInput>
  }


  /**
   * MataPelajaran createMany
   */
  export type MataPelajaranCreateManyArgs = {
    /**
     * The data used to create many MataPelajarans.
     */
    data: Enumerable<MataPelajaranCreateManyInput>
  }


  /**
   * MataPelajaran update
   */
  export type MataPelajaranUpdateArgs = {
    /**
     * Select specific fields to fetch from the MataPelajaran
     */
    select?: MataPelajaranSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MataPelajaranInclude | null
    /**
     * The data needed to update a MataPelajaran.
     */
    data: XOR<MataPelajaranUpdateInput, MataPelajaranUncheckedUpdateInput>
    /**
     * Choose, which MataPelajaran to update.
     */
    where: MataPelajaranWhereUniqueInput
  }


  /**
   * MataPelajaran updateMany
   */
  export type MataPelajaranUpdateManyArgs = {
    /**
     * The data used to update MataPelajarans.
     */
    data: XOR<MataPelajaranUpdateManyMutationInput, MataPelajaranUncheckedUpdateManyInput>
    /**
     * Filter which MataPelajarans to update
     */
    where?: MataPelajaranWhereInput
  }


  /**
   * MataPelajaran upsert
   */
  export type MataPelajaranUpsertArgs = {
    /**
     * Select specific fields to fetch from the MataPelajaran
     */
    select?: MataPelajaranSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MataPelajaranInclude | null
    /**
     * The filter to search for the MataPelajaran to update in case it exists.
     */
    where: MataPelajaranWhereUniqueInput
    /**
     * In case the MataPelajaran found by the `where` argument doesn't exist, create a new MataPelajaran with this data.
     */
    create: XOR<MataPelajaranCreateInput, MataPelajaranUncheckedCreateInput>
    /**
     * In case the MataPelajaran was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MataPelajaranUpdateInput, MataPelajaranUncheckedUpdateInput>
  }


  /**
   * MataPelajaran delete
   */
  export type MataPelajaranDeleteArgs = {
    /**
     * Select specific fields to fetch from the MataPelajaran
     */
    select?: MataPelajaranSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MataPelajaranInclude | null
    /**
     * Filter which MataPelajaran to delete.
     */
    where: MataPelajaranWhereUniqueInput
  }


  /**
   * MataPelajaran deleteMany
   */
  export type MataPelajaranDeleteManyArgs = {
    /**
     * Filter which MataPelajarans to delete
     */
    where?: MataPelajaranWhereInput
  }


  /**
   * MataPelajaran findRaw
   */
  export type MataPelajaranFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * MataPelajaran aggregateRaw
   */
  export type MataPelajaranAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * MataPelajaran.element
   */
  export type MataPelajaran$elementArgs = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ElementInclude | null
    where?: ElementWhereInput
    orderBy?: Enumerable<ElementOrderByWithRelationInput>
    cursor?: ElementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ElementScalarFieldEnum>
  }


  /**
   * MataPelajaran without action
   */
  export type MataPelajaranArgs = {
    /**
     * Select specific fields to fetch from the MataPelajaran
     */
    select?: MataPelajaranSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MataPelajaranInclude | null
  }



  /**
   * Model Instansi
   */


  export type AggregateInstansi = {
    _count: InstansiCountAggregateOutputType | null
    _min: InstansiMinAggregateOutputType | null
    _max: InstansiMaxAggregateOutputType | null
  }

  export type InstansiMinAggregateOutputType = {
    id: string | null
    npsn: string | null
    name: string | null
    isPrivate: boolean | null
    level: Level | null
    religion: Religion | null
    major: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstansiMaxAggregateOutputType = {
    id: string | null
    npsn: string | null
    name: string | null
    isPrivate: boolean | null
    level: Level | null
    religion: Religion | null
    major: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstansiCountAggregateOutputType = {
    id: number
    npsn: number
    name: number
    isPrivate: number
    level: number
    religion: number
    major: number
    majorIds: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InstansiMinAggregateInputType = {
    id?: true
    npsn?: true
    name?: true
    isPrivate?: true
    level?: true
    religion?: true
    major?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstansiMaxAggregateInputType = {
    id?: true
    npsn?: true
    name?: true
    isPrivate?: true
    level?: true
    religion?: true
    major?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstansiCountAggregateInputType = {
    id?: true
    npsn?: true
    name?: true
    isPrivate?: true
    level?: true
    religion?: true
    major?: true
    majorIds?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InstansiAggregateArgs = {
    /**
     * Filter which Instansi to aggregate.
     */
    where?: InstansiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instansis to fetch.
     */
    orderBy?: Enumerable<InstansiOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstansiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instansis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instansis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Instansis
    **/
    _count?: true | InstansiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstansiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstansiMaxAggregateInputType
  }

  export type GetInstansiAggregateType<T extends InstansiAggregateArgs> = {
        [P in keyof T & keyof AggregateInstansi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstansi[P]>
      : GetScalarType<T[P], AggregateInstansi[P]>
  }




  export type InstansiGroupByArgs = {
    where?: InstansiWhereInput
    orderBy?: Enumerable<InstansiOrderByWithAggregationInput>
    by: InstansiScalarFieldEnum[]
    having?: InstansiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstansiCountAggregateInputType | true
    _min?: InstansiMinAggregateInputType
    _max?: InstansiMaxAggregateInputType
  }


  export type InstansiGroupByOutputType = {
    id: string
    npsn: string
    name: string
    isPrivate: boolean
    level: Level
    religion: Religion | null
    major: boolean | null
    majorIds: string[]
    createdAt: Date
    updatedAt: Date
    _count: InstansiCountAggregateOutputType | null
    _min: InstansiMinAggregateOutputType | null
    _max: InstansiMaxAggregateOutputType | null
  }

  type GetInstansiGroupByPayload<T extends InstansiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<InstansiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstansiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstansiGroupByOutputType[P]>
            : GetScalarType<T[P], InstansiGroupByOutputType[P]>
        }
      >
    >


  export type InstansiSelect = {
    id?: boolean
    npsn?: boolean
    name?: boolean
    isPrivate?: boolean
    address?: boolean | AddressArgs
    level?: boolean
    religion?: boolean
    major?: boolean
    majorIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    majors?: boolean | Instansi$majorsArgs
    role?: boolean | Instansi$roleArgs
    schoolYear?: boolean | Instansi$schoolYearArgs
    teacher?: boolean | Instansi$teacherArgs
    student?: boolean | Instansi$studentArgs
    _count?: boolean | InstansiCountOutputTypeArgs
  }


  export type InstansiInclude = {
    majors?: boolean | Instansi$majorsArgs
    role?: boolean | Instansi$roleArgs
    schoolYear?: boolean | Instansi$schoolYearArgs
    teacher?: boolean | Instansi$teacherArgs
    student?: boolean | Instansi$studentArgs
    _count?: boolean | InstansiCountOutputTypeArgs
  }

  export type InstansiGetPayload<S extends boolean | null | undefined | InstansiArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Instansi :
    S extends undefined ? never :
    S extends { include: any } & (InstansiArgs | InstansiFindManyArgs)
    ? Instansi  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'majors' ? Array < KonsentrasiKeahlianGetPayload<S['include'][P]>>  :
        P extends 'role' ? Array < RoleGetPayload<S['include'][P]>>  :
        P extends 'schoolYear' ? Array < SchoolYearGetPayload<S['include'][P]>>  :
        P extends 'teacher' ? Array < TeacherGetPayload<S['include'][P]>>  :
        P extends 'student' ? Array < StudentGetPayload<S['include'][P]>>  :
        P extends '_count' ? InstansiCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (InstansiArgs | InstansiFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'address' ? AddressGetPayload<S['select'][P]> :
        P extends 'majors' ? Array < KonsentrasiKeahlianGetPayload<S['select'][P]>>  :
        P extends 'role' ? Array < RoleGetPayload<S['select'][P]>>  :
        P extends 'schoolYear' ? Array < SchoolYearGetPayload<S['select'][P]>>  :
        P extends 'teacher' ? Array < TeacherGetPayload<S['select'][P]>>  :
        P extends 'student' ? Array < StudentGetPayload<S['select'][P]>>  :
        P extends '_count' ? InstansiCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Instansi ? Instansi[P] : never
  } 
      : Instansi


  type InstansiCountArgs = 
    Omit<InstansiFindManyArgs, 'select' | 'include'> & {
      select?: InstansiCountAggregateInputType | true
    }

  export interface InstansiDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Instansi that matches the filter.
     * @param {InstansiFindUniqueArgs} args - Arguments to find a Instansi
     * @example
     * // Get one Instansi
     * const instansi = await prisma.instansi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InstansiFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InstansiFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Instansi'> extends True ? Prisma__InstansiClient<InstansiGetPayload<T>> : Prisma__InstansiClient<InstansiGetPayload<T> | null, null>

    /**
     * Find one Instansi that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InstansiFindUniqueOrThrowArgs} args - Arguments to find a Instansi
     * @example
     * // Get one Instansi
     * const instansi = await prisma.instansi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InstansiFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, InstansiFindUniqueOrThrowArgs>
    ): Prisma__InstansiClient<InstansiGetPayload<T>>

    /**
     * Find the first Instansi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstansiFindFirstArgs} args - Arguments to find a Instansi
     * @example
     * // Get one Instansi
     * const instansi = await prisma.instansi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InstansiFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InstansiFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Instansi'> extends True ? Prisma__InstansiClient<InstansiGetPayload<T>> : Prisma__InstansiClient<InstansiGetPayload<T> | null, null>

    /**
     * Find the first Instansi that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstansiFindFirstOrThrowArgs} args - Arguments to find a Instansi
     * @example
     * // Get one Instansi
     * const instansi = await prisma.instansi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InstansiFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InstansiFindFirstOrThrowArgs>
    ): Prisma__InstansiClient<InstansiGetPayload<T>>

    /**
     * Find zero or more Instansis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstansiFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Instansis
     * const instansis = await prisma.instansi.findMany()
     * 
     * // Get first 10 Instansis
     * const instansis = await prisma.instansi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instansiWithIdOnly = await prisma.instansi.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InstansiFindManyArgs>(
      args?: SelectSubset<T, InstansiFindManyArgs>
    ): Prisma.PrismaPromise<Array<InstansiGetPayload<T>>>

    /**
     * Create a Instansi.
     * @param {InstansiCreateArgs} args - Arguments to create a Instansi.
     * @example
     * // Create one Instansi
     * const Instansi = await prisma.instansi.create({
     *   data: {
     *     // ... data to create a Instansi
     *   }
     * })
     * 
    **/
    create<T extends InstansiCreateArgs>(
      args: SelectSubset<T, InstansiCreateArgs>
    ): Prisma__InstansiClient<InstansiGetPayload<T>>

    /**
     * Create many Instansis.
     *     @param {InstansiCreateManyArgs} args - Arguments to create many Instansis.
     *     @example
     *     // Create many Instansis
     *     const instansi = await prisma.instansi.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InstansiCreateManyArgs>(
      args?: SelectSubset<T, InstansiCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Instansi.
     * @param {InstansiDeleteArgs} args - Arguments to delete one Instansi.
     * @example
     * // Delete one Instansi
     * const Instansi = await prisma.instansi.delete({
     *   where: {
     *     // ... filter to delete one Instansi
     *   }
     * })
     * 
    **/
    delete<T extends InstansiDeleteArgs>(
      args: SelectSubset<T, InstansiDeleteArgs>
    ): Prisma__InstansiClient<InstansiGetPayload<T>>

    /**
     * Update one Instansi.
     * @param {InstansiUpdateArgs} args - Arguments to update one Instansi.
     * @example
     * // Update one Instansi
     * const instansi = await prisma.instansi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InstansiUpdateArgs>(
      args: SelectSubset<T, InstansiUpdateArgs>
    ): Prisma__InstansiClient<InstansiGetPayload<T>>

    /**
     * Delete zero or more Instansis.
     * @param {InstansiDeleteManyArgs} args - Arguments to filter Instansis to delete.
     * @example
     * // Delete a few Instansis
     * const { count } = await prisma.instansi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InstansiDeleteManyArgs>(
      args?: SelectSubset<T, InstansiDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instansis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstansiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Instansis
     * const instansi = await prisma.instansi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InstansiUpdateManyArgs>(
      args: SelectSubset<T, InstansiUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Instansi.
     * @param {InstansiUpsertArgs} args - Arguments to update or create a Instansi.
     * @example
     * // Update or create a Instansi
     * const instansi = await prisma.instansi.upsert({
     *   create: {
     *     // ... data to create a Instansi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Instansi we want to update
     *   }
     * })
    **/
    upsert<T extends InstansiUpsertArgs>(
      args: SelectSubset<T, InstansiUpsertArgs>
    ): Prisma__InstansiClient<InstansiGetPayload<T>>

    /**
     * Find zero or more Instansis that matches the filter.
     * @param {InstansiFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const instansi = await prisma.instansi.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: InstansiFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Instansi.
     * @param {InstansiAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const instansi = await prisma.instansi.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: InstansiAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Instansis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstansiCountArgs} args - Arguments to filter Instansis to count.
     * @example
     * // Count the number of Instansis
     * const count = await prisma.instansi.count({
     *   where: {
     *     // ... the filter for the Instansis we want to count
     *   }
     * })
    **/
    count<T extends InstansiCountArgs>(
      args?: Subset<T, InstansiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstansiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Instansi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstansiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstansiAggregateArgs>(args: Subset<T, InstansiAggregateArgs>): Prisma.PrismaPromise<GetInstansiAggregateType<T>>

    /**
     * Group by Instansi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstansiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstansiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstansiGroupByArgs['orderBy'] }
        : { orderBy?: InstansiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstansiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstansiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Instansi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InstansiClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    address<T extends AddressArgs= {}>(args?: Subset<T, AddressArgs>): Prisma__AddressClient<AddressGetPayload<T> | Null>;

    majors<T extends Instansi$majorsArgs= {}>(args?: Subset<T, Instansi$majorsArgs>): Prisma.PrismaPromise<Array<KonsentrasiKeahlianGetPayload<T>>| Null>;

    role<T extends Instansi$roleArgs= {}>(args?: Subset<T, Instansi$roleArgs>): Prisma.PrismaPromise<Array<RoleGetPayload<T>>| Null>;

    schoolYear<T extends Instansi$schoolYearArgs= {}>(args?: Subset<T, Instansi$schoolYearArgs>): Prisma.PrismaPromise<Array<SchoolYearGetPayload<T>>| Null>;

    teacher<T extends Instansi$teacherArgs= {}>(args?: Subset<T, Instansi$teacherArgs>): Prisma.PrismaPromise<Array<TeacherGetPayload<T>>| Null>;

    student<T extends Instansi$studentArgs= {}>(args?: Subset<T, Instansi$studentArgs>): Prisma.PrismaPromise<Array<StudentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Instansi base type for findUnique actions
   */
  export type InstansiFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Instansi
     */
    select?: InstansiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstansiInclude | null
    /**
     * Filter, which Instansi to fetch.
     */
    where: InstansiWhereUniqueInput
  }

  /**
   * Instansi findUnique
   */
  export interface InstansiFindUniqueArgs extends InstansiFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Instansi findUniqueOrThrow
   */
  export type InstansiFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Instansi
     */
    select?: InstansiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstansiInclude | null
    /**
     * Filter, which Instansi to fetch.
     */
    where: InstansiWhereUniqueInput
  }


  /**
   * Instansi base type for findFirst actions
   */
  export type InstansiFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Instansi
     */
    select?: InstansiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstansiInclude | null
    /**
     * Filter, which Instansi to fetch.
     */
    where?: InstansiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instansis to fetch.
     */
    orderBy?: Enumerable<InstansiOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instansis.
     */
    cursor?: InstansiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instansis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instansis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instansis.
     */
    distinct?: Enumerable<InstansiScalarFieldEnum>
  }

  /**
   * Instansi findFirst
   */
  export interface InstansiFindFirstArgs extends InstansiFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Instansi findFirstOrThrow
   */
  export type InstansiFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Instansi
     */
    select?: InstansiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstansiInclude | null
    /**
     * Filter, which Instansi to fetch.
     */
    where?: InstansiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instansis to fetch.
     */
    orderBy?: Enumerable<InstansiOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instansis.
     */
    cursor?: InstansiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instansis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instansis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instansis.
     */
    distinct?: Enumerable<InstansiScalarFieldEnum>
  }


  /**
   * Instansi findMany
   */
  export type InstansiFindManyArgs = {
    /**
     * Select specific fields to fetch from the Instansi
     */
    select?: InstansiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstansiInclude | null
    /**
     * Filter, which Instansis to fetch.
     */
    where?: InstansiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instansis to fetch.
     */
    orderBy?: Enumerable<InstansiOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Instansis.
     */
    cursor?: InstansiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instansis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instansis.
     */
    skip?: number
    distinct?: Enumerable<InstansiScalarFieldEnum>
  }


  /**
   * Instansi create
   */
  export type InstansiCreateArgs = {
    /**
     * Select specific fields to fetch from the Instansi
     */
    select?: InstansiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstansiInclude | null
    /**
     * The data needed to create a Instansi.
     */
    data: XOR<InstansiCreateInput, InstansiUncheckedCreateInput>
  }


  /**
   * Instansi createMany
   */
  export type InstansiCreateManyArgs = {
    /**
     * The data used to create many Instansis.
     */
    data: Enumerable<InstansiCreateManyInput>
  }


  /**
   * Instansi update
   */
  export type InstansiUpdateArgs = {
    /**
     * Select specific fields to fetch from the Instansi
     */
    select?: InstansiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstansiInclude | null
    /**
     * The data needed to update a Instansi.
     */
    data: XOR<InstansiUpdateInput, InstansiUncheckedUpdateInput>
    /**
     * Choose, which Instansi to update.
     */
    where: InstansiWhereUniqueInput
  }


  /**
   * Instansi updateMany
   */
  export type InstansiUpdateManyArgs = {
    /**
     * The data used to update Instansis.
     */
    data: XOR<InstansiUpdateManyMutationInput, InstansiUncheckedUpdateManyInput>
    /**
     * Filter which Instansis to update
     */
    where?: InstansiWhereInput
  }


  /**
   * Instansi upsert
   */
  export type InstansiUpsertArgs = {
    /**
     * Select specific fields to fetch from the Instansi
     */
    select?: InstansiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstansiInclude | null
    /**
     * The filter to search for the Instansi to update in case it exists.
     */
    where: InstansiWhereUniqueInput
    /**
     * In case the Instansi found by the `where` argument doesn't exist, create a new Instansi with this data.
     */
    create: XOR<InstansiCreateInput, InstansiUncheckedCreateInput>
    /**
     * In case the Instansi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstansiUpdateInput, InstansiUncheckedUpdateInput>
  }


  /**
   * Instansi delete
   */
  export type InstansiDeleteArgs = {
    /**
     * Select specific fields to fetch from the Instansi
     */
    select?: InstansiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstansiInclude | null
    /**
     * Filter which Instansi to delete.
     */
    where: InstansiWhereUniqueInput
  }


  /**
   * Instansi deleteMany
   */
  export type InstansiDeleteManyArgs = {
    /**
     * Filter which Instansis to delete
     */
    where?: InstansiWhereInput
  }


  /**
   * Instansi findRaw
   */
  export type InstansiFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Instansi aggregateRaw
   */
  export type InstansiAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Instansi.majors
   */
  export type Instansi$majorsArgs = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
    where?: KonsentrasiKeahlianWhereInput
    orderBy?: Enumerable<KonsentrasiKeahlianOrderByWithRelationInput>
    cursor?: KonsentrasiKeahlianWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<KonsentrasiKeahlianScalarFieldEnum>
  }


  /**
   * Instansi.role
   */
  export type Instansi$roleArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    where?: RoleWhereInput
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Instansi.schoolYear
   */
  export type Instansi$schoolYearArgs = {
    /**
     * Select specific fields to fetch from the SchoolYear
     */
    select?: SchoolYearSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolYearInclude | null
    where?: SchoolYearWhereInput
    orderBy?: Enumerable<SchoolYearOrderByWithRelationInput>
    cursor?: SchoolYearWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SchoolYearScalarFieldEnum>
  }


  /**
   * Instansi.teacher
   */
  export type Instansi$teacherArgs = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
    where?: TeacherWhereInput
    orderBy?: Enumerable<TeacherOrderByWithRelationInput>
    cursor?: TeacherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeacherScalarFieldEnum>
  }


  /**
   * Instansi.student
   */
  export type Instansi$studentArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    where?: StudentWhereInput
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * Instansi without action
   */
  export type InstansiArgs = {
    /**
     * Select specific fields to fetch from the Instansi
     */
    select?: InstansiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstansiInclude | null
  }



  /**
   * Model Role
   */


  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    key: Roles | null
    instansiId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    key: Roles | null
    instansiId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    key: number
    instansiId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    key?: true
    instansiId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    key?: true
    instansiId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    key?: true
    instansiId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs = {
    where?: RoleWhereInput
    orderBy?: Enumerable<RoleOrderByWithAggregationInput>
    by: RoleScalarFieldEnum[]
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }


  export type RoleGroupByOutputType = {
    id: string
    key: Roles
    instansiId: string
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect = {
    id?: boolean
    key?: boolean
    instansiId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instansi?: boolean | InstansiArgs
    users?: boolean | Role$usersArgs
    _count?: boolean | RoleCountOutputTypeArgs
  }


  export type RoleInclude = {
    instansi?: boolean | InstansiArgs
    users?: boolean | Role$usersArgs
    _count?: boolean | RoleCountOutputTypeArgs
  }

  export type RoleGetPayload<S extends boolean | null | undefined | RoleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Role :
    S extends undefined ? never :
    S extends { include: any } & (RoleArgs | RoleFindManyArgs)
    ? Role  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'instansi' ? InstansiGetPayload<S['include'][P]> :
        P extends 'users' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends '_count' ? RoleCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RoleArgs | RoleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'instansi' ? InstansiGetPayload<S['select'][P]> :
        P extends 'users' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends '_count' ? RoleCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Role ? Role[P] : never
  } 
      : Role


  type RoleCountArgs = 
    Omit<RoleFindManyArgs, 'select' | 'include'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RoleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Role'> extends True ? Prisma__RoleClient<RoleGetPayload<T>> : Prisma__RoleClient<RoleGetPayload<T> | null, null>

    /**
     * Find one Role that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RoleFindUniqueOrThrowArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RoleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Role'> extends True ? Prisma__RoleClient<RoleGetPayload<T>> : Prisma__RoleClient<RoleGetPayload<T> | null, null>

    /**
     * Find the first Role that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RoleFindFirstOrThrowArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoleFindManyArgs>(
      args?: SelectSubset<T, RoleFindManyArgs>
    ): Prisma.PrismaPromise<Array<RoleGetPayload<T>>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
    **/
    create<T extends RoleCreateArgs>(
      args: SelectSubset<T, RoleCreateArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Create many Roles.
     *     @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const role = await prisma.role.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoleCreateManyArgs>(
      args?: SelectSubset<T, RoleCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
    **/
    delete<T extends RoleDeleteArgs>(
      args: SelectSubset<T, RoleDeleteArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoleUpdateArgs>(
      args: SelectSubset<T, RoleUpdateArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoleDeleteManyArgs>(
      args?: SelectSubset<T, RoleDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoleUpdateManyArgs>(
      args: SelectSubset<T, RoleUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
    **/
    upsert<T extends RoleUpsertArgs>(
      args: SelectSubset<T, RoleUpsertArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Find zero or more Roles that matches the filter.
     * @param {RoleFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const role = await prisma.role.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: RoleFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Role.
     * @param {RoleAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const role = await prisma.role.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: RoleAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoleClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    instansi<T extends InstansiArgs= {}>(args?: Subset<T, InstansiArgs>): Prisma__InstansiClient<InstansiGetPayload<T> | Null>;

    users<T extends Role$usersArgs= {}>(args?: Subset<T, Role$usersArgs>): Prisma.PrismaPromise<Array<UserGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Role base type for findUnique actions
   */
  export type RoleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUnique
   */
  export interface RoleFindUniqueArgs extends RoleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role base type for findFirst actions
   */
  export type RoleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: Enumerable<RoleScalarFieldEnum>
  }

  /**
   * Role findFirst
   */
  export interface RoleFindFirstArgs extends RoleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role findMany
   */
  export type RoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role create
   */
  export type RoleCreateArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }


  /**
   * Role createMany
   */
  export type RoleCreateManyArgs = {
    /**
     * The data used to create many Roles.
     */
    data: Enumerable<RoleCreateManyInput>
  }


  /**
   * Role update
   */
  export type RoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }


  /**
   * Role upsert
   */
  export type RoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }


  /**
   * Role delete
   */
  export type RoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }


  /**
   * Role findRaw
   */
  export type RoleFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Role aggregateRaw
   */
  export type RoleAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Role.users
   */
  export type Role$usersArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * Role without action
   */
  export type RoleArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    picture: string | null
    username: string | null
    active: boolean | null
    verify: boolean | null
    password: string | null
    passhash: string | null
    createdAt: Date | null
    updatedAt: Date | null
    roleId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    picture: string | null
    username: string | null
    active: boolean | null
    verify: boolean | null
    password: string | null
    passhash: string | null
    createdAt: Date | null
    updatedAt: Date | null
    roleId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    picture: number
    username: number
    active: number
    verify: number
    password: number
    passhash: number
    createdAt: number
    updatedAt: number
    roleId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    picture?: true
    username?: true
    active?: true
    verify?: true
    password?: true
    passhash?: true
    createdAt?: true
    updatedAt?: true
    roleId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    picture?: true
    username?: true
    active?: true
    verify?: true
    password?: true
    passhash?: true
    createdAt?: true
    updatedAt?: true
    roleId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    picture?: true
    username?: true
    active?: true
    verify?: true
    password?: true
    passhash?: true
    createdAt?: true
    updatedAt?: true
    roleId?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    name: string
    picture: string | null
    username: string
    active: boolean
    verify: boolean
    password: string
    passhash: string
    createdAt: Date
    updatedAt: Date
    roleId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    name?: boolean
    picture?: boolean
    username?: boolean
    active?: boolean
    verify?: boolean
    password?: boolean
    passhash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roleId?: boolean
    role?: boolean | RoleArgs
    personal?: boolean | PersonalArgs
    student?: boolean | StudentArgs
    teacher?: boolean | TeacherArgs
  }


  export type UserInclude = {
    role?: boolean | RoleArgs
    personal?: boolean | PersonalArgs
    student?: boolean | StudentArgs
    teacher?: boolean | TeacherArgs
  }

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'role' ? RoleGetPayload<S['include'][P]> | null :
        P extends 'personal' ? PersonalGetPayload<S['include'][P]> | null :
        P extends 'student' ? StudentGetPayload<S['include'][P]> | null :
        P extends 'teacher' ? TeacherGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'role' ? RoleGetPayload<S['select'][P]> | null :
        P extends 'personal' ? PersonalGetPayload<S['select'][P]> | null :
        P extends 'student' ? StudentGetPayload<S['select'][P]> | null :
        P extends 'teacher' ? TeacherGetPayload<S['select'][P]> | null :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: UserFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: UserAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    role<T extends RoleArgs= {}>(args?: Subset<T, RoleArgs>): Prisma__RoleClient<RoleGetPayload<T> | Null>;

    personal<T extends PersonalArgs= {}>(args?: Subset<T, PersonalArgs>): Prisma__PersonalClient<PersonalGetPayload<T> | Null>;

    student<T extends StudentArgs= {}>(args?: Subset<T, StudentArgs>): Prisma__StudentClient<StudentGetPayload<T> | Null>;

    teacher<T extends TeacherArgs= {}>(args?: Subset<T, TeacherArgs>): Prisma__TeacherClient<TeacherGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User findRaw
   */
  export type UserFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
  }



  /**
   * Model Personal
   */


  export type AggregatePersonal = {
    _count: PersonalCountAggregateOutputType | null
    _min: PersonalMinAggregateOutputType | null
    _max: PersonalMaxAggregateOutputType | null
  }

  export type PersonalMinAggregateOutputType = {
    id: string | null
    nik: string | null
    nisn: string | null
    type: TypePersonal | null
    userId: string | null
    fullname: string | null
    gender: Gender | null
    foreign: boolean | null
    country: string | null
    religion: Religion | null
    email: string | null
    belajarId: string | null
    nophone: string | null
    isLife: boolean | null
  }

  export type PersonalMaxAggregateOutputType = {
    id: string | null
    nik: string | null
    nisn: string | null
    type: TypePersonal | null
    userId: string | null
    fullname: string | null
    gender: Gender | null
    foreign: boolean | null
    country: string | null
    religion: Religion | null
    email: string | null
    belajarId: string | null
    nophone: string | null
    isLife: boolean | null
  }

  export type PersonalCountAggregateOutputType = {
    id: number
    nik: number
    nisn: number
    type: number
    userId: number
    fullname: number
    gender: number
    foreign: number
    country: number
    religion: number
    email: number
    belajarId: number
    nophone: number
    isLife: number
    _all: number
  }


  export type PersonalMinAggregateInputType = {
    id?: true
    nik?: true
    nisn?: true
    type?: true
    userId?: true
    fullname?: true
    gender?: true
    foreign?: true
    country?: true
    religion?: true
    email?: true
    belajarId?: true
    nophone?: true
    isLife?: true
  }

  export type PersonalMaxAggregateInputType = {
    id?: true
    nik?: true
    nisn?: true
    type?: true
    userId?: true
    fullname?: true
    gender?: true
    foreign?: true
    country?: true
    religion?: true
    email?: true
    belajarId?: true
    nophone?: true
    isLife?: true
  }

  export type PersonalCountAggregateInputType = {
    id?: true
    nik?: true
    nisn?: true
    type?: true
    userId?: true
    fullname?: true
    gender?: true
    foreign?: true
    country?: true
    religion?: true
    email?: true
    belajarId?: true
    nophone?: true
    isLife?: true
    _all?: true
  }

  export type PersonalAggregateArgs = {
    /**
     * Filter which Personal to aggregate.
     */
    where?: PersonalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personals to fetch.
     */
    orderBy?: Enumerable<PersonalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Personals
    **/
    _count?: true | PersonalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonalMaxAggregateInputType
  }

  export type GetPersonalAggregateType<T extends PersonalAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonal[P]>
      : GetScalarType<T[P], AggregatePersonal[P]>
  }




  export type PersonalGroupByArgs = {
    where?: PersonalWhereInput
    orderBy?: Enumerable<PersonalOrderByWithAggregationInput>
    by: PersonalScalarFieldEnum[]
    having?: PersonalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonalCountAggregateInputType | true
    _min?: PersonalMinAggregateInputType
    _max?: PersonalMaxAggregateInputType
  }


  export type PersonalGroupByOutputType = {
    id: string
    nik: string | null
    nisn: string | null
    type: TypePersonal
    userId: string | null
    fullname: string
    gender: Gender
    foreign: boolean
    country: string | null
    religion: Religion
    email: string
    belajarId: string | null
    nophone: string
    isLife: boolean | null
    _count: PersonalCountAggregateOutputType | null
    _min: PersonalMinAggregateOutputType | null
    _max: PersonalMaxAggregateOutputType | null
  }

  type GetPersonalGroupByPayload<T extends PersonalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PersonalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonalGroupByOutputType[P]>
            : GetScalarType<T[P], PersonalGroupByOutputType[P]>
        }
      >
    >


  export type PersonalSelect = {
    id?: boolean
    nik?: boolean
    nisn?: boolean
    type?: boolean
    userId?: boolean
    fullname?: boolean
    gender?: boolean
    foreign?: boolean
    country?: boolean
    religion?: boolean
    born?: boolean | BornArgs
    email?: boolean
    belajarId?: boolean
    nophone?: boolean
    isLife?: boolean
    address?: boolean | AddressArgs
    user?: boolean | UserArgs
    father?: boolean | Personal$fatherArgs
    mother?: boolean | Personal$motherArgs
    wali?: boolean | Personal$waliArgs
    child?: boolean | FamilyTreeChildArgs
    _count?: boolean | PersonalCountOutputTypeArgs
  }


  export type PersonalInclude = {
    user?: boolean | UserArgs
    father?: boolean | Personal$fatherArgs
    mother?: boolean | Personal$motherArgs
    wali?: boolean | Personal$waliArgs
    child?: boolean | FamilyTreeChildArgs
    _count?: boolean | PersonalCountOutputTypeArgs
  }

  export type PersonalGetPayload<S extends boolean | null | undefined | PersonalArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Personal :
    S extends undefined ? never :
    S extends { include: any } & (PersonalArgs | PersonalFindManyArgs)
    ? Personal  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> | null :
        P extends 'father' ? Array < FamilyTreeGetPayload<S['include'][P]>>  :
        P extends 'mother' ? Array < FamilyTreeGetPayload<S['include'][P]>>  :
        P extends 'wali' ? Array < FamilyTreeGetPayload<S['include'][P]>>  :
        P extends 'child' ? FamilyTreeChildGetPayload<S['include'][P]> | null :
        P extends '_count' ? PersonalCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PersonalArgs | PersonalFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'born' ? BornGetPayload<S['select'][P]> :
        P extends 'address' ? AddressGetPayload<S['select'][P]> | null :
        P extends 'user' ? UserGetPayload<S['select'][P]> | null :
        P extends 'father' ? Array < FamilyTreeGetPayload<S['select'][P]>>  :
        P extends 'mother' ? Array < FamilyTreeGetPayload<S['select'][P]>>  :
        P extends 'wali' ? Array < FamilyTreeGetPayload<S['select'][P]>>  :
        P extends 'child' ? FamilyTreeChildGetPayload<S['select'][P]> | null :
        P extends '_count' ? PersonalCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Personal ? Personal[P] : never
  } 
      : Personal


  type PersonalCountArgs = 
    Omit<PersonalFindManyArgs, 'select' | 'include'> & {
      select?: PersonalCountAggregateInputType | true
    }

  export interface PersonalDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Personal that matches the filter.
     * @param {PersonalFindUniqueArgs} args - Arguments to find a Personal
     * @example
     * // Get one Personal
     * const personal = await prisma.personal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PersonalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PersonalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Personal'> extends True ? Prisma__PersonalClient<PersonalGetPayload<T>> : Prisma__PersonalClient<PersonalGetPayload<T> | null, null>

    /**
     * Find one Personal that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PersonalFindUniqueOrThrowArgs} args - Arguments to find a Personal
     * @example
     * // Get one Personal
     * const personal = await prisma.personal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PersonalFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PersonalFindUniqueOrThrowArgs>
    ): Prisma__PersonalClient<PersonalGetPayload<T>>

    /**
     * Find the first Personal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalFindFirstArgs} args - Arguments to find a Personal
     * @example
     * // Get one Personal
     * const personal = await prisma.personal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PersonalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PersonalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Personal'> extends True ? Prisma__PersonalClient<PersonalGetPayload<T>> : Prisma__PersonalClient<PersonalGetPayload<T> | null, null>

    /**
     * Find the first Personal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalFindFirstOrThrowArgs} args - Arguments to find a Personal
     * @example
     * // Get one Personal
     * const personal = await prisma.personal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PersonalFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PersonalFindFirstOrThrowArgs>
    ): Prisma__PersonalClient<PersonalGetPayload<T>>

    /**
     * Find zero or more Personals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Personals
     * const personals = await prisma.personal.findMany()
     * 
     * // Get first 10 Personals
     * const personals = await prisma.personal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personalWithIdOnly = await prisma.personal.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PersonalFindManyArgs>(
      args?: SelectSubset<T, PersonalFindManyArgs>
    ): Prisma.PrismaPromise<Array<PersonalGetPayload<T>>>

    /**
     * Create a Personal.
     * @param {PersonalCreateArgs} args - Arguments to create a Personal.
     * @example
     * // Create one Personal
     * const Personal = await prisma.personal.create({
     *   data: {
     *     // ... data to create a Personal
     *   }
     * })
     * 
    **/
    create<T extends PersonalCreateArgs>(
      args: SelectSubset<T, PersonalCreateArgs>
    ): Prisma__PersonalClient<PersonalGetPayload<T>>

    /**
     * Create many Personals.
     *     @param {PersonalCreateManyArgs} args - Arguments to create many Personals.
     *     @example
     *     // Create many Personals
     *     const personal = await prisma.personal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PersonalCreateManyArgs>(
      args?: SelectSubset<T, PersonalCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Personal.
     * @param {PersonalDeleteArgs} args - Arguments to delete one Personal.
     * @example
     * // Delete one Personal
     * const Personal = await prisma.personal.delete({
     *   where: {
     *     // ... filter to delete one Personal
     *   }
     * })
     * 
    **/
    delete<T extends PersonalDeleteArgs>(
      args: SelectSubset<T, PersonalDeleteArgs>
    ): Prisma__PersonalClient<PersonalGetPayload<T>>

    /**
     * Update one Personal.
     * @param {PersonalUpdateArgs} args - Arguments to update one Personal.
     * @example
     * // Update one Personal
     * const personal = await prisma.personal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PersonalUpdateArgs>(
      args: SelectSubset<T, PersonalUpdateArgs>
    ): Prisma__PersonalClient<PersonalGetPayload<T>>

    /**
     * Delete zero or more Personals.
     * @param {PersonalDeleteManyArgs} args - Arguments to filter Personals to delete.
     * @example
     * // Delete a few Personals
     * const { count } = await prisma.personal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PersonalDeleteManyArgs>(
      args?: SelectSubset<T, PersonalDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Personals
     * const personal = await prisma.personal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PersonalUpdateManyArgs>(
      args: SelectSubset<T, PersonalUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Personal.
     * @param {PersonalUpsertArgs} args - Arguments to update or create a Personal.
     * @example
     * // Update or create a Personal
     * const personal = await prisma.personal.upsert({
     *   create: {
     *     // ... data to create a Personal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Personal we want to update
     *   }
     * })
    **/
    upsert<T extends PersonalUpsertArgs>(
      args: SelectSubset<T, PersonalUpsertArgs>
    ): Prisma__PersonalClient<PersonalGetPayload<T>>

    /**
     * Find zero or more Personals that matches the filter.
     * @param {PersonalFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const personal = await prisma.personal.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: PersonalFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Personal.
     * @param {PersonalAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const personal = await prisma.personal.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: PersonalAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Personals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalCountArgs} args - Arguments to filter Personals to count.
     * @example
     * // Count the number of Personals
     * const count = await prisma.personal.count({
     *   where: {
     *     // ... the filter for the Personals we want to count
     *   }
     * })
    **/
    count<T extends PersonalCountArgs>(
      args?: Subset<T, PersonalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Personal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonalAggregateArgs>(args: Subset<T, PersonalAggregateArgs>): Prisma.PrismaPromise<GetPersonalAggregateType<T>>

    /**
     * Group by Personal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonalGroupByArgs['orderBy'] }
        : { orderBy?: PersonalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Personal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PersonalClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    born<T extends BornArgs= {}>(args?: Subset<T, BornArgs>): Prisma__BornClient<BornGetPayload<T> | Null>;

    address<T extends AddressArgs= {}>(args?: Subset<T, AddressArgs>): Prisma__AddressClient<AddressGetPayload<T> | Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    father<T extends Personal$fatherArgs= {}>(args?: Subset<T, Personal$fatherArgs>): Prisma.PrismaPromise<Array<FamilyTreeGetPayload<T>>| Null>;

    mother<T extends Personal$motherArgs= {}>(args?: Subset<T, Personal$motherArgs>): Prisma.PrismaPromise<Array<FamilyTreeGetPayload<T>>| Null>;

    wali<T extends Personal$waliArgs= {}>(args?: Subset<T, Personal$waliArgs>): Prisma.PrismaPromise<Array<FamilyTreeGetPayload<T>>| Null>;

    child<T extends FamilyTreeChildArgs= {}>(args?: Subset<T, FamilyTreeChildArgs>): Prisma__FamilyTreeChildClient<FamilyTreeChildGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Personal base type for findUnique actions
   */
  export type PersonalFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * Filter, which Personal to fetch.
     */
    where: PersonalWhereUniqueInput
  }

  /**
   * Personal findUnique
   */
  export interface PersonalFindUniqueArgs extends PersonalFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Personal findUniqueOrThrow
   */
  export type PersonalFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * Filter, which Personal to fetch.
     */
    where: PersonalWhereUniqueInput
  }


  /**
   * Personal base type for findFirst actions
   */
  export type PersonalFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * Filter, which Personal to fetch.
     */
    where?: PersonalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personals to fetch.
     */
    orderBy?: Enumerable<PersonalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personals.
     */
    cursor?: PersonalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personals.
     */
    distinct?: Enumerable<PersonalScalarFieldEnum>
  }

  /**
   * Personal findFirst
   */
  export interface PersonalFindFirstArgs extends PersonalFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Personal findFirstOrThrow
   */
  export type PersonalFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * Filter, which Personal to fetch.
     */
    where?: PersonalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personals to fetch.
     */
    orderBy?: Enumerable<PersonalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personals.
     */
    cursor?: PersonalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personals.
     */
    distinct?: Enumerable<PersonalScalarFieldEnum>
  }


  /**
   * Personal findMany
   */
  export type PersonalFindManyArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * Filter, which Personals to fetch.
     */
    where?: PersonalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personals to fetch.
     */
    orderBy?: Enumerable<PersonalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Personals.
     */
    cursor?: PersonalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personals.
     */
    skip?: number
    distinct?: Enumerable<PersonalScalarFieldEnum>
  }


  /**
   * Personal create
   */
  export type PersonalCreateArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * The data needed to create a Personal.
     */
    data: XOR<PersonalCreateInput, PersonalUncheckedCreateInput>
  }


  /**
   * Personal createMany
   */
  export type PersonalCreateManyArgs = {
    /**
     * The data used to create many Personals.
     */
    data: Enumerable<PersonalCreateManyInput>
  }


  /**
   * Personal update
   */
  export type PersonalUpdateArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * The data needed to update a Personal.
     */
    data: XOR<PersonalUpdateInput, PersonalUncheckedUpdateInput>
    /**
     * Choose, which Personal to update.
     */
    where: PersonalWhereUniqueInput
  }


  /**
   * Personal updateMany
   */
  export type PersonalUpdateManyArgs = {
    /**
     * The data used to update Personals.
     */
    data: XOR<PersonalUpdateManyMutationInput, PersonalUncheckedUpdateManyInput>
    /**
     * Filter which Personals to update
     */
    where?: PersonalWhereInput
  }


  /**
   * Personal upsert
   */
  export type PersonalUpsertArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * The filter to search for the Personal to update in case it exists.
     */
    where: PersonalWhereUniqueInput
    /**
     * In case the Personal found by the `where` argument doesn't exist, create a new Personal with this data.
     */
    create: XOR<PersonalCreateInput, PersonalUncheckedCreateInput>
    /**
     * In case the Personal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonalUpdateInput, PersonalUncheckedUpdateInput>
  }


  /**
   * Personal delete
   */
  export type PersonalDeleteArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * Filter which Personal to delete.
     */
    where: PersonalWhereUniqueInput
  }


  /**
   * Personal deleteMany
   */
  export type PersonalDeleteManyArgs = {
    /**
     * Filter which Personals to delete
     */
    where?: PersonalWhereInput
  }


  /**
   * Personal findRaw
   */
  export type PersonalFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Personal aggregateRaw
   */
  export type PersonalAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Personal.father
   */
  export type Personal$fatherArgs = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    where?: FamilyTreeWhereInput
    orderBy?: Enumerable<FamilyTreeOrderByWithRelationInput>
    cursor?: FamilyTreeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FamilyTreeScalarFieldEnum>
  }


  /**
   * Personal.mother
   */
  export type Personal$motherArgs = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    where?: FamilyTreeWhereInput
    orderBy?: Enumerable<FamilyTreeOrderByWithRelationInput>
    cursor?: FamilyTreeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FamilyTreeScalarFieldEnum>
  }


  /**
   * Personal.wali
   */
  export type Personal$waliArgs = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    where?: FamilyTreeWhereInput
    orderBy?: Enumerable<FamilyTreeOrderByWithRelationInput>
    cursor?: FamilyTreeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FamilyTreeScalarFieldEnum>
  }


  /**
   * Personal without action
   */
  export type PersonalArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
  }



  /**
   * Model FamilyTree
   */


  export type AggregateFamilyTree = {
    _count: FamilyTreeCountAggregateOutputType | null
    _min: FamilyTreeMinAggregateOutputType | null
    _max: FamilyTreeMaxAggregateOutputType | null
  }

  export type FamilyTreeMinAggregateOutputType = {
    id: string | null
    nokk: string | null
    fatherId: string | null
    motherId: string | null
    waliId: string | null
  }

  export type FamilyTreeMaxAggregateOutputType = {
    id: string | null
    nokk: string | null
    fatherId: string | null
    motherId: string | null
    waliId: string | null
  }

  export type FamilyTreeCountAggregateOutputType = {
    id: number
    nokk: number
    fatherId: number
    motherId: number
    waliId: number
    _all: number
  }


  export type FamilyTreeMinAggregateInputType = {
    id?: true
    nokk?: true
    fatherId?: true
    motherId?: true
    waliId?: true
  }

  export type FamilyTreeMaxAggregateInputType = {
    id?: true
    nokk?: true
    fatherId?: true
    motherId?: true
    waliId?: true
  }

  export type FamilyTreeCountAggregateInputType = {
    id?: true
    nokk?: true
    fatherId?: true
    motherId?: true
    waliId?: true
    _all?: true
  }

  export type FamilyTreeAggregateArgs = {
    /**
     * Filter which FamilyTree to aggregate.
     */
    where?: FamilyTreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyTrees to fetch.
     */
    orderBy?: Enumerable<FamilyTreeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FamilyTreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyTrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyTrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FamilyTrees
    **/
    _count?: true | FamilyTreeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FamilyTreeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FamilyTreeMaxAggregateInputType
  }

  export type GetFamilyTreeAggregateType<T extends FamilyTreeAggregateArgs> = {
        [P in keyof T & keyof AggregateFamilyTree]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFamilyTree[P]>
      : GetScalarType<T[P], AggregateFamilyTree[P]>
  }




  export type FamilyTreeGroupByArgs = {
    where?: FamilyTreeWhereInput
    orderBy?: Enumerable<FamilyTreeOrderByWithAggregationInput>
    by: FamilyTreeScalarFieldEnum[]
    having?: FamilyTreeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FamilyTreeCountAggregateInputType | true
    _min?: FamilyTreeMinAggregateInputType
    _max?: FamilyTreeMaxAggregateInputType
  }


  export type FamilyTreeGroupByOutputType = {
    id: string
    nokk: string
    fatherId: string | null
    motherId: string | null
    waliId: string | null
    _count: FamilyTreeCountAggregateOutputType | null
    _min: FamilyTreeMinAggregateOutputType | null
    _max: FamilyTreeMaxAggregateOutputType | null
  }

  type GetFamilyTreeGroupByPayload<T extends FamilyTreeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FamilyTreeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FamilyTreeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FamilyTreeGroupByOutputType[P]>
            : GetScalarType<T[P], FamilyTreeGroupByOutputType[P]>
        }
      >
    >


  export type FamilyTreeSelect = {
    id?: boolean
    nokk?: boolean
    fatherId?: boolean
    motherId?: boolean
    waliId?: boolean
    address?: boolean | AddressArgs
    father?: boolean | PersonalArgs
    mother?: boolean | PersonalArgs
    wali?: boolean | PersonalArgs
    childs?: boolean | FamilyTree$childsArgs
    _count?: boolean | FamilyTreeCountOutputTypeArgs
  }


  export type FamilyTreeInclude = {
    father?: boolean | PersonalArgs
    mother?: boolean | PersonalArgs
    wali?: boolean | PersonalArgs
    childs?: boolean | FamilyTree$childsArgs
    _count?: boolean | FamilyTreeCountOutputTypeArgs
  }

  export type FamilyTreeGetPayload<S extends boolean | null | undefined | FamilyTreeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FamilyTree :
    S extends undefined ? never :
    S extends { include: any } & (FamilyTreeArgs | FamilyTreeFindManyArgs)
    ? FamilyTree  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'father' ? PersonalGetPayload<S['include'][P]> | null :
        P extends 'mother' ? PersonalGetPayload<S['include'][P]> | null :
        P extends 'wali' ? PersonalGetPayload<S['include'][P]> | null :
        P extends 'childs' ? Array < FamilyTreeChildGetPayload<S['include'][P]>>  :
        P extends '_count' ? FamilyTreeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FamilyTreeArgs | FamilyTreeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'address' ? AddressGetPayload<S['select'][P]> :
        P extends 'father' ? PersonalGetPayload<S['select'][P]> | null :
        P extends 'mother' ? PersonalGetPayload<S['select'][P]> | null :
        P extends 'wali' ? PersonalGetPayload<S['select'][P]> | null :
        P extends 'childs' ? Array < FamilyTreeChildGetPayload<S['select'][P]>>  :
        P extends '_count' ? FamilyTreeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FamilyTree ? FamilyTree[P] : never
  } 
      : FamilyTree


  type FamilyTreeCountArgs = 
    Omit<FamilyTreeFindManyArgs, 'select' | 'include'> & {
      select?: FamilyTreeCountAggregateInputType | true
    }

  export interface FamilyTreeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FamilyTree that matches the filter.
     * @param {FamilyTreeFindUniqueArgs} args - Arguments to find a FamilyTree
     * @example
     * // Get one FamilyTree
     * const familyTree = await prisma.familyTree.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FamilyTreeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FamilyTreeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FamilyTree'> extends True ? Prisma__FamilyTreeClient<FamilyTreeGetPayload<T>> : Prisma__FamilyTreeClient<FamilyTreeGetPayload<T> | null, null>

    /**
     * Find one FamilyTree that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FamilyTreeFindUniqueOrThrowArgs} args - Arguments to find a FamilyTree
     * @example
     * // Get one FamilyTree
     * const familyTree = await prisma.familyTree.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FamilyTreeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FamilyTreeFindUniqueOrThrowArgs>
    ): Prisma__FamilyTreeClient<FamilyTreeGetPayload<T>>

    /**
     * Find the first FamilyTree that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeFindFirstArgs} args - Arguments to find a FamilyTree
     * @example
     * // Get one FamilyTree
     * const familyTree = await prisma.familyTree.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FamilyTreeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FamilyTreeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FamilyTree'> extends True ? Prisma__FamilyTreeClient<FamilyTreeGetPayload<T>> : Prisma__FamilyTreeClient<FamilyTreeGetPayload<T> | null, null>

    /**
     * Find the first FamilyTree that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeFindFirstOrThrowArgs} args - Arguments to find a FamilyTree
     * @example
     * // Get one FamilyTree
     * const familyTree = await prisma.familyTree.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FamilyTreeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FamilyTreeFindFirstOrThrowArgs>
    ): Prisma__FamilyTreeClient<FamilyTreeGetPayload<T>>

    /**
     * Find zero or more FamilyTrees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FamilyTrees
     * const familyTrees = await prisma.familyTree.findMany()
     * 
     * // Get first 10 FamilyTrees
     * const familyTrees = await prisma.familyTree.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const familyTreeWithIdOnly = await prisma.familyTree.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FamilyTreeFindManyArgs>(
      args?: SelectSubset<T, FamilyTreeFindManyArgs>
    ): Prisma.PrismaPromise<Array<FamilyTreeGetPayload<T>>>

    /**
     * Create a FamilyTree.
     * @param {FamilyTreeCreateArgs} args - Arguments to create a FamilyTree.
     * @example
     * // Create one FamilyTree
     * const FamilyTree = await prisma.familyTree.create({
     *   data: {
     *     // ... data to create a FamilyTree
     *   }
     * })
     * 
    **/
    create<T extends FamilyTreeCreateArgs>(
      args: SelectSubset<T, FamilyTreeCreateArgs>
    ): Prisma__FamilyTreeClient<FamilyTreeGetPayload<T>>

    /**
     * Create many FamilyTrees.
     *     @param {FamilyTreeCreateManyArgs} args - Arguments to create many FamilyTrees.
     *     @example
     *     // Create many FamilyTrees
     *     const familyTree = await prisma.familyTree.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FamilyTreeCreateManyArgs>(
      args?: SelectSubset<T, FamilyTreeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FamilyTree.
     * @param {FamilyTreeDeleteArgs} args - Arguments to delete one FamilyTree.
     * @example
     * // Delete one FamilyTree
     * const FamilyTree = await prisma.familyTree.delete({
     *   where: {
     *     // ... filter to delete one FamilyTree
     *   }
     * })
     * 
    **/
    delete<T extends FamilyTreeDeleteArgs>(
      args: SelectSubset<T, FamilyTreeDeleteArgs>
    ): Prisma__FamilyTreeClient<FamilyTreeGetPayload<T>>

    /**
     * Update one FamilyTree.
     * @param {FamilyTreeUpdateArgs} args - Arguments to update one FamilyTree.
     * @example
     * // Update one FamilyTree
     * const familyTree = await prisma.familyTree.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FamilyTreeUpdateArgs>(
      args: SelectSubset<T, FamilyTreeUpdateArgs>
    ): Prisma__FamilyTreeClient<FamilyTreeGetPayload<T>>

    /**
     * Delete zero or more FamilyTrees.
     * @param {FamilyTreeDeleteManyArgs} args - Arguments to filter FamilyTrees to delete.
     * @example
     * // Delete a few FamilyTrees
     * const { count } = await prisma.familyTree.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FamilyTreeDeleteManyArgs>(
      args?: SelectSubset<T, FamilyTreeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FamilyTrees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FamilyTrees
     * const familyTree = await prisma.familyTree.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FamilyTreeUpdateManyArgs>(
      args: SelectSubset<T, FamilyTreeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FamilyTree.
     * @param {FamilyTreeUpsertArgs} args - Arguments to update or create a FamilyTree.
     * @example
     * // Update or create a FamilyTree
     * const familyTree = await prisma.familyTree.upsert({
     *   create: {
     *     // ... data to create a FamilyTree
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FamilyTree we want to update
     *   }
     * })
    **/
    upsert<T extends FamilyTreeUpsertArgs>(
      args: SelectSubset<T, FamilyTreeUpsertArgs>
    ): Prisma__FamilyTreeClient<FamilyTreeGetPayload<T>>

    /**
     * Find zero or more FamilyTrees that matches the filter.
     * @param {FamilyTreeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const familyTree = await prisma.familyTree.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: FamilyTreeFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a FamilyTree.
     * @param {FamilyTreeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const familyTree = await prisma.familyTree.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: FamilyTreeAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of FamilyTrees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeCountArgs} args - Arguments to filter FamilyTrees to count.
     * @example
     * // Count the number of FamilyTrees
     * const count = await prisma.familyTree.count({
     *   where: {
     *     // ... the filter for the FamilyTrees we want to count
     *   }
     * })
    **/
    count<T extends FamilyTreeCountArgs>(
      args?: Subset<T, FamilyTreeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FamilyTreeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FamilyTree.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FamilyTreeAggregateArgs>(args: Subset<T, FamilyTreeAggregateArgs>): Prisma.PrismaPromise<GetFamilyTreeAggregateType<T>>

    /**
     * Group by FamilyTree.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FamilyTreeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FamilyTreeGroupByArgs['orderBy'] }
        : { orderBy?: FamilyTreeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FamilyTreeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFamilyTreeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FamilyTree.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FamilyTreeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    address<T extends AddressArgs= {}>(args?: Subset<T, AddressArgs>): Prisma__AddressClient<AddressGetPayload<T> | Null>;

    father<T extends PersonalArgs= {}>(args?: Subset<T, PersonalArgs>): Prisma__PersonalClient<PersonalGetPayload<T> | Null>;

    mother<T extends PersonalArgs= {}>(args?: Subset<T, PersonalArgs>): Prisma__PersonalClient<PersonalGetPayload<T> | Null>;

    wali<T extends PersonalArgs= {}>(args?: Subset<T, PersonalArgs>): Prisma__PersonalClient<PersonalGetPayload<T> | Null>;

    childs<T extends FamilyTree$childsArgs= {}>(args?: Subset<T, FamilyTree$childsArgs>): Prisma.PrismaPromise<Array<FamilyTreeChildGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FamilyTree base type for findUnique actions
   */
  export type FamilyTreeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    /**
     * Filter, which FamilyTree to fetch.
     */
    where: FamilyTreeWhereUniqueInput
  }

  /**
   * FamilyTree findUnique
   */
  export interface FamilyTreeFindUniqueArgs extends FamilyTreeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FamilyTree findUniqueOrThrow
   */
  export type FamilyTreeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    /**
     * Filter, which FamilyTree to fetch.
     */
    where: FamilyTreeWhereUniqueInput
  }


  /**
   * FamilyTree base type for findFirst actions
   */
  export type FamilyTreeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    /**
     * Filter, which FamilyTree to fetch.
     */
    where?: FamilyTreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyTrees to fetch.
     */
    orderBy?: Enumerable<FamilyTreeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyTrees.
     */
    cursor?: FamilyTreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyTrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyTrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyTrees.
     */
    distinct?: Enumerable<FamilyTreeScalarFieldEnum>
  }

  /**
   * FamilyTree findFirst
   */
  export interface FamilyTreeFindFirstArgs extends FamilyTreeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FamilyTree findFirstOrThrow
   */
  export type FamilyTreeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    /**
     * Filter, which FamilyTree to fetch.
     */
    where?: FamilyTreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyTrees to fetch.
     */
    orderBy?: Enumerable<FamilyTreeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyTrees.
     */
    cursor?: FamilyTreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyTrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyTrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyTrees.
     */
    distinct?: Enumerable<FamilyTreeScalarFieldEnum>
  }


  /**
   * FamilyTree findMany
   */
  export type FamilyTreeFindManyArgs = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    /**
     * Filter, which FamilyTrees to fetch.
     */
    where?: FamilyTreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyTrees to fetch.
     */
    orderBy?: Enumerable<FamilyTreeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FamilyTrees.
     */
    cursor?: FamilyTreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyTrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyTrees.
     */
    skip?: number
    distinct?: Enumerable<FamilyTreeScalarFieldEnum>
  }


  /**
   * FamilyTree create
   */
  export type FamilyTreeCreateArgs = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    /**
     * The data needed to create a FamilyTree.
     */
    data: XOR<FamilyTreeCreateInput, FamilyTreeUncheckedCreateInput>
  }


  /**
   * FamilyTree createMany
   */
  export type FamilyTreeCreateManyArgs = {
    /**
     * The data used to create many FamilyTrees.
     */
    data: Enumerable<FamilyTreeCreateManyInput>
  }


  /**
   * FamilyTree update
   */
  export type FamilyTreeUpdateArgs = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    /**
     * The data needed to update a FamilyTree.
     */
    data: XOR<FamilyTreeUpdateInput, FamilyTreeUncheckedUpdateInput>
    /**
     * Choose, which FamilyTree to update.
     */
    where: FamilyTreeWhereUniqueInput
  }


  /**
   * FamilyTree updateMany
   */
  export type FamilyTreeUpdateManyArgs = {
    /**
     * The data used to update FamilyTrees.
     */
    data: XOR<FamilyTreeUpdateManyMutationInput, FamilyTreeUncheckedUpdateManyInput>
    /**
     * Filter which FamilyTrees to update
     */
    where?: FamilyTreeWhereInput
  }


  /**
   * FamilyTree upsert
   */
  export type FamilyTreeUpsertArgs = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    /**
     * The filter to search for the FamilyTree to update in case it exists.
     */
    where: FamilyTreeWhereUniqueInput
    /**
     * In case the FamilyTree found by the `where` argument doesn't exist, create a new FamilyTree with this data.
     */
    create: XOR<FamilyTreeCreateInput, FamilyTreeUncheckedCreateInput>
    /**
     * In case the FamilyTree was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FamilyTreeUpdateInput, FamilyTreeUncheckedUpdateInput>
  }


  /**
   * FamilyTree delete
   */
  export type FamilyTreeDeleteArgs = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    /**
     * Filter which FamilyTree to delete.
     */
    where: FamilyTreeWhereUniqueInput
  }


  /**
   * FamilyTree deleteMany
   */
  export type FamilyTreeDeleteManyArgs = {
    /**
     * Filter which FamilyTrees to delete
     */
    where?: FamilyTreeWhereInput
  }


  /**
   * FamilyTree findRaw
   */
  export type FamilyTreeFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * FamilyTree aggregateRaw
   */
  export type FamilyTreeAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * FamilyTree.childs
   */
  export type FamilyTree$childsArgs = {
    /**
     * Select specific fields to fetch from the FamilyTreeChild
     */
    select?: FamilyTreeChildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeChildInclude | null
    where?: FamilyTreeChildWhereInput
    orderBy?: Enumerable<FamilyTreeChildOrderByWithRelationInput>
    cursor?: FamilyTreeChildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FamilyTreeChildScalarFieldEnum>
  }


  /**
   * FamilyTree without action
   */
  export type FamilyTreeArgs = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
  }



  /**
   * Model FamilyTreeChild
   */


  export type AggregateFamilyTreeChild = {
    _count: FamilyTreeChildCountAggregateOutputType | null
    _avg: FamilyTreeChildAvgAggregateOutputType | null
    _sum: FamilyTreeChildSumAggregateOutputType | null
    _min: FamilyTreeChildMinAggregateOutputType | null
    _max: FamilyTreeChildMaxAggregateOutputType | null
  }

  export type FamilyTreeChildAvgAggregateOutputType = {
    no: number | null
  }

  export type FamilyTreeChildSumAggregateOutputType = {
    no: number | null
  }

  export type FamilyTreeChildMinAggregateOutputType = {
    id: string | null
    no: number | null
    type: ChildType | null
    kkId: string | null
    personalId: string | null
  }

  export type FamilyTreeChildMaxAggregateOutputType = {
    id: string | null
    no: number | null
    type: ChildType | null
    kkId: string | null
    personalId: string | null
  }

  export type FamilyTreeChildCountAggregateOutputType = {
    id: number
    no: number
    type: number
    kkId: number
    personalId: number
    _all: number
  }


  export type FamilyTreeChildAvgAggregateInputType = {
    no?: true
  }

  export type FamilyTreeChildSumAggregateInputType = {
    no?: true
  }

  export type FamilyTreeChildMinAggregateInputType = {
    id?: true
    no?: true
    type?: true
    kkId?: true
    personalId?: true
  }

  export type FamilyTreeChildMaxAggregateInputType = {
    id?: true
    no?: true
    type?: true
    kkId?: true
    personalId?: true
  }

  export type FamilyTreeChildCountAggregateInputType = {
    id?: true
    no?: true
    type?: true
    kkId?: true
    personalId?: true
    _all?: true
  }

  export type FamilyTreeChildAggregateArgs = {
    /**
     * Filter which FamilyTreeChild to aggregate.
     */
    where?: FamilyTreeChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyTreeChildren to fetch.
     */
    orderBy?: Enumerable<FamilyTreeChildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FamilyTreeChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyTreeChildren from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyTreeChildren.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FamilyTreeChildren
    **/
    _count?: true | FamilyTreeChildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FamilyTreeChildAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FamilyTreeChildSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FamilyTreeChildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FamilyTreeChildMaxAggregateInputType
  }

  export type GetFamilyTreeChildAggregateType<T extends FamilyTreeChildAggregateArgs> = {
        [P in keyof T & keyof AggregateFamilyTreeChild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFamilyTreeChild[P]>
      : GetScalarType<T[P], AggregateFamilyTreeChild[P]>
  }




  export type FamilyTreeChildGroupByArgs = {
    where?: FamilyTreeChildWhereInput
    orderBy?: Enumerable<FamilyTreeChildOrderByWithAggregationInput>
    by: FamilyTreeChildScalarFieldEnum[]
    having?: FamilyTreeChildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FamilyTreeChildCountAggregateInputType | true
    _avg?: FamilyTreeChildAvgAggregateInputType
    _sum?: FamilyTreeChildSumAggregateInputType
    _min?: FamilyTreeChildMinAggregateInputType
    _max?: FamilyTreeChildMaxAggregateInputType
  }


  export type FamilyTreeChildGroupByOutputType = {
    id: string
    no: number
    type: ChildType
    kkId: string
    personalId: string
    _count: FamilyTreeChildCountAggregateOutputType | null
    _avg: FamilyTreeChildAvgAggregateOutputType | null
    _sum: FamilyTreeChildSumAggregateOutputType | null
    _min: FamilyTreeChildMinAggregateOutputType | null
    _max: FamilyTreeChildMaxAggregateOutputType | null
  }

  type GetFamilyTreeChildGroupByPayload<T extends FamilyTreeChildGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FamilyTreeChildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FamilyTreeChildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FamilyTreeChildGroupByOutputType[P]>
            : GetScalarType<T[P], FamilyTreeChildGroupByOutputType[P]>
        }
      >
    >


  export type FamilyTreeChildSelect = {
    id?: boolean
    no?: boolean
    type?: boolean
    kkId?: boolean
    personalId?: boolean
    kk?: boolean | FamilyTreeArgs
    personal?: boolean | PersonalArgs
  }


  export type FamilyTreeChildInclude = {
    kk?: boolean | FamilyTreeArgs
    personal?: boolean | PersonalArgs
  }

  export type FamilyTreeChildGetPayload<S extends boolean | null | undefined | FamilyTreeChildArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FamilyTreeChild :
    S extends undefined ? never :
    S extends { include: any } & (FamilyTreeChildArgs | FamilyTreeChildFindManyArgs)
    ? FamilyTreeChild  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'kk' ? FamilyTreeGetPayload<S['include'][P]> :
        P extends 'personal' ? PersonalGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FamilyTreeChildArgs | FamilyTreeChildFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'kk' ? FamilyTreeGetPayload<S['select'][P]> :
        P extends 'personal' ? PersonalGetPayload<S['select'][P]> :  P extends keyof FamilyTreeChild ? FamilyTreeChild[P] : never
  } 
      : FamilyTreeChild


  type FamilyTreeChildCountArgs = 
    Omit<FamilyTreeChildFindManyArgs, 'select' | 'include'> & {
      select?: FamilyTreeChildCountAggregateInputType | true
    }

  export interface FamilyTreeChildDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FamilyTreeChild that matches the filter.
     * @param {FamilyTreeChildFindUniqueArgs} args - Arguments to find a FamilyTreeChild
     * @example
     * // Get one FamilyTreeChild
     * const familyTreeChild = await prisma.familyTreeChild.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FamilyTreeChildFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FamilyTreeChildFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FamilyTreeChild'> extends True ? Prisma__FamilyTreeChildClient<FamilyTreeChildGetPayload<T>> : Prisma__FamilyTreeChildClient<FamilyTreeChildGetPayload<T> | null, null>

    /**
     * Find one FamilyTreeChild that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FamilyTreeChildFindUniqueOrThrowArgs} args - Arguments to find a FamilyTreeChild
     * @example
     * // Get one FamilyTreeChild
     * const familyTreeChild = await prisma.familyTreeChild.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FamilyTreeChildFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FamilyTreeChildFindUniqueOrThrowArgs>
    ): Prisma__FamilyTreeChildClient<FamilyTreeChildGetPayload<T>>

    /**
     * Find the first FamilyTreeChild that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeChildFindFirstArgs} args - Arguments to find a FamilyTreeChild
     * @example
     * // Get one FamilyTreeChild
     * const familyTreeChild = await prisma.familyTreeChild.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FamilyTreeChildFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FamilyTreeChildFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FamilyTreeChild'> extends True ? Prisma__FamilyTreeChildClient<FamilyTreeChildGetPayload<T>> : Prisma__FamilyTreeChildClient<FamilyTreeChildGetPayload<T> | null, null>

    /**
     * Find the first FamilyTreeChild that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeChildFindFirstOrThrowArgs} args - Arguments to find a FamilyTreeChild
     * @example
     * // Get one FamilyTreeChild
     * const familyTreeChild = await prisma.familyTreeChild.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FamilyTreeChildFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FamilyTreeChildFindFirstOrThrowArgs>
    ): Prisma__FamilyTreeChildClient<FamilyTreeChildGetPayload<T>>

    /**
     * Find zero or more FamilyTreeChildren that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeChildFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FamilyTreeChildren
     * const familyTreeChildren = await prisma.familyTreeChild.findMany()
     * 
     * // Get first 10 FamilyTreeChildren
     * const familyTreeChildren = await prisma.familyTreeChild.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const familyTreeChildWithIdOnly = await prisma.familyTreeChild.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FamilyTreeChildFindManyArgs>(
      args?: SelectSubset<T, FamilyTreeChildFindManyArgs>
    ): Prisma.PrismaPromise<Array<FamilyTreeChildGetPayload<T>>>

    /**
     * Create a FamilyTreeChild.
     * @param {FamilyTreeChildCreateArgs} args - Arguments to create a FamilyTreeChild.
     * @example
     * // Create one FamilyTreeChild
     * const FamilyTreeChild = await prisma.familyTreeChild.create({
     *   data: {
     *     // ... data to create a FamilyTreeChild
     *   }
     * })
     * 
    **/
    create<T extends FamilyTreeChildCreateArgs>(
      args: SelectSubset<T, FamilyTreeChildCreateArgs>
    ): Prisma__FamilyTreeChildClient<FamilyTreeChildGetPayload<T>>

    /**
     * Create many FamilyTreeChildren.
     *     @param {FamilyTreeChildCreateManyArgs} args - Arguments to create many FamilyTreeChildren.
     *     @example
     *     // Create many FamilyTreeChildren
     *     const familyTreeChild = await prisma.familyTreeChild.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FamilyTreeChildCreateManyArgs>(
      args?: SelectSubset<T, FamilyTreeChildCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FamilyTreeChild.
     * @param {FamilyTreeChildDeleteArgs} args - Arguments to delete one FamilyTreeChild.
     * @example
     * // Delete one FamilyTreeChild
     * const FamilyTreeChild = await prisma.familyTreeChild.delete({
     *   where: {
     *     // ... filter to delete one FamilyTreeChild
     *   }
     * })
     * 
    **/
    delete<T extends FamilyTreeChildDeleteArgs>(
      args: SelectSubset<T, FamilyTreeChildDeleteArgs>
    ): Prisma__FamilyTreeChildClient<FamilyTreeChildGetPayload<T>>

    /**
     * Update one FamilyTreeChild.
     * @param {FamilyTreeChildUpdateArgs} args - Arguments to update one FamilyTreeChild.
     * @example
     * // Update one FamilyTreeChild
     * const familyTreeChild = await prisma.familyTreeChild.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FamilyTreeChildUpdateArgs>(
      args: SelectSubset<T, FamilyTreeChildUpdateArgs>
    ): Prisma__FamilyTreeChildClient<FamilyTreeChildGetPayload<T>>

    /**
     * Delete zero or more FamilyTreeChildren.
     * @param {FamilyTreeChildDeleteManyArgs} args - Arguments to filter FamilyTreeChildren to delete.
     * @example
     * // Delete a few FamilyTreeChildren
     * const { count } = await prisma.familyTreeChild.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FamilyTreeChildDeleteManyArgs>(
      args?: SelectSubset<T, FamilyTreeChildDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FamilyTreeChildren.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeChildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FamilyTreeChildren
     * const familyTreeChild = await prisma.familyTreeChild.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FamilyTreeChildUpdateManyArgs>(
      args: SelectSubset<T, FamilyTreeChildUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FamilyTreeChild.
     * @param {FamilyTreeChildUpsertArgs} args - Arguments to update or create a FamilyTreeChild.
     * @example
     * // Update or create a FamilyTreeChild
     * const familyTreeChild = await prisma.familyTreeChild.upsert({
     *   create: {
     *     // ... data to create a FamilyTreeChild
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FamilyTreeChild we want to update
     *   }
     * })
    **/
    upsert<T extends FamilyTreeChildUpsertArgs>(
      args: SelectSubset<T, FamilyTreeChildUpsertArgs>
    ): Prisma__FamilyTreeChildClient<FamilyTreeChildGetPayload<T>>

    /**
     * Find zero or more FamilyTreeChildren that matches the filter.
     * @param {FamilyTreeChildFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const familyTreeChild = await prisma.familyTreeChild.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: FamilyTreeChildFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a FamilyTreeChild.
     * @param {FamilyTreeChildAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const familyTreeChild = await prisma.familyTreeChild.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: FamilyTreeChildAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of FamilyTreeChildren.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeChildCountArgs} args - Arguments to filter FamilyTreeChildren to count.
     * @example
     * // Count the number of FamilyTreeChildren
     * const count = await prisma.familyTreeChild.count({
     *   where: {
     *     // ... the filter for the FamilyTreeChildren we want to count
     *   }
     * })
    **/
    count<T extends FamilyTreeChildCountArgs>(
      args?: Subset<T, FamilyTreeChildCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FamilyTreeChildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FamilyTreeChild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeChildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FamilyTreeChildAggregateArgs>(args: Subset<T, FamilyTreeChildAggregateArgs>): Prisma.PrismaPromise<GetFamilyTreeChildAggregateType<T>>

    /**
     * Group by FamilyTreeChild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeChildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FamilyTreeChildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FamilyTreeChildGroupByArgs['orderBy'] }
        : { orderBy?: FamilyTreeChildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FamilyTreeChildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFamilyTreeChildGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FamilyTreeChild.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FamilyTreeChildClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    kk<T extends FamilyTreeArgs= {}>(args?: Subset<T, FamilyTreeArgs>): Prisma__FamilyTreeClient<FamilyTreeGetPayload<T> | Null>;

    personal<T extends PersonalArgs= {}>(args?: Subset<T, PersonalArgs>): Prisma__PersonalClient<PersonalGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FamilyTreeChild base type for findUnique actions
   */
  export type FamilyTreeChildFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FamilyTreeChild
     */
    select?: FamilyTreeChildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeChildInclude | null
    /**
     * Filter, which FamilyTreeChild to fetch.
     */
    where: FamilyTreeChildWhereUniqueInput
  }

  /**
   * FamilyTreeChild findUnique
   */
  export interface FamilyTreeChildFindUniqueArgs extends FamilyTreeChildFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FamilyTreeChild findUniqueOrThrow
   */
  export type FamilyTreeChildFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FamilyTreeChild
     */
    select?: FamilyTreeChildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeChildInclude | null
    /**
     * Filter, which FamilyTreeChild to fetch.
     */
    where: FamilyTreeChildWhereUniqueInput
  }


  /**
   * FamilyTreeChild base type for findFirst actions
   */
  export type FamilyTreeChildFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FamilyTreeChild
     */
    select?: FamilyTreeChildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeChildInclude | null
    /**
     * Filter, which FamilyTreeChild to fetch.
     */
    where?: FamilyTreeChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyTreeChildren to fetch.
     */
    orderBy?: Enumerable<FamilyTreeChildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyTreeChildren.
     */
    cursor?: FamilyTreeChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyTreeChildren from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyTreeChildren.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyTreeChildren.
     */
    distinct?: Enumerable<FamilyTreeChildScalarFieldEnum>
  }

  /**
   * FamilyTreeChild findFirst
   */
  export interface FamilyTreeChildFindFirstArgs extends FamilyTreeChildFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FamilyTreeChild findFirstOrThrow
   */
  export type FamilyTreeChildFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FamilyTreeChild
     */
    select?: FamilyTreeChildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeChildInclude | null
    /**
     * Filter, which FamilyTreeChild to fetch.
     */
    where?: FamilyTreeChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyTreeChildren to fetch.
     */
    orderBy?: Enumerable<FamilyTreeChildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyTreeChildren.
     */
    cursor?: FamilyTreeChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyTreeChildren from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyTreeChildren.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyTreeChildren.
     */
    distinct?: Enumerable<FamilyTreeChildScalarFieldEnum>
  }


  /**
   * FamilyTreeChild findMany
   */
  export type FamilyTreeChildFindManyArgs = {
    /**
     * Select specific fields to fetch from the FamilyTreeChild
     */
    select?: FamilyTreeChildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeChildInclude | null
    /**
     * Filter, which FamilyTreeChildren to fetch.
     */
    where?: FamilyTreeChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyTreeChildren to fetch.
     */
    orderBy?: Enumerable<FamilyTreeChildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FamilyTreeChildren.
     */
    cursor?: FamilyTreeChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyTreeChildren from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyTreeChildren.
     */
    skip?: number
    distinct?: Enumerable<FamilyTreeChildScalarFieldEnum>
  }


  /**
   * FamilyTreeChild create
   */
  export type FamilyTreeChildCreateArgs = {
    /**
     * Select specific fields to fetch from the FamilyTreeChild
     */
    select?: FamilyTreeChildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeChildInclude | null
    /**
     * The data needed to create a FamilyTreeChild.
     */
    data: XOR<FamilyTreeChildCreateInput, FamilyTreeChildUncheckedCreateInput>
  }


  /**
   * FamilyTreeChild createMany
   */
  export type FamilyTreeChildCreateManyArgs = {
    /**
     * The data used to create many FamilyTreeChildren.
     */
    data: Enumerable<FamilyTreeChildCreateManyInput>
  }


  /**
   * FamilyTreeChild update
   */
  export type FamilyTreeChildUpdateArgs = {
    /**
     * Select specific fields to fetch from the FamilyTreeChild
     */
    select?: FamilyTreeChildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeChildInclude | null
    /**
     * The data needed to update a FamilyTreeChild.
     */
    data: XOR<FamilyTreeChildUpdateInput, FamilyTreeChildUncheckedUpdateInput>
    /**
     * Choose, which FamilyTreeChild to update.
     */
    where: FamilyTreeChildWhereUniqueInput
  }


  /**
   * FamilyTreeChild updateMany
   */
  export type FamilyTreeChildUpdateManyArgs = {
    /**
     * The data used to update FamilyTreeChildren.
     */
    data: XOR<FamilyTreeChildUpdateManyMutationInput, FamilyTreeChildUncheckedUpdateManyInput>
    /**
     * Filter which FamilyTreeChildren to update
     */
    where?: FamilyTreeChildWhereInput
  }


  /**
   * FamilyTreeChild upsert
   */
  export type FamilyTreeChildUpsertArgs = {
    /**
     * Select specific fields to fetch from the FamilyTreeChild
     */
    select?: FamilyTreeChildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeChildInclude | null
    /**
     * The filter to search for the FamilyTreeChild to update in case it exists.
     */
    where: FamilyTreeChildWhereUniqueInput
    /**
     * In case the FamilyTreeChild found by the `where` argument doesn't exist, create a new FamilyTreeChild with this data.
     */
    create: XOR<FamilyTreeChildCreateInput, FamilyTreeChildUncheckedCreateInput>
    /**
     * In case the FamilyTreeChild was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FamilyTreeChildUpdateInput, FamilyTreeChildUncheckedUpdateInput>
  }


  /**
   * FamilyTreeChild delete
   */
  export type FamilyTreeChildDeleteArgs = {
    /**
     * Select specific fields to fetch from the FamilyTreeChild
     */
    select?: FamilyTreeChildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeChildInclude | null
    /**
     * Filter which FamilyTreeChild to delete.
     */
    where: FamilyTreeChildWhereUniqueInput
  }


  /**
   * FamilyTreeChild deleteMany
   */
  export type FamilyTreeChildDeleteManyArgs = {
    /**
     * Filter which FamilyTreeChildren to delete
     */
    where?: FamilyTreeChildWhereInput
  }


  /**
   * FamilyTreeChild findRaw
   */
  export type FamilyTreeChildFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * FamilyTreeChild aggregateRaw
   */
  export type FamilyTreeChildAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * FamilyTreeChild without action
   */
  export type FamilyTreeChildArgs = {
    /**
     * Select specific fields to fetch from the FamilyTreeChild
     */
    select?: FamilyTreeChildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeChildInclude | null
  }



  /**
   * Model Student
   */


  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    majorId: string | null
    startYearId: string | null
    instansiId: string | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    majorId: string | null
    startYearId: string | null
    instansiId: string | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    userId: number
    majorId: number
    classRoomIds: number
    startYearId: number
    instansiId: number
    eventIds: number
    _all: number
  }


  export type StudentMinAggregateInputType = {
    id?: true
    userId?: true
    majorId?: true
    startYearId?: true
    instansiId?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    userId?: true
    majorId?: true
    startYearId?: true
    instansiId?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    userId?: true
    majorId?: true
    classRoomIds?: true
    startYearId?: true
    instansiId?: true
    eventIds?: true
    _all?: true
  }

  export type StudentAggregateArgs = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs = {
    where?: StudentWhereInput
    orderBy?: Enumerable<StudentOrderByWithAggregationInput>
    by: StudentScalarFieldEnum[]
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }


  export type StudentGroupByOutputType = {
    id: string
    userId: string | null
    majorId: string | null
    classRoomIds: string[]
    startYearId: string
    instansiId: string
    eventIds: string[]
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect = {
    id?: boolean
    userId?: boolean
    majorId?: boolean
    classRoomIds?: boolean
    startYearId?: boolean
    instansiId?: boolean
    eventIds?: boolean
    user?: boolean | UserArgs
    major?: boolean | KonsentrasiKeahlianArgs
    classRoom?: boolean | Student$classRoomArgs
    startYear?: boolean | SchoolYearArgs
    instansi?: boolean | InstansiArgs
    event?: boolean | Student$eventArgs
    _count?: boolean | StudentCountOutputTypeArgs
  }


  export type StudentInclude = {
    user?: boolean | UserArgs
    major?: boolean | KonsentrasiKeahlianArgs
    classRoom?: boolean | Student$classRoomArgs
    startYear?: boolean | SchoolYearArgs
    instansi?: boolean | InstansiArgs
    event?: boolean | Student$eventArgs
    _count?: boolean | StudentCountOutputTypeArgs
  }

  export type StudentGetPayload<S extends boolean | null | undefined | StudentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Student :
    S extends undefined ? never :
    S extends { include: any } & (StudentArgs | StudentFindManyArgs)
    ? Student  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> | null :
        P extends 'major' ? KonsentrasiKeahlianGetPayload<S['include'][P]> | null :
        P extends 'classRoom' ? Array < ClassRoomGetPayload<S['include'][P]>>  :
        P extends 'startYear' ? SchoolYearGetPayload<S['include'][P]> :
        P extends 'instansi' ? InstansiGetPayload<S['include'][P]> :
        P extends 'event' ? Array < CalendarGetPayload<S['include'][P]>>  :
        P extends '_count' ? StudentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (StudentArgs | StudentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> | null :
        P extends 'major' ? KonsentrasiKeahlianGetPayload<S['select'][P]> | null :
        P extends 'classRoom' ? Array < ClassRoomGetPayload<S['select'][P]>>  :
        P extends 'startYear' ? SchoolYearGetPayload<S['select'][P]> :
        P extends 'instansi' ? InstansiGetPayload<S['select'][P]> :
        P extends 'event' ? Array < CalendarGetPayload<S['select'][P]>>  :
        P extends '_count' ? StudentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Student ? Student[P] : never
  } 
      : Student


  type StudentCountArgs = 
    Omit<StudentFindManyArgs, 'select' | 'include'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StudentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Student'> extends True ? Prisma__StudentClient<StudentGetPayload<T>> : Prisma__StudentClient<StudentGetPayload<T> | null, null>

    /**
     * Find one Student that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StudentFindUniqueOrThrowArgs>
    ): Prisma__StudentClient<StudentGetPayload<T>>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StudentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Student'> extends True ? Prisma__StudentClient<StudentGetPayload<T>> : Prisma__StudentClient<StudentGetPayload<T> | null, null>

    /**
     * Find the first Student that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StudentFindFirstOrThrowArgs>
    ): Prisma__StudentClient<StudentGetPayload<T>>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StudentFindManyArgs>(
      args?: SelectSubset<T, StudentFindManyArgs>
    ): Prisma.PrismaPromise<Array<StudentGetPayload<T>>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
    **/
    create<T extends StudentCreateArgs>(
      args: SelectSubset<T, StudentCreateArgs>
    ): Prisma__StudentClient<StudentGetPayload<T>>

    /**
     * Create many Students.
     *     @param {StudentCreateManyArgs} args - Arguments to create many Students.
     *     @example
     *     // Create many Students
     *     const student = await prisma.student.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentCreateManyArgs>(
      args?: SelectSubset<T, StudentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
    **/
    delete<T extends StudentDeleteArgs>(
      args: SelectSubset<T, StudentDeleteArgs>
    ): Prisma__StudentClient<StudentGetPayload<T>>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentUpdateArgs>(
      args: SelectSubset<T, StudentUpdateArgs>
    ): Prisma__StudentClient<StudentGetPayload<T>>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentDeleteManyArgs>(
      args?: SelectSubset<T, StudentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentUpdateManyArgs>(
      args: SelectSubset<T, StudentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
    **/
    upsert<T extends StudentUpsertArgs>(
      args: SelectSubset<T, StudentUpsertArgs>
    ): Prisma__StudentClient<StudentGetPayload<T>>

    /**
     * Find zero or more Students that matches the filter.
     * @param {StudentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const student = await prisma.student.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: StudentFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Student.
     * @param {StudentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const student = await prisma.student.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: StudentAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StudentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    major<T extends KonsentrasiKeahlianArgs= {}>(args?: Subset<T, KonsentrasiKeahlianArgs>): Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T> | Null>;

    classRoom<T extends Student$classRoomArgs= {}>(args?: Subset<T, Student$classRoomArgs>): Prisma.PrismaPromise<Array<ClassRoomGetPayload<T>>| Null>;

    startYear<T extends SchoolYearArgs= {}>(args?: Subset<T, SchoolYearArgs>): Prisma__SchoolYearClient<SchoolYearGetPayload<T> | Null>;

    instansi<T extends InstansiArgs= {}>(args?: Subset<T, InstansiArgs>): Prisma__InstansiClient<InstansiGetPayload<T> | Null>;

    event<T extends Student$eventArgs= {}>(args?: Subset<T, Student$eventArgs>): Prisma.PrismaPromise<Array<CalendarGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Student base type for findUnique actions
   */
  export type StudentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUnique
   */
  export interface StudentFindUniqueArgs extends StudentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }


  /**
   * Student base type for findFirst actions
   */
  export type StudentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: Enumerable<StudentScalarFieldEnum>
  }

  /**
   * Student findFirst
   */
  export interface StudentFindFirstArgs extends StudentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * Student findMany
   */
  export type StudentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * Student create
   */
  export type StudentCreateArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }


  /**
   * Student createMany
   */
  export type StudentCreateManyArgs = {
    /**
     * The data used to create many Students.
     */
    data: Enumerable<StudentCreateManyInput>
  }


  /**
   * Student update
   */
  export type StudentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }


  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
  }


  /**
   * Student upsert
   */
  export type StudentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }


  /**
   * Student delete
   */
  export type StudentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }


  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
  }


  /**
   * Student findRaw
   */
  export type StudentFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Student aggregateRaw
   */
  export type StudentAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Student.classRoom
   */
  export type Student$classRoomArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    where?: ClassRoomWhereInput
    orderBy?: Enumerable<ClassRoomOrderByWithRelationInput>
    cursor?: ClassRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ClassRoomScalarFieldEnum>
  }


  /**
   * Student.event
   */
  export type Student$eventArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    where?: CalendarWhereInput
    orderBy?: Enumerable<CalendarOrderByWithRelationInput>
    cursor?: CalendarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CalendarScalarFieldEnum>
  }


  /**
   * Student without action
   */
  export type StudentArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
  }



  /**
   * Model Teacher
   */


  export type AggregateTeacher = {
    _count: TeacherCountAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  export type TeacherMinAggregateOutputType = {
    id: string | null
    userId: string | null
    instansiId: string | null
    nip: string | null
    nrg: string | null
    noKarpeg: string | null
    tmtTugas: string | null
    tmtGol: string | null
    position: string | null
    rank: string | null
    period: string | null
    certificate: string | null
  }

  export type TeacherMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    instansiId: string | null
    nip: string | null
    nrg: string | null
    noKarpeg: string | null
    tmtTugas: string | null
    tmtGol: string | null
    position: string | null
    rank: string | null
    period: string | null
    certificate: string | null
  }

  export type TeacherCountAggregateOutputType = {
    id: number
    userId: number
    instansiId: number
    eventIds: number
    nip: number
    nrg: number
    noKarpeg: number
    tmtTugas: number
    tmtGol: number
    position: number
    rank: number
    period: number
    certificate: number
    _all: number
  }


  export type TeacherMinAggregateInputType = {
    id?: true
    userId?: true
    instansiId?: true
    nip?: true
    nrg?: true
    noKarpeg?: true
    tmtTugas?: true
    tmtGol?: true
    position?: true
    rank?: true
    period?: true
    certificate?: true
  }

  export type TeacherMaxAggregateInputType = {
    id?: true
    userId?: true
    instansiId?: true
    nip?: true
    nrg?: true
    noKarpeg?: true
    tmtTugas?: true
    tmtGol?: true
    position?: true
    rank?: true
    period?: true
    certificate?: true
  }

  export type TeacherCountAggregateInputType = {
    id?: true
    userId?: true
    instansiId?: true
    eventIds?: true
    nip?: true
    nrg?: true
    noKarpeg?: true
    tmtTugas?: true
    tmtGol?: true
    position?: true
    rank?: true
    period?: true
    certificate?: true
    _all?: true
  }

  export type TeacherAggregateArgs = {
    /**
     * Filter which Teacher to aggregate.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: Enumerable<TeacherOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teachers
    **/
    _count?: true | TeacherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherMaxAggregateInputType
  }

  export type GetTeacherAggregateType<T extends TeacherAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacher[P]>
      : GetScalarType<T[P], AggregateTeacher[P]>
  }




  export type TeacherGroupByArgs = {
    where?: TeacherWhereInput
    orderBy?: Enumerable<TeacherOrderByWithAggregationInput>
    by: TeacherScalarFieldEnum[]
    having?: TeacherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherCountAggregateInputType | true
    _min?: TeacherMinAggregateInputType
    _max?: TeacherMaxAggregateInputType
  }


  export type TeacherGroupByOutputType = {
    id: string
    userId: string | null
    instansiId: string
    eventIds: string[]
    nip: string | null
    nrg: string | null
    noKarpeg: string | null
    tmtTugas: string | null
    tmtGol: string | null
    position: string | null
    rank: string | null
    period: string | null
    certificate: string | null
    _count: TeacherCountAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  type GetTeacherGroupByPayload<T extends TeacherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TeacherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherGroupByOutputType[P]>
        }
      >
    >


  export type TeacherSelect = {
    id?: boolean
    userId?: boolean
    instansiId?: boolean
    eventIds?: boolean
    nip?: boolean
    nrg?: boolean
    noKarpeg?: boolean
    tmtTugas?: boolean
    tmtGol?: boolean
    position?: boolean
    rank?: boolean
    period?: boolean
    certificate?: boolean
    education?: boolean | EducationArgs
    training?: boolean | TrainingArgs
    employment?: boolean | EmploymentArgs
    profession?: boolean | ProfessionArgs
    overseas?: boolean | OverseasArgs
    scientific?: boolean | ScientificArgs
    organization?: boolean | OrganizationArgs
    papers?: boolean | PapersArgs
    innovation?: boolean | InnovationArgs
    award?: boolean | AwardArgs
    sourcePerson?: boolean | SourcePersonArgs
    contest?: boolean | ContestArgs
    documents?: boolean | DocumentsArgs
    additional?: boolean | AdditionalArgs
    user?: boolean | UserArgs
    classRoom?: boolean | Teacher$classRoomArgs
    instansi?: boolean | InstansiArgs
    event?: boolean | Teacher$eventArgs
    _count?: boolean | TeacherCountOutputTypeArgs
  }


  export type TeacherInclude = {
    user?: boolean | UserArgs
    classRoom?: boolean | Teacher$classRoomArgs
    instansi?: boolean | InstansiArgs
    event?: boolean | Teacher$eventArgs
    _count?: boolean | TeacherCountOutputTypeArgs
  }

  export type TeacherGetPayload<S extends boolean | null | undefined | TeacherArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Teacher :
    S extends undefined ? never :
    S extends { include: any } & (TeacherArgs | TeacherFindManyArgs)
    ? Teacher  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> | null :
        P extends 'classRoom' ? Array < ClassRoomGetPayload<S['include'][P]>>  :
        P extends 'instansi' ? InstansiGetPayload<S['include'][P]> :
        P extends 'event' ? Array < CalendarGetPayload<S['include'][P]>>  :
        P extends '_count' ? TeacherCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TeacherArgs | TeacherFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'education' ? Array < EducationGetPayload<S['select'][P]>>  :
        P extends 'training' ? Array < TrainingGetPayload<S['select'][P]>>  :
        P extends 'employment' ? Array < EmploymentGetPayload<S['select'][P]>>  :
        P extends 'profession' ? Array < ProfessionGetPayload<S['select'][P]>>  :
        P extends 'overseas' ? Array < OverseasGetPayload<S['select'][P]>>  :
        P extends 'scientific' ? Array < ScientificGetPayload<S['select'][P]>>  :
        P extends 'organization' ? Array < OrganizationGetPayload<S['select'][P]>>  :
        P extends 'papers' ? Array < PapersGetPayload<S['select'][P]>>  :
        P extends 'innovation' ? Array < InnovationGetPayload<S['select'][P]>>  :
        P extends 'award' ? Array < AwardGetPayload<S['select'][P]>>  :
        P extends 'sourcePerson' ? Array < SourcePersonGetPayload<S['select'][P]>>  :
        P extends 'contest' ? Array < ContestGetPayload<S['select'][P]>>  :
        P extends 'documents' ? Array < DocumentsGetPayload<S['select'][P]>>  :
        P extends 'additional' ? Array < AdditionalGetPayload<S['select'][P]>>  :
        P extends 'user' ? UserGetPayload<S['select'][P]> | null :
        P extends 'classRoom' ? Array < ClassRoomGetPayload<S['select'][P]>>  :
        P extends 'instansi' ? InstansiGetPayload<S['select'][P]> :
        P extends 'event' ? Array < CalendarGetPayload<S['select'][P]>>  :
        P extends '_count' ? TeacherCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Teacher ? Teacher[P] : never
  } 
      : Teacher


  type TeacherCountArgs = 
    Omit<TeacherFindManyArgs, 'select' | 'include'> & {
      select?: TeacherCountAggregateInputType | true
    }

  export interface TeacherDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Teacher that matches the filter.
     * @param {TeacherFindUniqueArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeacherFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TeacherFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Teacher'> extends True ? Prisma__TeacherClient<TeacherGetPayload<T>> : Prisma__TeacherClient<TeacherGetPayload<T> | null, null>

    /**
     * Find one Teacher that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TeacherFindUniqueOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TeacherFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TeacherFindUniqueOrThrowArgs>
    ): Prisma__TeacherClient<TeacherGetPayload<T>>

    /**
     * Find the first Teacher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeacherFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TeacherFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Teacher'> extends True ? Prisma__TeacherClient<TeacherGetPayload<T>> : Prisma__TeacherClient<TeacherGetPayload<T> | null, null>

    /**
     * Find the first Teacher that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TeacherFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TeacherFindFirstOrThrowArgs>
    ): Prisma__TeacherClient<TeacherGetPayload<T>>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teacher.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teacher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherWithIdOnly = await prisma.teacher.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeacherFindManyArgs>(
      args?: SelectSubset<T, TeacherFindManyArgs>
    ): Prisma.PrismaPromise<Array<TeacherGetPayload<T>>>

    /**
     * Create a Teacher.
     * @param {TeacherCreateArgs} args - Arguments to create a Teacher.
     * @example
     * // Create one Teacher
     * const Teacher = await prisma.teacher.create({
     *   data: {
     *     // ... data to create a Teacher
     *   }
     * })
     * 
    **/
    create<T extends TeacherCreateArgs>(
      args: SelectSubset<T, TeacherCreateArgs>
    ): Prisma__TeacherClient<TeacherGetPayload<T>>

    /**
     * Create many Teachers.
     *     @param {TeacherCreateManyArgs} args - Arguments to create many Teachers.
     *     @example
     *     // Create many Teachers
     *     const teacher = await prisma.teacher.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeacherCreateManyArgs>(
      args?: SelectSubset<T, TeacherCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Teacher.
     * @param {TeacherDeleteArgs} args - Arguments to delete one Teacher.
     * @example
     * // Delete one Teacher
     * const Teacher = await prisma.teacher.delete({
     *   where: {
     *     // ... filter to delete one Teacher
     *   }
     * })
     * 
    **/
    delete<T extends TeacherDeleteArgs>(
      args: SelectSubset<T, TeacherDeleteArgs>
    ): Prisma__TeacherClient<TeacherGetPayload<T>>

    /**
     * Update one Teacher.
     * @param {TeacherUpdateArgs} args - Arguments to update one Teacher.
     * @example
     * // Update one Teacher
     * const teacher = await prisma.teacher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeacherUpdateArgs>(
      args: SelectSubset<T, TeacherUpdateArgs>
    ): Prisma__TeacherClient<TeacherGetPayload<T>>

    /**
     * Delete zero or more Teachers.
     * @param {TeacherDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teacher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeacherDeleteManyArgs>(
      args?: SelectSubset<T, TeacherDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeacherUpdateManyArgs>(
      args: SelectSubset<T, TeacherUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Teacher.
     * @param {TeacherUpsertArgs} args - Arguments to update or create a Teacher.
     * @example
     * // Update or create a Teacher
     * const teacher = await prisma.teacher.upsert({
     *   create: {
     *     // ... data to create a Teacher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teacher we want to update
     *   }
     * })
    **/
    upsert<T extends TeacherUpsertArgs>(
      args: SelectSubset<T, TeacherUpsertArgs>
    ): Prisma__TeacherClient<TeacherGetPayload<T>>

    /**
     * Find zero or more Teachers that matches the filter.
     * @param {TeacherFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const teacher = await prisma.teacher.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: TeacherFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Teacher.
     * @param {TeacherAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const teacher = await prisma.teacher.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: TeacherAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teacher.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends TeacherCountArgs>(
      args?: Subset<T, TeacherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherAggregateArgs>(args: Subset<T, TeacherAggregateArgs>): Prisma.PrismaPromise<GetTeacherAggregateType<T>>

    /**
     * Group by Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherGroupByArgs['orderBy'] }
        : { orderBy?: TeacherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Teacher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TeacherClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    education<T extends EducationArgs= {}>(args?: Subset<T, EducationArgs>): Prisma.PrismaPromise<Array<EducationGetPayload<T>>| Null>;

    training<T extends TrainingArgs= {}>(args?: Subset<T, TrainingArgs>): Prisma.PrismaPromise<Array<TrainingGetPayload<T>>| Null>;

    employment<T extends EmploymentArgs= {}>(args?: Subset<T, EmploymentArgs>): Prisma.PrismaPromise<Array<EmploymentGetPayload<T>>| Null>;

    profession<T extends ProfessionArgs= {}>(args?: Subset<T, ProfessionArgs>): Prisma.PrismaPromise<Array<ProfessionGetPayload<T>>| Null>;

    overseas<T extends OverseasArgs= {}>(args?: Subset<T, OverseasArgs>): Prisma.PrismaPromise<Array<OverseasGetPayload<T>>| Null>;

    scientific<T extends ScientificArgs= {}>(args?: Subset<T, ScientificArgs>): Prisma.PrismaPromise<Array<ScientificGetPayload<T>>| Null>;

    organization<T extends OrganizationArgs= {}>(args?: Subset<T, OrganizationArgs>): Prisma.PrismaPromise<Array<OrganizationGetPayload<T>>| Null>;

    papers<T extends PapersArgs= {}>(args?: Subset<T, PapersArgs>): Prisma.PrismaPromise<Array<PapersGetPayload<T>>| Null>;

    innovation<T extends InnovationArgs= {}>(args?: Subset<T, InnovationArgs>): Prisma.PrismaPromise<Array<InnovationGetPayload<T>>| Null>;

    award<T extends AwardArgs= {}>(args?: Subset<T, AwardArgs>): Prisma.PrismaPromise<Array<AwardGetPayload<T>>| Null>;

    sourcePerson<T extends SourcePersonArgs= {}>(args?: Subset<T, SourcePersonArgs>): Prisma.PrismaPromise<Array<SourcePersonGetPayload<T>>| Null>;

    contest<T extends ContestArgs= {}>(args?: Subset<T, ContestArgs>): Prisma.PrismaPromise<Array<ContestGetPayload<T>>| Null>;

    documents<T extends DocumentsArgs= {}>(args?: Subset<T, DocumentsArgs>): Prisma.PrismaPromise<Array<DocumentsGetPayload<T>>| Null>;

    additional<T extends AdditionalArgs= {}>(args?: Subset<T, AdditionalArgs>): Prisma.PrismaPromise<Array<AdditionalGetPayload<T>>| Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    classRoom<T extends Teacher$classRoomArgs= {}>(args?: Subset<T, Teacher$classRoomArgs>): Prisma.PrismaPromise<Array<ClassRoomGetPayload<T>>| Null>;

    instansi<T extends InstansiArgs= {}>(args?: Subset<T, InstansiArgs>): Prisma__InstansiClient<InstansiGetPayload<T> | Null>;

    event<T extends Teacher$eventArgs= {}>(args?: Subset<T, Teacher$eventArgs>): Prisma.PrismaPromise<Array<CalendarGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Teacher base type for findUnique actions
   */
  export type TeacherFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findUnique
   */
  export interface TeacherFindUniqueArgs extends TeacherFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Teacher findUniqueOrThrow
   */
  export type TeacherFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }


  /**
   * Teacher base type for findFirst actions
   */
  export type TeacherFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: Enumerable<TeacherOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: Enumerable<TeacherScalarFieldEnum>
  }

  /**
   * Teacher findFirst
   */
  export interface TeacherFindFirstArgs extends TeacherFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Teacher findFirstOrThrow
   */
  export type TeacherFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: Enumerable<TeacherOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: Enumerable<TeacherScalarFieldEnum>
  }


  /**
   * Teacher findMany
   */
  export type TeacherFindManyArgs = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: Enumerable<TeacherOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    distinct?: Enumerable<TeacherScalarFieldEnum>
  }


  /**
   * Teacher create
   */
  export type TeacherCreateArgs = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
    /**
     * The data needed to create a Teacher.
     */
    data: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
  }


  /**
   * Teacher createMany
   */
  export type TeacherCreateManyArgs = {
    /**
     * The data used to create many Teachers.
     */
    data: Enumerable<TeacherCreateManyInput>
  }


  /**
   * Teacher update
   */
  export type TeacherUpdateArgs = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
    /**
     * The data needed to update a Teacher.
     */
    data: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
    /**
     * Choose, which Teacher to update.
     */
    where: TeacherWhereUniqueInput
  }


  /**
   * Teacher updateMany
   */
  export type TeacherUpdateManyArgs = {
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeacherWhereInput
  }


  /**
   * Teacher upsert
   */
  export type TeacherUpsertArgs = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
    /**
     * The filter to search for the Teacher to update in case it exists.
     */
    where: TeacherWhereUniqueInput
    /**
     * In case the Teacher found by the `where` argument doesn't exist, create a new Teacher with this data.
     */
    create: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
    /**
     * In case the Teacher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
  }


  /**
   * Teacher delete
   */
  export type TeacherDeleteArgs = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
    /**
     * Filter which Teacher to delete.
     */
    where: TeacherWhereUniqueInput
  }


  /**
   * Teacher deleteMany
   */
  export type TeacherDeleteManyArgs = {
    /**
     * Filter which Teachers to delete
     */
    where?: TeacherWhereInput
  }


  /**
   * Teacher findRaw
   */
  export type TeacherFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Teacher aggregateRaw
   */
  export type TeacherAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Teacher.classRoom
   */
  export type Teacher$classRoomArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    where?: ClassRoomWhereInput
    orderBy?: Enumerable<ClassRoomOrderByWithRelationInput>
    cursor?: ClassRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ClassRoomScalarFieldEnum>
  }


  /**
   * Teacher.event
   */
  export type Teacher$eventArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    where?: CalendarWhereInput
    orderBy?: Enumerable<CalendarOrderByWithRelationInput>
    cursor?: CalendarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CalendarScalarFieldEnum>
  }


  /**
   * Teacher without action
   */
  export type TeacherArgs = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
  }



  /**
   * Model ClassRoom
   */


  export type AggregateClassRoom = {
    _count: ClassRoomCountAggregateOutputType | null
    _min: ClassRoomMinAggregateOutputType | null
    _max: ClassRoomMaxAggregateOutputType | null
  }

  export type ClassRoomMinAggregateOutputType = {
    id: string | null
    name: string | null
    yearId: string | null
    waliId: string | null
  }

  export type ClassRoomMaxAggregateOutputType = {
    id: string | null
    name: string | null
    yearId: string | null
    waliId: string | null
  }

  export type ClassRoomCountAggregateOutputType = {
    id: number
    name: number
    yearId: number
    waliId: number
    studentIds: number
    eventIds: number
    _all: number
  }


  export type ClassRoomMinAggregateInputType = {
    id?: true
    name?: true
    yearId?: true
    waliId?: true
  }

  export type ClassRoomMaxAggregateInputType = {
    id?: true
    name?: true
    yearId?: true
    waliId?: true
  }

  export type ClassRoomCountAggregateInputType = {
    id?: true
    name?: true
    yearId?: true
    waliId?: true
    studentIds?: true
    eventIds?: true
    _all?: true
  }

  export type ClassRoomAggregateArgs = {
    /**
     * Filter which ClassRoom to aggregate.
     */
    where?: ClassRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassRooms to fetch.
     */
    orderBy?: Enumerable<ClassRoomOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassRooms
    **/
    _count?: true | ClassRoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassRoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassRoomMaxAggregateInputType
  }

  export type GetClassRoomAggregateType<T extends ClassRoomAggregateArgs> = {
        [P in keyof T & keyof AggregateClassRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassRoom[P]>
      : GetScalarType<T[P], AggregateClassRoom[P]>
  }




  export type ClassRoomGroupByArgs = {
    where?: ClassRoomWhereInput
    orderBy?: Enumerable<ClassRoomOrderByWithAggregationInput>
    by: ClassRoomScalarFieldEnum[]
    having?: ClassRoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassRoomCountAggregateInputType | true
    _min?: ClassRoomMinAggregateInputType
    _max?: ClassRoomMaxAggregateInputType
  }


  export type ClassRoomGroupByOutputType = {
    id: string
    name: string
    yearId: string
    waliId: string
    studentIds: string[]
    eventIds: string[]
    _count: ClassRoomCountAggregateOutputType | null
    _min: ClassRoomMinAggregateOutputType | null
    _max: ClassRoomMaxAggregateOutputType | null
  }

  type GetClassRoomGroupByPayload<T extends ClassRoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ClassRoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassRoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassRoomGroupByOutputType[P]>
            : GetScalarType<T[P], ClassRoomGroupByOutputType[P]>
        }
      >
    >


  export type ClassRoomSelect = {
    id?: boolean
    name?: boolean
    yearId?: boolean
    waliId?: boolean
    studentIds?: boolean
    eventIds?: boolean
    year?: boolean | SchoolYearArgs
    wali?: boolean | TeacherArgs
    students?: boolean | ClassRoom$studentsArgs
    event?: boolean | ClassRoom$eventArgs
    _count?: boolean | ClassRoomCountOutputTypeArgs
  }


  export type ClassRoomInclude = {
    year?: boolean | SchoolYearArgs
    wali?: boolean | TeacherArgs
    students?: boolean | ClassRoom$studentsArgs
    event?: boolean | ClassRoom$eventArgs
    _count?: boolean | ClassRoomCountOutputTypeArgs
  }

  export type ClassRoomGetPayload<S extends boolean | null | undefined | ClassRoomArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ClassRoom :
    S extends undefined ? never :
    S extends { include: any } & (ClassRoomArgs | ClassRoomFindManyArgs)
    ? ClassRoom  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'year' ? SchoolYearGetPayload<S['include'][P]> :
        P extends 'wali' ? TeacherGetPayload<S['include'][P]> :
        P extends 'students' ? Array < StudentGetPayload<S['include'][P]>>  :
        P extends 'event' ? Array < CalendarGetPayload<S['include'][P]>>  :
        P extends '_count' ? ClassRoomCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ClassRoomArgs | ClassRoomFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'year' ? SchoolYearGetPayload<S['select'][P]> :
        P extends 'wali' ? TeacherGetPayload<S['select'][P]> :
        P extends 'students' ? Array < StudentGetPayload<S['select'][P]>>  :
        P extends 'event' ? Array < CalendarGetPayload<S['select'][P]>>  :
        P extends '_count' ? ClassRoomCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ClassRoom ? ClassRoom[P] : never
  } 
      : ClassRoom


  type ClassRoomCountArgs = 
    Omit<ClassRoomFindManyArgs, 'select' | 'include'> & {
      select?: ClassRoomCountAggregateInputType | true
    }

  export interface ClassRoomDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ClassRoom that matches the filter.
     * @param {ClassRoomFindUniqueArgs} args - Arguments to find a ClassRoom
     * @example
     * // Get one ClassRoom
     * const classRoom = await prisma.classRoom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClassRoomFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ClassRoomFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ClassRoom'> extends True ? Prisma__ClassRoomClient<ClassRoomGetPayload<T>> : Prisma__ClassRoomClient<ClassRoomGetPayload<T> | null, null>

    /**
     * Find one ClassRoom that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClassRoomFindUniqueOrThrowArgs} args - Arguments to find a ClassRoom
     * @example
     * // Get one ClassRoom
     * const classRoom = await prisma.classRoom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClassRoomFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ClassRoomFindUniqueOrThrowArgs>
    ): Prisma__ClassRoomClient<ClassRoomGetPayload<T>>

    /**
     * Find the first ClassRoom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassRoomFindFirstArgs} args - Arguments to find a ClassRoom
     * @example
     * // Get one ClassRoom
     * const classRoom = await prisma.classRoom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClassRoomFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ClassRoomFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ClassRoom'> extends True ? Prisma__ClassRoomClient<ClassRoomGetPayload<T>> : Prisma__ClassRoomClient<ClassRoomGetPayload<T> | null, null>

    /**
     * Find the first ClassRoom that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassRoomFindFirstOrThrowArgs} args - Arguments to find a ClassRoom
     * @example
     * // Get one ClassRoom
     * const classRoom = await prisma.classRoom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClassRoomFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ClassRoomFindFirstOrThrowArgs>
    ): Prisma__ClassRoomClient<ClassRoomGetPayload<T>>

    /**
     * Find zero or more ClassRooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassRoomFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassRooms
     * const classRooms = await prisma.classRoom.findMany()
     * 
     * // Get first 10 ClassRooms
     * const classRooms = await prisma.classRoom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classRoomWithIdOnly = await prisma.classRoom.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClassRoomFindManyArgs>(
      args?: SelectSubset<T, ClassRoomFindManyArgs>
    ): Prisma.PrismaPromise<Array<ClassRoomGetPayload<T>>>

    /**
     * Create a ClassRoom.
     * @param {ClassRoomCreateArgs} args - Arguments to create a ClassRoom.
     * @example
     * // Create one ClassRoom
     * const ClassRoom = await prisma.classRoom.create({
     *   data: {
     *     // ... data to create a ClassRoom
     *   }
     * })
     * 
    **/
    create<T extends ClassRoomCreateArgs>(
      args: SelectSubset<T, ClassRoomCreateArgs>
    ): Prisma__ClassRoomClient<ClassRoomGetPayload<T>>

    /**
     * Create many ClassRooms.
     *     @param {ClassRoomCreateManyArgs} args - Arguments to create many ClassRooms.
     *     @example
     *     // Create many ClassRooms
     *     const classRoom = await prisma.classRoom.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClassRoomCreateManyArgs>(
      args?: SelectSubset<T, ClassRoomCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClassRoom.
     * @param {ClassRoomDeleteArgs} args - Arguments to delete one ClassRoom.
     * @example
     * // Delete one ClassRoom
     * const ClassRoom = await prisma.classRoom.delete({
     *   where: {
     *     // ... filter to delete one ClassRoom
     *   }
     * })
     * 
    **/
    delete<T extends ClassRoomDeleteArgs>(
      args: SelectSubset<T, ClassRoomDeleteArgs>
    ): Prisma__ClassRoomClient<ClassRoomGetPayload<T>>

    /**
     * Update one ClassRoom.
     * @param {ClassRoomUpdateArgs} args - Arguments to update one ClassRoom.
     * @example
     * // Update one ClassRoom
     * const classRoom = await prisma.classRoom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClassRoomUpdateArgs>(
      args: SelectSubset<T, ClassRoomUpdateArgs>
    ): Prisma__ClassRoomClient<ClassRoomGetPayload<T>>

    /**
     * Delete zero or more ClassRooms.
     * @param {ClassRoomDeleteManyArgs} args - Arguments to filter ClassRooms to delete.
     * @example
     * // Delete a few ClassRooms
     * const { count } = await prisma.classRoom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClassRoomDeleteManyArgs>(
      args?: SelectSubset<T, ClassRoomDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassRoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassRooms
     * const classRoom = await prisma.classRoom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClassRoomUpdateManyArgs>(
      args: SelectSubset<T, ClassRoomUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassRoom.
     * @param {ClassRoomUpsertArgs} args - Arguments to update or create a ClassRoom.
     * @example
     * // Update or create a ClassRoom
     * const classRoom = await prisma.classRoom.upsert({
     *   create: {
     *     // ... data to create a ClassRoom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassRoom we want to update
     *   }
     * })
    **/
    upsert<T extends ClassRoomUpsertArgs>(
      args: SelectSubset<T, ClassRoomUpsertArgs>
    ): Prisma__ClassRoomClient<ClassRoomGetPayload<T>>

    /**
     * Find zero or more ClassRooms that matches the filter.
     * @param {ClassRoomFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const classRoom = await prisma.classRoom.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ClassRoomFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ClassRoom.
     * @param {ClassRoomAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const classRoom = await prisma.classRoom.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ClassRoomAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of ClassRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassRoomCountArgs} args - Arguments to filter ClassRooms to count.
     * @example
     * // Count the number of ClassRooms
     * const count = await prisma.classRoom.count({
     *   where: {
     *     // ... the filter for the ClassRooms we want to count
     *   }
     * })
    **/
    count<T extends ClassRoomCountArgs>(
      args?: Subset<T, ClassRoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassRoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassRoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassRoomAggregateArgs>(args: Subset<T, ClassRoomAggregateArgs>): Prisma.PrismaPromise<GetClassRoomAggregateType<T>>

    /**
     * Group by ClassRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassRoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassRoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassRoomGroupByArgs['orderBy'] }
        : { orderBy?: ClassRoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassRoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassRoom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ClassRoomClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    year<T extends SchoolYearArgs= {}>(args?: Subset<T, SchoolYearArgs>): Prisma__SchoolYearClient<SchoolYearGetPayload<T> | Null>;

    wali<T extends TeacherArgs= {}>(args?: Subset<T, TeacherArgs>): Prisma__TeacherClient<TeacherGetPayload<T> | Null>;

    students<T extends ClassRoom$studentsArgs= {}>(args?: Subset<T, ClassRoom$studentsArgs>): Prisma.PrismaPromise<Array<StudentGetPayload<T>>| Null>;

    event<T extends ClassRoom$eventArgs= {}>(args?: Subset<T, ClassRoom$eventArgs>): Prisma.PrismaPromise<Array<CalendarGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ClassRoom base type for findUnique actions
   */
  export type ClassRoomFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    /**
     * Filter, which ClassRoom to fetch.
     */
    where: ClassRoomWhereUniqueInput
  }

  /**
   * ClassRoom findUnique
   */
  export interface ClassRoomFindUniqueArgs extends ClassRoomFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ClassRoom findUniqueOrThrow
   */
  export type ClassRoomFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    /**
     * Filter, which ClassRoom to fetch.
     */
    where: ClassRoomWhereUniqueInput
  }


  /**
   * ClassRoom base type for findFirst actions
   */
  export type ClassRoomFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    /**
     * Filter, which ClassRoom to fetch.
     */
    where?: ClassRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassRooms to fetch.
     */
    orderBy?: Enumerable<ClassRoomOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassRooms.
     */
    cursor?: ClassRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassRooms.
     */
    distinct?: Enumerable<ClassRoomScalarFieldEnum>
  }

  /**
   * ClassRoom findFirst
   */
  export interface ClassRoomFindFirstArgs extends ClassRoomFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ClassRoom findFirstOrThrow
   */
  export type ClassRoomFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    /**
     * Filter, which ClassRoom to fetch.
     */
    where?: ClassRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassRooms to fetch.
     */
    orderBy?: Enumerable<ClassRoomOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassRooms.
     */
    cursor?: ClassRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassRooms.
     */
    distinct?: Enumerable<ClassRoomScalarFieldEnum>
  }


  /**
   * ClassRoom findMany
   */
  export type ClassRoomFindManyArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    /**
     * Filter, which ClassRooms to fetch.
     */
    where?: ClassRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassRooms to fetch.
     */
    orderBy?: Enumerable<ClassRoomOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassRooms.
     */
    cursor?: ClassRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassRooms.
     */
    skip?: number
    distinct?: Enumerable<ClassRoomScalarFieldEnum>
  }


  /**
   * ClassRoom create
   */
  export type ClassRoomCreateArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    /**
     * The data needed to create a ClassRoom.
     */
    data: XOR<ClassRoomCreateInput, ClassRoomUncheckedCreateInput>
  }


  /**
   * ClassRoom createMany
   */
  export type ClassRoomCreateManyArgs = {
    /**
     * The data used to create many ClassRooms.
     */
    data: Enumerable<ClassRoomCreateManyInput>
  }


  /**
   * ClassRoom update
   */
  export type ClassRoomUpdateArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    /**
     * The data needed to update a ClassRoom.
     */
    data: XOR<ClassRoomUpdateInput, ClassRoomUncheckedUpdateInput>
    /**
     * Choose, which ClassRoom to update.
     */
    where: ClassRoomWhereUniqueInput
  }


  /**
   * ClassRoom updateMany
   */
  export type ClassRoomUpdateManyArgs = {
    /**
     * The data used to update ClassRooms.
     */
    data: XOR<ClassRoomUpdateManyMutationInput, ClassRoomUncheckedUpdateManyInput>
    /**
     * Filter which ClassRooms to update
     */
    where?: ClassRoomWhereInput
  }


  /**
   * ClassRoom upsert
   */
  export type ClassRoomUpsertArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    /**
     * The filter to search for the ClassRoom to update in case it exists.
     */
    where: ClassRoomWhereUniqueInput
    /**
     * In case the ClassRoom found by the `where` argument doesn't exist, create a new ClassRoom with this data.
     */
    create: XOR<ClassRoomCreateInput, ClassRoomUncheckedCreateInput>
    /**
     * In case the ClassRoom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassRoomUpdateInput, ClassRoomUncheckedUpdateInput>
  }


  /**
   * ClassRoom delete
   */
  export type ClassRoomDeleteArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    /**
     * Filter which ClassRoom to delete.
     */
    where: ClassRoomWhereUniqueInput
  }


  /**
   * ClassRoom deleteMany
   */
  export type ClassRoomDeleteManyArgs = {
    /**
     * Filter which ClassRooms to delete
     */
    where?: ClassRoomWhereInput
  }


  /**
   * ClassRoom findRaw
   */
  export type ClassRoomFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * ClassRoom aggregateRaw
   */
  export type ClassRoomAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * ClassRoom.students
   */
  export type ClassRoom$studentsArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    where?: StudentWhereInput
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * ClassRoom.event
   */
  export type ClassRoom$eventArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    where?: CalendarWhereInput
    orderBy?: Enumerable<CalendarOrderByWithRelationInput>
    cursor?: CalendarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CalendarScalarFieldEnum>
  }


  /**
   * ClassRoom without action
   */
  export type ClassRoomArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
  }



  /**
   * Model SchoolYear
   */


  export type AggregateSchoolYear = {
    _count: SchoolYearCountAggregateOutputType | null
    _avg: SchoolYearAvgAggregateOutputType | null
    _sum: SchoolYearSumAggregateOutputType | null
    _min: SchoolYearMinAggregateOutputType | null
    _max: SchoolYearMaxAggregateOutputType | null
  }

  export type SchoolYearAvgAggregateOutputType = {
    year: number | null
  }

  export type SchoolYearSumAggregateOutputType = {
    year: number | null
  }

  export type SchoolYearMinAggregateOutputType = {
    id: string | null
    year: number | null
    instansiId: string | null
  }

  export type SchoolYearMaxAggregateOutputType = {
    id: string | null
    year: number | null
    instansiId: string | null
  }

  export type SchoolYearCountAggregateOutputType = {
    id: number
    year: number
    instansiId: number
    _all: number
  }


  export type SchoolYearAvgAggregateInputType = {
    year?: true
  }

  export type SchoolYearSumAggregateInputType = {
    year?: true
  }

  export type SchoolYearMinAggregateInputType = {
    id?: true
    year?: true
    instansiId?: true
  }

  export type SchoolYearMaxAggregateInputType = {
    id?: true
    year?: true
    instansiId?: true
  }

  export type SchoolYearCountAggregateInputType = {
    id?: true
    year?: true
    instansiId?: true
    _all?: true
  }

  export type SchoolYearAggregateArgs = {
    /**
     * Filter which SchoolYear to aggregate.
     */
    where?: SchoolYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolYears to fetch.
     */
    orderBy?: Enumerable<SchoolYearOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolYears
    **/
    _count?: true | SchoolYearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SchoolYearAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SchoolYearSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolYearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolYearMaxAggregateInputType
  }

  export type GetSchoolYearAggregateType<T extends SchoolYearAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolYear]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolYear[P]>
      : GetScalarType<T[P], AggregateSchoolYear[P]>
  }




  export type SchoolYearGroupByArgs = {
    where?: SchoolYearWhereInput
    orderBy?: Enumerable<SchoolYearOrderByWithAggregationInput>
    by: SchoolYearScalarFieldEnum[]
    having?: SchoolYearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolYearCountAggregateInputType | true
    _avg?: SchoolYearAvgAggregateInputType
    _sum?: SchoolYearSumAggregateInputType
    _min?: SchoolYearMinAggregateInputType
    _max?: SchoolYearMaxAggregateInputType
  }


  export type SchoolYearGroupByOutputType = {
    id: string
    year: number
    instansiId: string
    _count: SchoolYearCountAggregateOutputType | null
    _avg: SchoolYearAvgAggregateOutputType | null
    _sum: SchoolYearSumAggregateOutputType | null
    _min: SchoolYearMinAggregateOutputType | null
    _max: SchoolYearMaxAggregateOutputType | null
  }

  type GetSchoolYearGroupByPayload<T extends SchoolYearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SchoolYearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolYearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolYearGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolYearGroupByOutputType[P]>
        }
      >
    >


  export type SchoolYearSelect = {
    id?: boolean
    year?: boolean
    instansiId?: boolean
    organizational?: boolean | OrganizationalArgs
    instansi?: boolean | InstansiArgs
    classRoom?: boolean | SchoolYear$classRoomArgs
    studentsIn?: boolean | SchoolYear$studentsInArgs
    calendar?: boolean | SchoolYear$calendarArgs
    _count?: boolean | SchoolYearCountOutputTypeArgs
  }


  export type SchoolYearInclude = {
    instansi?: boolean | InstansiArgs
    classRoom?: boolean | SchoolYear$classRoomArgs
    studentsIn?: boolean | SchoolYear$studentsInArgs
    calendar?: boolean | SchoolYear$calendarArgs
    _count?: boolean | SchoolYearCountOutputTypeArgs
  }

  export type SchoolYearGetPayload<S extends boolean | null | undefined | SchoolYearArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SchoolYear :
    S extends undefined ? never :
    S extends { include: any } & (SchoolYearArgs | SchoolYearFindManyArgs)
    ? SchoolYear  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'instansi' ? InstansiGetPayload<S['include'][P]> :
        P extends 'classRoom' ? Array < ClassRoomGetPayload<S['include'][P]>>  :
        P extends 'studentsIn' ? Array < StudentGetPayload<S['include'][P]>>  :
        P extends 'calendar' ? Array < CalendarGetPayload<S['include'][P]>>  :
        P extends '_count' ? SchoolYearCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SchoolYearArgs | SchoolYearFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'organizational' ? OrganizationalGetPayload<S['select'][P]> :
        P extends 'instansi' ? InstansiGetPayload<S['select'][P]> :
        P extends 'classRoom' ? Array < ClassRoomGetPayload<S['select'][P]>>  :
        P extends 'studentsIn' ? Array < StudentGetPayload<S['select'][P]>>  :
        P extends 'calendar' ? Array < CalendarGetPayload<S['select'][P]>>  :
        P extends '_count' ? SchoolYearCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof SchoolYear ? SchoolYear[P] : never
  } 
      : SchoolYear


  type SchoolYearCountArgs = 
    Omit<SchoolYearFindManyArgs, 'select' | 'include'> & {
      select?: SchoolYearCountAggregateInputType | true
    }

  export interface SchoolYearDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SchoolYear that matches the filter.
     * @param {SchoolYearFindUniqueArgs} args - Arguments to find a SchoolYear
     * @example
     * // Get one SchoolYear
     * const schoolYear = await prisma.schoolYear.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SchoolYearFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SchoolYearFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SchoolYear'> extends True ? Prisma__SchoolYearClient<SchoolYearGetPayload<T>> : Prisma__SchoolYearClient<SchoolYearGetPayload<T> | null, null>

    /**
     * Find one SchoolYear that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SchoolYearFindUniqueOrThrowArgs} args - Arguments to find a SchoolYear
     * @example
     * // Get one SchoolYear
     * const schoolYear = await prisma.schoolYear.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SchoolYearFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SchoolYearFindUniqueOrThrowArgs>
    ): Prisma__SchoolYearClient<SchoolYearGetPayload<T>>

    /**
     * Find the first SchoolYear that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolYearFindFirstArgs} args - Arguments to find a SchoolYear
     * @example
     * // Get one SchoolYear
     * const schoolYear = await prisma.schoolYear.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SchoolYearFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SchoolYearFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SchoolYear'> extends True ? Prisma__SchoolYearClient<SchoolYearGetPayload<T>> : Prisma__SchoolYearClient<SchoolYearGetPayload<T> | null, null>

    /**
     * Find the first SchoolYear that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolYearFindFirstOrThrowArgs} args - Arguments to find a SchoolYear
     * @example
     * // Get one SchoolYear
     * const schoolYear = await prisma.schoolYear.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SchoolYearFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SchoolYearFindFirstOrThrowArgs>
    ): Prisma__SchoolYearClient<SchoolYearGetPayload<T>>

    /**
     * Find zero or more SchoolYears that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolYearFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolYears
     * const schoolYears = await prisma.schoolYear.findMany()
     * 
     * // Get first 10 SchoolYears
     * const schoolYears = await prisma.schoolYear.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolYearWithIdOnly = await prisma.schoolYear.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SchoolYearFindManyArgs>(
      args?: SelectSubset<T, SchoolYearFindManyArgs>
    ): Prisma.PrismaPromise<Array<SchoolYearGetPayload<T>>>

    /**
     * Create a SchoolYear.
     * @param {SchoolYearCreateArgs} args - Arguments to create a SchoolYear.
     * @example
     * // Create one SchoolYear
     * const SchoolYear = await prisma.schoolYear.create({
     *   data: {
     *     // ... data to create a SchoolYear
     *   }
     * })
     * 
    **/
    create<T extends SchoolYearCreateArgs>(
      args: SelectSubset<T, SchoolYearCreateArgs>
    ): Prisma__SchoolYearClient<SchoolYearGetPayload<T>>

    /**
     * Create many SchoolYears.
     *     @param {SchoolYearCreateManyArgs} args - Arguments to create many SchoolYears.
     *     @example
     *     // Create many SchoolYears
     *     const schoolYear = await prisma.schoolYear.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SchoolYearCreateManyArgs>(
      args?: SelectSubset<T, SchoolYearCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SchoolYear.
     * @param {SchoolYearDeleteArgs} args - Arguments to delete one SchoolYear.
     * @example
     * // Delete one SchoolYear
     * const SchoolYear = await prisma.schoolYear.delete({
     *   where: {
     *     // ... filter to delete one SchoolYear
     *   }
     * })
     * 
    **/
    delete<T extends SchoolYearDeleteArgs>(
      args: SelectSubset<T, SchoolYearDeleteArgs>
    ): Prisma__SchoolYearClient<SchoolYearGetPayload<T>>

    /**
     * Update one SchoolYear.
     * @param {SchoolYearUpdateArgs} args - Arguments to update one SchoolYear.
     * @example
     * // Update one SchoolYear
     * const schoolYear = await prisma.schoolYear.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SchoolYearUpdateArgs>(
      args: SelectSubset<T, SchoolYearUpdateArgs>
    ): Prisma__SchoolYearClient<SchoolYearGetPayload<T>>

    /**
     * Delete zero or more SchoolYears.
     * @param {SchoolYearDeleteManyArgs} args - Arguments to filter SchoolYears to delete.
     * @example
     * // Delete a few SchoolYears
     * const { count } = await prisma.schoolYear.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SchoolYearDeleteManyArgs>(
      args?: SelectSubset<T, SchoolYearDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolYearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolYears
     * const schoolYear = await prisma.schoolYear.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SchoolYearUpdateManyArgs>(
      args: SelectSubset<T, SchoolYearUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SchoolYear.
     * @param {SchoolYearUpsertArgs} args - Arguments to update or create a SchoolYear.
     * @example
     * // Update or create a SchoolYear
     * const schoolYear = await prisma.schoolYear.upsert({
     *   create: {
     *     // ... data to create a SchoolYear
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolYear we want to update
     *   }
     * })
    **/
    upsert<T extends SchoolYearUpsertArgs>(
      args: SelectSubset<T, SchoolYearUpsertArgs>
    ): Prisma__SchoolYearClient<SchoolYearGetPayload<T>>

    /**
     * Find zero or more SchoolYears that matches the filter.
     * @param {SchoolYearFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const schoolYear = await prisma.schoolYear.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: SchoolYearFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SchoolYear.
     * @param {SchoolYearAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const schoolYear = await prisma.schoolYear.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: SchoolYearAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of SchoolYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolYearCountArgs} args - Arguments to filter SchoolYears to count.
     * @example
     * // Count the number of SchoolYears
     * const count = await prisma.schoolYear.count({
     *   where: {
     *     // ... the filter for the SchoolYears we want to count
     *   }
     * })
    **/
    count<T extends SchoolYearCountArgs>(
      args?: Subset<T, SchoolYearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolYearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolYearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolYearAggregateArgs>(args: Subset<T, SchoolYearAggregateArgs>): Prisma.PrismaPromise<GetSchoolYearAggregateType<T>>

    /**
     * Group by SchoolYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolYearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolYearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolYearGroupByArgs['orderBy'] }
        : { orderBy?: SchoolYearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolYearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolYearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolYear.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SchoolYearClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    organizational<T extends OrganizationalArgs= {}>(args?: Subset<T, OrganizationalArgs>): Prisma__OrganizationalClient<OrganizationalGetPayload<T> | Null>;

    instansi<T extends InstansiArgs= {}>(args?: Subset<T, InstansiArgs>): Prisma__InstansiClient<InstansiGetPayload<T> | Null>;

    classRoom<T extends SchoolYear$classRoomArgs= {}>(args?: Subset<T, SchoolYear$classRoomArgs>): Prisma.PrismaPromise<Array<ClassRoomGetPayload<T>>| Null>;

    studentsIn<T extends SchoolYear$studentsInArgs= {}>(args?: Subset<T, SchoolYear$studentsInArgs>): Prisma.PrismaPromise<Array<StudentGetPayload<T>>| Null>;

    calendar<T extends SchoolYear$calendarArgs= {}>(args?: Subset<T, SchoolYear$calendarArgs>): Prisma.PrismaPromise<Array<CalendarGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SchoolYear base type for findUnique actions
   */
  export type SchoolYearFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SchoolYear
     */
    select?: SchoolYearSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolYearInclude | null
    /**
     * Filter, which SchoolYear to fetch.
     */
    where: SchoolYearWhereUniqueInput
  }

  /**
   * SchoolYear findUnique
   */
  export interface SchoolYearFindUniqueArgs extends SchoolYearFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SchoolYear findUniqueOrThrow
   */
  export type SchoolYearFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SchoolYear
     */
    select?: SchoolYearSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolYearInclude | null
    /**
     * Filter, which SchoolYear to fetch.
     */
    where: SchoolYearWhereUniqueInput
  }


  /**
   * SchoolYear base type for findFirst actions
   */
  export type SchoolYearFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SchoolYear
     */
    select?: SchoolYearSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolYearInclude | null
    /**
     * Filter, which SchoolYear to fetch.
     */
    where?: SchoolYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolYears to fetch.
     */
    orderBy?: Enumerable<SchoolYearOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolYears.
     */
    cursor?: SchoolYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolYears.
     */
    distinct?: Enumerable<SchoolYearScalarFieldEnum>
  }

  /**
   * SchoolYear findFirst
   */
  export interface SchoolYearFindFirstArgs extends SchoolYearFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SchoolYear findFirstOrThrow
   */
  export type SchoolYearFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SchoolYear
     */
    select?: SchoolYearSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolYearInclude | null
    /**
     * Filter, which SchoolYear to fetch.
     */
    where?: SchoolYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolYears to fetch.
     */
    orderBy?: Enumerable<SchoolYearOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolYears.
     */
    cursor?: SchoolYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolYears.
     */
    distinct?: Enumerable<SchoolYearScalarFieldEnum>
  }


  /**
   * SchoolYear findMany
   */
  export type SchoolYearFindManyArgs = {
    /**
     * Select specific fields to fetch from the SchoolYear
     */
    select?: SchoolYearSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolYearInclude | null
    /**
     * Filter, which SchoolYears to fetch.
     */
    where?: SchoolYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolYears to fetch.
     */
    orderBy?: Enumerable<SchoolYearOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolYears.
     */
    cursor?: SchoolYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolYears.
     */
    skip?: number
    distinct?: Enumerable<SchoolYearScalarFieldEnum>
  }


  /**
   * SchoolYear create
   */
  export type SchoolYearCreateArgs = {
    /**
     * Select specific fields to fetch from the SchoolYear
     */
    select?: SchoolYearSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolYearInclude | null
    /**
     * The data needed to create a SchoolYear.
     */
    data: XOR<SchoolYearCreateInput, SchoolYearUncheckedCreateInput>
  }


  /**
   * SchoolYear createMany
   */
  export type SchoolYearCreateManyArgs = {
    /**
     * The data used to create many SchoolYears.
     */
    data: Enumerable<SchoolYearCreateManyInput>
  }


  /**
   * SchoolYear update
   */
  export type SchoolYearUpdateArgs = {
    /**
     * Select specific fields to fetch from the SchoolYear
     */
    select?: SchoolYearSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolYearInclude | null
    /**
     * The data needed to update a SchoolYear.
     */
    data: XOR<SchoolYearUpdateInput, SchoolYearUncheckedUpdateInput>
    /**
     * Choose, which SchoolYear to update.
     */
    where: SchoolYearWhereUniqueInput
  }


  /**
   * SchoolYear updateMany
   */
  export type SchoolYearUpdateManyArgs = {
    /**
     * The data used to update SchoolYears.
     */
    data: XOR<SchoolYearUpdateManyMutationInput, SchoolYearUncheckedUpdateManyInput>
    /**
     * Filter which SchoolYears to update
     */
    where?: SchoolYearWhereInput
  }


  /**
   * SchoolYear upsert
   */
  export type SchoolYearUpsertArgs = {
    /**
     * Select specific fields to fetch from the SchoolYear
     */
    select?: SchoolYearSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolYearInclude | null
    /**
     * The filter to search for the SchoolYear to update in case it exists.
     */
    where: SchoolYearWhereUniqueInput
    /**
     * In case the SchoolYear found by the `where` argument doesn't exist, create a new SchoolYear with this data.
     */
    create: XOR<SchoolYearCreateInput, SchoolYearUncheckedCreateInput>
    /**
     * In case the SchoolYear was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolYearUpdateInput, SchoolYearUncheckedUpdateInput>
  }


  /**
   * SchoolYear delete
   */
  export type SchoolYearDeleteArgs = {
    /**
     * Select specific fields to fetch from the SchoolYear
     */
    select?: SchoolYearSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolYearInclude | null
    /**
     * Filter which SchoolYear to delete.
     */
    where: SchoolYearWhereUniqueInput
  }


  /**
   * SchoolYear deleteMany
   */
  export type SchoolYearDeleteManyArgs = {
    /**
     * Filter which SchoolYears to delete
     */
    where?: SchoolYearWhereInput
  }


  /**
   * SchoolYear findRaw
   */
  export type SchoolYearFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * SchoolYear aggregateRaw
   */
  export type SchoolYearAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * SchoolYear.classRoom
   */
  export type SchoolYear$classRoomArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    where?: ClassRoomWhereInput
    orderBy?: Enumerable<ClassRoomOrderByWithRelationInput>
    cursor?: ClassRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ClassRoomScalarFieldEnum>
  }


  /**
   * SchoolYear.studentsIn
   */
  export type SchoolYear$studentsInArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    where?: StudentWhereInput
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * SchoolYear.calendar
   */
  export type SchoolYear$calendarArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    where?: CalendarWhereInput
    orderBy?: Enumerable<CalendarOrderByWithRelationInput>
    cursor?: CalendarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CalendarScalarFieldEnum>
  }


  /**
   * SchoolYear without action
   */
  export type SchoolYearArgs = {
    /**
     * Select specific fields to fetch from the SchoolYear
     */
    select?: SchoolYearSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolYearInclude | null
  }



  /**
   * Model Calendar
   */


  export type AggregateCalendar = {
    _count: CalendarCountAggregateOutputType | null
    _min: CalendarMinAggregateOutputType | null
    _max: CalendarMaxAggregateOutputType | null
  }

  export type CalendarMinAggregateOutputType = {
    id: string | null
    refId: string | null
    name: string | null
    description: string | null
    start: Date | null
    end: Date | null
    color: string | null
  }

  export type CalendarMaxAggregateOutputType = {
    id: string | null
    refId: string | null
    name: string | null
    description: string | null
    start: Date | null
    end: Date | null
    color: string | null
  }

  export type CalendarCountAggregateOutputType = {
    id: number
    refId: number
    name: number
    description: number
    start: number
    end: number
    color: number
    classRoomIds: number
    studentIds: number
    teacherIds: number
    _all: number
  }


  export type CalendarMinAggregateInputType = {
    id?: true
    refId?: true
    name?: true
    description?: true
    start?: true
    end?: true
    color?: true
  }

  export type CalendarMaxAggregateInputType = {
    id?: true
    refId?: true
    name?: true
    description?: true
    start?: true
    end?: true
    color?: true
  }

  export type CalendarCountAggregateInputType = {
    id?: true
    refId?: true
    name?: true
    description?: true
    start?: true
    end?: true
    color?: true
    classRoomIds?: true
    studentIds?: true
    teacherIds?: true
    _all?: true
  }

  export type CalendarAggregateArgs = {
    /**
     * Filter which Calendar to aggregate.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: Enumerable<CalendarOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Calendars
    **/
    _count?: true | CalendarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarMaxAggregateInputType
  }

  export type GetCalendarAggregateType<T extends CalendarAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendar[P]>
      : GetScalarType<T[P], AggregateCalendar[P]>
  }




  export type CalendarGroupByArgs = {
    where?: CalendarWhereInput
    orderBy?: Enumerable<CalendarOrderByWithAggregationInput>
    by: CalendarScalarFieldEnum[]
    having?: CalendarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarCountAggregateInputType | true
    _min?: CalendarMinAggregateInputType
    _max?: CalendarMaxAggregateInputType
  }


  export type CalendarGroupByOutputType = {
    id: string
    refId: string
    name: string
    description: string | null
    start: Date
    end: Date | null
    color: string
    classRoomIds: string[]
    studentIds: string[]
    teacherIds: string[]
    _count: CalendarCountAggregateOutputType | null
    _min: CalendarMinAggregateOutputType | null
    _max: CalendarMaxAggregateOutputType | null
  }

  type GetCalendarGroupByPayload<T extends CalendarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CalendarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarGroupByOutputType[P]>
        }
      >
    >


  export type CalendarSelect = {
    id?: boolean
    refId?: boolean
    name?: boolean
    description?: boolean
    start?: boolean
    end?: boolean
    color?: boolean
    classRoomIds?: boolean
    studentIds?: boolean
    teacherIds?: boolean
    ref?: boolean | SchoolYearArgs
    classRoom?: boolean | Calendar$classRoomArgs
    student?: boolean | Calendar$studentArgs
    teacher?: boolean | Calendar$teacherArgs
    _count?: boolean | CalendarCountOutputTypeArgs
  }


  export type CalendarInclude = {
    ref?: boolean | SchoolYearArgs
    classRoom?: boolean | Calendar$classRoomArgs
    student?: boolean | Calendar$studentArgs
    teacher?: boolean | Calendar$teacherArgs
    _count?: boolean | CalendarCountOutputTypeArgs
  }

  export type CalendarGetPayload<S extends boolean | null | undefined | CalendarArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Calendar :
    S extends undefined ? never :
    S extends { include: any } & (CalendarArgs | CalendarFindManyArgs)
    ? Calendar  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ref' ? SchoolYearGetPayload<S['include'][P]> :
        P extends 'classRoom' ? Array < ClassRoomGetPayload<S['include'][P]>>  :
        P extends 'student' ? Array < StudentGetPayload<S['include'][P]>>  :
        P extends 'teacher' ? Array < TeacherGetPayload<S['include'][P]>>  :
        P extends '_count' ? CalendarCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CalendarArgs | CalendarFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ref' ? SchoolYearGetPayload<S['select'][P]> :
        P extends 'classRoom' ? Array < ClassRoomGetPayload<S['select'][P]>>  :
        P extends 'student' ? Array < StudentGetPayload<S['select'][P]>>  :
        P extends 'teacher' ? Array < TeacherGetPayload<S['select'][P]>>  :
        P extends '_count' ? CalendarCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Calendar ? Calendar[P] : never
  } 
      : Calendar


  type CalendarCountArgs = 
    Omit<CalendarFindManyArgs, 'select' | 'include'> & {
      select?: CalendarCountAggregateInputType | true
    }

  export interface CalendarDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Calendar that matches the filter.
     * @param {CalendarFindUniqueArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CalendarFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CalendarFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Calendar'> extends True ? Prisma__CalendarClient<CalendarGetPayload<T>> : Prisma__CalendarClient<CalendarGetPayload<T> | null, null>

    /**
     * Find one Calendar that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CalendarFindUniqueOrThrowArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CalendarFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CalendarFindUniqueOrThrowArgs>
    ): Prisma__CalendarClient<CalendarGetPayload<T>>

    /**
     * Find the first Calendar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFindFirstArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CalendarFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CalendarFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Calendar'> extends True ? Prisma__CalendarClient<CalendarGetPayload<T>> : Prisma__CalendarClient<CalendarGetPayload<T> | null, null>

    /**
     * Find the first Calendar that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFindFirstOrThrowArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CalendarFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CalendarFindFirstOrThrowArgs>
    ): Prisma__CalendarClient<CalendarGetPayload<T>>

    /**
     * Find zero or more Calendars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Calendars
     * const calendars = await prisma.calendar.findMany()
     * 
     * // Get first 10 Calendars
     * const calendars = await prisma.calendar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarWithIdOnly = await prisma.calendar.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CalendarFindManyArgs>(
      args?: SelectSubset<T, CalendarFindManyArgs>
    ): Prisma.PrismaPromise<Array<CalendarGetPayload<T>>>

    /**
     * Create a Calendar.
     * @param {CalendarCreateArgs} args - Arguments to create a Calendar.
     * @example
     * // Create one Calendar
     * const Calendar = await prisma.calendar.create({
     *   data: {
     *     // ... data to create a Calendar
     *   }
     * })
     * 
    **/
    create<T extends CalendarCreateArgs>(
      args: SelectSubset<T, CalendarCreateArgs>
    ): Prisma__CalendarClient<CalendarGetPayload<T>>

    /**
     * Create many Calendars.
     *     @param {CalendarCreateManyArgs} args - Arguments to create many Calendars.
     *     @example
     *     // Create many Calendars
     *     const calendar = await prisma.calendar.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CalendarCreateManyArgs>(
      args?: SelectSubset<T, CalendarCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Calendar.
     * @param {CalendarDeleteArgs} args - Arguments to delete one Calendar.
     * @example
     * // Delete one Calendar
     * const Calendar = await prisma.calendar.delete({
     *   where: {
     *     // ... filter to delete one Calendar
     *   }
     * })
     * 
    **/
    delete<T extends CalendarDeleteArgs>(
      args: SelectSubset<T, CalendarDeleteArgs>
    ): Prisma__CalendarClient<CalendarGetPayload<T>>

    /**
     * Update one Calendar.
     * @param {CalendarUpdateArgs} args - Arguments to update one Calendar.
     * @example
     * // Update one Calendar
     * const calendar = await prisma.calendar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CalendarUpdateArgs>(
      args: SelectSubset<T, CalendarUpdateArgs>
    ): Prisma__CalendarClient<CalendarGetPayload<T>>

    /**
     * Delete zero or more Calendars.
     * @param {CalendarDeleteManyArgs} args - Arguments to filter Calendars to delete.
     * @example
     * // Delete a few Calendars
     * const { count } = await prisma.calendar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CalendarDeleteManyArgs>(
      args?: SelectSubset<T, CalendarDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Calendars
     * const calendar = await prisma.calendar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CalendarUpdateManyArgs>(
      args: SelectSubset<T, CalendarUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Calendar.
     * @param {CalendarUpsertArgs} args - Arguments to update or create a Calendar.
     * @example
     * // Update or create a Calendar
     * const calendar = await prisma.calendar.upsert({
     *   create: {
     *     // ... data to create a Calendar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Calendar we want to update
     *   }
     * })
    **/
    upsert<T extends CalendarUpsertArgs>(
      args: SelectSubset<T, CalendarUpsertArgs>
    ): Prisma__CalendarClient<CalendarGetPayload<T>>

    /**
     * Find zero or more Calendars that matches the filter.
     * @param {CalendarFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const calendar = await prisma.calendar.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: CalendarFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Calendar.
     * @param {CalendarAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const calendar = await prisma.calendar.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: CalendarAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Calendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarCountArgs} args - Arguments to filter Calendars to count.
     * @example
     * // Count the number of Calendars
     * const count = await prisma.calendar.count({
     *   where: {
     *     // ... the filter for the Calendars we want to count
     *   }
     * })
    **/
    count<T extends CalendarCountArgs>(
      args?: Subset<T, CalendarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Calendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarAggregateArgs>(args: Subset<T, CalendarAggregateArgs>): Prisma.PrismaPromise<GetCalendarAggregateType<T>>

    /**
     * Group by Calendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarGroupByArgs['orderBy'] }
        : { orderBy?: CalendarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Calendar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CalendarClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ref<T extends SchoolYearArgs= {}>(args?: Subset<T, SchoolYearArgs>): Prisma__SchoolYearClient<SchoolYearGetPayload<T> | Null>;

    classRoom<T extends Calendar$classRoomArgs= {}>(args?: Subset<T, Calendar$classRoomArgs>): Prisma.PrismaPromise<Array<ClassRoomGetPayload<T>>| Null>;

    student<T extends Calendar$studentArgs= {}>(args?: Subset<T, Calendar$studentArgs>): Prisma.PrismaPromise<Array<StudentGetPayload<T>>| Null>;

    teacher<T extends Calendar$teacherArgs= {}>(args?: Subset<T, Calendar$teacherArgs>): Prisma.PrismaPromise<Array<TeacherGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Calendar base type for findUnique actions
   */
  export type CalendarFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    /**
     * Filter, which Calendar to fetch.
     */
    where: CalendarWhereUniqueInput
  }

  /**
   * Calendar findUnique
   */
  export interface CalendarFindUniqueArgs extends CalendarFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Calendar findUniqueOrThrow
   */
  export type CalendarFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    /**
     * Filter, which Calendar to fetch.
     */
    where: CalendarWhereUniqueInput
  }


  /**
   * Calendar base type for findFirst actions
   */
  export type CalendarFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    /**
     * Filter, which Calendar to fetch.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: Enumerable<CalendarOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Calendars.
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Calendars.
     */
    distinct?: Enumerable<CalendarScalarFieldEnum>
  }

  /**
   * Calendar findFirst
   */
  export interface CalendarFindFirstArgs extends CalendarFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Calendar findFirstOrThrow
   */
  export type CalendarFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    /**
     * Filter, which Calendar to fetch.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: Enumerable<CalendarOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Calendars.
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Calendars.
     */
    distinct?: Enumerable<CalendarScalarFieldEnum>
  }


  /**
   * Calendar findMany
   */
  export type CalendarFindManyArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    /**
     * Filter, which Calendars to fetch.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: Enumerable<CalendarOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Calendars.
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    distinct?: Enumerable<CalendarScalarFieldEnum>
  }


  /**
   * Calendar create
   */
  export type CalendarCreateArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    /**
     * The data needed to create a Calendar.
     */
    data: XOR<CalendarCreateInput, CalendarUncheckedCreateInput>
  }


  /**
   * Calendar createMany
   */
  export type CalendarCreateManyArgs = {
    /**
     * The data used to create many Calendars.
     */
    data: Enumerable<CalendarCreateManyInput>
  }


  /**
   * Calendar update
   */
  export type CalendarUpdateArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    /**
     * The data needed to update a Calendar.
     */
    data: XOR<CalendarUpdateInput, CalendarUncheckedUpdateInput>
    /**
     * Choose, which Calendar to update.
     */
    where: CalendarWhereUniqueInput
  }


  /**
   * Calendar updateMany
   */
  export type CalendarUpdateManyArgs = {
    /**
     * The data used to update Calendars.
     */
    data: XOR<CalendarUpdateManyMutationInput, CalendarUncheckedUpdateManyInput>
    /**
     * Filter which Calendars to update
     */
    where?: CalendarWhereInput
  }


  /**
   * Calendar upsert
   */
  export type CalendarUpsertArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    /**
     * The filter to search for the Calendar to update in case it exists.
     */
    where: CalendarWhereUniqueInput
    /**
     * In case the Calendar found by the `where` argument doesn't exist, create a new Calendar with this data.
     */
    create: XOR<CalendarCreateInput, CalendarUncheckedCreateInput>
    /**
     * In case the Calendar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarUpdateInput, CalendarUncheckedUpdateInput>
  }


  /**
   * Calendar delete
   */
  export type CalendarDeleteArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    /**
     * Filter which Calendar to delete.
     */
    where: CalendarWhereUniqueInput
  }


  /**
   * Calendar deleteMany
   */
  export type CalendarDeleteManyArgs = {
    /**
     * Filter which Calendars to delete
     */
    where?: CalendarWhereInput
  }


  /**
   * Calendar findRaw
   */
  export type CalendarFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Calendar aggregateRaw
   */
  export type CalendarAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Calendar.classRoom
   */
  export type Calendar$classRoomArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    where?: ClassRoomWhereInput
    orderBy?: Enumerable<ClassRoomOrderByWithRelationInput>
    cursor?: ClassRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ClassRoomScalarFieldEnum>
  }


  /**
   * Calendar.student
   */
  export type Calendar$studentArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    where?: StudentWhereInput
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * Calendar.teacher
   */
  export type Calendar$teacherArgs = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
    where?: TeacherWhereInput
    orderBy?: Enumerable<TeacherOrderByWithRelationInput>
    cursor?: TeacherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeacherScalarFieldEnum>
  }


  /**
   * Calendar without action
   */
  export type CalendarArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AchievementScalarFieldEnum: {
    id: 'id',
    fase: 'fase',
    description: 'description',
    elementId: 'elementId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const BidangKeahlianScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BidangKeahlianScalarFieldEnum = (typeof BidangKeahlianScalarFieldEnum)[keyof typeof BidangKeahlianScalarFieldEnum]


  export const CalendarScalarFieldEnum: {
    id: 'id',
    refId: 'refId',
    name: 'name',
    description: 'description',
    start: 'start',
    end: 'end',
    color: 'color',
    classRoomIds: 'classRoomIds',
    studentIds: 'studentIds',
    teacherIds: 'teacherIds'
  };

  export type CalendarScalarFieldEnum = (typeof CalendarScalarFieldEnum)[keyof typeof CalendarScalarFieldEnum]


  export const ClassRoomScalarFieldEnum: {
    id: 'id',
    name: 'name',
    yearId: 'yearId',
    waliId: 'waliId',
    studentIds: 'studentIds',
    eventIds: 'eventIds'
  };

  export type ClassRoomScalarFieldEnum = (typeof ClassRoomScalarFieldEnum)[keyof typeof ClassRoomScalarFieldEnum]


  export const ElementScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    mapelId: 'mapelId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ElementScalarFieldEnum = (typeof ElementScalarFieldEnum)[keyof typeof ElementScalarFieldEnum]


  export const FamilyTreeChildScalarFieldEnum: {
    id: 'id',
    no: 'no',
    type: 'type',
    kkId: 'kkId',
    personalId: 'personalId'
  };

  export type FamilyTreeChildScalarFieldEnum = (typeof FamilyTreeChildScalarFieldEnum)[keyof typeof FamilyTreeChildScalarFieldEnum]


  export const FamilyTreeScalarFieldEnum: {
    id: 'id',
    nokk: 'nokk',
    fatherId: 'fatherId',
    motherId: 'motherId',
    waliId: 'waliId'
  };

  export type FamilyTreeScalarFieldEnum = (typeof FamilyTreeScalarFieldEnum)[keyof typeof FamilyTreeScalarFieldEnum]


  export const InstansiScalarFieldEnum: {
    id: 'id',
    npsn: 'npsn',
    name: 'name',
    isPrivate: 'isPrivate',
    level: 'level',
    religion: 'religion',
    major: 'major',
    majorIds: 'majorIds',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InstansiScalarFieldEnum = (typeof InstansiScalarFieldEnum)[keyof typeof InstansiScalarFieldEnum]


  export const KonsentrasiKeahlianScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    programId: 'programId',
    tahun: 'tahun',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    instansiIds: 'instansiIds'
  };

  export type KonsentrasiKeahlianScalarFieldEnum = (typeof KonsentrasiKeahlianScalarFieldEnum)[keyof typeof KonsentrasiKeahlianScalarFieldEnum]


  export const MataPelajaranScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    religion: 'religion',
    vocational: 'vocational',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MataPelajaranScalarFieldEnum = (typeof MataPelajaranScalarFieldEnum)[keyof typeof MataPelajaranScalarFieldEnum]


  export const PersonalScalarFieldEnum: {
    id: 'id',
    nik: 'nik',
    nisn: 'nisn',
    type: 'type',
    userId: 'userId',
    fullname: 'fullname',
    gender: 'gender',
    foreign: 'foreign',
    country: 'country',
    religion: 'religion',
    email: 'email',
    belajarId: 'belajarId',
    nophone: 'nophone',
    isLife: 'isLife'
  };

  export type PersonalScalarFieldEnum = (typeof PersonalScalarFieldEnum)[keyof typeof PersonalScalarFieldEnum]


  export const ProgramKeahlianScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    bidangId: 'bidangId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProgramKeahlianScalarFieldEnum = (typeof ProgramKeahlianScalarFieldEnum)[keyof typeof ProgramKeahlianScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const RoleScalarFieldEnum: {
    id: 'id',
    key: 'key',
    instansiId: 'instansiId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const SchoolYearScalarFieldEnum: {
    id: 'id',
    year: 'year',
    instansiId: 'instansiId'
  };

  export type SchoolYearScalarFieldEnum = (typeof SchoolYearScalarFieldEnum)[keyof typeof SchoolYearScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const StudentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    majorId: 'majorId',
    classRoomIds: 'classRoomIds',
    startYearId: 'startYearId',
    instansiId: 'instansiId',
    eventIds: 'eventIds'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const TeacherScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    instansiId: 'instansiId',
    eventIds: 'eventIds',
    nip: 'nip',
    nrg: 'nrg',
    noKarpeg: 'noKarpeg',
    tmtTugas: 'tmtTugas',
    tmtGol: 'tmtGol',
    position: 'position',
    rank: 'rank',
    period: 'period',
    certificate: 'certificate'
  };

  export type TeacherScalarFieldEnum = (typeof TeacherScalarFieldEnum)[keyof typeof TeacherScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    picture: 'picture',
    username: 'username',
    active: 'active',
    verify: 'verify',
    password: 'password',
    passhash: 'passhash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    roleId: 'roleId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type BidangKeahlianWhereInput = {
    AND?: Enumerable<BidangKeahlianWhereInput>
    OR?: Enumerable<BidangKeahlianWhereInput>
    NOT?: Enumerable<BidangKeahlianWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    program?: ProgramKeahlianListRelationFilter
  }

  export type BidangKeahlianOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    program?: ProgramKeahlianOrderByRelationAggregateInput
  }

  export type BidangKeahlianWhereUniqueInput = {
    id?: string
    code_name?: BidangKeahlianCodeNameCompoundUniqueInput
  }

  export type BidangKeahlianOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BidangKeahlianCountOrderByAggregateInput
    _max?: BidangKeahlianMaxOrderByAggregateInput
    _min?: BidangKeahlianMinOrderByAggregateInput
  }

  export type BidangKeahlianScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BidangKeahlianScalarWhereWithAggregatesInput>
    OR?: Enumerable<BidangKeahlianScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BidangKeahlianScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProgramKeahlianWhereInput = {
    AND?: Enumerable<ProgramKeahlianWhereInput>
    OR?: Enumerable<ProgramKeahlianWhereInput>
    NOT?: Enumerable<ProgramKeahlianWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    name?: StringFilter | string
    bidangId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    bidang?: XOR<BidangKeahlianRelationFilter, BidangKeahlianWhereInput>
    konsentrasi?: KonsentrasiKeahlianListRelationFilter
  }

  export type ProgramKeahlianOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    bidangId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bidang?: BidangKeahlianOrderByWithRelationInput
    konsentrasi?: KonsentrasiKeahlianOrderByRelationAggregateInput
  }

  export type ProgramKeahlianWhereUniqueInput = {
    id?: string
    code_name?: ProgramKeahlianCodeNameCompoundUniqueInput
  }

  export type ProgramKeahlianOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    bidangId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProgramKeahlianCountOrderByAggregateInput
    _max?: ProgramKeahlianMaxOrderByAggregateInput
    _min?: ProgramKeahlianMinOrderByAggregateInput
  }

  export type ProgramKeahlianScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProgramKeahlianScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProgramKeahlianScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProgramKeahlianScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    bidangId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type KonsentrasiKeahlianWhereInput = {
    AND?: Enumerable<KonsentrasiKeahlianWhereInput>
    OR?: Enumerable<KonsentrasiKeahlianWhereInput>
    NOT?: Enumerable<KonsentrasiKeahlianWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    name?: StringFilter | string
    programId?: StringFilter | string
    tahun?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    instansiIds?: StringNullableListFilter
    program?: XOR<ProgramKeahlianRelationFilter, ProgramKeahlianWhereInput>
    student?: StudentListRelationFilter
    instansi?: InstansiListRelationFilter
  }

  export type KonsentrasiKeahlianOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    programId?: SortOrder
    tahun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instansiIds?: SortOrder
    program?: ProgramKeahlianOrderByWithRelationInput
    student?: StudentOrderByRelationAggregateInput
    instansi?: InstansiOrderByRelationAggregateInput
  }

  export type KonsentrasiKeahlianWhereUniqueInput = {
    id?: string
    programId_name?: KonsentrasiKeahlianProgramIdNameCompoundUniqueInput
  }

  export type KonsentrasiKeahlianOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    programId?: SortOrder
    tahun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instansiIds?: SortOrder
    _count?: KonsentrasiKeahlianCountOrderByAggregateInput
    _avg?: KonsentrasiKeahlianAvgOrderByAggregateInput
    _max?: KonsentrasiKeahlianMaxOrderByAggregateInput
    _min?: KonsentrasiKeahlianMinOrderByAggregateInput
    _sum?: KonsentrasiKeahlianSumOrderByAggregateInput
  }

  export type KonsentrasiKeahlianScalarWhereWithAggregatesInput = {
    AND?: Enumerable<KonsentrasiKeahlianScalarWhereWithAggregatesInput>
    OR?: Enumerable<KonsentrasiKeahlianScalarWhereWithAggregatesInput>
    NOT?: Enumerable<KonsentrasiKeahlianScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    programId?: StringWithAggregatesFilter | string
    tahun?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    instansiIds?: StringNullableListFilter
  }

  export type AchievementWhereInput = {
    AND?: Enumerable<AchievementWhereInput>
    OR?: Enumerable<AchievementWhereInput>
    NOT?: Enumerable<AchievementWhereInput>
    id?: StringFilter | string
    fase?: EnumFaseFilter | Fase
    description?: StringFilter | string
    elementId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    element?: XOR<ElementRelationFilter, ElementWhereInput>
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    fase?: SortOrder
    description?: SortOrder
    elementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    element?: ElementOrderByWithRelationInput
  }

  export type AchievementWhereUniqueInput = {
    id?: string
    elementId_fase?: AchievementElementIdFaseCompoundUniqueInput
  }

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    fase?: SortOrder
    description?: SortOrder
    elementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AchievementScalarWhereWithAggregatesInput>
    OR?: Enumerable<AchievementScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AchievementScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    fase?: EnumFaseWithAggregatesFilter | Fase
    description?: StringWithAggregatesFilter | string
    elementId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ElementWhereInput = {
    AND?: Enumerable<ElementWhereInput>
    OR?: Enumerable<ElementWhereInput>
    NOT?: Enumerable<ElementWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringFilter | string
    mapelId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    achievement?: AchievementListRelationFilter
    mapel?: XOR<MataPelajaranRelationFilter, MataPelajaranWhereInput>
  }

  export type ElementOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    mapelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    achievement?: AchievementOrderByRelationAggregateInput
    mapel?: MataPelajaranOrderByWithRelationInput
  }

  export type ElementWhereUniqueInput = {
    id?: string
    mapelId_name?: ElementMapelIdNameCompoundUniqueInput
  }

  export type ElementOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    mapelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ElementCountOrderByAggregateInput
    _max?: ElementMaxOrderByAggregateInput
    _min?: ElementMinOrderByAggregateInput
  }

  export type ElementScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ElementScalarWhereWithAggregatesInput>
    OR?: Enumerable<ElementScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ElementScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    mapelId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MataPelajaranWhereInput = {
    AND?: Enumerable<MataPelajaranWhereInput>
    OR?: Enumerable<MataPelajaranWhereInput>
    NOT?: Enumerable<MataPelajaranWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    name?: StringFilter | string
    religion?: EnumReligionNullableFilter | Religion | null
    vocational?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    element?: ElementListRelationFilter
  }

  export type MataPelajaranOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    religion?: SortOrder
    vocational?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    element?: ElementOrderByRelationAggregateInput
  }

  export type MataPelajaranWhereUniqueInput = {
    id?: string
    code_name?: MataPelajaranCodeNameCompoundUniqueInput
  }

  export type MataPelajaranOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    religion?: SortOrder
    vocational?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MataPelajaranCountOrderByAggregateInput
    _max?: MataPelajaranMaxOrderByAggregateInput
    _min?: MataPelajaranMinOrderByAggregateInput
  }

  export type MataPelajaranScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MataPelajaranScalarWhereWithAggregatesInput>
    OR?: Enumerable<MataPelajaranScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MataPelajaranScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    religion?: EnumReligionNullableWithAggregatesFilter | Religion | null
    vocational?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type InstansiWhereInput = {
    AND?: Enumerable<InstansiWhereInput>
    OR?: Enumerable<InstansiWhereInput>
    NOT?: Enumerable<InstansiWhereInput>
    id?: StringFilter | string
    npsn?: StringFilter | string
    name?: StringFilter | string
    isPrivate?: BoolFilter | boolean
    address?: XOR<AddressCompositeFilter, AddressObjectEqualityInput>
    level?: EnumLevelFilter | Level
    religion?: EnumReligionNullableFilter | Religion | null
    major?: BoolNullableFilter | boolean | null
    majorIds?: StringNullableListFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    majors?: KonsentrasiKeahlianListRelationFilter
    role?: RoleListRelationFilter
    schoolYear?: SchoolYearListRelationFilter
    teacher?: TeacherListRelationFilter
    student?: StudentListRelationFilter
  }

  export type InstansiOrderByWithRelationInput = {
    id?: SortOrder
    npsn?: SortOrder
    name?: SortOrder
    isPrivate?: SortOrder
    address?: AddressOrderByInput
    level?: SortOrder
    religion?: SortOrder
    major?: SortOrder
    majorIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    majors?: KonsentrasiKeahlianOrderByRelationAggregateInput
    role?: RoleOrderByRelationAggregateInput
    schoolYear?: SchoolYearOrderByRelationAggregateInput
    teacher?: TeacherOrderByRelationAggregateInput
    student?: StudentOrderByRelationAggregateInput
  }

  export type InstansiWhereUniqueInput = {
    id?: string
    npsn?: string
  }

  export type InstansiOrderByWithAggregationInput = {
    id?: SortOrder
    npsn?: SortOrder
    name?: SortOrder
    isPrivate?: SortOrder
    level?: SortOrder
    religion?: SortOrder
    major?: SortOrder
    majorIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InstansiCountOrderByAggregateInput
    _max?: InstansiMaxOrderByAggregateInput
    _min?: InstansiMinOrderByAggregateInput
  }

  export type InstansiScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InstansiScalarWhereWithAggregatesInput>
    OR?: Enumerable<InstansiScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InstansiScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    npsn?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    isPrivate?: BoolWithAggregatesFilter | boolean
    level?: EnumLevelWithAggregatesFilter | Level
    religion?: EnumReligionNullableWithAggregatesFilter | Religion | null
    major?: BoolNullableWithAggregatesFilter | boolean | null
    majorIds?: StringNullableListFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RoleWhereInput = {
    AND?: Enumerable<RoleWhereInput>
    OR?: Enumerable<RoleWhereInput>
    NOT?: Enumerable<RoleWhereInput>
    id?: StringFilter | string
    key?: EnumRolesFilter | Roles
    instansiId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    instansi?: XOR<InstansiRelationFilter, InstansiWhereInput>
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    instansiId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instansi?: InstansiOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = {
    id?: string
    instansiId_key?: RoleInstansiIdKeyCompoundUniqueInput
  }

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    instansiId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RoleScalarWhereWithAggregatesInput>
    OR?: Enumerable<RoleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RoleScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    key?: EnumRolesWithAggregatesFilter | Roles
    instansiId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    picture?: StringNullableFilter | string | null
    username?: StringFilter | string
    active?: BoolFilter | boolean
    verify?: BoolFilter | boolean
    password?: StringFilter | string
    passhash?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    roleId?: StringNullableFilter | string | null
    role?: XOR<RoleRelationFilter, RoleWhereInput> | null
    personal?: XOR<PersonalRelationFilter, PersonalWhereInput> | null
    student?: XOR<StudentRelationFilter, StudentWhereInput> | null
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    picture?: SortOrder
    username?: SortOrder
    active?: SortOrder
    verify?: SortOrder
    password?: SortOrder
    passhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
    role?: RoleOrderByWithRelationInput
    personal?: PersonalOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    username?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    picture?: SortOrder
    username?: SortOrder
    active?: SortOrder
    verify?: SortOrder
    password?: SortOrder
    passhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    picture?: StringNullableWithAggregatesFilter | string | null
    username?: StringWithAggregatesFilter | string
    active?: BoolWithAggregatesFilter | boolean
    verify?: BoolWithAggregatesFilter | boolean
    password?: StringWithAggregatesFilter | string
    passhash?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    roleId?: StringNullableWithAggregatesFilter | string | null
  }

  export type PersonalWhereInput = {
    AND?: Enumerable<PersonalWhereInput>
    OR?: Enumerable<PersonalWhereInput>
    NOT?: Enumerable<PersonalWhereInput>
    id?: StringFilter | string
    nik?: StringNullableFilter | string | null
    nisn?: StringNullableFilter | string | null
    type?: EnumTypePersonalFilter | TypePersonal
    userId?: StringNullableFilter | string | null
    fullname?: StringFilter | string
    gender?: EnumGenderFilter | Gender
    foreign?: BoolFilter | boolean
    country?: StringNullableFilter | string | null
    religion?: EnumReligionFilter | Religion
    born?: XOR<BornCompositeFilter, BornObjectEqualityInput>
    email?: StringFilter | string
    belajarId?: StringNullableFilter | string | null
    nophone?: StringFilter | string
    isLife?: BoolNullableFilter | boolean | null
    address?: XOR<AddressNullableCompositeFilter, AddressObjectEqualityInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    father?: FamilyTreeListRelationFilter
    mother?: FamilyTreeListRelationFilter
    wali?: FamilyTreeListRelationFilter
    child?: XOR<FamilyTreeChildRelationFilter, FamilyTreeChildWhereInput> | null
  }

  export type PersonalOrderByWithRelationInput = {
    id?: SortOrder
    nik?: SortOrder
    nisn?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    fullname?: SortOrder
    gender?: SortOrder
    foreign?: SortOrder
    country?: SortOrder
    religion?: SortOrder
    born?: BornOrderByInput
    email?: SortOrder
    belajarId?: SortOrder
    nophone?: SortOrder
    isLife?: SortOrder
    address?: AddressOrderByInput
    user?: UserOrderByWithRelationInput
    father?: FamilyTreeOrderByRelationAggregateInput
    mother?: FamilyTreeOrderByRelationAggregateInput
    wali?: FamilyTreeOrderByRelationAggregateInput
    child?: FamilyTreeChildOrderByWithRelationInput
  }

  export type PersonalWhereUniqueInput = {
    id?: string
    userId?: string
  }

  export type PersonalOrderByWithAggregationInput = {
    id?: SortOrder
    nik?: SortOrder
    nisn?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    fullname?: SortOrder
    gender?: SortOrder
    foreign?: SortOrder
    country?: SortOrder
    religion?: SortOrder
    email?: SortOrder
    belajarId?: SortOrder
    nophone?: SortOrder
    isLife?: SortOrder
    _count?: PersonalCountOrderByAggregateInput
    _max?: PersonalMaxOrderByAggregateInput
    _min?: PersonalMinOrderByAggregateInput
  }

  export type PersonalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PersonalScalarWhereWithAggregatesInput>
    OR?: Enumerable<PersonalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PersonalScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    nik?: StringNullableWithAggregatesFilter | string | null
    nisn?: StringNullableWithAggregatesFilter | string | null
    type?: EnumTypePersonalWithAggregatesFilter | TypePersonal
    userId?: StringNullableWithAggregatesFilter | string | null
    fullname?: StringWithAggregatesFilter | string
    gender?: EnumGenderWithAggregatesFilter | Gender
    foreign?: BoolWithAggregatesFilter | boolean
    country?: StringNullableWithAggregatesFilter | string | null
    religion?: EnumReligionWithAggregatesFilter | Religion
    email?: StringWithAggregatesFilter | string
    belajarId?: StringNullableWithAggregatesFilter | string | null
    nophone?: StringWithAggregatesFilter | string
    isLife?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type FamilyTreeWhereInput = {
    AND?: Enumerable<FamilyTreeWhereInput>
    OR?: Enumerable<FamilyTreeWhereInput>
    NOT?: Enumerable<FamilyTreeWhereInput>
    id?: StringFilter | string
    nokk?: StringFilter | string
    fatherId?: StringNullableFilter | string | null
    motherId?: StringNullableFilter | string | null
    waliId?: StringNullableFilter | string | null
    address?: XOR<AddressCompositeFilter, AddressObjectEqualityInput>
    father?: XOR<PersonalRelationFilter, PersonalWhereInput> | null
    mother?: XOR<PersonalRelationFilter, PersonalWhereInput> | null
    wali?: XOR<PersonalRelationFilter, PersonalWhereInput> | null
    childs?: FamilyTreeChildListRelationFilter
  }

  export type FamilyTreeOrderByWithRelationInput = {
    id?: SortOrder
    nokk?: SortOrder
    fatherId?: SortOrder
    motherId?: SortOrder
    waliId?: SortOrder
    address?: AddressOrderByInput
    father?: PersonalOrderByWithRelationInput
    mother?: PersonalOrderByWithRelationInput
    wali?: PersonalOrderByWithRelationInput
    childs?: FamilyTreeChildOrderByRelationAggregateInput
  }

  export type FamilyTreeWhereUniqueInput = {
    id?: string
  }

  export type FamilyTreeOrderByWithAggregationInput = {
    id?: SortOrder
    nokk?: SortOrder
    fatherId?: SortOrder
    motherId?: SortOrder
    waliId?: SortOrder
    _count?: FamilyTreeCountOrderByAggregateInput
    _max?: FamilyTreeMaxOrderByAggregateInput
    _min?: FamilyTreeMinOrderByAggregateInput
  }

  export type FamilyTreeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FamilyTreeScalarWhereWithAggregatesInput>
    OR?: Enumerable<FamilyTreeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FamilyTreeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    nokk?: StringWithAggregatesFilter | string
    fatherId?: StringNullableWithAggregatesFilter | string | null
    motherId?: StringNullableWithAggregatesFilter | string | null
    waliId?: StringNullableWithAggregatesFilter | string | null
  }

  export type FamilyTreeChildWhereInput = {
    AND?: Enumerable<FamilyTreeChildWhereInput>
    OR?: Enumerable<FamilyTreeChildWhereInput>
    NOT?: Enumerable<FamilyTreeChildWhereInput>
    id?: StringFilter | string
    no?: IntFilter | number
    type?: EnumChildTypeFilter | ChildType
    kkId?: StringFilter | string
    personalId?: StringFilter | string
    kk?: XOR<FamilyTreeRelationFilter, FamilyTreeWhereInput>
    personal?: XOR<PersonalRelationFilter, PersonalWhereInput>
  }

  export type FamilyTreeChildOrderByWithRelationInput = {
    id?: SortOrder
    no?: SortOrder
    type?: SortOrder
    kkId?: SortOrder
    personalId?: SortOrder
    kk?: FamilyTreeOrderByWithRelationInput
    personal?: PersonalOrderByWithRelationInput
  }

  export type FamilyTreeChildWhereUniqueInput = {
    id?: string
    personalId?: string
  }

  export type FamilyTreeChildOrderByWithAggregationInput = {
    id?: SortOrder
    no?: SortOrder
    type?: SortOrder
    kkId?: SortOrder
    personalId?: SortOrder
    _count?: FamilyTreeChildCountOrderByAggregateInput
    _avg?: FamilyTreeChildAvgOrderByAggregateInput
    _max?: FamilyTreeChildMaxOrderByAggregateInput
    _min?: FamilyTreeChildMinOrderByAggregateInput
    _sum?: FamilyTreeChildSumOrderByAggregateInput
  }

  export type FamilyTreeChildScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FamilyTreeChildScalarWhereWithAggregatesInput>
    OR?: Enumerable<FamilyTreeChildScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FamilyTreeChildScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    no?: IntWithAggregatesFilter | number
    type?: EnumChildTypeWithAggregatesFilter | ChildType
    kkId?: StringWithAggregatesFilter | string
    personalId?: StringWithAggregatesFilter | string
  }

  export type StudentWhereInput = {
    AND?: Enumerable<StudentWhereInput>
    OR?: Enumerable<StudentWhereInput>
    NOT?: Enumerable<StudentWhereInput>
    id?: StringFilter | string
    userId?: StringNullableFilter | string | null
    majorId?: StringNullableFilter | string | null
    classRoomIds?: StringNullableListFilter
    startYearId?: StringFilter | string
    instansiId?: StringFilter | string
    eventIds?: StringNullableListFilter
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    major?: XOR<KonsentrasiKeahlianRelationFilter, KonsentrasiKeahlianWhereInput> | null
    classRoom?: ClassRoomListRelationFilter
    startYear?: XOR<SchoolYearRelationFilter, SchoolYearWhereInput>
    instansi?: XOR<InstansiRelationFilter, InstansiWhereInput>
    event?: CalendarListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    majorId?: SortOrder
    classRoomIds?: SortOrder
    startYearId?: SortOrder
    instansiId?: SortOrder
    eventIds?: SortOrder
    user?: UserOrderByWithRelationInput
    major?: KonsentrasiKeahlianOrderByWithRelationInput
    classRoom?: ClassRoomOrderByRelationAggregateInput
    startYear?: SchoolYearOrderByWithRelationInput
    instansi?: InstansiOrderByWithRelationInput
    event?: CalendarOrderByRelationAggregateInput
  }

  export type StudentWhereUniqueInput = {
    id?: string
    userId?: string
  }

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    majorId?: SortOrder
    classRoomIds?: SortOrder
    startYearId?: SortOrder
    instansiId?: SortOrder
    eventIds?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StudentScalarWhereWithAggregatesInput>
    OR?: Enumerable<StudentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StudentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringNullableWithAggregatesFilter | string | null
    majorId?: StringNullableWithAggregatesFilter | string | null
    classRoomIds?: StringNullableListFilter
    startYearId?: StringWithAggregatesFilter | string
    instansiId?: StringWithAggregatesFilter | string
    eventIds?: StringNullableListFilter
  }

  export type TeacherWhereInput = {
    AND?: Enumerable<TeacherWhereInput>
    OR?: Enumerable<TeacherWhereInput>
    NOT?: Enumerable<TeacherWhereInput>
    id?: StringFilter | string
    userId?: StringNullableFilter | string | null
    instansiId?: StringFilter | string
    eventIds?: StringNullableListFilter
    nip?: StringNullableFilter | string | null
    nrg?: StringNullableFilter | string | null
    noKarpeg?: StringNullableFilter | string | null
    tmtTugas?: StringNullableFilter | string | null
    tmtGol?: StringNullableFilter | string | null
    position?: StringNullableFilter | string | null
    rank?: StringNullableFilter | string | null
    period?: StringNullableFilter | string | null
    certificate?: StringNullableFilter | string | null
    education?: XOR<EducationCompositeListFilter, Enumerable<EducationObjectEqualityInput>>
    training?: XOR<TrainingCompositeListFilter, Enumerable<TrainingObjectEqualityInput>>
    employment?: XOR<EmploymentCompositeListFilter, Enumerable<EmploymentObjectEqualityInput>>
    profession?: XOR<ProfessionCompositeListFilter, Enumerable<ProfessionObjectEqualityInput>>
    overseas?: XOR<OverseasCompositeListFilter, Enumerable<OverseasObjectEqualityInput>>
    scientific?: XOR<ScientificCompositeListFilter, Enumerable<ScientificObjectEqualityInput>>
    organization?: XOR<OrganizationCompositeListFilter, Enumerable<OrganizationObjectEqualityInput>>
    papers?: XOR<PapersCompositeListFilter, Enumerable<PapersObjectEqualityInput>>
    innovation?: XOR<InnovationCompositeListFilter, Enumerable<InnovationObjectEqualityInput>>
    award?: XOR<AwardCompositeListFilter, Enumerable<AwardObjectEqualityInput>>
    sourcePerson?: XOR<SourcePersonCompositeListFilter, Enumerable<SourcePersonObjectEqualityInput>>
    contest?: XOR<ContestCompositeListFilter, Enumerable<ContestObjectEqualityInput>>
    documents?: XOR<DocumentsCompositeListFilter, Enumerable<DocumentsObjectEqualityInput>>
    additional?: XOR<AdditionalCompositeListFilter, Enumerable<AdditionalObjectEqualityInput>>
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    classRoom?: ClassRoomListRelationFilter
    instansi?: XOR<InstansiRelationFilter, InstansiWhereInput>
    event?: CalendarListRelationFilter
  }

  export type TeacherOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    instansiId?: SortOrder
    eventIds?: SortOrder
    nip?: SortOrder
    nrg?: SortOrder
    noKarpeg?: SortOrder
    tmtTugas?: SortOrder
    tmtGol?: SortOrder
    position?: SortOrder
    rank?: SortOrder
    period?: SortOrder
    certificate?: SortOrder
    education?: EducationOrderByCompositeAggregateInput
    training?: TrainingOrderByCompositeAggregateInput
    employment?: EmploymentOrderByCompositeAggregateInput
    profession?: ProfessionOrderByCompositeAggregateInput
    overseas?: OverseasOrderByCompositeAggregateInput
    scientific?: ScientificOrderByCompositeAggregateInput
    organization?: OrganizationOrderByCompositeAggregateInput
    papers?: PapersOrderByCompositeAggregateInput
    innovation?: InnovationOrderByCompositeAggregateInput
    award?: AwardOrderByCompositeAggregateInput
    sourcePerson?: SourcePersonOrderByCompositeAggregateInput
    contest?: ContestOrderByCompositeAggregateInput
    documents?: DocumentsOrderByCompositeAggregateInput
    additional?: AdditionalOrderByCompositeAggregateInput
    user?: UserOrderByWithRelationInput
    classRoom?: ClassRoomOrderByRelationAggregateInput
    instansi?: InstansiOrderByWithRelationInput
    event?: CalendarOrderByRelationAggregateInput
  }

  export type TeacherWhereUniqueInput = {
    id?: string
    userId?: string
  }

  export type TeacherOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    instansiId?: SortOrder
    eventIds?: SortOrder
    nip?: SortOrder
    nrg?: SortOrder
    noKarpeg?: SortOrder
    tmtTugas?: SortOrder
    tmtGol?: SortOrder
    position?: SortOrder
    rank?: SortOrder
    period?: SortOrder
    certificate?: SortOrder
    _count?: TeacherCountOrderByAggregateInput
    _max?: TeacherMaxOrderByAggregateInput
    _min?: TeacherMinOrderByAggregateInput
  }

  export type TeacherScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TeacherScalarWhereWithAggregatesInput>
    OR?: Enumerable<TeacherScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TeacherScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringNullableWithAggregatesFilter | string | null
    instansiId?: StringWithAggregatesFilter | string
    eventIds?: StringNullableListFilter
    nip?: StringNullableWithAggregatesFilter | string | null
    nrg?: StringNullableWithAggregatesFilter | string | null
    noKarpeg?: StringNullableWithAggregatesFilter | string | null
    tmtTugas?: StringNullableWithAggregatesFilter | string | null
    tmtGol?: StringNullableWithAggregatesFilter | string | null
    position?: StringNullableWithAggregatesFilter | string | null
    rank?: StringNullableWithAggregatesFilter | string | null
    period?: StringNullableWithAggregatesFilter | string | null
    certificate?: StringNullableWithAggregatesFilter | string | null
  }

  export type ClassRoomWhereInput = {
    AND?: Enumerable<ClassRoomWhereInput>
    OR?: Enumerable<ClassRoomWhereInput>
    NOT?: Enumerable<ClassRoomWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    yearId?: StringFilter | string
    waliId?: StringFilter | string
    studentIds?: StringNullableListFilter
    eventIds?: StringNullableListFilter
    year?: XOR<SchoolYearRelationFilter, SchoolYearWhereInput>
    wali?: XOR<TeacherRelationFilter, TeacherWhereInput>
    students?: StudentListRelationFilter
    event?: CalendarListRelationFilter
  }

  export type ClassRoomOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    yearId?: SortOrder
    waliId?: SortOrder
    studentIds?: SortOrder
    eventIds?: SortOrder
    year?: SchoolYearOrderByWithRelationInput
    wali?: TeacherOrderByWithRelationInput
    students?: StudentOrderByRelationAggregateInput
    event?: CalendarOrderByRelationAggregateInput
  }

  export type ClassRoomWhereUniqueInput = {
    id?: string
    yearId_name?: ClassRoomYearIdNameCompoundUniqueInput
  }

  export type ClassRoomOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    yearId?: SortOrder
    waliId?: SortOrder
    studentIds?: SortOrder
    eventIds?: SortOrder
    _count?: ClassRoomCountOrderByAggregateInput
    _max?: ClassRoomMaxOrderByAggregateInput
    _min?: ClassRoomMinOrderByAggregateInput
  }

  export type ClassRoomScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ClassRoomScalarWhereWithAggregatesInput>
    OR?: Enumerable<ClassRoomScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ClassRoomScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    yearId?: StringWithAggregatesFilter | string
    waliId?: StringWithAggregatesFilter | string
    studentIds?: StringNullableListFilter
    eventIds?: StringNullableListFilter
  }

  export type SchoolYearWhereInput = {
    AND?: Enumerable<SchoolYearWhereInput>
    OR?: Enumerable<SchoolYearWhereInput>
    NOT?: Enumerable<SchoolYearWhereInput>
    id?: StringFilter | string
    year?: IntFilter | number
    instansiId?: StringFilter | string
    organizational?: XOR<OrganizationalCompositeFilter, OrganizationalObjectEqualityInput>
    instansi?: XOR<InstansiRelationFilter, InstansiWhereInput>
    classRoom?: ClassRoomListRelationFilter
    studentsIn?: StudentListRelationFilter
    calendar?: CalendarListRelationFilter
  }

  export type SchoolYearOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrder
    instansiId?: SortOrder
    organizational?: OrganizationalOrderByInput
    instansi?: InstansiOrderByWithRelationInput
    classRoom?: ClassRoomOrderByRelationAggregateInput
    studentsIn?: StudentOrderByRelationAggregateInput
    calendar?: CalendarOrderByRelationAggregateInput
  }

  export type SchoolYearWhereUniqueInput = {
    id?: string
    instansiId_year?: SchoolYearInstansiIdYearCompoundUniqueInput
  }

  export type SchoolYearOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrder
    instansiId?: SortOrder
    _count?: SchoolYearCountOrderByAggregateInput
    _avg?: SchoolYearAvgOrderByAggregateInput
    _max?: SchoolYearMaxOrderByAggregateInput
    _min?: SchoolYearMinOrderByAggregateInput
    _sum?: SchoolYearSumOrderByAggregateInput
  }

  export type SchoolYearScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SchoolYearScalarWhereWithAggregatesInput>
    OR?: Enumerable<SchoolYearScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SchoolYearScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    year?: IntWithAggregatesFilter | number
    instansiId?: StringWithAggregatesFilter | string
  }

  export type CalendarWhereInput = {
    AND?: Enumerable<CalendarWhereInput>
    OR?: Enumerable<CalendarWhereInput>
    NOT?: Enumerable<CalendarWhereInput>
    id?: StringFilter | string
    refId?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    start?: DateTimeFilter | Date | string
    end?: DateTimeNullableFilter | Date | string | null
    color?: StringFilter | string
    classRoomIds?: StringNullableListFilter
    studentIds?: StringNullableListFilter
    teacherIds?: StringNullableListFilter
    ref?: XOR<SchoolYearRelationFilter, SchoolYearWhereInput>
    classRoom?: ClassRoomListRelationFilter
    student?: StudentListRelationFilter
    teacher?: TeacherListRelationFilter
  }

  export type CalendarOrderByWithRelationInput = {
    id?: SortOrder
    refId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    start?: SortOrder
    end?: SortOrder
    color?: SortOrder
    classRoomIds?: SortOrder
    studentIds?: SortOrder
    teacherIds?: SortOrder
    ref?: SchoolYearOrderByWithRelationInput
    classRoom?: ClassRoomOrderByRelationAggregateInput
    student?: StudentOrderByRelationAggregateInput
    teacher?: TeacherOrderByRelationAggregateInput
  }

  export type CalendarWhereUniqueInput = {
    id?: string
  }

  export type CalendarOrderByWithAggregationInput = {
    id?: SortOrder
    refId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    start?: SortOrder
    end?: SortOrder
    color?: SortOrder
    classRoomIds?: SortOrder
    studentIds?: SortOrder
    teacherIds?: SortOrder
    _count?: CalendarCountOrderByAggregateInput
    _max?: CalendarMaxOrderByAggregateInput
    _min?: CalendarMinOrderByAggregateInput
  }

  export type CalendarScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CalendarScalarWhereWithAggregatesInput>
    OR?: Enumerable<CalendarScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CalendarScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    refId?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    start?: DateTimeWithAggregatesFilter | Date | string
    end?: DateTimeNullableWithAggregatesFilter | Date | string | null
    color?: StringWithAggregatesFilter | string
    classRoomIds?: StringNullableListFilter
    studentIds?: StringNullableListFilter
    teacherIds?: StringNullableListFilter
  }

  export type BidangKeahlianCreateInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    program?: ProgramKeahlianCreateNestedManyWithoutBidangInput
  }

  export type BidangKeahlianUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    program?: ProgramKeahlianUncheckedCreateNestedManyWithoutBidangInput
  }

  export type BidangKeahlianUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramKeahlianUpdateManyWithoutBidangNestedInput
  }

  export type BidangKeahlianUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramKeahlianUncheckedUpdateManyWithoutBidangNestedInput
  }

  export type BidangKeahlianCreateManyInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidangKeahlianUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidangKeahlianUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramKeahlianCreateInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bidang: BidangKeahlianCreateNestedOneWithoutProgramInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedManyWithoutProgramInput
  }

  export type ProgramKeahlianUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    bidangId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    konsentrasi?: KonsentrasiKeahlianUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramKeahlianUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidang?: BidangKeahlianUpdateOneRequiredWithoutProgramNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateManyWithoutProgramNestedInput
  }

  export type ProgramKeahlianUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bidangId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    konsentrasi?: KonsentrasiKeahlianUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramKeahlianCreateManyInput = {
    id?: string
    code: string
    name: string
    bidangId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramKeahlianUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramKeahlianUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bidangId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KonsentrasiKeahlianCreateInput = {
    id?: string
    code: string
    name: string
    tahun: number
    createdAt?: Date | string
    updatedAt?: Date | string
    program: ProgramKeahlianCreateNestedOneWithoutKonsentrasiInput
    student?: StudentCreateNestedManyWithoutMajorInput
    instansi?: InstansiCreateNestedManyWithoutMajorsInput
  }

  export type KonsentrasiKeahlianUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    programId: string
    tahun: number
    createdAt?: Date | string
    updatedAt?: Date | string
    instansiIds?: KonsentrasiKeahlianCreateinstansiIdsInput | Enumerable<string>
    student?: StudentUncheckedCreateNestedManyWithoutMajorInput
    instansi?: InstansiUncheckedCreateNestedManyWithoutMajorsInput
  }

  export type KonsentrasiKeahlianUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramKeahlianUpdateOneRequiredWithoutKonsentrasiNestedInput
    student?: StudentUpdateManyWithoutMajorNestedInput
    instansi?: InstansiUpdateManyWithoutMajorsNestedInput
  }

  export type KonsentrasiKeahlianUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instansiIds?: KonsentrasiKeahlianUpdateinstansiIdsInput | Enumerable<string>
    student?: StudentUncheckedUpdateManyWithoutMajorNestedInput
    instansi?: InstansiUncheckedUpdateManyWithoutMajorsNestedInput
  }

  export type KonsentrasiKeahlianCreateManyInput = {
    id?: string
    code: string
    name: string
    programId: string
    tahun: number
    createdAt?: Date | string
    updatedAt?: Date | string
    instansiIds?: KonsentrasiKeahlianCreateinstansiIdsInput | Enumerable<string>
  }

  export type KonsentrasiKeahlianUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KonsentrasiKeahlianUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instansiIds?: KonsentrasiKeahlianUpdateinstansiIdsInput | Enumerable<string>
  }

  export type AchievementCreateInput = {
    id?: string
    fase?: Fase
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    element: ElementCreateNestedOneWithoutAchievementInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: string
    fase?: Fase
    description: string
    elementId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementUpdateInput = {
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    element?: ElementUpdateOneRequiredWithoutAchievementNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    description?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateManyInput = {
    id?: string
    fase?: Fase
    description: string
    elementId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementUpdateManyMutationInput = {
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateManyInput = {
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    description?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElementCreateInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    achievement?: AchievementCreateNestedManyWithoutElementInput
    mapel: MataPelajaranCreateNestedOneWithoutElementInput
  }

  export type ElementUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    mapelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    achievement?: AchievementUncheckedCreateNestedManyWithoutElementInput
  }

  export type ElementUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: AchievementUpdateManyWithoutElementNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutElementNestedInput
  }

  export type ElementUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: AchievementUncheckedUpdateManyWithoutElementNestedInput
  }

  export type ElementCreateManyInput = {
    id?: string
    name: string
    description: string
    mapelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ElementUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElementUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MataPelajaranCreateInput = {
    id?: string
    code: string
    name: string
    religion?: Religion | null
    vocational: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    element?: ElementCreateNestedManyWithoutMapelInput
  }

  export type MataPelajaranUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    religion?: Religion | null
    vocational: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    element?: ElementUncheckedCreateNestedManyWithoutMapelInput
  }

  export type MataPelajaranUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    vocational?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    element?: ElementUpdateManyWithoutMapelNestedInput
  }

  export type MataPelajaranUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    vocational?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    element?: ElementUncheckedUpdateManyWithoutMapelNestedInput
  }

  export type MataPelajaranCreateManyInput = {
    id?: string
    code: string
    name: string
    religion?: Religion | null
    vocational: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MataPelajaranUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    vocational?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MataPelajaranUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    vocational?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstansiCreateInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    majors?: KonsentrasiKeahlianCreateNestedManyWithoutInstansiInput
    role?: RoleCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearCreateNestedManyWithoutInstansiInput
    teacher?: TeacherCreateNestedManyWithoutInstansiInput
    student?: StudentCreateNestedManyWithoutInstansiInput
  }

  export type InstansiUncheckedCreateInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    majorIds?: InstansiCreatemajorIdsInput | Enumerable<string>
    createdAt?: Date | string
    updatedAt?: Date | string
    majors?: KonsentrasiKeahlianUncheckedCreateNestedManyWithoutInstansiInput
    role?: RoleUncheckedCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearUncheckedCreateNestedManyWithoutInstansiInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutInstansiInput
    student?: StudentUncheckedCreateNestedManyWithoutInstansiInput
  }

  export type InstansiUpdateInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    majors?: KonsentrasiKeahlianUpdateManyWithoutInstansiNestedInput
    role?: RoleUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUpdateManyWithoutInstansiNestedInput
    student?: StudentUpdateManyWithoutInstansiNestedInput
  }

  export type InstansiUncheckedUpdateInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    majorIds?: InstansiUpdatemajorIdsInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    majors?: KonsentrasiKeahlianUncheckedUpdateManyWithoutInstansiNestedInput
    role?: RoleUncheckedUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUncheckedUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutInstansiNestedInput
    student?: StudentUncheckedUpdateManyWithoutInstansiNestedInput
  }

  export type InstansiCreateManyInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    majorIds?: InstansiCreatemajorIdsInput | Enumerable<string>
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstansiUpdateManyMutationInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstansiUncheckedUpdateManyInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    majorIds?: InstansiUpdatemajorIdsInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    key: Roles
    createdAt?: Date | string
    updatedAt?: Date | string
    instansi: InstansiCreateNestedOneWithoutRoleInput
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    key: Roles
    instansiId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    key?: EnumRolesFieldUpdateOperationsInput | Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instansi?: InstansiUpdateOneRequiredWithoutRoleNestedInput
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    key?: EnumRolesFieldUpdateOperationsInput | Roles
    instansiId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    key: Roles
    instansiId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    key?: EnumRolesFieldUpdateOperationsInput | Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    key?: EnumRolesFieldUpdateOperationsInput | Roles
    instansiId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    personal?: PersonalCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: string | null
    personal?: PersonalUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    personal?: PersonalUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    personal?: PersonalUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonalCreateInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign: boolean
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email: string
    belajarId?: string | null
    nophone: string
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    user?: UserCreateNestedOneWithoutPersonalInput
    father?: FamilyTreeCreateNestedManyWithoutFatherInput
    mother?: FamilyTreeCreateNestedManyWithoutMotherInput
    wali?: FamilyTreeCreateNestedManyWithoutWaliInput
    child?: FamilyTreeChildCreateNestedOneWithoutPersonalInput
  }

  export type PersonalUncheckedCreateInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    userId?: string | null
    fullname: string
    gender: Gender
    foreign: boolean
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email: string
    belajarId?: string | null
    nophone: string
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    father?: FamilyTreeUncheckedCreateNestedManyWithoutFatherInput
    mother?: FamilyTreeUncheckedCreateNestedManyWithoutMotherInput
    wali?: FamilyTreeUncheckedCreateNestedManyWithoutWaliInput
    child?: FamilyTreeChildUncheckedCreateNestedOneWithoutPersonalInput
  }

  export type PersonalUpdateInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: BoolFieldUpdateOperationsInput | boolean
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: StringFieldUpdateOperationsInput | string
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: StringFieldUpdateOperationsInput | string
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    user?: UserUpdateOneWithoutPersonalNestedInput
    father?: FamilyTreeUpdateManyWithoutFatherNestedInput
    mother?: FamilyTreeUpdateManyWithoutMotherNestedInput
    wali?: FamilyTreeUpdateManyWithoutWaliNestedInput
    child?: FamilyTreeChildUpdateOneWithoutPersonalNestedInput
  }

  export type PersonalUncheckedUpdateInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: BoolFieldUpdateOperationsInput | boolean
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: StringFieldUpdateOperationsInput | string
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: StringFieldUpdateOperationsInput | string
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    father?: FamilyTreeUncheckedUpdateManyWithoutFatherNestedInput
    mother?: FamilyTreeUncheckedUpdateManyWithoutMotherNestedInput
    wali?: FamilyTreeUncheckedUpdateManyWithoutWaliNestedInput
    child?: FamilyTreeChildUncheckedUpdateOneWithoutPersonalNestedInput
  }

  export type PersonalCreateManyInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    userId?: string | null
    fullname: string
    gender: Gender
    foreign: boolean
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email: string
    belajarId?: string | null
    nophone: string
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
  }

  export type PersonalUpdateManyMutationInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: BoolFieldUpdateOperationsInput | boolean
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: StringFieldUpdateOperationsInput | string
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: StringFieldUpdateOperationsInput | string
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
  }

  export type PersonalUncheckedUpdateManyInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: BoolFieldUpdateOperationsInput | boolean
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: StringFieldUpdateOperationsInput | string
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: StringFieldUpdateOperationsInput | string
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
  }

  export type FamilyTreeCreateInput = {
    id?: string
    nokk: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    father?: PersonalCreateNestedOneWithoutFatherInput
    mother?: PersonalCreateNestedOneWithoutMotherInput
    wali?: PersonalCreateNestedOneWithoutWaliInput
    childs?: FamilyTreeChildCreateNestedManyWithoutKkInput
  }

  export type FamilyTreeUncheckedCreateInput = {
    id?: string
    nokk: string
    fatherId?: string | null
    motherId?: string | null
    waliId?: string | null
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    childs?: FamilyTreeChildUncheckedCreateNestedManyWithoutKkInput
  }

  export type FamilyTreeUpdateInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    father?: PersonalUpdateOneWithoutFatherNestedInput
    mother?: PersonalUpdateOneWithoutMotherNestedInput
    wali?: PersonalUpdateOneWithoutWaliNestedInput
    childs?: FamilyTreeChildUpdateManyWithoutKkNestedInput
  }

  export type FamilyTreeUncheckedUpdateInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    fatherId?: NullableStringFieldUpdateOperationsInput | string | null
    motherId?: NullableStringFieldUpdateOperationsInput | string | null
    waliId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    childs?: FamilyTreeChildUncheckedUpdateManyWithoutKkNestedInput
  }

  export type FamilyTreeCreateManyInput = {
    id?: string
    nokk: string
    fatherId?: string | null
    motherId?: string | null
    waliId?: string | null
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
  }

  export type FamilyTreeUpdateManyMutationInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
  }

  export type FamilyTreeUncheckedUpdateManyInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    fatherId?: NullableStringFieldUpdateOperationsInput | string | null
    motherId?: NullableStringFieldUpdateOperationsInput | string | null
    waliId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
  }

  export type FamilyTreeChildCreateInput = {
    id?: string
    no: number
    type: ChildType
    kk: FamilyTreeCreateNestedOneWithoutChildsInput
    personal: PersonalCreateNestedOneWithoutChildInput
  }

  export type FamilyTreeChildUncheckedCreateInput = {
    id?: string
    no: number
    type: ChildType
    kkId: string
    personalId: string
  }

  export type FamilyTreeChildUpdateInput = {
    no?: IntFieldUpdateOperationsInput | number
    type?: EnumChildTypeFieldUpdateOperationsInput | ChildType
    kk?: FamilyTreeUpdateOneRequiredWithoutChildsNestedInput
    personal?: PersonalUpdateOneRequiredWithoutChildNestedInput
  }

  export type FamilyTreeChildUncheckedUpdateInput = {
    no?: IntFieldUpdateOperationsInput | number
    type?: EnumChildTypeFieldUpdateOperationsInput | ChildType
    kkId?: StringFieldUpdateOperationsInput | string
    personalId?: StringFieldUpdateOperationsInput | string
  }

  export type FamilyTreeChildCreateManyInput = {
    id?: string
    no: number
    type: ChildType
    kkId: string
    personalId: string
  }

  export type FamilyTreeChildUpdateManyMutationInput = {
    no?: IntFieldUpdateOperationsInput | number
    type?: EnumChildTypeFieldUpdateOperationsInput | ChildType
  }

  export type FamilyTreeChildUncheckedUpdateManyInput = {
    no?: IntFieldUpdateOperationsInput | number
    type?: EnumChildTypeFieldUpdateOperationsInput | ChildType
    kkId?: StringFieldUpdateOperationsInput | string
    personalId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentCreateInput = {
    id?: string
    user?: UserCreateNestedOneWithoutStudentInput
    major?: KonsentrasiKeahlianCreateNestedOneWithoutStudentInput
    classRoom?: ClassRoomCreateNestedManyWithoutStudentsInput
    startYear: SchoolYearCreateNestedOneWithoutStudentsInInput
    instansi: InstansiCreateNestedOneWithoutStudentInput
    event?: CalendarCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    userId?: string | null
    majorId?: string | null
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    startYearId: string
    instansiId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutStudentsInput
    event?: CalendarUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    user?: UserUpdateOneWithoutStudentNestedInput
    major?: KonsentrasiKeahlianUpdateOneWithoutStudentNestedInput
    classRoom?: ClassRoomUpdateManyWithoutStudentsNestedInput
    startYear?: SchoolYearUpdateOneRequiredWithoutStudentsInNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutStudentNestedInput
    event?: CalendarUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomIds?: StudentUpdateclassRoomIdsInput | Enumerable<string>
    startYearId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: StudentUpdateeventIdsInput | Enumerable<string>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutStudentsNestedInput
    event?: CalendarUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    userId?: string | null
    majorId?: string | null
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    startYearId: string
    instansiId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
  }

  export type StudentUpdateManyMutationInput = {

  }

  export type StudentUncheckedUpdateManyInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomIds?: StudentUpdateclassRoomIdsInput | Enumerable<string>
    startYearId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: StudentUpdateeventIdsInput | Enumerable<string>
  }

  export type TeacherCreateInput = {
    id?: string
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: string | null
    tmtGol?: string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    user?: UserCreateNestedOneWithoutTeacherInput
    classRoom?: ClassRoomCreateNestedManyWithoutWaliInput
    instansi: InstansiCreateNestedOneWithoutTeacherInput
    event?: CalendarCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateInput = {
    id?: string
    userId?: string | null
    instansiId: string
    eventIds?: TeacherCreateeventIdsInput | Enumerable<string>
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: string | null
    tmtGol?: string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutWaliInput
    event?: CalendarUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUpdateInput = {
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableStringFieldUpdateOperationsInput | string | null
    tmtGol?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    user?: UserUpdateOneWithoutTeacherNestedInput
    classRoom?: ClassRoomUpdateManyWithoutWaliNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutTeacherNestedInput
    event?: CalendarUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: TeacherUpdateeventIdsInput | Enumerable<string>
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableStringFieldUpdateOperationsInput | string | null
    tmtGol?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutWaliNestedInput
    event?: CalendarUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherCreateManyInput = {
    id?: string
    userId?: string | null
    instansiId: string
    eventIds?: TeacherCreateeventIdsInput | Enumerable<string>
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: string | null
    tmtGol?: string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
  }

  export type TeacherUpdateManyMutationInput = {
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableStringFieldUpdateOperationsInput | string | null
    tmtGol?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
  }

  export type TeacherUncheckedUpdateManyInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: TeacherUpdateeventIdsInput | Enumerable<string>
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableStringFieldUpdateOperationsInput | string | null
    tmtGol?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
  }

  export type ClassRoomCreateInput = {
    id?: string
    name: string
    year: SchoolYearCreateNestedOneWithoutClassRoomInput
    wali: TeacherCreateNestedOneWithoutClassRoomInput
    students?: StudentCreateNestedManyWithoutClassRoomInput
    event?: CalendarCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomUncheckedCreateInput = {
    id?: string
    name: string
    yearId: string
    waliId: string
    studentIds?: ClassRoomCreatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomCreateeventIdsInput | Enumerable<string>
    students?: StudentUncheckedCreateNestedManyWithoutClassRoomInput
    event?: CalendarUncheckedCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    year?: SchoolYearUpdateOneRequiredWithoutClassRoomNestedInput
    wali?: TeacherUpdateOneRequiredWithoutClassRoomNestedInput
    students?: StudentUpdateManyWithoutClassRoomNestedInput
    event?: CalendarUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    waliId?: StringFieldUpdateOperationsInput | string
    studentIds?: ClassRoomUpdatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomUpdateeventIdsInput | Enumerable<string>
    students?: StudentUncheckedUpdateManyWithoutClassRoomNestedInput
    event?: CalendarUncheckedUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomCreateManyInput = {
    id?: string
    name: string
    yearId: string
    waliId: string
    studentIds?: ClassRoomCreatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomCreateeventIdsInput | Enumerable<string>
  }

  export type ClassRoomUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ClassRoomUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    waliId?: StringFieldUpdateOperationsInput | string
    studentIds?: ClassRoomUpdatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomUpdateeventIdsInput | Enumerable<string>
  }

  export type SchoolYearCreateInput = {
    id?: string
    year: number
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    instansi: InstansiCreateNestedOneWithoutSchoolYearInput
    classRoom?: ClassRoomCreateNestedManyWithoutYearInput
    studentsIn?: StudentCreateNestedManyWithoutStartYearInput
    calendar?: CalendarCreateNestedManyWithoutRefInput
  }

  export type SchoolYearUncheckedCreateInput = {
    id?: string
    year: number
    instansiId: string
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutYearInput
    studentsIn?: StudentUncheckedCreateNestedManyWithoutStartYearInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutRefInput
  }

  export type SchoolYearUpdateInput = {
    year?: IntFieldUpdateOperationsInput | number
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    instansi?: InstansiUpdateOneRequiredWithoutSchoolYearNestedInput
    classRoom?: ClassRoomUpdateManyWithoutYearNestedInput
    studentsIn?: StudentUpdateManyWithoutStartYearNestedInput
    calendar?: CalendarUpdateManyWithoutRefNestedInput
  }

  export type SchoolYearUncheckedUpdateInput = {
    year?: IntFieldUpdateOperationsInput | number
    instansiId?: StringFieldUpdateOperationsInput | string
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutYearNestedInput
    studentsIn?: StudentUncheckedUpdateManyWithoutStartYearNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutRefNestedInput
  }

  export type SchoolYearCreateManyInput = {
    id?: string
    year: number
    instansiId: string
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
  }

  export type SchoolYearUpdateManyMutationInput = {
    year?: IntFieldUpdateOperationsInput | number
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
  }

  export type SchoolYearUncheckedUpdateManyInput = {
    year?: IntFieldUpdateOperationsInput | number
    instansiId?: StringFieldUpdateOperationsInput | string
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
  }

  export type CalendarCreateInput = {
    id?: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    ref: SchoolYearCreateNestedOneWithoutCalendarInput
    classRoom?: ClassRoomCreateNestedManyWithoutEventInput
    student?: StudentCreateNestedManyWithoutEventInput
    teacher?: TeacherCreateNestedManyWithoutEventInput
  }

  export type CalendarUncheckedCreateInput = {
    id?: string
    refId: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    classRoomIds?: CalendarCreateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarCreatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarCreateteacherIdsInput | Enumerable<string>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutEventInput
    student?: StudentUncheckedCreateNestedManyWithoutEventInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutEventInput
  }

  export type CalendarUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    ref?: SchoolYearUpdateOneRequiredWithoutCalendarNestedInput
    classRoom?: ClassRoomUpdateManyWithoutEventNestedInput
    student?: StudentUpdateManyWithoutEventNestedInput
    teacher?: TeacherUpdateManyWithoutEventNestedInput
  }

  export type CalendarUncheckedUpdateInput = {
    refId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    classRoomIds?: CalendarUpdateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarUpdatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarUpdateteacherIdsInput | Enumerable<string>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutEventNestedInput
    student?: StudentUncheckedUpdateManyWithoutEventNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutEventNestedInput
  }

  export type CalendarCreateManyInput = {
    id?: string
    refId: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    classRoomIds?: CalendarCreateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarCreatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarCreateteacherIdsInput | Enumerable<string>
  }

  export type CalendarUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
  }

  export type CalendarUncheckedUpdateManyInput = {
    refId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    classRoomIds?: CalendarUpdateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarUpdatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarUpdateteacherIdsInput | Enumerable<string>
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type ProgramKeahlianListRelationFilter = {
    every?: ProgramKeahlianWhereInput
    some?: ProgramKeahlianWhereInput
    none?: ProgramKeahlianWhereInput
  }

  export type ProgramKeahlianOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BidangKeahlianCodeNameCompoundUniqueInput = {
    code: string
    name: string
  }

  export type BidangKeahlianCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BidangKeahlianMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BidangKeahlianMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type BidangKeahlianRelationFilter = {
    is?: BidangKeahlianWhereInput
    isNot?: BidangKeahlianWhereInput
  }

  export type KonsentrasiKeahlianListRelationFilter = {
    every?: KonsentrasiKeahlianWhereInput
    some?: KonsentrasiKeahlianWhereInput
    none?: KonsentrasiKeahlianWhereInput
  }

  export type KonsentrasiKeahlianOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramKeahlianCodeNameCompoundUniqueInput = {
    code: string
    name: string
  }

  export type ProgramKeahlianCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    bidangId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramKeahlianMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    bidangId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramKeahlianMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    bidangId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type ProgramKeahlianRelationFilter = {
    is?: ProgramKeahlianWhereInput
    isNot?: ProgramKeahlianWhereInput
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type InstansiListRelationFilter = {
    every?: InstansiWhereInput
    some?: InstansiWhereInput
    none?: InstansiWhereInput
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstansiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KonsentrasiKeahlianProgramIdNameCompoundUniqueInput = {
    programId: string
    name: string
  }

  export type KonsentrasiKeahlianCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    programId?: SortOrder
    tahun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instansiIds?: SortOrder
  }

  export type KonsentrasiKeahlianAvgOrderByAggregateInput = {
    tahun?: SortOrder
  }

  export type KonsentrasiKeahlianMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    programId?: SortOrder
    tahun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KonsentrasiKeahlianMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    programId?: SortOrder
    tahun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KonsentrasiKeahlianSumOrderByAggregateInput = {
    tahun?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type EnumFaseFilter = {
    equals?: Fase
    in?: Enumerable<Fase>
    notIn?: Enumerable<Fase>
    not?: NestedEnumFaseFilter | Fase
  }

  export type ElementRelationFilter = {
    is?: ElementWhereInput
    isNot?: ElementWhereInput
  }

  export type AchievementElementIdFaseCompoundUniqueInput = {
    elementId: string
    fase: Fase
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    fase?: SortOrder
    description?: SortOrder
    elementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    fase?: SortOrder
    description?: SortOrder
    elementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    fase?: SortOrder
    description?: SortOrder
    elementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumFaseWithAggregatesFilter = {
    equals?: Fase
    in?: Enumerable<Fase>
    notIn?: Enumerable<Fase>
    not?: NestedEnumFaseWithAggregatesFilter | Fase
    _count?: NestedIntFilter
    _min?: NestedEnumFaseFilter
    _max?: NestedEnumFaseFilter
  }

  export type AchievementListRelationFilter = {
    every?: AchievementWhereInput
    some?: AchievementWhereInput
    none?: AchievementWhereInput
  }

  export type MataPelajaranRelationFilter = {
    is?: MataPelajaranWhereInput
    isNot?: MataPelajaranWhereInput
  }

  export type AchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ElementMapelIdNameCompoundUniqueInput = {
    mapelId: string
    name: string
  }

  export type ElementCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    mapelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ElementMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    mapelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ElementMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    mapelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumReligionNullableFilter = {
    equals?: Religion | null
    in?: Enumerable<Religion> | null
    notIn?: Enumerable<Religion> | null
    not?: NestedEnumReligionNullableFilter | Religion | null
    isSet?: boolean
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type ElementListRelationFilter = {
    every?: ElementWhereInput
    some?: ElementWhereInput
    none?: ElementWhereInput
  }

  export type ElementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MataPelajaranCodeNameCompoundUniqueInput = {
    code: string
    name: string
  }

  export type MataPelajaranCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    religion?: SortOrder
    vocational?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MataPelajaranMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    religion?: SortOrder
    vocational?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MataPelajaranMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    religion?: SortOrder
    vocational?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumReligionNullableWithAggregatesFilter = {
    equals?: Religion | null
    in?: Enumerable<Religion> | null
    notIn?: Enumerable<Religion> | null
    not?: NestedEnumReligionNullableWithAggregatesFilter | Religion | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumReligionNullableFilter
    _max?: NestedEnumReligionNullableFilter
    isSet?: boolean
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type AddressCompositeFilter = {
    equals?: AddressObjectEqualityInput
    is?: AddressWhereInput
    isNot?: AddressWhereInput
  }

  export type AddressObjectEqualityInput = {
    provinsi: string
    kabupaten: string
    kecamatan: string
    kelurahan: string
    kodepos: string
    coordinate: CoordinateObjectEqualityInput
  }

  export type EnumLevelFilter = {
    equals?: Level
    in?: Enumerable<Level>
    notIn?: Enumerable<Level>
    not?: NestedEnumLevelFilter | Level
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
    isSet?: boolean
  }

  export type RoleListRelationFilter = {
    every?: RoleWhereInput
    some?: RoleWhereInput
    none?: RoleWhereInput
  }

  export type SchoolYearListRelationFilter = {
    every?: SchoolYearWhereInput
    some?: SchoolYearWhereInput
    none?: SchoolYearWhereInput
  }

  export type TeacherListRelationFilter = {
    every?: TeacherWhereInput
    some?: TeacherWhereInput
    none?: TeacherWhereInput
  }

  export type AddressOrderByInput = {
    provinsi?: SortOrder
    kabupaten?: SortOrder
    kecamatan?: SortOrder
    kelurahan?: SortOrder
    kodepos?: SortOrder
    coordinate?: CoordinateOrderByInput
  }

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolYearOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstansiCountOrderByAggregateInput = {
    id?: SortOrder
    npsn?: SortOrder
    name?: SortOrder
    isPrivate?: SortOrder
    level?: SortOrder
    religion?: SortOrder
    major?: SortOrder
    majorIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstansiMaxOrderByAggregateInput = {
    id?: SortOrder
    npsn?: SortOrder
    name?: SortOrder
    isPrivate?: SortOrder
    level?: SortOrder
    religion?: SortOrder
    major?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstansiMinOrderByAggregateInput = {
    id?: SortOrder
    npsn?: SortOrder
    name?: SortOrder
    isPrivate?: SortOrder
    level?: SortOrder
    religion?: SortOrder
    major?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLevelWithAggregatesFilter = {
    equals?: Level
    in?: Enumerable<Level>
    notIn?: Enumerable<Level>
    not?: NestedEnumLevelWithAggregatesFilter | Level
    _count?: NestedIntFilter
    _min?: NestedEnumLevelFilter
    _max?: NestedEnumLevelFilter
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
    isSet?: boolean
  }

  export type EnumRolesFilter = {
    equals?: Roles
    in?: Enumerable<Roles>
    notIn?: Enumerable<Roles>
    not?: NestedEnumRolesFilter | Roles
  }

  export type InstansiRelationFilter = {
    is?: InstansiWhereInput
    isNot?: InstansiWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleInstansiIdKeyCompoundUniqueInput = {
    instansiId: string
    key: Roles
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    instansiId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    instansiId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    instansiId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRolesWithAggregatesFilter = {
    equals?: Roles
    in?: Enumerable<Roles>
    notIn?: Enumerable<Roles>
    not?: NestedEnumRolesWithAggregatesFilter | Roles
    _count?: NestedIntFilter
    _min?: NestedEnumRolesFilter
    _max?: NestedEnumRolesFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
    isSet?: boolean
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput | null
    isNot?: RoleWhereInput | null
  }

  export type PersonalRelationFilter = {
    is?: PersonalWhereInput | null
    isNot?: PersonalWhereInput | null
  }

  export type StudentRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type TeacherRelationFilter = {
    is?: TeacherWhereInput
    isNot?: TeacherWhereInput
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    picture?: SortOrder
    username?: SortOrder
    active?: SortOrder
    verify?: SortOrder
    password?: SortOrder
    passhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    picture?: SortOrder
    username?: SortOrder
    active?: SortOrder
    verify?: SortOrder
    password?: SortOrder
    passhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    picture?: SortOrder
    username?: SortOrder
    active?: SortOrder
    verify?: SortOrder
    password?: SortOrder
    passhash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    isSet?: boolean
  }

  export type EnumTypePersonalFilter = {
    equals?: TypePersonal
    in?: Enumerable<TypePersonal>
    notIn?: Enumerable<TypePersonal>
    not?: NestedEnumTypePersonalFilter | TypePersonal
  }

  export type EnumGenderFilter = {
    equals?: Gender
    in?: Enumerable<Gender>
    notIn?: Enumerable<Gender>
    not?: NestedEnumGenderFilter | Gender
  }

  export type EnumReligionFilter = {
    equals?: Religion
    in?: Enumerable<Religion>
    notIn?: Enumerable<Religion>
    not?: NestedEnumReligionFilter | Religion
  }

  export type BornCompositeFilter = {
    equals?: BornObjectEqualityInput
    is?: BornWhereInput
    isNot?: BornWhereInput
  }

  export type BornObjectEqualityInput = {
    place: string
    date: string
  }

  export type AddressNullableCompositeFilter = {
    equals?: AddressObjectEqualityInput | null
    is?: AddressWhereInput | null
    isNot?: AddressWhereInput | null
    isSet?: boolean
  }

  export type UserRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type FamilyTreeListRelationFilter = {
    every?: FamilyTreeWhereInput
    some?: FamilyTreeWhereInput
    none?: FamilyTreeWhereInput
  }

  export type FamilyTreeChildRelationFilter = {
    is?: FamilyTreeChildWhereInput | null
    isNot?: FamilyTreeChildWhereInput | null
  }

  export type BornOrderByInput = {
    place?: SortOrder
    date?: SortOrder
  }

  export type FamilyTreeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonalCountOrderByAggregateInput = {
    id?: SortOrder
    nik?: SortOrder
    nisn?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    fullname?: SortOrder
    gender?: SortOrder
    foreign?: SortOrder
    country?: SortOrder
    religion?: SortOrder
    email?: SortOrder
    belajarId?: SortOrder
    nophone?: SortOrder
    isLife?: SortOrder
  }

  export type PersonalMaxOrderByAggregateInput = {
    id?: SortOrder
    nik?: SortOrder
    nisn?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    fullname?: SortOrder
    gender?: SortOrder
    foreign?: SortOrder
    country?: SortOrder
    religion?: SortOrder
    email?: SortOrder
    belajarId?: SortOrder
    nophone?: SortOrder
    isLife?: SortOrder
  }

  export type PersonalMinOrderByAggregateInput = {
    id?: SortOrder
    nik?: SortOrder
    nisn?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    fullname?: SortOrder
    gender?: SortOrder
    foreign?: SortOrder
    country?: SortOrder
    religion?: SortOrder
    email?: SortOrder
    belajarId?: SortOrder
    nophone?: SortOrder
    isLife?: SortOrder
  }

  export type EnumTypePersonalWithAggregatesFilter = {
    equals?: TypePersonal
    in?: Enumerable<TypePersonal>
    notIn?: Enumerable<TypePersonal>
    not?: NestedEnumTypePersonalWithAggregatesFilter | TypePersonal
    _count?: NestedIntFilter
    _min?: NestedEnumTypePersonalFilter
    _max?: NestedEnumTypePersonalFilter
  }

  export type EnumGenderWithAggregatesFilter = {
    equals?: Gender
    in?: Enumerable<Gender>
    notIn?: Enumerable<Gender>
    not?: NestedEnumGenderWithAggregatesFilter | Gender
    _count?: NestedIntFilter
    _min?: NestedEnumGenderFilter
    _max?: NestedEnumGenderFilter
  }

  export type EnumReligionWithAggregatesFilter = {
    equals?: Religion
    in?: Enumerable<Religion>
    notIn?: Enumerable<Religion>
    not?: NestedEnumReligionWithAggregatesFilter | Religion
    _count?: NestedIntFilter
    _min?: NestedEnumReligionFilter
    _max?: NestedEnumReligionFilter
  }

  export type FamilyTreeChildListRelationFilter = {
    every?: FamilyTreeChildWhereInput
    some?: FamilyTreeChildWhereInput
    none?: FamilyTreeChildWhereInput
  }

  export type FamilyTreeChildOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FamilyTreeCountOrderByAggregateInput = {
    id?: SortOrder
    nokk?: SortOrder
    fatherId?: SortOrder
    motherId?: SortOrder
    waliId?: SortOrder
  }

  export type FamilyTreeMaxOrderByAggregateInput = {
    id?: SortOrder
    nokk?: SortOrder
    fatherId?: SortOrder
    motherId?: SortOrder
    waliId?: SortOrder
  }

  export type FamilyTreeMinOrderByAggregateInput = {
    id?: SortOrder
    nokk?: SortOrder
    fatherId?: SortOrder
    motherId?: SortOrder
    waliId?: SortOrder
  }

  export type EnumChildTypeFilter = {
    equals?: ChildType
    in?: Enumerable<ChildType>
    notIn?: Enumerable<ChildType>
    not?: NestedEnumChildTypeFilter | ChildType
  }

  export type FamilyTreeRelationFilter = {
    is?: FamilyTreeWhereInput
    isNot?: FamilyTreeWhereInput
  }

  export type FamilyTreeChildCountOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    type?: SortOrder
    kkId?: SortOrder
    personalId?: SortOrder
  }

  export type FamilyTreeChildAvgOrderByAggregateInput = {
    no?: SortOrder
  }

  export type FamilyTreeChildMaxOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    type?: SortOrder
    kkId?: SortOrder
    personalId?: SortOrder
  }

  export type FamilyTreeChildMinOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    type?: SortOrder
    kkId?: SortOrder
    personalId?: SortOrder
  }

  export type FamilyTreeChildSumOrderByAggregateInput = {
    no?: SortOrder
  }

  export type EnumChildTypeWithAggregatesFilter = {
    equals?: ChildType
    in?: Enumerable<ChildType>
    notIn?: Enumerable<ChildType>
    not?: NestedEnumChildTypeWithAggregatesFilter | ChildType
    _count?: NestedIntFilter
    _min?: NestedEnumChildTypeFilter
    _max?: NestedEnumChildTypeFilter
  }

  export type KonsentrasiKeahlianRelationFilter = {
    is?: KonsentrasiKeahlianWhereInput | null
    isNot?: KonsentrasiKeahlianWhereInput | null
  }

  export type ClassRoomListRelationFilter = {
    every?: ClassRoomWhereInput
    some?: ClassRoomWhereInput
    none?: ClassRoomWhereInput
  }

  export type SchoolYearRelationFilter = {
    is?: SchoolYearWhereInput
    isNot?: SchoolYearWhereInput
  }

  export type CalendarListRelationFilter = {
    every?: CalendarWhereInput
    some?: CalendarWhereInput
    none?: CalendarWhereInput
  }

  export type ClassRoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalendarOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    majorId?: SortOrder
    classRoomIds?: SortOrder
    startYearId?: SortOrder
    instansiId?: SortOrder
    eventIds?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    majorId?: SortOrder
    startYearId?: SortOrder
    instansiId?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    majorId?: SortOrder
    startYearId?: SortOrder
    instansiId?: SortOrder
  }

  export type EducationCompositeListFilter = {
    equals?: Enumerable<EducationObjectEqualityInput>
    every?: EducationWhereInput
    some?: EducationWhereInput
    none?: EducationWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type EducationObjectEqualityInput = {
    instansi: string
    level: LevelEdu
    major?: string | null
    year: number
    attachment?: string | null
  }

  export type TrainingCompositeListFilter = {
    equals?: Enumerable<TrainingObjectEqualityInput>
    every?: TrainingWhereInput
    some?: TrainingWhereInput
    none?: TrainingWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type TrainingObjectEqualityInput = {
    name: string
    instansi: string
    long: number
    year: number
    place: string
    attachment?: string | null
  }

  export type EmploymentCompositeListFilter = {
    equals?: Enumerable<EmploymentObjectEqualityInput>
    every?: EmploymentWhereInput
    some?: EmploymentWhereInput
    none?: EmploymentWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type EmploymentObjectEqualityInput = {
    position: string
    year: number
    place: string
    note?: string | null
  }

  export type ProfessionCompositeListFilter = {
    equals?: Enumerable<ProfessionObjectEqualityInput>
    every?: ProfessionWhereInput
    some?: ProfessionWhereInput
    none?: ProfessionWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type ProfessionObjectEqualityInput = {
    name: string
    instansi: string
    year: number
    attachment?: string | null
  }

  export type OverseasCompositeListFilter = {
    equals?: Enumerable<OverseasObjectEqualityInput>
    every?: OverseasWhereInput
    some?: OverseasWhereInput
    none?: OverseasWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type OverseasObjectEqualityInput = {
    country: string
    instansi: string
    objective: string
    long: number
    year: number
    attachment?: string | null
  }

  export type ScientificCompositeListFilter = {
    equals?: Enumerable<ScientificObjectEqualityInput>
    every?: ScientificWhereInput
    some?: ScientificWhereInput
    none?: ScientificWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type ScientificObjectEqualityInput = {
    name: string
    instansi: string
    position: string
    place: string
    period: string
    attachment?: string | null
  }

  export type OrganizationCompositeListFilter = {
    equals?: Enumerable<OrganizationObjectEqualityInput>
    every?: OrganizationWhereInput
    some?: OrganizationWhereInput
    none?: OrganizationWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type OrganizationObjectEqualityInput = {
    name: string
    position: string
    period: string
    leader: string
    place: string
  }

  export type PapersCompositeListFilter = {
    equals?: Enumerable<PapersObjectEqualityInput>
    every?: PapersWhereInput
    some?: PapersWhereInput
    none?: PapersWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type PapersObjectEqualityInput = {
    name: string
    year: number
    published: string
  }

  export type InnovationCompositeListFilter = {
    equals?: Enumerable<InnovationObjectEqualityInput>
    every?: InnovationWhereInput
    some?: InnovationWhereInput
    none?: InnovationWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type InnovationObjectEqualityInput = {
    name: string
    year: number
    patent: boolean
  }

  export type AwardCompositeListFilter = {
    equals?: Enumerable<AwardObjectEqualityInput>
    every?: AwardWhereInput
    some?: AwardWhereInput
    none?: AwardWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type AwardObjectEqualityInput = {
    name: string
    year: number
    instansi: string
    attachment?: string | null
  }

  export type SourcePersonCompositeListFilter = {
    equals?: Enumerable<SourcePersonObjectEqualityInput>
    every?: SourcePersonWhereInput
    some?: SourcePersonWhereInput
    none?: SourcePersonWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type SourcePersonObjectEqualityInput = {
    name: string
    date: string
    instansi: string
    note?: string | null
    attachment?: string | null
  }

  export type ContestCompositeListFilter = {
    equals?: Enumerable<ContestObjectEqualityInput>
    every?: ContestWhereInput
    some?: ContestWhereInput
    none?: ContestWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type ContestObjectEqualityInput = {
    name: string
    date: string
    instansi: string
    level: string
    attachment?: string | null
  }

  export type DocumentsCompositeListFilter = {
    equals?: Enumerable<DocumentsObjectEqualityInput>
    every?: DocumentsWhereInput
    some?: DocumentsWhereInput
    none?: DocumentsWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type DocumentsObjectEqualityInput = {
    name: string
    date: string
    instansi: string
    note?: string | null
    attachment?: string | null
  }

  export type AdditionalCompositeListFilter = {
    equals?: Enumerable<AdditionalObjectEqualityInput>
    every?: AdditionalWhereInput
    some?: AdditionalWhereInput
    none?: AdditionalWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type AdditionalObjectEqualityInput = {
    position: string
    date: string
    instansi: string
    note?: string | null
    attachment?: string | null
  }

  export type EducationOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type EmploymentOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type ProfessionOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type OverseasOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type ScientificOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type PapersOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type InnovationOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type AwardOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type SourcePersonOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type ContestOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentsOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type AdditionalOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    instansiId?: SortOrder
    eventIds?: SortOrder
    nip?: SortOrder
    nrg?: SortOrder
    noKarpeg?: SortOrder
    tmtTugas?: SortOrder
    tmtGol?: SortOrder
    position?: SortOrder
    rank?: SortOrder
    period?: SortOrder
    certificate?: SortOrder
  }

  export type TeacherMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    instansiId?: SortOrder
    nip?: SortOrder
    nrg?: SortOrder
    noKarpeg?: SortOrder
    tmtTugas?: SortOrder
    tmtGol?: SortOrder
    position?: SortOrder
    rank?: SortOrder
    period?: SortOrder
    certificate?: SortOrder
  }

  export type TeacherMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    instansiId?: SortOrder
    nip?: SortOrder
    nrg?: SortOrder
    noKarpeg?: SortOrder
    tmtTugas?: SortOrder
    tmtGol?: SortOrder
    position?: SortOrder
    rank?: SortOrder
    period?: SortOrder
    certificate?: SortOrder
  }

  export type ClassRoomYearIdNameCompoundUniqueInput = {
    yearId: string
    name: string
  }

  export type ClassRoomCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    yearId?: SortOrder
    waliId?: SortOrder
    studentIds?: SortOrder
    eventIds?: SortOrder
  }

  export type ClassRoomMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    yearId?: SortOrder
    waliId?: SortOrder
  }

  export type ClassRoomMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    yearId?: SortOrder
    waliId?: SortOrder
  }

  export type OrganizationalCompositeFilter = {
    equals?: OrganizationalObjectEqualityInput
    is?: OrganizationalWhereInput
    isNot?: OrganizationalWhereInput
  }

  export type OrganizationalObjectEqualityInput = {
    kepsek: string
    wakasek: string
    wakakur: string
    wakasiw: string
    wakapra: string
    wakahum?: string | null
  }

  export type OrganizationalOrderByInput = {
    kepsek?: SortOrder
    wakasek?: SortOrder
    wakakur?: SortOrder
    wakasiw?: SortOrder
    wakapra?: SortOrder
    wakahum?: SortOrder
  }

  export type SchoolYearInstansiIdYearCompoundUniqueInput = {
    instansiId: string
    year: number
  }

  export type SchoolYearCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    instansiId?: SortOrder
  }

  export type SchoolYearAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type SchoolYearMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    instansiId?: SortOrder
  }

  export type SchoolYearMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    instansiId?: SortOrder
  }

  export type SchoolYearSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
    isSet?: boolean
  }

  export type CalendarCountOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    start?: SortOrder
    end?: SortOrder
    color?: SortOrder
    classRoomIds?: SortOrder
    studentIds?: SortOrder
    teacherIds?: SortOrder
  }

  export type CalendarMaxOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    start?: SortOrder
    end?: SortOrder
    color?: SortOrder
  }

  export type CalendarMinOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    start?: SortOrder
    end?: SortOrder
    color?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    isSet?: boolean
  }

  export type ProgramKeahlianCreateNestedManyWithoutBidangInput = {
    create?: XOR<Enumerable<ProgramKeahlianCreateWithoutBidangInput>, Enumerable<ProgramKeahlianUncheckedCreateWithoutBidangInput>>
    connectOrCreate?: Enumerable<ProgramKeahlianCreateOrConnectWithoutBidangInput>
    createMany?: ProgramKeahlianCreateManyBidangInputEnvelope
    connect?: Enumerable<ProgramKeahlianWhereUniqueInput>
  }

  export type ProgramKeahlianUncheckedCreateNestedManyWithoutBidangInput = {
    create?: XOR<Enumerable<ProgramKeahlianCreateWithoutBidangInput>, Enumerable<ProgramKeahlianUncheckedCreateWithoutBidangInput>>
    connectOrCreate?: Enumerable<ProgramKeahlianCreateOrConnectWithoutBidangInput>
    createMany?: ProgramKeahlianCreateManyBidangInputEnvelope
    connect?: Enumerable<ProgramKeahlianWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProgramKeahlianUpdateManyWithoutBidangNestedInput = {
    create?: XOR<Enumerable<ProgramKeahlianCreateWithoutBidangInput>, Enumerable<ProgramKeahlianUncheckedCreateWithoutBidangInput>>
    connectOrCreate?: Enumerable<ProgramKeahlianCreateOrConnectWithoutBidangInput>
    upsert?: Enumerable<ProgramKeahlianUpsertWithWhereUniqueWithoutBidangInput>
    createMany?: ProgramKeahlianCreateManyBidangInputEnvelope
    set?: Enumerable<ProgramKeahlianWhereUniqueInput>
    disconnect?: Enumerable<ProgramKeahlianWhereUniqueInput>
    delete?: Enumerable<ProgramKeahlianWhereUniqueInput>
    connect?: Enumerable<ProgramKeahlianWhereUniqueInput>
    update?: Enumerable<ProgramKeahlianUpdateWithWhereUniqueWithoutBidangInput>
    updateMany?: Enumerable<ProgramKeahlianUpdateManyWithWhereWithoutBidangInput>
    deleteMany?: Enumerable<ProgramKeahlianScalarWhereInput>
  }

  export type ProgramKeahlianUncheckedUpdateManyWithoutBidangNestedInput = {
    create?: XOR<Enumerable<ProgramKeahlianCreateWithoutBidangInput>, Enumerable<ProgramKeahlianUncheckedCreateWithoutBidangInput>>
    connectOrCreate?: Enumerable<ProgramKeahlianCreateOrConnectWithoutBidangInput>
    upsert?: Enumerable<ProgramKeahlianUpsertWithWhereUniqueWithoutBidangInput>
    createMany?: ProgramKeahlianCreateManyBidangInputEnvelope
    set?: Enumerable<ProgramKeahlianWhereUniqueInput>
    disconnect?: Enumerable<ProgramKeahlianWhereUniqueInput>
    delete?: Enumerable<ProgramKeahlianWhereUniqueInput>
    connect?: Enumerable<ProgramKeahlianWhereUniqueInput>
    update?: Enumerable<ProgramKeahlianUpdateWithWhereUniqueWithoutBidangInput>
    updateMany?: Enumerable<ProgramKeahlianUpdateManyWithWhereWithoutBidangInput>
    deleteMany?: Enumerable<ProgramKeahlianScalarWhereInput>
  }

  export type BidangKeahlianCreateNestedOneWithoutProgramInput = {
    create?: XOR<BidangKeahlianCreateWithoutProgramInput, BidangKeahlianUncheckedCreateWithoutProgramInput>
    connectOrCreate?: BidangKeahlianCreateOrConnectWithoutProgramInput
    connect?: BidangKeahlianWhereUniqueInput
  }

  export type KonsentrasiKeahlianCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<KonsentrasiKeahlianCreateWithoutProgramInput>, Enumerable<KonsentrasiKeahlianUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<KonsentrasiKeahlianCreateOrConnectWithoutProgramInput>
    createMany?: KonsentrasiKeahlianCreateManyProgramInputEnvelope
    connect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
  }

  export type KonsentrasiKeahlianUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<KonsentrasiKeahlianCreateWithoutProgramInput>, Enumerable<KonsentrasiKeahlianUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<KonsentrasiKeahlianCreateOrConnectWithoutProgramInput>
    createMany?: KonsentrasiKeahlianCreateManyProgramInputEnvelope
    connect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
  }

  export type BidangKeahlianUpdateOneRequiredWithoutProgramNestedInput = {
    create?: XOR<BidangKeahlianCreateWithoutProgramInput, BidangKeahlianUncheckedCreateWithoutProgramInput>
    connectOrCreate?: BidangKeahlianCreateOrConnectWithoutProgramInput
    upsert?: BidangKeahlianUpsertWithoutProgramInput
    connect?: BidangKeahlianWhereUniqueInput
    update?: XOR<BidangKeahlianUpdateWithoutProgramInput, BidangKeahlianUncheckedUpdateWithoutProgramInput>
  }

  export type KonsentrasiKeahlianUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<KonsentrasiKeahlianCreateWithoutProgramInput>, Enumerable<KonsentrasiKeahlianUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<KonsentrasiKeahlianCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<KonsentrasiKeahlianUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: KonsentrasiKeahlianCreateManyProgramInputEnvelope
    set?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    disconnect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    delete?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    connect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    update?: Enumerable<KonsentrasiKeahlianUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<KonsentrasiKeahlianUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<KonsentrasiKeahlianScalarWhereInput>
  }

  export type KonsentrasiKeahlianUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<KonsentrasiKeahlianCreateWithoutProgramInput>, Enumerable<KonsentrasiKeahlianUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<KonsentrasiKeahlianCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<KonsentrasiKeahlianUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: KonsentrasiKeahlianCreateManyProgramInputEnvelope
    set?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    disconnect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    delete?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    connect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    update?: Enumerable<KonsentrasiKeahlianUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<KonsentrasiKeahlianUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<KonsentrasiKeahlianScalarWhereInput>
  }

  export type ProgramKeahlianCreateNestedOneWithoutKonsentrasiInput = {
    create?: XOR<ProgramKeahlianCreateWithoutKonsentrasiInput, ProgramKeahlianUncheckedCreateWithoutKonsentrasiInput>
    connectOrCreate?: ProgramKeahlianCreateOrConnectWithoutKonsentrasiInput
    connect?: ProgramKeahlianWhereUniqueInput
  }

  export type StudentCreateNestedManyWithoutMajorInput = {
    create?: XOR<Enumerable<StudentCreateWithoutMajorInput>, Enumerable<StudentUncheckedCreateWithoutMajorInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutMajorInput>
    createMany?: StudentCreateManyMajorInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type InstansiCreateNestedManyWithoutMajorsInput = {
    create?: XOR<Enumerable<InstansiCreateWithoutMajorsInput>, Enumerable<InstansiUncheckedCreateWithoutMajorsInput>>
    connectOrCreate?: Enumerable<InstansiCreateOrConnectWithoutMajorsInput>
    connect?: Enumerable<InstansiWhereUniqueInput>
  }

  export type KonsentrasiKeahlianCreateinstansiIdsInput = {
    set: Enumerable<string>
  }

  export type StudentUncheckedCreateNestedManyWithoutMajorInput = {
    create?: XOR<Enumerable<StudentCreateWithoutMajorInput>, Enumerable<StudentUncheckedCreateWithoutMajorInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutMajorInput>
    createMany?: StudentCreateManyMajorInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type InstansiUncheckedCreateNestedManyWithoutMajorsInput = {
    create?: XOR<Enumerable<InstansiCreateWithoutMajorsInput>, Enumerable<InstansiUncheckedCreateWithoutMajorsInput>>
    connectOrCreate?: Enumerable<InstansiCreateOrConnectWithoutMajorsInput>
    connect?: Enumerable<InstansiWhereUniqueInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProgramKeahlianUpdateOneRequiredWithoutKonsentrasiNestedInput = {
    create?: XOR<ProgramKeahlianCreateWithoutKonsentrasiInput, ProgramKeahlianUncheckedCreateWithoutKonsentrasiInput>
    connectOrCreate?: ProgramKeahlianCreateOrConnectWithoutKonsentrasiInput
    upsert?: ProgramKeahlianUpsertWithoutKonsentrasiInput
    connect?: ProgramKeahlianWhereUniqueInput
    update?: XOR<ProgramKeahlianUpdateWithoutKonsentrasiInput, ProgramKeahlianUncheckedUpdateWithoutKonsentrasiInput>
  }

  export type StudentUpdateManyWithoutMajorNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutMajorInput>, Enumerable<StudentUncheckedCreateWithoutMajorInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutMajorInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutMajorInput>
    createMany?: StudentCreateManyMajorInputEnvelope
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutMajorInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutMajorInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type InstansiUpdateManyWithoutMajorsNestedInput = {
    create?: XOR<Enumerable<InstansiCreateWithoutMajorsInput>, Enumerable<InstansiUncheckedCreateWithoutMajorsInput>>
    connectOrCreate?: Enumerable<InstansiCreateOrConnectWithoutMajorsInput>
    upsert?: Enumerable<InstansiUpsertWithWhereUniqueWithoutMajorsInput>
    set?: Enumerable<InstansiWhereUniqueInput>
    disconnect?: Enumerable<InstansiWhereUniqueInput>
    delete?: Enumerable<InstansiWhereUniqueInput>
    connect?: Enumerable<InstansiWhereUniqueInput>
    update?: Enumerable<InstansiUpdateWithWhereUniqueWithoutMajorsInput>
    updateMany?: Enumerable<InstansiUpdateManyWithWhereWithoutMajorsInput>
    deleteMany?: Enumerable<InstansiScalarWhereInput>
  }

  export type KonsentrasiKeahlianUpdateinstansiIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type StudentUncheckedUpdateManyWithoutMajorNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutMajorInput>, Enumerable<StudentUncheckedCreateWithoutMajorInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutMajorInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutMajorInput>
    createMany?: StudentCreateManyMajorInputEnvelope
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutMajorInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutMajorInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type InstansiUncheckedUpdateManyWithoutMajorsNestedInput = {
    create?: XOR<Enumerable<InstansiCreateWithoutMajorsInput>, Enumerable<InstansiUncheckedCreateWithoutMajorsInput>>
    connectOrCreate?: Enumerable<InstansiCreateOrConnectWithoutMajorsInput>
    upsert?: Enumerable<InstansiUpsertWithWhereUniqueWithoutMajorsInput>
    set?: Enumerable<InstansiWhereUniqueInput>
    disconnect?: Enumerable<InstansiWhereUniqueInput>
    delete?: Enumerable<InstansiWhereUniqueInput>
    connect?: Enumerable<InstansiWhereUniqueInput>
    update?: Enumerable<InstansiUpdateWithWhereUniqueWithoutMajorsInput>
    updateMany?: Enumerable<InstansiUpdateManyWithWhereWithoutMajorsInput>
    deleteMany?: Enumerable<InstansiScalarWhereInput>
  }

  export type ElementCreateNestedOneWithoutAchievementInput = {
    create?: XOR<ElementCreateWithoutAchievementInput, ElementUncheckedCreateWithoutAchievementInput>
    connectOrCreate?: ElementCreateOrConnectWithoutAchievementInput
    connect?: ElementWhereUniqueInput
  }

  export type EnumFaseFieldUpdateOperationsInput = {
    set?: Fase
  }

  export type ElementUpdateOneRequiredWithoutAchievementNestedInput = {
    create?: XOR<ElementCreateWithoutAchievementInput, ElementUncheckedCreateWithoutAchievementInput>
    connectOrCreate?: ElementCreateOrConnectWithoutAchievementInput
    upsert?: ElementUpsertWithoutAchievementInput
    connect?: ElementWhereUniqueInput
    update?: XOR<ElementUpdateWithoutAchievementInput, ElementUncheckedUpdateWithoutAchievementInput>
  }

  export type AchievementCreateNestedManyWithoutElementInput = {
    create?: XOR<Enumerable<AchievementCreateWithoutElementInput>, Enumerable<AchievementUncheckedCreateWithoutElementInput>>
    connectOrCreate?: Enumerable<AchievementCreateOrConnectWithoutElementInput>
    createMany?: AchievementCreateManyElementInputEnvelope
    connect?: Enumerable<AchievementWhereUniqueInput>
  }

  export type MataPelajaranCreateNestedOneWithoutElementInput = {
    create?: XOR<MataPelajaranCreateWithoutElementInput, MataPelajaranUncheckedCreateWithoutElementInput>
    connectOrCreate?: MataPelajaranCreateOrConnectWithoutElementInput
    connect?: MataPelajaranWhereUniqueInput
  }

  export type AchievementUncheckedCreateNestedManyWithoutElementInput = {
    create?: XOR<Enumerable<AchievementCreateWithoutElementInput>, Enumerable<AchievementUncheckedCreateWithoutElementInput>>
    connectOrCreate?: Enumerable<AchievementCreateOrConnectWithoutElementInput>
    createMany?: AchievementCreateManyElementInputEnvelope
    connect?: Enumerable<AchievementWhereUniqueInput>
  }

  export type AchievementUpdateManyWithoutElementNestedInput = {
    create?: XOR<Enumerable<AchievementCreateWithoutElementInput>, Enumerable<AchievementUncheckedCreateWithoutElementInput>>
    connectOrCreate?: Enumerable<AchievementCreateOrConnectWithoutElementInput>
    upsert?: Enumerable<AchievementUpsertWithWhereUniqueWithoutElementInput>
    createMany?: AchievementCreateManyElementInputEnvelope
    set?: Enumerable<AchievementWhereUniqueInput>
    disconnect?: Enumerable<AchievementWhereUniqueInput>
    delete?: Enumerable<AchievementWhereUniqueInput>
    connect?: Enumerable<AchievementWhereUniqueInput>
    update?: Enumerable<AchievementUpdateWithWhereUniqueWithoutElementInput>
    updateMany?: Enumerable<AchievementUpdateManyWithWhereWithoutElementInput>
    deleteMany?: Enumerable<AchievementScalarWhereInput>
  }

  export type MataPelajaranUpdateOneRequiredWithoutElementNestedInput = {
    create?: XOR<MataPelajaranCreateWithoutElementInput, MataPelajaranUncheckedCreateWithoutElementInput>
    connectOrCreate?: MataPelajaranCreateOrConnectWithoutElementInput
    upsert?: MataPelajaranUpsertWithoutElementInput
    connect?: MataPelajaranWhereUniqueInput
    update?: XOR<MataPelajaranUpdateWithoutElementInput, MataPelajaranUncheckedUpdateWithoutElementInput>
  }

  export type AchievementUncheckedUpdateManyWithoutElementNestedInput = {
    create?: XOR<Enumerable<AchievementCreateWithoutElementInput>, Enumerable<AchievementUncheckedCreateWithoutElementInput>>
    connectOrCreate?: Enumerable<AchievementCreateOrConnectWithoutElementInput>
    upsert?: Enumerable<AchievementUpsertWithWhereUniqueWithoutElementInput>
    createMany?: AchievementCreateManyElementInputEnvelope
    set?: Enumerable<AchievementWhereUniqueInput>
    disconnect?: Enumerable<AchievementWhereUniqueInput>
    delete?: Enumerable<AchievementWhereUniqueInput>
    connect?: Enumerable<AchievementWhereUniqueInput>
    update?: Enumerable<AchievementUpdateWithWhereUniqueWithoutElementInput>
    updateMany?: Enumerable<AchievementUpdateManyWithWhereWithoutElementInput>
    deleteMany?: Enumerable<AchievementScalarWhereInput>
  }

  export type ElementCreateNestedManyWithoutMapelInput = {
    create?: XOR<Enumerable<ElementCreateWithoutMapelInput>, Enumerable<ElementUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<ElementCreateOrConnectWithoutMapelInput>
    createMany?: ElementCreateManyMapelInputEnvelope
    connect?: Enumerable<ElementWhereUniqueInput>
  }

  export type ElementUncheckedCreateNestedManyWithoutMapelInput = {
    create?: XOR<Enumerable<ElementCreateWithoutMapelInput>, Enumerable<ElementUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<ElementCreateOrConnectWithoutMapelInput>
    createMany?: ElementCreateManyMapelInputEnvelope
    connect?: Enumerable<ElementWhereUniqueInput>
  }

  export type NullableEnumReligionFieldUpdateOperationsInput = {
    set?: Religion | null
    unset?: boolean
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ElementUpdateManyWithoutMapelNestedInput = {
    create?: XOR<Enumerable<ElementCreateWithoutMapelInput>, Enumerable<ElementUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<ElementCreateOrConnectWithoutMapelInput>
    upsert?: Enumerable<ElementUpsertWithWhereUniqueWithoutMapelInput>
    createMany?: ElementCreateManyMapelInputEnvelope
    set?: Enumerable<ElementWhereUniqueInput>
    disconnect?: Enumerable<ElementWhereUniqueInput>
    delete?: Enumerable<ElementWhereUniqueInput>
    connect?: Enumerable<ElementWhereUniqueInput>
    update?: Enumerable<ElementUpdateWithWhereUniqueWithoutMapelInput>
    updateMany?: Enumerable<ElementUpdateManyWithWhereWithoutMapelInput>
    deleteMany?: Enumerable<ElementScalarWhereInput>
  }

  export type ElementUncheckedUpdateManyWithoutMapelNestedInput = {
    create?: XOR<Enumerable<ElementCreateWithoutMapelInput>, Enumerable<ElementUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<ElementCreateOrConnectWithoutMapelInput>
    upsert?: Enumerable<ElementUpsertWithWhereUniqueWithoutMapelInput>
    createMany?: ElementCreateManyMapelInputEnvelope
    set?: Enumerable<ElementWhereUniqueInput>
    disconnect?: Enumerable<ElementWhereUniqueInput>
    delete?: Enumerable<ElementWhereUniqueInput>
    connect?: Enumerable<ElementWhereUniqueInput>
    update?: Enumerable<ElementUpdateWithWhereUniqueWithoutMapelInput>
    updateMany?: Enumerable<ElementUpdateManyWithWhereWithoutMapelInput>
    deleteMany?: Enumerable<ElementScalarWhereInput>
  }

  export type AddressCreateEnvelopeInput = {
    set?: AddressCreateInput
  }

  export type AddressCreateInput = {
    provinsi: string
    kabupaten: string
    kecamatan: string
    kelurahan: string
    kodepos: string
    coordinate: CoordinateCreateInput
  }

  export type KonsentrasiKeahlianCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<KonsentrasiKeahlianCreateWithoutInstansiInput>, Enumerable<KonsentrasiKeahlianUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<KonsentrasiKeahlianCreateOrConnectWithoutInstansiInput>
    connect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
  }

  export type RoleCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<RoleCreateWithoutInstansiInput>, Enumerable<RoleUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutInstansiInput>
    createMany?: RoleCreateManyInstansiInputEnvelope
    connect?: Enumerable<RoleWhereUniqueInput>
  }

  export type SchoolYearCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<SchoolYearCreateWithoutInstansiInput>, Enumerable<SchoolYearUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<SchoolYearCreateOrConnectWithoutInstansiInput>
    createMany?: SchoolYearCreateManyInstansiInputEnvelope
    connect?: Enumerable<SchoolYearWhereUniqueInput>
  }

  export type TeacherCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<TeacherCreateWithoutInstansiInput>, Enumerable<TeacherUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<TeacherCreateOrConnectWithoutInstansiInput>
    createMany?: TeacherCreateManyInstansiInputEnvelope
    connect?: Enumerable<TeacherWhereUniqueInput>
  }

  export type StudentCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<StudentCreateWithoutInstansiInput>, Enumerable<StudentUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutInstansiInput>
    createMany?: StudentCreateManyInstansiInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type InstansiCreatemajorIdsInput = {
    set: Enumerable<string>
  }

  export type KonsentrasiKeahlianUncheckedCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<KonsentrasiKeahlianCreateWithoutInstansiInput>, Enumerable<KonsentrasiKeahlianUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<KonsentrasiKeahlianCreateOrConnectWithoutInstansiInput>
    connect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
  }

  export type RoleUncheckedCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<RoleCreateWithoutInstansiInput>, Enumerable<RoleUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutInstansiInput>
    createMany?: RoleCreateManyInstansiInputEnvelope
    connect?: Enumerable<RoleWhereUniqueInput>
  }

  export type SchoolYearUncheckedCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<SchoolYearCreateWithoutInstansiInput>, Enumerable<SchoolYearUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<SchoolYearCreateOrConnectWithoutInstansiInput>
    createMany?: SchoolYearCreateManyInstansiInputEnvelope
    connect?: Enumerable<SchoolYearWhereUniqueInput>
  }

  export type TeacherUncheckedCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<TeacherCreateWithoutInstansiInput>, Enumerable<TeacherUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<TeacherCreateOrConnectWithoutInstansiInput>
    createMany?: TeacherCreateManyInstansiInputEnvelope
    connect?: Enumerable<TeacherWhereUniqueInput>
  }

  export type StudentUncheckedCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<StudentCreateWithoutInstansiInput>, Enumerable<StudentUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutInstansiInput>
    createMany?: StudentCreateManyInstansiInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type AddressUpdateEnvelopeInput = {
    set?: AddressCreateInput
    update?: AddressUpdateInput
  }

  export type EnumLevelFieldUpdateOperationsInput = {
    set?: Level
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
    unset?: boolean
  }

  export type KonsentrasiKeahlianUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<KonsentrasiKeahlianCreateWithoutInstansiInput>, Enumerable<KonsentrasiKeahlianUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<KonsentrasiKeahlianCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<KonsentrasiKeahlianUpsertWithWhereUniqueWithoutInstansiInput>
    set?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    disconnect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    delete?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    connect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    update?: Enumerable<KonsentrasiKeahlianUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<KonsentrasiKeahlianUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<KonsentrasiKeahlianScalarWhereInput>
  }

  export type RoleUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<RoleCreateWithoutInstansiInput>, Enumerable<RoleUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<RoleUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: RoleCreateManyInstansiInputEnvelope
    set?: Enumerable<RoleWhereUniqueInput>
    disconnect?: Enumerable<RoleWhereUniqueInput>
    delete?: Enumerable<RoleWhereUniqueInput>
    connect?: Enumerable<RoleWhereUniqueInput>
    update?: Enumerable<RoleUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<RoleUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<RoleScalarWhereInput>
  }

  export type SchoolYearUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<SchoolYearCreateWithoutInstansiInput>, Enumerable<SchoolYearUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<SchoolYearCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<SchoolYearUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: SchoolYearCreateManyInstansiInputEnvelope
    set?: Enumerable<SchoolYearWhereUniqueInput>
    disconnect?: Enumerable<SchoolYearWhereUniqueInput>
    delete?: Enumerable<SchoolYearWhereUniqueInput>
    connect?: Enumerable<SchoolYearWhereUniqueInput>
    update?: Enumerable<SchoolYearUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<SchoolYearUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<SchoolYearScalarWhereInput>
  }

  export type TeacherUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<TeacherCreateWithoutInstansiInput>, Enumerable<TeacherUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<TeacherCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<TeacherUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: TeacherCreateManyInstansiInputEnvelope
    set?: Enumerable<TeacherWhereUniqueInput>
    disconnect?: Enumerable<TeacherWhereUniqueInput>
    delete?: Enumerable<TeacherWhereUniqueInput>
    connect?: Enumerable<TeacherWhereUniqueInput>
    update?: Enumerable<TeacherUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<TeacherUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<TeacherScalarWhereInput>
  }

  export type StudentUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutInstansiInput>, Enumerable<StudentUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: StudentCreateManyInstansiInputEnvelope
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type InstansiUpdatemajorIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type KonsentrasiKeahlianUncheckedUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<KonsentrasiKeahlianCreateWithoutInstansiInput>, Enumerable<KonsentrasiKeahlianUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<KonsentrasiKeahlianCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<KonsentrasiKeahlianUpsertWithWhereUniqueWithoutInstansiInput>
    set?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    disconnect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    delete?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    connect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    update?: Enumerable<KonsentrasiKeahlianUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<KonsentrasiKeahlianUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<KonsentrasiKeahlianScalarWhereInput>
  }

  export type RoleUncheckedUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<RoleCreateWithoutInstansiInput>, Enumerable<RoleUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<RoleUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: RoleCreateManyInstansiInputEnvelope
    set?: Enumerable<RoleWhereUniqueInput>
    disconnect?: Enumerable<RoleWhereUniqueInput>
    delete?: Enumerable<RoleWhereUniqueInput>
    connect?: Enumerable<RoleWhereUniqueInput>
    update?: Enumerable<RoleUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<RoleUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<RoleScalarWhereInput>
  }

  export type SchoolYearUncheckedUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<SchoolYearCreateWithoutInstansiInput>, Enumerable<SchoolYearUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<SchoolYearCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<SchoolYearUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: SchoolYearCreateManyInstansiInputEnvelope
    set?: Enumerable<SchoolYearWhereUniqueInput>
    disconnect?: Enumerable<SchoolYearWhereUniqueInput>
    delete?: Enumerable<SchoolYearWhereUniqueInput>
    connect?: Enumerable<SchoolYearWhereUniqueInput>
    update?: Enumerable<SchoolYearUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<SchoolYearUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<SchoolYearScalarWhereInput>
  }

  export type TeacherUncheckedUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<TeacherCreateWithoutInstansiInput>, Enumerable<TeacherUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<TeacherCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<TeacherUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: TeacherCreateManyInstansiInputEnvelope
    set?: Enumerable<TeacherWhereUniqueInput>
    disconnect?: Enumerable<TeacherWhereUniqueInput>
    delete?: Enumerable<TeacherWhereUniqueInput>
    connect?: Enumerable<TeacherWhereUniqueInput>
    update?: Enumerable<TeacherUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<TeacherUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<TeacherScalarWhereInput>
  }

  export type StudentUncheckedUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutInstansiInput>, Enumerable<StudentUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: StudentCreateManyInstansiInputEnvelope
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type InstansiCreateNestedOneWithoutRoleInput = {
    create?: XOR<InstansiCreateWithoutRoleInput, InstansiUncheckedCreateWithoutRoleInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutRoleInput
    connect?: InstansiWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<UserCreateWithoutRoleInput>, Enumerable<UserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<UserCreateWithoutRoleInput>, Enumerable<UserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type EnumRolesFieldUpdateOperationsInput = {
    set?: Roles
  }

  export type InstansiUpdateOneRequiredWithoutRoleNestedInput = {
    create?: XOR<InstansiCreateWithoutRoleInput, InstansiUncheckedCreateWithoutRoleInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutRoleInput
    upsert?: InstansiUpsertWithoutRoleInput
    connect?: InstansiWhereUniqueInput
    update?: XOR<InstansiUpdateWithoutRoleInput, InstansiUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutRoleInput>, Enumerable<UserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: UserCreateManyRoleInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutRoleInput>, Enumerable<UserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: UserCreateManyRoleInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type PersonalCreateNestedOneWithoutUserInput = {
    create?: XOR<PersonalCreateWithoutUserInput, PersonalUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutUserInput
    connect?: PersonalWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutUserInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    connect?: TeacherWhereUniqueInput
  }

  export type PersonalUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PersonalCreateWithoutUserInput, PersonalUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutUserInput
    connect?: PersonalWhereUniqueInput
  }

  export type StudentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type TeacherUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    connect?: TeacherWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type RoleUpdateOneWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: RoleWhereUniqueInput
    update?: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type PersonalUpdateOneWithoutUserNestedInput = {
    create?: XOR<PersonalCreateWithoutUserInput, PersonalUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutUserInput
    upsert?: PersonalUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: PersonalWhereUniqueInput
    update?: XOR<PersonalUpdateWithoutUserInput, PersonalUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
  }

  export type TeacherUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    upsert?: TeacherUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<TeacherUpdateWithoutUserInput, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type PersonalUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PersonalCreateWithoutUserInput, PersonalUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutUserInput
    upsert?: PersonalUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: PersonalWhereUniqueInput
    update?: XOR<PersonalUpdateWithoutUserInput, PersonalUncheckedUpdateWithoutUserInput>
  }

  export type StudentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
  }

  export type TeacherUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    upsert?: TeacherUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<TeacherUpdateWithoutUserInput, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type BornCreateEnvelopeInput = {
    set?: BornCreateInput
  }

  export type BornCreateInput = {
    place: string
    date: string
  }

  export type AddressNullableCreateEnvelopeInput = {
    set?: AddressCreateInput | null
  }

  export type UserCreateNestedOneWithoutPersonalInput = {
    create?: XOR<UserCreateWithoutPersonalInput, UserUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonalInput
    connect?: UserWhereUniqueInput
  }

  export type FamilyTreeCreateNestedManyWithoutFatherInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutFatherInput>, Enumerable<FamilyTreeUncheckedCreateWithoutFatherInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutFatherInput>
    createMany?: FamilyTreeCreateManyFatherInputEnvelope
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
  }

  export type FamilyTreeCreateNestedManyWithoutMotherInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutMotherInput>, Enumerable<FamilyTreeUncheckedCreateWithoutMotherInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutMotherInput>
    createMany?: FamilyTreeCreateManyMotherInputEnvelope
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
  }

  export type FamilyTreeCreateNestedManyWithoutWaliInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutWaliInput>, Enumerable<FamilyTreeUncheckedCreateWithoutWaliInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutWaliInput>
    createMany?: FamilyTreeCreateManyWaliInputEnvelope
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
  }

  export type FamilyTreeChildCreateNestedOneWithoutPersonalInput = {
    create?: XOR<FamilyTreeChildCreateWithoutPersonalInput, FamilyTreeChildUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: FamilyTreeChildCreateOrConnectWithoutPersonalInput
    connect?: FamilyTreeChildWhereUniqueInput
  }

  export type FamilyTreeUncheckedCreateNestedManyWithoutFatherInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutFatherInput>, Enumerable<FamilyTreeUncheckedCreateWithoutFatherInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutFatherInput>
    createMany?: FamilyTreeCreateManyFatherInputEnvelope
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
  }

  export type FamilyTreeUncheckedCreateNestedManyWithoutMotherInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutMotherInput>, Enumerable<FamilyTreeUncheckedCreateWithoutMotherInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutMotherInput>
    createMany?: FamilyTreeCreateManyMotherInputEnvelope
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
  }

  export type FamilyTreeUncheckedCreateNestedManyWithoutWaliInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutWaliInput>, Enumerable<FamilyTreeUncheckedCreateWithoutWaliInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutWaliInput>
    createMany?: FamilyTreeCreateManyWaliInputEnvelope
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
  }

  export type FamilyTreeChildUncheckedCreateNestedOneWithoutPersonalInput = {
    create?: XOR<FamilyTreeChildCreateWithoutPersonalInput, FamilyTreeChildUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: FamilyTreeChildCreateOrConnectWithoutPersonalInput
    connect?: FamilyTreeChildWhereUniqueInput
  }

  export type EnumTypePersonalFieldUpdateOperationsInput = {
    set?: TypePersonal
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: Gender
  }

  export type EnumReligionFieldUpdateOperationsInput = {
    set?: Religion
  }

  export type BornUpdateEnvelopeInput = {
    set?: BornCreateInput
    update?: BornUpdateInput
  }

  export type AddressNullableUpdateEnvelopeInput = {
    set?: AddressCreateInput | null
    upsert?: AddressUpsertInput
    unset?: boolean
  }

  export type UserUpdateOneWithoutPersonalNestedInput = {
    create?: XOR<UserCreateWithoutPersonalInput, UserUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonalInput
    upsert?: UserUpsertWithoutPersonalInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPersonalInput, UserUncheckedUpdateWithoutPersonalInput>
  }

  export type FamilyTreeUpdateManyWithoutFatherNestedInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutFatherInput>, Enumerable<FamilyTreeUncheckedCreateWithoutFatherInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutFatherInput>
    upsert?: Enumerable<FamilyTreeUpsertWithWhereUniqueWithoutFatherInput>
    createMany?: FamilyTreeCreateManyFatherInputEnvelope
    set?: Enumerable<FamilyTreeWhereUniqueInput>
    disconnect?: Enumerable<FamilyTreeWhereUniqueInput>
    delete?: Enumerable<FamilyTreeWhereUniqueInput>
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
    update?: Enumerable<FamilyTreeUpdateWithWhereUniqueWithoutFatherInput>
    updateMany?: Enumerable<FamilyTreeUpdateManyWithWhereWithoutFatherInput>
    deleteMany?: Enumerable<FamilyTreeScalarWhereInput>
  }

  export type FamilyTreeUpdateManyWithoutMotherNestedInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutMotherInput>, Enumerable<FamilyTreeUncheckedCreateWithoutMotherInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutMotherInput>
    upsert?: Enumerable<FamilyTreeUpsertWithWhereUniqueWithoutMotherInput>
    createMany?: FamilyTreeCreateManyMotherInputEnvelope
    set?: Enumerable<FamilyTreeWhereUniqueInput>
    disconnect?: Enumerable<FamilyTreeWhereUniqueInput>
    delete?: Enumerable<FamilyTreeWhereUniqueInput>
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
    update?: Enumerable<FamilyTreeUpdateWithWhereUniqueWithoutMotherInput>
    updateMany?: Enumerable<FamilyTreeUpdateManyWithWhereWithoutMotherInput>
    deleteMany?: Enumerable<FamilyTreeScalarWhereInput>
  }

  export type FamilyTreeUpdateManyWithoutWaliNestedInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutWaliInput>, Enumerable<FamilyTreeUncheckedCreateWithoutWaliInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutWaliInput>
    upsert?: Enumerable<FamilyTreeUpsertWithWhereUniqueWithoutWaliInput>
    createMany?: FamilyTreeCreateManyWaliInputEnvelope
    set?: Enumerable<FamilyTreeWhereUniqueInput>
    disconnect?: Enumerable<FamilyTreeWhereUniqueInput>
    delete?: Enumerable<FamilyTreeWhereUniqueInput>
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
    update?: Enumerable<FamilyTreeUpdateWithWhereUniqueWithoutWaliInput>
    updateMany?: Enumerable<FamilyTreeUpdateManyWithWhereWithoutWaliInput>
    deleteMany?: Enumerable<FamilyTreeScalarWhereInput>
  }

  export type FamilyTreeChildUpdateOneWithoutPersonalNestedInput = {
    create?: XOR<FamilyTreeChildCreateWithoutPersonalInput, FamilyTreeChildUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: FamilyTreeChildCreateOrConnectWithoutPersonalInput
    upsert?: FamilyTreeChildUpsertWithoutPersonalInput
    disconnect?: boolean
    delete?: boolean
    connect?: FamilyTreeChildWhereUniqueInput
    update?: XOR<FamilyTreeChildUpdateWithoutPersonalInput, FamilyTreeChildUncheckedUpdateWithoutPersonalInput>
  }

  export type FamilyTreeUncheckedUpdateManyWithoutFatherNestedInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutFatherInput>, Enumerable<FamilyTreeUncheckedCreateWithoutFatherInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutFatherInput>
    upsert?: Enumerable<FamilyTreeUpsertWithWhereUniqueWithoutFatherInput>
    createMany?: FamilyTreeCreateManyFatherInputEnvelope
    set?: Enumerable<FamilyTreeWhereUniqueInput>
    disconnect?: Enumerable<FamilyTreeWhereUniqueInput>
    delete?: Enumerable<FamilyTreeWhereUniqueInput>
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
    update?: Enumerable<FamilyTreeUpdateWithWhereUniqueWithoutFatherInput>
    updateMany?: Enumerable<FamilyTreeUpdateManyWithWhereWithoutFatherInput>
    deleteMany?: Enumerable<FamilyTreeScalarWhereInput>
  }

  export type FamilyTreeUncheckedUpdateManyWithoutMotherNestedInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutMotherInput>, Enumerable<FamilyTreeUncheckedCreateWithoutMotherInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutMotherInput>
    upsert?: Enumerable<FamilyTreeUpsertWithWhereUniqueWithoutMotherInput>
    createMany?: FamilyTreeCreateManyMotherInputEnvelope
    set?: Enumerable<FamilyTreeWhereUniqueInput>
    disconnect?: Enumerable<FamilyTreeWhereUniqueInput>
    delete?: Enumerable<FamilyTreeWhereUniqueInput>
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
    update?: Enumerable<FamilyTreeUpdateWithWhereUniqueWithoutMotherInput>
    updateMany?: Enumerable<FamilyTreeUpdateManyWithWhereWithoutMotherInput>
    deleteMany?: Enumerable<FamilyTreeScalarWhereInput>
  }

  export type FamilyTreeUncheckedUpdateManyWithoutWaliNestedInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutWaliInput>, Enumerable<FamilyTreeUncheckedCreateWithoutWaliInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutWaliInput>
    upsert?: Enumerable<FamilyTreeUpsertWithWhereUniqueWithoutWaliInput>
    createMany?: FamilyTreeCreateManyWaliInputEnvelope
    set?: Enumerable<FamilyTreeWhereUniqueInput>
    disconnect?: Enumerable<FamilyTreeWhereUniqueInput>
    delete?: Enumerable<FamilyTreeWhereUniqueInput>
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
    update?: Enumerable<FamilyTreeUpdateWithWhereUniqueWithoutWaliInput>
    updateMany?: Enumerable<FamilyTreeUpdateManyWithWhereWithoutWaliInput>
    deleteMany?: Enumerable<FamilyTreeScalarWhereInput>
  }

  export type FamilyTreeChildUncheckedUpdateOneWithoutPersonalNestedInput = {
    create?: XOR<FamilyTreeChildCreateWithoutPersonalInput, FamilyTreeChildUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: FamilyTreeChildCreateOrConnectWithoutPersonalInput
    upsert?: FamilyTreeChildUpsertWithoutPersonalInput
    disconnect?: boolean
    delete?: boolean
    connect?: FamilyTreeChildWhereUniqueInput
    update?: XOR<FamilyTreeChildUpdateWithoutPersonalInput, FamilyTreeChildUncheckedUpdateWithoutPersonalInput>
  }

  export type PersonalCreateNestedOneWithoutFatherInput = {
    create?: XOR<PersonalCreateWithoutFatherInput, PersonalUncheckedCreateWithoutFatherInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutFatherInput
    connect?: PersonalWhereUniqueInput
  }

  export type PersonalCreateNestedOneWithoutMotherInput = {
    create?: XOR<PersonalCreateWithoutMotherInput, PersonalUncheckedCreateWithoutMotherInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutMotherInput
    connect?: PersonalWhereUniqueInput
  }

  export type PersonalCreateNestedOneWithoutWaliInput = {
    create?: XOR<PersonalCreateWithoutWaliInput, PersonalUncheckedCreateWithoutWaliInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutWaliInput
    connect?: PersonalWhereUniqueInput
  }

  export type FamilyTreeChildCreateNestedManyWithoutKkInput = {
    create?: XOR<Enumerable<FamilyTreeChildCreateWithoutKkInput>, Enumerable<FamilyTreeChildUncheckedCreateWithoutKkInput>>
    connectOrCreate?: Enumerable<FamilyTreeChildCreateOrConnectWithoutKkInput>
    createMany?: FamilyTreeChildCreateManyKkInputEnvelope
    connect?: Enumerable<FamilyTreeChildWhereUniqueInput>
  }

  export type FamilyTreeChildUncheckedCreateNestedManyWithoutKkInput = {
    create?: XOR<Enumerable<FamilyTreeChildCreateWithoutKkInput>, Enumerable<FamilyTreeChildUncheckedCreateWithoutKkInput>>
    connectOrCreate?: Enumerable<FamilyTreeChildCreateOrConnectWithoutKkInput>
    createMany?: FamilyTreeChildCreateManyKkInputEnvelope
    connect?: Enumerable<FamilyTreeChildWhereUniqueInput>
  }

  export type PersonalUpdateOneWithoutFatherNestedInput = {
    create?: XOR<PersonalCreateWithoutFatherInput, PersonalUncheckedCreateWithoutFatherInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutFatherInput
    upsert?: PersonalUpsertWithoutFatherInput
    disconnect?: boolean
    delete?: boolean
    connect?: PersonalWhereUniqueInput
    update?: XOR<PersonalUpdateWithoutFatherInput, PersonalUncheckedUpdateWithoutFatherInput>
  }

  export type PersonalUpdateOneWithoutMotherNestedInput = {
    create?: XOR<PersonalCreateWithoutMotherInput, PersonalUncheckedCreateWithoutMotherInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutMotherInput
    upsert?: PersonalUpsertWithoutMotherInput
    disconnect?: boolean
    delete?: boolean
    connect?: PersonalWhereUniqueInput
    update?: XOR<PersonalUpdateWithoutMotherInput, PersonalUncheckedUpdateWithoutMotherInput>
  }

  export type PersonalUpdateOneWithoutWaliNestedInput = {
    create?: XOR<PersonalCreateWithoutWaliInput, PersonalUncheckedCreateWithoutWaliInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutWaliInput
    upsert?: PersonalUpsertWithoutWaliInput
    disconnect?: boolean
    delete?: boolean
    connect?: PersonalWhereUniqueInput
    update?: XOR<PersonalUpdateWithoutWaliInput, PersonalUncheckedUpdateWithoutWaliInput>
  }

  export type FamilyTreeChildUpdateManyWithoutKkNestedInput = {
    create?: XOR<Enumerable<FamilyTreeChildCreateWithoutKkInput>, Enumerable<FamilyTreeChildUncheckedCreateWithoutKkInput>>
    connectOrCreate?: Enumerable<FamilyTreeChildCreateOrConnectWithoutKkInput>
    upsert?: Enumerable<FamilyTreeChildUpsertWithWhereUniqueWithoutKkInput>
    createMany?: FamilyTreeChildCreateManyKkInputEnvelope
    set?: Enumerable<FamilyTreeChildWhereUniqueInput>
    disconnect?: Enumerable<FamilyTreeChildWhereUniqueInput>
    delete?: Enumerable<FamilyTreeChildWhereUniqueInput>
    connect?: Enumerable<FamilyTreeChildWhereUniqueInput>
    update?: Enumerable<FamilyTreeChildUpdateWithWhereUniqueWithoutKkInput>
    updateMany?: Enumerable<FamilyTreeChildUpdateManyWithWhereWithoutKkInput>
    deleteMany?: Enumerable<FamilyTreeChildScalarWhereInput>
  }

  export type FamilyTreeChildUncheckedUpdateManyWithoutKkNestedInput = {
    create?: XOR<Enumerable<FamilyTreeChildCreateWithoutKkInput>, Enumerable<FamilyTreeChildUncheckedCreateWithoutKkInput>>
    connectOrCreate?: Enumerable<FamilyTreeChildCreateOrConnectWithoutKkInput>
    upsert?: Enumerable<FamilyTreeChildUpsertWithWhereUniqueWithoutKkInput>
    createMany?: FamilyTreeChildCreateManyKkInputEnvelope
    set?: Enumerable<FamilyTreeChildWhereUniqueInput>
    disconnect?: Enumerable<FamilyTreeChildWhereUniqueInput>
    delete?: Enumerable<FamilyTreeChildWhereUniqueInput>
    connect?: Enumerable<FamilyTreeChildWhereUniqueInput>
    update?: Enumerable<FamilyTreeChildUpdateWithWhereUniqueWithoutKkInput>
    updateMany?: Enumerable<FamilyTreeChildUpdateManyWithWhereWithoutKkInput>
    deleteMany?: Enumerable<FamilyTreeChildScalarWhereInput>
  }

  export type FamilyTreeCreateNestedOneWithoutChildsInput = {
    create?: XOR<FamilyTreeCreateWithoutChildsInput, FamilyTreeUncheckedCreateWithoutChildsInput>
    connectOrCreate?: FamilyTreeCreateOrConnectWithoutChildsInput
    connect?: FamilyTreeWhereUniqueInput
  }

  export type PersonalCreateNestedOneWithoutChildInput = {
    create?: XOR<PersonalCreateWithoutChildInput, PersonalUncheckedCreateWithoutChildInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutChildInput
    connect?: PersonalWhereUniqueInput
  }

  export type EnumChildTypeFieldUpdateOperationsInput = {
    set?: ChildType
  }

  export type FamilyTreeUpdateOneRequiredWithoutChildsNestedInput = {
    create?: XOR<FamilyTreeCreateWithoutChildsInput, FamilyTreeUncheckedCreateWithoutChildsInput>
    connectOrCreate?: FamilyTreeCreateOrConnectWithoutChildsInput
    upsert?: FamilyTreeUpsertWithoutChildsInput
    connect?: FamilyTreeWhereUniqueInput
    update?: XOR<FamilyTreeUpdateWithoutChildsInput, FamilyTreeUncheckedUpdateWithoutChildsInput>
  }

  export type PersonalUpdateOneRequiredWithoutChildNestedInput = {
    create?: XOR<PersonalCreateWithoutChildInput, PersonalUncheckedCreateWithoutChildInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutChildInput
    upsert?: PersonalUpsertWithoutChildInput
    connect?: PersonalWhereUniqueInput
    update?: XOR<PersonalUpdateWithoutChildInput, PersonalUncheckedUpdateWithoutChildInput>
  }

  export type UserCreateNestedOneWithoutStudentInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    connect?: UserWhereUniqueInput
  }

  export type KonsentrasiKeahlianCreateNestedOneWithoutStudentInput = {
    create?: XOR<KonsentrasiKeahlianCreateWithoutStudentInput, KonsentrasiKeahlianUncheckedCreateWithoutStudentInput>
    connectOrCreate?: KonsentrasiKeahlianCreateOrConnectWithoutStudentInput
    connect?: KonsentrasiKeahlianWhereUniqueInput
  }

  export type ClassRoomCreateNestedManyWithoutStudentsInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutStudentsInput>, Enumerable<ClassRoomUncheckedCreateWithoutStudentsInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutStudentsInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
  }

  export type SchoolYearCreateNestedOneWithoutStudentsInInput = {
    create?: XOR<SchoolYearCreateWithoutStudentsInInput, SchoolYearUncheckedCreateWithoutStudentsInInput>
    connectOrCreate?: SchoolYearCreateOrConnectWithoutStudentsInInput
    connect?: SchoolYearWhereUniqueInput
  }

  export type InstansiCreateNestedOneWithoutStudentInput = {
    create?: XOR<InstansiCreateWithoutStudentInput, InstansiUncheckedCreateWithoutStudentInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutStudentInput
    connect?: InstansiWhereUniqueInput
  }

  export type CalendarCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutStudentInput>, Enumerable<CalendarUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutStudentInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
  }

  export type StudentCreateclassRoomIdsInput = {
    set: Enumerable<string>
  }

  export type StudentCreateeventIdsInput = {
    set: Enumerable<string>
  }

  export type ClassRoomUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutStudentsInput>, Enumerable<ClassRoomUncheckedCreateWithoutStudentsInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutStudentsInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
  }

  export type CalendarUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutStudentInput>, Enumerable<CalendarUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutStudentInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
  }

  export type UserUpdateOneWithoutStudentNestedInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    upsert?: UserUpsertWithoutStudentInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
  }

  export type KonsentrasiKeahlianUpdateOneWithoutStudentNestedInput = {
    create?: XOR<KonsentrasiKeahlianCreateWithoutStudentInput, KonsentrasiKeahlianUncheckedCreateWithoutStudentInput>
    connectOrCreate?: KonsentrasiKeahlianCreateOrConnectWithoutStudentInput
    upsert?: KonsentrasiKeahlianUpsertWithoutStudentInput
    disconnect?: boolean
    delete?: boolean
    connect?: KonsentrasiKeahlianWhereUniqueInput
    update?: XOR<KonsentrasiKeahlianUpdateWithoutStudentInput, KonsentrasiKeahlianUncheckedUpdateWithoutStudentInput>
  }

  export type ClassRoomUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutStudentsInput>, Enumerable<ClassRoomUncheckedCreateWithoutStudentsInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutStudentsInput>
    upsert?: Enumerable<ClassRoomUpsertWithWhereUniqueWithoutStudentsInput>
    set?: Enumerable<ClassRoomWhereUniqueInput>
    disconnect?: Enumerable<ClassRoomWhereUniqueInput>
    delete?: Enumerable<ClassRoomWhereUniqueInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
    update?: Enumerable<ClassRoomUpdateWithWhereUniqueWithoutStudentsInput>
    updateMany?: Enumerable<ClassRoomUpdateManyWithWhereWithoutStudentsInput>
    deleteMany?: Enumerable<ClassRoomScalarWhereInput>
  }

  export type SchoolYearUpdateOneRequiredWithoutStudentsInNestedInput = {
    create?: XOR<SchoolYearCreateWithoutStudentsInInput, SchoolYearUncheckedCreateWithoutStudentsInInput>
    connectOrCreate?: SchoolYearCreateOrConnectWithoutStudentsInInput
    upsert?: SchoolYearUpsertWithoutStudentsInInput
    connect?: SchoolYearWhereUniqueInput
    update?: XOR<SchoolYearUpdateWithoutStudentsInInput, SchoolYearUncheckedUpdateWithoutStudentsInInput>
  }

  export type InstansiUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<InstansiCreateWithoutStudentInput, InstansiUncheckedCreateWithoutStudentInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutStudentInput
    upsert?: InstansiUpsertWithoutStudentInput
    connect?: InstansiWhereUniqueInput
    update?: XOR<InstansiUpdateWithoutStudentInput, InstansiUncheckedUpdateWithoutStudentInput>
  }

  export type CalendarUpdateManyWithoutStudentNestedInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutStudentInput>, Enumerable<CalendarUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<CalendarUpsertWithWhereUniqueWithoutStudentInput>
    set?: Enumerable<CalendarWhereUniqueInput>
    disconnect?: Enumerable<CalendarWhereUniqueInput>
    delete?: Enumerable<CalendarWhereUniqueInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
    update?: Enumerable<CalendarUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<CalendarUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<CalendarScalarWhereInput>
  }

  export type StudentUpdateclassRoomIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type StudentUpdateeventIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ClassRoomUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutStudentsInput>, Enumerable<ClassRoomUncheckedCreateWithoutStudentsInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutStudentsInput>
    upsert?: Enumerable<ClassRoomUpsertWithWhereUniqueWithoutStudentsInput>
    set?: Enumerable<ClassRoomWhereUniqueInput>
    disconnect?: Enumerable<ClassRoomWhereUniqueInput>
    delete?: Enumerable<ClassRoomWhereUniqueInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
    update?: Enumerable<ClassRoomUpdateWithWhereUniqueWithoutStudentsInput>
    updateMany?: Enumerable<ClassRoomUpdateManyWithWhereWithoutStudentsInput>
    deleteMany?: Enumerable<ClassRoomScalarWhereInput>
  }

  export type CalendarUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutStudentInput>, Enumerable<CalendarUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<CalendarUpsertWithWhereUniqueWithoutStudentInput>
    set?: Enumerable<CalendarWhereUniqueInput>
    disconnect?: Enumerable<CalendarWhereUniqueInput>
    delete?: Enumerable<CalendarWhereUniqueInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
    update?: Enumerable<CalendarUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<CalendarUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<CalendarScalarWhereInput>
  }

  export type EducationListCreateEnvelopeInput = {
    set?: Enumerable<EducationCreateInput>
  }

  export type EducationCreateInput = {
    instansi: string
    level: LevelEdu
    major?: string | null
    year: number
    attachment?: string | null
  }

  export type TrainingListCreateEnvelopeInput = {
    set?: Enumerable<TrainingCreateInput>
  }

  export type TrainingCreateInput = {
    name: string
    instansi: string
    long: number
    year: number
    place: string
    attachment?: string | null
  }

  export type EmploymentListCreateEnvelopeInput = {
    set?: Enumerable<EmploymentCreateInput>
  }

  export type EmploymentCreateInput = {
    position: string
    year: number
    place: string
    note?: string | null
  }

  export type ProfessionListCreateEnvelopeInput = {
    set?: Enumerable<ProfessionCreateInput>
  }

  export type ProfessionCreateInput = {
    name: string
    instansi: string
    year: number
    attachment?: string | null
  }

  export type OverseasListCreateEnvelopeInput = {
    set?: Enumerable<OverseasCreateInput>
  }

  export type OverseasCreateInput = {
    country: string
    instansi: string
    objective: string
    long: number
    year: number
    attachment?: string | null
  }

  export type ScientificListCreateEnvelopeInput = {
    set?: Enumerable<ScientificCreateInput>
  }

  export type ScientificCreateInput = {
    name: string
    instansi: string
    position: string
    place: string
    period: string
    attachment?: string | null
  }

  export type OrganizationListCreateEnvelopeInput = {
    set?: Enumerable<OrganizationCreateInput>
  }

  export type OrganizationCreateInput = {
    name: string
    position: string
    period: string
    leader: string
    place: string
  }

  export type PapersListCreateEnvelopeInput = {
    set?: Enumerable<PapersCreateInput>
  }

  export type PapersCreateInput = {
    name: string
    year: number
    published: string
  }

  export type InnovationListCreateEnvelopeInput = {
    set?: Enumerable<InnovationCreateInput>
  }

  export type InnovationCreateInput = {
    name: string
    year: number
    patent: boolean
  }

  export type AwardListCreateEnvelopeInput = {
    set?: Enumerable<AwardCreateInput>
  }

  export type AwardCreateInput = {
    name: string
    year: number
    instansi: string
    attachment?: string | null
  }

  export type SourcePersonListCreateEnvelopeInput = {
    set?: Enumerable<SourcePersonCreateInput>
  }

  export type SourcePersonCreateInput = {
    name: string
    date: string
    instansi: string
    note?: string | null
    attachment?: string | null
  }

  export type ContestListCreateEnvelopeInput = {
    set?: Enumerable<ContestCreateInput>
  }

  export type ContestCreateInput = {
    name: string
    date: string
    instansi: string
    level: string
    attachment?: string | null
  }

  export type DocumentsListCreateEnvelopeInput = {
    set?: Enumerable<DocumentsCreateInput>
  }

  export type DocumentsCreateInput = {
    name: string
    date: string
    instansi: string
    note?: string | null
    attachment?: string | null
  }

  export type AdditionalListCreateEnvelopeInput = {
    set?: Enumerable<AdditionalCreateInput>
  }

  export type AdditionalCreateInput = {
    position: string
    date: string
    instansi: string
    note?: string | null
    attachment?: string | null
  }

  export type UserCreateNestedOneWithoutTeacherInput = {
    create?: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherInput
    connect?: UserWhereUniqueInput
  }

  export type ClassRoomCreateNestedManyWithoutWaliInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutWaliInput>, Enumerable<ClassRoomUncheckedCreateWithoutWaliInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutWaliInput>
    createMany?: ClassRoomCreateManyWaliInputEnvelope
    connect?: Enumerable<ClassRoomWhereUniqueInput>
  }

  export type InstansiCreateNestedOneWithoutTeacherInput = {
    create?: XOR<InstansiCreateWithoutTeacherInput, InstansiUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutTeacherInput
    connect?: InstansiWhereUniqueInput
  }

  export type CalendarCreateNestedManyWithoutTeacherInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutTeacherInput>, Enumerable<CalendarUncheckedCreateWithoutTeacherInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutTeacherInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
  }

  export type TeacherCreateeventIdsInput = {
    set: Enumerable<string>
  }

  export type ClassRoomUncheckedCreateNestedManyWithoutWaliInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutWaliInput>, Enumerable<ClassRoomUncheckedCreateWithoutWaliInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutWaliInput>
    createMany?: ClassRoomCreateManyWaliInputEnvelope
    connect?: Enumerable<ClassRoomWhereUniqueInput>
  }

  export type CalendarUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutTeacherInput>, Enumerable<CalendarUncheckedCreateWithoutTeacherInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutTeacherInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
  }

  export type EducationListUpdateEnvelopeInput = {
    set?: Enumerable<EducationCreateInput>
    push?: Enumerable<EducationCreateInput>
    updateMany?: EducationUpdateManyInput
    deleteMany?: EducationDeleteManyInput
  }

  export type TrainingListUpdateEnvelopeInput = {
    set?: Enumerable<TrainingCreateInput>
    push?: Enumerable<TrainingCreateInput>
    updateMany?: TrainingUpdateManyInput
    deleteMany?: TrainingDeleteManyInput
  }

  export type EmploymentListUpdateEnvelopeInput = {
    set?: Enumerable<EmploymentCreateInput>
    push?: Enumerable<EmploymentCreateInput>
    updateMany?: EmploymentUpdateManyInput
    deleteMany?: EmploymentDeleteManyInput
  }

  export type ProfessionListUpdateEnvelopeInput = {
    set?: Enumerable<ProfessionCreateInput>
    push?: Enumerable<ProfessionCreateInput>
    updateMany?: ProfessionUpdateManyInput
    deleteMany?: ProfessionDeleteManyInput
  }

  export type OverseasListUpdateEnvelopeInput = {
    set?: Enumerable<OverseasCreateInput>
    push?: Enumerable<OverseasCreateInput>
    updateMany?: OverseasUpdateManyInput
    deleteMany?: OverseasDeleteManyInput
  }

  export type ScientificListUpdateEnvelopeInput = {
    set?: Enumerable<ScientificCreateInput>
    push?: Enumerable<ScientificCreateInput>
    updateMany?: ScientificUpdateManyInput
    deleteMany?: ScientificDeleteManyInput
  }

  export type OrganizationListUpdateEnvelopeInput = {
    set?: Enumerable<OrganizationCreateInput>
    push?: Enumerable<OrganizationCreateInput>
    updateMany?: OrganizationUpdateManyInput
    deleteMany?: OrganizationDeleteManyInput
  }

  export type PapersListUpdateEnvelopeInput = {
    set?: Enumerable<PapersCreateInput>
    push?: Enumerable<PapersCreateInput>
    updateMany?: PapersUpdateManyInput
    deleteMany?: PapersDeleteManyInput
  }

  export type InnovationListUpdateEnvelopeInput = {
    set?: Enumerable<InnovationCreateInput>
    push?: Enumerable<InnovationCreateInput>
    updateMany?: InnovationUpdateManyInput
    deleteMany?: InnovationDeleteManyInput
  }

  export type AwardListUpdateEnvelopeInput = {
    set?: Enumerable<AwardCreateInput>
    push?: Enumerable<AwardCreateInput>
    updateMany?: AwardUpdateManyInput
    deleteMany?: AwardDeleteManyInput
  }

  export type SourcePersonListUpdateEnvelopeInput = {
    set?: Enumerable<SourcePersonCreateInput>
    push?: Enumerable<SourcePersonCreateInput>
    updateMany?: SourcePersonUpdateManyInput
    deleteMany?: SourcePersonDeleteManyInput
  }

  export type ContestListUpdateEnvelopeInput = {
    set?: Enumerable<ContestCreateInput>
    push?: Enumerable<ContestCreateInput>
    updateMany?: ContestUpdateManyInput
    deleteMany?: ContestDeleteManyInput
  }

  export type DocumentsListUpdateEnvelopeInput = {
    set?: Enumerable<DocumentsCreateInput>
    push?: Enumerable<DocumentsCreateInput>
    updateMany?: DocumentsUpdateManyInput
    deleteMany?: DocumentsDeleteManyInput
  }

  export type AdditionalListUpdateEnvelopeInput = {
    set?: Enumerable<AdditionalCreateInput>
    push?: Enumerable<AdditionalCreateInput>
    updateMany?: AdditionalUpdateManyInput
    deleteMany?: AdditionalDeleteManyInput
  }

  export type UserUpdateOneWithoutTeacherNestedInput = {
    create?: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherInput
    upsert?: UserUpsertWithoutTeacherInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTeacherInput, UserUncheckedUpdateWithoutTeacherInput>
  }

  export type ClassRoomUpdateManyWithoutWaliNestedInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutWaliInput>, Enumerable<ClassRoomUncheckedCreateWithoutWaliInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutWaliInput>
    upsert?: Enumerable<ClassRoomUpsertWithWhereUniqueWithoutWaliInput>
    createMany?: ClassRoomCreateManyWaliInputEnvelope
    set?: Enumerable<ClassRoomWhereUniqueInput>
    disconnect?: Enumerable<ClassRoomWhereUniqueInput>
    delete?: Enumerable<ClassRoomWhereUniqueInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
    update?: Enumerable<ClassRoomUpdateWithWhereUniqueWithoutWaliInput>
    updateMany?: Enumerable<ClassRoomUpdateManyWithWhereWithoutWaliInput>
    deleteMany?: Enumerable<ClassRoomScalarWhereInput>
  }

  export type InstansiUpdateOneRequiredWithoutTeacherNestedInput = {
    create?: XOR<InstansiCreateWithoutTeacherInput, InstansiUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutTeacherInput
    upsert?: InstansiUpsertWithoutTeacherInput
    connect?: InstansiWhereUniqueInput
    update?: XOR<InstansiUpdateWithoutTeacherInput, InstansiUncheckedUpdateWithoutTeacherInput>
  }

  export type CalendarUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutTeacherInput>, Enumerable<CalendarUncheckedCreateWithoutTeacherInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutTeacherInput>
    upsert?: Enumerable<CalendarUpsertWithWhereUniqueWithoutTeacherInput>
    set?: Enumerable<CalendarWhereUniqueInput>
    disconnect?: Enumerable<CalendarWhereUniqueInput>
    delete?: Enumerable<CalendarWhereUniqueInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
    update?: Enumerable<CalendarUpdateWithWhereUniqueWithoutTeacherInput>
    updateMany?: Enumerable<CalendarUpdateManyWithWhereWithoutTeacherInput>
    deleteMany?: Enumerable<CalendarScalarWhereInput>
  }

  export type TeacherUpdateeventIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ClassRoomUncheckedUpdateManyWithoutWaliNestedInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutWaliInput>, Enumerable<ClassRoomUncheckedCreateWithoutWaliInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutWaliInput>
    upsert?: Enumerable<ClassRoomUpsertWithWhereUniqueWithoutWaliInput>
    createMany?: ClassRoomCreateManyWaliInputEnvelope
    set?: Enumerable<ClassRoomWhereUniqueInput>
    disconnect?: Enumerable<ClassRoomWhereUniqueInput>
    delete?: Enumerable<ClassRoomWhereUniqueInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
    update?: Enumerable<ClassRoomUpdateWithWhereUniqueWithoutWaliInput>
    updateMany?: Enumerable<ClassRoomUpdateManyWithWhereWithoutWaliInput>
    deleteMany?: Enumerable<ClassRoomScalarWhereInput>
  }

  export type CalendarUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutTeacherInput>, Enumerable<CalendarUncheckedCreateWithoutTeacherInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutTeacherInput>
    upsert?: Enumerable<CalendarUpsertWithWhereUniqueWithoutTeacherInput>
    set?: Enumerable<CalendarWhereUniqueInput>
    disconnect?: Enumerable<CalendarWhereUniqueInput>
    delete?: Enumerable<CalendarWhereUniqueInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
    update?: Enumerable<CalendarUpdateWithWhereUniqueWithoutTeacherInput>
    updateMany?: Enumerable<CalendarUpdateManyWithWhereWithoutTeacherInput>
    deleteMany?: Enumerable<CalendarScalarWhereInput>
  }

  export type SchoolYearCreateNestedOneWithoutClassRoomInput = {
    create?: XOR<SchoolYearCreateWithoutClassRoomInput, SchoolYearUncheckedCreateWithoutClassRoomInput>
    connectOrCreate?: SchoolYearCreateOrConnectWithoutClassRoomInput
    connect?: SchoolYearWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutClassRoomInput = {
    create?: XOR<TeacherCreateWithoutClassRoomInput, TeacherUncheckedCreateWithoutClassRoomInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutClassRoomInput
    connect?: TeacherWhereUniqueInput
  }

  export type StudentCreateNestedManyWithoutClassRoomInput = {
    create?: XOR<Enumerable<StudentCreateWithoutClassRoomInput>, Enumerable<StudentUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutClassRoomInput>
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type CalendarCreateNestedManyWithoutClassRoomInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutClassRoomInput>, Enumerable<CalendarUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutClassRoomInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
  }

  export type ClassRoomCreatestudentIdsInput = {
    set: Enumerable<string>
  }

  export type ClassRoomCreateeventIdsInput = {
    set: Enumerable<string>
  }

  export type StudentUncheckedCreateNestedManyWithoutClassRoomInput = {
    create?: XOR<Enumerable<StudentCreateWithoutClassRoomInput>, Enumerable<StudentUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutClassRoomInput>
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type CalendarUncheckedCreateNestedManyWithoutClassRoomInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutClassRoomInput>, Enumerable<CalendarUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutClassRoomInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
  }

  export type SchoolYearUpdateOneRequiredWithoutClassRoomNestedInput = {
    create?: XOR<SchoolYearCreateWithoutClassRoomInput, SchoolYearUncheckedCreateWithoutClassRoomInput>
    connectOrCreate?: SchoolYearCreateOrConnectWithoutClassRoomInput
    upsert?: SchoolYearUpsertWithoutClassRoomInput
    connect?: SchoolYearWhereUniqueInput
    update?: XOR<SchoolYearUpdateWithoutClassRoomInput, SchoolYearUncheckedUpdateWithoutClassRoomInput>
  }

  export type TeacherUpdateOneRequiredWithoutClassRoomNestedInput = {
    create?: XOR<TeacherCreateWithoutClassRoomInput, TeacherUncheckedCreateWithoutClassRoomInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutClassRoomInput
    upsert?: TeacherUpsertWithoutClassRoomInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<TeacherUpdateWithoutClassRoomInput, TeacherUncheckedUpdateWithoutClassRoomInput>
  }

  export type StudentUpdateManyWithoutClassRoomNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutClassRoomInput>, Enumerable<StudentUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutClassRoomInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutClassRoomInput>
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutClassRoomInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutClassRoomInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type CalendarUpdateManyWithoutClassRoomNestedInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutClassRoomInput>, Enumerable<CalendarUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutClassRoomInput>
    upsert?: Enumerable<CalendarUpsertWithWhereUniqueWithoutClassRoomInput>
    set?: Enumerable<CalendarWhereUniqueInput>
    disconnect?: Enumerable<CalendarWhereUniqueInput>
    delete?: Enumerable<CalendarWhereUniqueInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
    update?: Enumerable<CalendarUpdateWithWhereUniqueWithoutClassRoomInput>
    updateMany?: Enumerable<CalendarUpdateManyWithWhereWithoutClassRoomInput>
    deleteMany?: Enumerable<CalendarScalarWhereInput>
  }

  export type ClassRoomUpdatestudentIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ClassRoomUpdateeventIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type StudentUncheckedUpdateManyWithoutClassRoomNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutClassRoomInput>, Enumerable<StudentUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutClassRoomInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutClassRoomInput>
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutClassRoomInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutClassRoomInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type CalendarUncheckedUpdateManyWithoutClassRoomNestedInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutClassRoomInput>, Enumerable<CalendarUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutClassRoomInput>
    upsert?: Enumerable<CalendarUpsertWithWhereUniqueWithoutClassRoomInput>
    set?: Enumerable<CalendarWhereUniqueInput>
    disconnect?: Enumerable<CalendarWhereUniqueInput>
    delete?: Enumerable<CalendarWhereUniqueInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
    update?: Enumerable<CalendarUpdateWithWhereUniqueWithoutClassRoomInput>
    updateMany?: Enumerable<CalendarUpdateManyWithWhereWithoutClassRoomInput>
    deleteMany?: Enumerable<CalendarScalarWhereInput>
  }

  export type OrganizationalCreateEnvelopeInput = {
    set?: OrganizationalCreateInput
  }

  export type OrganizationalCreateInput = {
    kepsek: string
    wakasek: string
    wakakur: string
    wakasiw: string
    wakapra: string
    wakahum?: string | null
  }

  export type InstansiCreateNestedOneWithoutSchoolYearInput = {
    create?: XOR<InstansiCreateWithoutSchoolYearInput, InstansiUncheckedCreateWithoutSchoolYearInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutSchoolYearInput
    connect?: InstansiWhereUniqueInput
  }

  export type ClassRoomCreateNestedManyWithoutYearInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutYearInput>, Enumerable<ClassRoomUncheckedCreateWithoutYearInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutYearInput>
    createMany?: ClassRoomCreateManyYearInputEnvelope
    connect?: Enumerable<ClassRoomWhereUniqueInput>
  }

  export type StudentCreateNestedManyWithoutStartYearInput = {
    create?: XOR<Enumerable<StudentCreateWithoutStartYearInput>, Enumerable<StudentUncheckedCreateWithoutStartYearInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutStartYearInput>
    createMany?: StudentCreateManyStartYearInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type CalendarCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutRefInput>, Enumerable<CalendarUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutRefInput>
    createMany?: CalendarCreateManyRefInputEnvelope
    connect?: Enumerable<CalendarWhereUniqueInput>
  }

  export type ClassRoomUncheckedCreateNestedManyWithoutYearInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutYearInput>, Enumerable<ClassRoomUncheckedCreateWithoutYearInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutYearInput>
    createMany?: ClassRoomCreateManyYearInputEnvelope
    connect?: Enumerable<ClassRoomWhereUniqueInput>
  }

  export type StudentUncheckedCreateNestedManyWithoutStartYearInput = {
    create?: XOR<Enumerable<StudentCreateWithoutStartYearInput>, Enumerable<StudentUncheckedCreateWithoutStartYearInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutStartYearInput>
    createMany?: StudentCreateManyStartYearInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type CalendarUncheckedCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutRefInput>, Enumerable<CalendarUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutRefInput>
    createMany?: CalendarCreateManyRefInputEnvelope
    connect?: Enumerable<CalendarWhereUniqueInput>
  }

  export type OrganizationalUpdateEnvelopeInput = {
    set?: OrganizationalCreateInput
    update?: OrganizationalUpdateInput
  }

  export type InstansiUpdateOneRequiredWithoutSchoolYearNestedInput = {
    create?: XOR<InstansiCreateWithoutSchoolYearInput, InstansiUncheckedCreateWithoutSchoolYearInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutSchoolYearInput
    upsert?: InstansiUpsertWithoutSchoolYearInput
    connect?: InstansiWhereUniqueInput
    update?: XOR<InstansiUpdateWithoutSchoolYearInput, InstansiUncheckedUpdateWithoutSchoolYearInput>
  }

  export type ClassRoomUpdateManyWithoutYearNestedInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutYearInput>, Enumerable<ClassRoomUncheckedCreateWithoutYearInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutYearInput>
    upsert?: Enumerable<ClassRoomUpsertWithWhereUniqueWithoutYearInput>
    createMany?: ClassRoomCreateManyYearInputEnvelope
    set?: Enumerable<ClassRoomWhereUniqueInput>
    disconnect?: Enumerable<ClassRoomWhereUniqueInput>
    delete?: Enumerable<ClassRoomWhereUniqueInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
    update?: Enumerable<ClassRoomUpdateWithWhereUniqueWithoutYearInput>
    updateMany?: Enumerable<ClassRoomUpdateManyWithWhereWithoutYearInput>
    deleteMany?: Enumerable<ClassRoomScalarWhereInput>
  }

  export type StudentUpdateManyWithoutStartYearNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutStartYearInput>, Enumerable<StudentUncheckedCreateWithoutStartYearInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutStartYearInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutStartYearInput>
    createMany?: StudentCreateManyStartYearInputEnvelope
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutStartYearInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutStartYearInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type CalendarUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutRefInput>, Enumerable<CalendarUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<CalendarUpsertWithWhereUniqueWithoutRefInput>
    createMany?: CalendarCreateManyRefInputEnvelope
    set?: Enumerable<CalendarWhereUniqueInput>
    disconnect?: Enumerable<CalendarWhereUniqueInput>
    delete?: Enumerable<CalendarWhereUniqueInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
    update?: Enumerable<CalendarUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<CalendarUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<CalendarScalarWhereInput>
  }

  export type ClassRoomUncheckedUpdateManyWithoutYearNestedInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutYearInput>, Enumerable<ClassRoomUncheckedCreateWithoutYearInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutYearInput>
    upsert?: Enumerable<ClassRoomUpsertWithWhereUniqueWithoutYearInput>
    createMany?: ClassRoomCreateManyYearInputEnvelope
    set?: Enumerable<ClassRoomWhereUniqueInput>
    disconnect?: Enumerable<ClassRoomWhereUniqueInput>
    delete?: Enumerable<ClassRoomWhereUniqueInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
    update?: Enumerable<ClassRoomUpdateWithWhereUniqueWithoutYearInput>
    updateMany?: Enumerable<ClassRoomUpdateManyWithWhereWithoutYearInput>
    deleteMany?: Enumerable<ClassRoomScalarWhereInput>
  }

  export type StudentUncheckedUpdateManyWithoutStartYearNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutStartYearInput>, Enumerable<StudentUncheckedCreateWithoutStartYearInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutStartYearInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutStartYearInput>
    createMany?: StudentCreateManyStartYearInputEnvelope
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutStartYearInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutStartYearInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type CalendarUncheckedUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutRefInput>, Enumerable<CalendarUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<CalendarUpsertWithWhereUniqueWithoutRefInput>
    createMany?: CalendarCreateManyRefInputEnvelope
    set?: Enumerable<CalendarWhereUniqueInput>
    disconnect?: Enumerable<CalendarWhereUniqueInput>
    delete?: Enumerable<CalendarWhereUniqueInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
    update?: Enumerable<CalendarUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<CalendarUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<CalendarScalarWhereInput>
  }

  export type SchoolYearCreateNestedOneWithoutCalendarInput = {
    create?: XOR<SchoolYearCreateWithoutCalendarInput, SchoolYearUncheckedCreateWithoutCalendarInput>
    connectOrCreate?: SchoolYearCreateOrConnectWithoutCalendarInput
    connect?: SchoolYearWhereUniqueInput
  }

  export type ClassRoomCreateNestedManyWithoutEventInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutEventInput>, Enumerable<ClassRoomUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutEventInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
  }

  export type StudentCreateNestedManyWithoutEventInput = {
    create?: XOR<Enumerable<StudentCreateWithoutEventInput>, Enumerable<StudentUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutEventInput>
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type TeacherCreateNestedManyWithoutEventInput = {
    create?: XOR<Enumerable<TeacherCreateWithoutEventInput>, Enumerable<TeacherUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<TeacherCreateOrConnectWithoutEventInput>
    connect?: Enumerable<TeacherWhereUniqueInput>
  }

  export type CalendarCreateclassRoomIdsInput = {
    set: Enumerable<string>
  }

  export type CalendarCreatestudentIdsInput = {
    set: Enumerable<string>
  }

  export type CalendarCreateteacherIdsInput = {
    set: Enumerable<string>
  }

  export type ClassRoomUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutEventInput>, Enumerable<ClassRoomUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutEventInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
  }

  export type StudentUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<Enumerable<StudentCreateWithoutEventInput>, Enumerable<StudentUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutEventInput>
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type TeacherUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<Enumerable<TeacherCreateWithoutEventInput>, Enumerable<TeacherUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<TeacherCreateOrConnectWithoutEventInput>
    connect?: Enumerable<TeacherWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type SchoolYearUpdateOneRequiredWithoutCalendarNestedInput = {
    create?: XOR<SchoolYearCreateWithoutCalendarInput, SchoolYearUncheckedCreateWithoutCalendarInput>
    connectOrCreate?: SchoolYearCreateOrConnectWithoutCalendarInput
    upsert?: SchoolYearUpsertWithoutCalendarInput
    connect?: SchoolYearWhereUniqueInput
    update?: XOR<SchoolYearUpdateWithoutCalendarInput, SchoolYearUncheckedUpdateWithoutCalendarInput>
  }

  export type ClassRoomUpdateManyWithoutEventNestedInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutEventInput>, Enumerable<ClassRoomUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutEventInput>
    upsert?: Enumerable<ClassRoomUpsertWithWhereUniqueWithoutEventInput>
    set?: Enumerable<ClassRoomWhereUniqueInput>
    disconnect?: Enumerable<ClassRoomWhereUniqueInput>
    delete?: Enumerable<ClassRoomWhereUniqueInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
    update?: Enumerable<ClassRoomUpdateWithWhereUniqueWithoutEventInput>
    updateMany?: Enumerable<ClassRoomUpdateManyWithWhereWithoutEventInput>
    deleteMany?: Enumerable<ClassRoomScalarWhereInput>
  }

  export type StudentUpdateManyWithoutEventNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutEventInput>, Enumerable<StudentUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutEventInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutEventInput>
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutEventInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutEventInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type TeacherUpdateManyWithoutEventNestedInput = {
    create?: XOR<Enumerable<TeacherCreateWithoutEventInput>, Enumerable<TeacherUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<TeacherCreateOrConnectWithoutEventInput>
    upsert?: Enumerable<TeacherUpsertWithWhereUniqueWithoutEventInput>
    set?: Enumerable<TeacherWhereUniqueInput>
    disconnect?: Enumerable<TeacherWhereUniqueInput>
    delete?: Enumerable<TeacherWhereUniqueInput>
    connect?: Enumerable<TeacherWhereUniqueInput>
    update?: Enumerable<TeacherUpdateWithWhereUniqueWithoutEventInput>
    updateMany?: Enumerable<TeacherUpdateManyWithWhereWithoutEventInput>
    deleteMany?: Enumerable<TeacherScalarWhereInput>
  }

  export type CalendarUpdateclassRoomIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type CalendarUpdatestudentIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type CalendarUpdateteacherIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ClassRoomUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutEventInput>, Enumerable<ClassRoomUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutEventInput>
    upsert?: Enumerable<ClassRoomUpsertWithWhereUniqueWithoutEventInput>
    set?: Enumerable<ClassRoomWhereUniqueInput>
    disconnect?: Enumerable<ClassRoomWhereUniqueInput>
    delete?: Enumerable<ClassRoomWhereUniqueInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
    update?: Enumerable<ClassRoomUpdateWithWhereUniqueWithoutEventInput>
    updateMany?: Enumerable<ClassRoomUpdateManyWithWhereWithoutEventInput>
    deleteMany?: Enumerable<ClassRoomScalarWhereInput>
  }

  export type StudentUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutEventInput>, Enumerable<StudentUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutEventInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutEventInput>
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutEventInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutEventInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type TeacherUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<Enumerable<TeacherCreateWithoutEventInput>, Enumerable<TeacherUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<TeacherCreateOrConnectWithoutEventInput>
    upsert?: Enumerable<TeacherUpsertWithWhereUniqueWithoutEventInput>
    set?: Enumerable<TeacherWhereUniqueInput>
    disconnect?: Enumerable<TeacherWhereUniqueInput>
    delete?: Enumerable<TeacherWhereUniqueInput>
    connect?: Enumerable<TeacherWhereUniqueInput>
    update?: Enumerable<TeacherUpdateWithWhereUniqueWithoutEventInput>
    updateMany?: Enumerable<TeacherUpdateManyWithWhereWithoutEventInput>
    deleteMany?: Enumerable<TeacherScalarWhereInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedEnumFaseFilter = {
    equals?: Fase
    in?: Enumerable<Fase>
    notIn?: Enumerable<Fase>
    not?: NestedEnumFaseFilter | Fase
  }

  export type NestedEnumFaseWithAggregatesFilter = {
    equals?: Fase
    in?: Enumerable<Fase>
    notIn?: Enumerable<Fase>
    not?: NestedEnumFaseWithAggregatesFilter | Fase
    _count?: NestedIntFilter
    _min?: NestedEnumFaseFilter
    _max?: NestedEnumFaseFilter
  }

  export type NestedEnumReligionNullableFilter = {
    equals?: Religion | null
    in?: Enumerable<Religion> | null
    notIn?: Enumerable<Religion> | null
    not?: NestedEnumReligionNullableFilter | Religion | null
    isSet?: boolean
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedEnumReligionNullableWithAggregatesFilter = {
    equals?: Religion | null
    in?: Enumerable<Religion> | null
    notIn?: Enumerable<Religion> | null
    not?: NestedEnumReligionNullableWithAggregatesFilter | Religion | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumReligionNullableFilter
    _max?: NestedEnumReligionNullableFilter
    isSet?: boolean
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
    isSet?: boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type AddressWhereInput = {
    AND?: Enumerable<AddressWhereInput>
    OR?: Enumerable<AddressWhereInput>
    NOT?: Enumerable<AddressWhereInput>
    provinsi?: StringFilter | string
    kabupaten?: StringFilter | string
    kecamatan?: StringFilter | string
    kelurahan?: StringFilter | string
    kodepos?: StringFilter | string
    coordinate?: XOR<CoordinateCompositeFilter, CoordinateObjectEqualityInput>
  }

  export type CoordinateObjectEqualityInput = {
    longitude: number
    latitude: number
  }

  export type NestedEnumLevelFilter = {
    equals?: Level
    in?: Enumerable<Level>
    notIn?: Enumerable<Level>
    not?: NestedEnumLevelFilter | Level
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
    isSet?: boolean
  }

  export type CoordinateOrderByInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type NestedEnumLevelWithAggregatesFilter = {
    equals?: Level
    in?: Enumerable<Level>
    notIn?: Enumerable<Level>
    not?: NestedEnumLevelWithAggregatesFilter | Level
    _count?: NestedIntFilter
    _min?: NestedEnumLevelFilter
    _max?: NestedEnumLevelFilter
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
    isSet?: boolean
  }

  export type NestedEnumRolesFilter = {
    equals?: Roles
    in?: Enumerable<Roles>
    notIn?: Enumerable<Roles>
    not?: NestedEnumRolesFilter | Roles
  }

  export type NestedEnumRolesWithAggregatesFilter = {
    equals?: Roles
    in?: Enumerable<Roles>
    notIn?: Enumerable<Roles>
    not?: NestedEnumRolesWithAggregatesFilter | Roles
    _count?: NestedIntFilter
    _min?: NestedEnumRolesFilter
    _max?: NestedEnumRolesFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
    isSet?: boolean
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    isSet?: boolean
  }

  export type NestedEnumTypePersonalFilter = {
    equals?: TypePersonal
    in?: Enumerable<TypePersonal>
    notIn?: Enumerable<TypePersonal>
    not?: NestedEnumTypePersonalFilter | TypePersonal
  }

  export type NestedEnumGenderFilter = {
    equals?: Gender
    in?: Enumerable<Gender>
    notIn?: Enumerable<Gender>
    not?: NestedEnumGenderFilter | Gender
  }

  export type NestedEnumReligionFilter = {
    equals?: Religion
    in?: Enumerable<Religion>
    notIn?: Enumerable<Religion>
    not?: NestedEnumReligionFilter | Religion
  }

  export type BornWhereInput = {
    AND?: Enumerable<BornWhereInput>
    OR?: Enumerable<BornWhereInput>
    NOT?: Enumerable<BornWhereInput>
    place?: StringFilter | string
    date?: StringFilter | string
  }

  export type NestedEnumTypePersonalWithAggregatesFilter = {
    equals?: TypePersonal
    in?: Enumerable<TypePersonal>
    notIn?: Enumerable<TypePersonal>
    not?: NestedEnumTypePersonalWithAggregatesFilter | TypePersonal
    _count?: NestedIntFilter
    _min?: NestedEnumTypePersonalFilter
    _max?: NestedEnumTypePersonalFilter
  }

  export type NestedEnumGenderWithAggregatesFilter = {
    equals?: Gender
    in?: Enumerable<Gender>
    notIn?: Enumerable<Gender>
    not?: NestedEnumGenderWithAggregatesFilter | Gender
    _count?: NestedIntFilter
    _min?: NestedEnumGenderFilter
    _max?: NestedEnumGenderFilter
  }

  export type NestedEnumReligionWithAggregatesFilter = {
    equals?: Religion
    in?: Enumerable<Religion>
    notIn?: Enumerable<Religion>
    not?: NestedEnumReligionWithAggregatesFilter | Religion
    _count?: NestedIntFilter
    _min?: NestedEnumReligionFilter
    _max?: NestedEnumReligionFilter
  }

  export type NestedEnumChildTypeFilter = {
    equals?: ChildType
    in?: Enumerable<ChildType>
    notIn?: Enumerable<ChildType>
    not?: NestedEnumChildTypeFilter | ChildType
  }

  export type NestedEnumChildTypeWithAggregatesFilter = {
    equals?: ChildType
    in?: Enumerable<ChildType>
    notIn?: Enumerable<ChildType>
    not?: NestedEnumChildTypeWithAggregatesFilter | ChildType
    _count?: NestedIntFilter
    _min?: NestedEnumChildTypeFilter
    _max?: NestedEnumChildTypeFilter
  }

  export type EducationWhereInput = {
    AND?: Enumerable<EducationWhereInput>
    OR?: Enumerable<EducationWhereInput>
    NOT?: Enumerable<EducationWhereInput>
    instansi?: StringFilter | string
    level?: EnumLevelEduFilter | LevelEdu
    major?: StringNullableFilter | string | null
    year?: IntFilter | number
    attachment?: StringNullableFilter | string | null
  }

  export type TrainingWhereInput = {
    AND?: Enumerable<TrainingWhereInput>
    OR?: Enumerable<TrainingWhereInput>
    NOT?: Enumerable<TrainingWhereInput>
    name?: StringFilter | string
    instansi?: StringFilter | string
    long?: IntFilter | number
    year?: IntFilter | number
    place?: StringFilter | string
    attachment?: StringNullableFilter | string | null
  }

  export type EmploymentWhereInput = {
    AND?: Enumerable<EmploymentWhereInput>
    OR?: Enumerable<EmploymentWhereInput>
    NOT?: Enumerable<EmploymentWhereInput>
    position?: StringFilter | string
    year?: IntFilter | number
    place?: StringFilter | string
    note?: StringNullableFilter | string | null
  }

  export type ProfessionWhereInput = {
    AND?: Enumerable<ProfessionWhereInput>
    OR?: Enumerable<ProfessionWhereInput>
    NOT?: Enumerable<ProfessionWhereInput>
    name?: StringFilter | string
    instansi?: StringFilter | string
    year?: IntFilter | number
    attachment?: StringNullableFilter | string | null
  }

  export type OverseasWhereInput = {
    AND?: Enumerable<OverseasWhereInput>
    OR?: Enumerable<OverseasWhereInput>
    NOT?: Enumerable<OverseasWhereInput>
    country?: StringFilter | string
    instansi?: StringFilter | string
    objective?: StringFilter | string
    long?: IntFilter | number
    year?: IntFilter | number
    attachment?: StringNullableFilter | string | null
  }

  export type ScientificWhereInput = {
    AND?: Enumerable<ScientificWhereInput>
    OR?: Enumerable<ScientificWhereInput>
    NOT?: Enumerable<ScientificWhereInput>
    name?: StringFilter | string
    instansi?: StringFilter | string
    position?: StringFilter | string
    place?: StringFilter | string
    period?: StringFilter | string
    attachment?: StringNullableFilter | string | null
  }

  export type OrganizationWhereInput = {
    AND?: Enumerable<OrganizationWhereInput>
    OR?: Enumerable<OrganizationWhereInput>
    NOT?: Enumerable<OrganizationWhereInput>
    name?: StringFilter | string
    position?: StringFilter | string
    period?: StringFilter | string
    leader?: StringFilter | string
    place?: StringFilter | string
  }

  export type PapersWhereInput = {
    AND?: Enumerable<PapersWhereInput>
    OR?: Enumerable<PapersWhereInput>
    NOT?: Enumerable<PapersWhereInput>
    name?: StringFilter | string
    year?: IntFilter | number
    published?: StringFilter | string
  }

  export type InnovationWhereInput = {
    AND?: Enumerable<InnovationWhereInput>
    OR?: Enumerable<InnovationWhereInput>
    NOT?: Enumerable<InnovationWhereInput>
    name?: StringFilter | string
    year?: IntFilter | number
    patent?: BoolFilter | boolean
  }

  export type AwardWhereInput = {
    AND?: Enumerable<AwardWhereInput>
    OR?: Enumerable<AwardWhereInput>
    NOT?: Enumerable<AwardWhereInput>
    name?: StringFilter | string
    year?: IntFilter | number
    instansi?: StringFilter | string
    attachment?: StringNullableFilter | string | null
  }

  export type SourcePersonWhereInput = {
    AND?: Enumerable<SourcePersonWhereInput>
    OR?: Enumerable<SourcePersonWhereInput>
    NOT?: Enumerable<SourcePersonWhereInput>
    name?: StringFilter | string
    date?: StringFilter | string
    instansi?: StringFilter | string
    note?: StringNullableFilter | string | null
    attachment?: StringNullableFilter | string | null
  }

  export type ContestWhereInput = {
    AND?: Enumerable<ContestWhereInput>
    OR?: Enumerable<ContestWhereInput>
    NOT?: Enumerable<ContestWhereInput>
    name?: StringFilter | string
    date?: StringFilter | string
    instansi?: StringFilter | string
    level?: StringFilter | string
    attachment?: StringNullableFilter | string | null
  }

  export type DocumentsWhereInput = {
    AND?: Enumerable<DocumentsWhereInput>
    OR?: Enumerable<DocumentsWhereInput>
    NOT?: Enumerable<DocumentsWhereInput>
    name?: StringFilter | string
    date?: StringFilter | string
    instansi?: StringFilter | string
    note?: StringNullableFilter | string | null
    attachment?: StringNullableFilter | string | null
  }

  export type AdditionalWhereInput = {
    AND?: Enumerable<AdditionalWhereInput>
    OR?: Enumerable<AdditionalWhereInput>
    NOT?: Enumerable<AdditionalWhereInput>
    position?: StringFilter | string
    date?: StringFilter | string
    instansi?: StringFilter | string
    note?: StringNullableFilter | string | null
    attachment?: StringNullableFilter | string | null
  }

  export type OrganizationalWhereInput = {
    AND?: Enumerable<OrganizationalWhereInput>
    OR?: Enumerable<OrganizationalWhereInput>
    NOT?: Enumerable<OrganizationalWhereInput>
    kepsek?: StringFilter | string
    wakasek?: StringFilter | string
    wakakur?: StringFilter | string
    wakasiw?: StringFilter | string
    wakapra?: StringFilter | string
    wakahum?: StringNullableFilter | string | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    isSet?: boolean
  }

  export type ProgramKeahlianCreateWithoutBidangInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    konsentrasi?: KonsentrasiKeahlianCreateNestedManyWithoutProgramInput
  }

  export type ProgramKeahlianUncheckedCreateWithoutBidangInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    konsentrasi?: KonsentrasiKeahlianUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramKeahlianCreateOrConnectWithoutBidangInput = {
    where: ProgramKeahlianWhereUniqueInput
    create: XOR<ProgramKeahlianCreateWithoutBidangInput, ProgramKeahlianUncheckedCreateWithoutBidangInput>
  }

  export type ProgramKeahlianCreateManyBidangInputEnvelope = {
    data: Enumerable<ProgramKeahlianCreateManyBidangInput>
  }

  export type ProgramKeahlianUpsertWithWhereUniqueWithoutBidangInput = {
    where: ProgramKeahlianWhereUniqueInput
    update: XOR<ProgramKeahlianUpdateWithoutBidangInput, ProgramKeahlianUncheckedUpdateWithoutBidangInput>
    create: XOR<ProgramKeahlianCreateWithoutBidangInput, ProgramKeahlianUncheckedCreateWithoutBidangInput>
  }

  export type ProgramKeahlianUpdateWithWhereUniqueWithoutBidangInput = {
    where: ProgramKeahlianWhereUniqueInput
    data: XOR<ProgramKeahlianUpdateWithoutBidangInput, ProgramKeahlianUncheckedUpdateWithoutBidangInput>
  }

  export type ProgramKeahlianUpdateManyWithWhereWithoutBidangInput = {
    where: ProgramKeahlianScalarWhereInput
    data: XOR<ProgramKeahlianUpdateManyMutationInput, ProgramKeahlianUncheckedUpdateManyWithoutProgramInput>
  }

  export type ProgramKeahlianScalarWhereInput = {
    AND?: Enumerable<ProgramKeahlianScalarWhereInput>
    OR?: Enumerable<ProgramKeahlianScalarWhereInput>
    NOT?: Enumerable<ProgramKeahlianScalarWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    name?: StringFilter | string
    bidangId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BidangKeahlianCreateWithoutProgramInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidangKeahlianUncheckedCreateWithoutProgramInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BidangKeahlianCreateOrConnectWithoutProgramInput = {
    where: BidangKeahlianWhereUniqueInput
    create: XOR<BidangKeahlianCreateWithoutProgramInput, BidangKeahlianUncheckedCreateWithoutProgramInput>
  }

  export type KonsentrasiKeahlianCreateWithoutProgramInput = {
    id?: string
    code: string
    name: string
    tahun: number
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedManyWithoutMajorInput
    instansi?: InstansiCreateNestedManyWithoutMajorsInput
  }

  export type KonsentrasiKeahlianUncheckedCreateWithoutProgramInput = {
    id?: string
    code: string
    name: string
    tahun: number
    createdAt?: Date | string
    updatedAt?: Date | string
    instansiIds?: KonsentrasiKeahlianCreateinstansiIdsInput | Enumerable<string>
    student?: StudentUncheckedCreateNestedManyWithoutMajorInput
    instansi?: InstansiUncheckedCreateNestedManyWithoutMajorsInput
  }

  export type KonsentrasiKeahlianCreateOrConnectWithoutProgramInput = {
    where: KonsentrasiKeahlianWhereUniqueInput
    create: XOR<KonsentrasiKeahlianCreateWithoutProgramInput, KonsentrasiKeahlianUncheckedCreateWithoutProgramInput>
  }

  export type KonsentrasiKeahlianCreateManyProgramInputEnvelope = {
    data: Enumerable<KonsentrasiKeahlianCreateManyProgramInput>
  }

  export type BidangKeahlianUpsertWithoutProgramInput = {
    update: XOR<BidangKeahlianUpdateWithoutProgramInput, BidangKeahlianUncheckedUpdateWithoutProgramInput>
    create: XOR<BidangKeahlianCreateWithoutProgramInput, BidangKeahlianUncheckedCreateWithoutProgramInput>
  }

  export type BidangKeahlianUpdateWithoutProgramInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidangKeahlianUncheckedUpdateWithoutProgramInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KonsentrasiKeahlianUpsertWithWhereUniqueWithoutProgramInput = {
    where: KonsentrasiKeahlianWhereUniqueInput
    update: XOR<KonsentrasiKeahlianUpdateWithoutProgramInput, KonsentrasiKeahlianUncheckedUpdateWithoutProgramInput>
    create: XOR<KonsentrasiKeahlianCreateWithoutProgramInput, KonsentrasiKeahlianUncheckedCreateWithoutProgramInput>
  }

  export type KonsentrasiKeahlianUpdateWithWhereUniqueWithoutProgramInput = {
    where: KonsentrasiKeahlianWhereUniqueInput
    data: XOR<KonsentrasiKeahlianUpdateWithoutProgramInput, KonsentrasiKeahlianUncheckedUpdateWithoutProgramInput>
  }

  export type KonsentrasiKeahlianUpdateManyWithWhereWithoutProgramInput = {
    where: KonsentrasiKeahlianScalarWhereInput
    data: XOR<KonsentrasiKeahlianUpdateManyMutationInput, KonsentrasiKeahlianUncheckedUpdateManyWithoutKonsentrasiInput>
  }

  export type KonsentrasiKeahlianScalarWhereInput = {
    AND?: Enumerable<KonsentrasiKeahlianScalarWhereInput>
    OR?: Enumerable<KonsentrasiKeahlianScalarWhereInput>
    NOT?: Enumerable<KonsentrasiKeahlianScalarWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    name?: StringFilter | string
    programId?: StringFilter | string
    tahun?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    instansiIds?: StringNullableListFilter
  }

  export type ProgramKeahlianCreateWithoutKonsentrasiInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bidang: BidangKeahlianCreateNestedOneWithoutProgramInput
  }

  export type ProgramKeahlianUncheckedCreateWithoutKonsentrasiInput = {
    id?: string
    code: string
    name: string
    bidangId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramKeahlianCreateOrConnectWithoutKonsentrasiInput = {
    where: ProgramKeahlianWhereUniqueInput
    create: XOR<ProgramKeahlianCreateWithoutKonsentrasiInput, ProgramKeahlianUncheckedCreateWithoutKonsentrasiInput>
  }

  export type StudentCreateWithoutMajorInput = {
    id?: string
    user?: UserCreateNestedOneWithoutStudentInput
    classRoom?: ClassRoomCreateNestedManyWithoutStudentsInput
    startYear: SchoolYearCreateNestedOneWithoutStudentsInInput
    instansi: InstansiCreateNestedOneWithoutStudentInput
    event?: CalendarCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutMajorInput = {
    id?: string
    userId?: string | null
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    startYearId: string
    instansiId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutStudentsInput
    event?: CalendarUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutMajorInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutMajorInput, StudentUncheckedCreateWithoutMajorInput>
  }

  export type StudentCreateManyMajorInputEnvelope = {
    data: Enumerable<StudentCreateManyMajorInput>
  }

  export type InstansiCreateWithoutMajorsInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: RoleCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearCreateNestedManyWithoutInstansiInput
    teacher?: TeacherCreateNestedManyWithoutInstansiInput
    student?: StudentCreateNestedManyWithoutInstansiInput
  }

  export type InstansiUncheckedCreateWithoutMajorsInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    majorIds?: InstansiCreatemajorIdsInput | Enumerable<string>
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: RoleUncheckedCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearUncheckedCreateNestedManyWithoutInstansiInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutInstansiInput
    student?: StudentUncheckedCreateNestedManyWithoutInstansiInput
  }

  export type InstansiCreateOrConnectWithoutMajorsInput = {
    where: InstansiWhereUniqueInput
    create: XOR<InstansiCreateWithoutMajorsInput, InstansiUncheckedCreateWithoutMajorsInput>
  }

  export type ProgramKeahlianUpsertWithoutKonsentrasiInput = {
    update: XOR<ProgramKeahlianUpdateWithoutKonsentrasiInput, ProgramKeahlianUncheckedUpdateWithoutKonsentrasiInput>
    create: XOR<ProgramKeahlianCreateWithoutKonsentrasiInput, ProgramKeahlianUncheckedCreateWithoutKonsentrasiInput>
  }

  export type ProgramKeahlianUpdateWithoutKonsentrasiInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidang?: BidangKeahlianUpdateOneRequiredWithoutProgramNestedInput
  }

  export type ProgramKeahlianUncheckedUpdateWithoutKonsentrasiInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bidangId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpsertWithWhereUniqueWithoutMajorInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutMajorInput, StudentUncheckedUpdateWithoutMajorInput>
    create: XOR<StudentCreateWithoutMajorInput, StudentUncheckedCreateWithoutMajorInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutMajorInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutMajorInput, StudentUncheckedUpdateWithoutMajorInput>
  }

  export type StudentUpdateManyWithWhereWithoutMajorInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentScalarWhereInput = {
    AND?: Enumerable<StudentScalarWhereInput>
    OR?: Enumerable<StudentScalarWhereInput>
    NOT?: Enumerable<StudentScalarWhereInput>
    id?: StringFilter | string
    userId?: StringNullableFilter | string | null
    majorId?: StringNullableFilter | string | null
    classRoomIds?: StringNullableListFilter
    startYearId?: StringFilter | string
    instansiId?: StringFilter | string
    eventIds?: StringNullableListFilter
  }

  export type InstansiUpsertWithWhereUniqueWithoutMajorsInput = {
    where: InstansiWhereUniqueInput
    update: XOR<InstansiUpdateWithoutMajorsInput, InstansiUncheckedUpdateWithoutMajorsInput>
    create: XOR<InstansiCreateWithoutMajorsInput, InstansiUncheckedCreateWithoutMajorsInput>
  }

  export type InstansiUpdateWithWhereUniqueWithoutMajorsInput = {
    where: InstansiWhereUniqueInput
    data: XOR<InstansiUpdateWithoutMajorsInput, InstansiUncheckedUpdateWithoutMajorsInput>
  }

  export type InstansiUpdateManyWithWhereWithoutMajorsInput = {
    where: InstansiScalarWhereInput
    data: XOR<InstansiUpdateManyMutationInput, InstansiUncheckedUpdateManyWithoutInstansiInput>
  }

  export type InstansiScalarWhereInput = {
    AND?: Enumerable<InstansiScalarWhereInput>
    OR?: Enumerable<InstansiScalarWhereInput>
    NOT?: Enumerable<InstansiScalarWhereInput>
    id?: StringFilter | string
    npsn?: StringFilter | string
    name?: StringFilter | string
    isPrivate?: BoolFilter | boolean
    level?: EnumLevelFilter | Level
    religion?: EnumReligionNullableFilter | Religion | null
    major?: BoolNullableFilter | boolean | null
    majorIds?: StringNullableListFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ElementCreateWithoutAchievementInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mapel: MataPelajaranCreateNestedOneWithoutElementInput
  }

  export type ElementUncheckedCreateWithoutAchievementInput = {
    id?: string
    name: string
    description: string
    mapelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ElementCreateOrConnectWithoutAchievementInput = {
    where: ElementWhereUniqueInput
    create: XOR<ElementCreateWithoutAchievementInput, ElementUncheckedCreateWithoutAchievementInput>
  }

  export type ElementUpsertWithoutAchievementInput = {
    update: XOR<ElementUpdateWithoutAchievementInput, ElementUncheckedUpdateWithoutAchievementInput>
    create: XOR<ElementCreateWithoutAchievementInput, ElementUncheckedCreateWithoutAchievementInput>
  }

  export type ElementUpdateWithoutAchievementInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapel?: MataPelajaranUpdateOneRequiredWithoutElementNestedInput
  }

  export type ElementUncheckedUpdateWithoutAchievementInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateWithoutElementInput = {
    id?: string
    fase?: Fase
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementUncheckedCreateWithoutElementInput = {
    id?: string
    fase?: Fase
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementCreateOrConnectWithoutElementInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutElementInput, AchievementUncheckedCreateWithoutElementInput>
  }

  export type AchievementCreateManyElementInputEnvelope = {
    data: Enumerable<AchievementCreateManyElementInput>
  }

  export type MataPelajaranCreateWithoutElementInput = {
    id?: string
    code: string
    name: string
    religion?: Religion | null
    vocational: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MataPelajaranUncheckedCreateWithoutElementInput = {
    id?: string
    code: string
    name: string
    religion?: Religion | null
    vocational: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MataPelajaranCreateOrConnectWithoutElementInput = {
    where: MataPelajaranWhereUniqueInput
    create: XOR<MataPelajaranCreateWithoutElementInput, MataPelajaranUncheckedCreateWithoutElementInput>
  }

  export type AchievementUpsertWithWhereUniqueWithoutElementInput = {
    where: AchievementWhereUniqueInput
    update: XOR<AchievementUpdateWithoutElementInput, AchievementUncheckedUpdateWithoutElementInput>
    create: XOR<AchievementCreateWithoutElementInput, AchievementUncheckedCreateWithoutElementInput>
  }

  export type AchievementUpdateWithWhereUniqueWithoutElementInput = {
    where: AchievementWhereUniqueInput
    data: XOR<AchievementUpdateWithoutElementInput, AchievementUncheckedUpdateWithoutElementInput>
  }

  export type AchievementUpdateManyWithWhereWithoutElementInput = {
    where: AchievementScalarWhereInput
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyWithoutAchievementInput>
  }

  export type AchievementScalarWhereInput = {
    AND?: Enumerable<AchievementScalarWhereInput>
    OR?: Enumerable<AchievementScalarWhereInput>
    NOT?: Enumerable<AchievementScalarWhereInput>
    id?: StringFilter | string
    fase?: EnumFaseFilter | Fase
    description?: StringFilter | string
    elementId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type MataPelajaranUpsertWithoutElementInput = {
    update: XOR<MataPelajaranUpdateWithoutElementInput, MataPelajaranUncheckedUpdateWithoutElementInput>
    create: XOR<MataPelajaranCreateWithoutElementInput, MataPelajaranUncheckedCreateWithoutElementInput>
  }

  export type MataPelajaranUpdateWithoutElementInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    vocational?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MataPelajaranUncheckedUpdateWithoutElementInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    vocational?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElementCreateWithoutMapelInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    achievement?: AchievementCreateNestedManyWithoutElementInput
  }

  export type ElementUncheckedCreateWithoutMapelInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    achievement?: AchievementUncheckedCreateNestedManyWithoutElementInput
  }

  export type ElementCreateOrConnectWithoutMapelInput = {
    where: ElementWhereUniqueInput
    create: XOR<ElementCreateWithoutMapelInput, ElementUncheckedCreateWithoutMapelInput>
  }

  export type ElementCreateManyMapelInputEnvelope = {
    data: Enumerable<ElementCreateManyMapelInput>
  }

  export type ElementUpsertWithWhereUniqueWithoutMapelInput = {
    where: ElementWhereUniqueInput
    update: XOR<ElementUpdateWithoutMapelInput, ElementUncheckedUpdateWithoutMapelInput>
    create: XOR<ElementCreateWithoutMapelInput, ElementUncheckedCreateWithoutMapelInput>
  }

  export type ElementUpdateWithWhereUniqueWithoutMapelInput = {
    where: ElementWhereUniqueInput
    data: XOR<ElementUpdateWithoutMapelInput, ElementUncheckedUpdateWithoutMapelInput>
  }

  export type ElementUpdateManyWithWhereWithoutMapelInput = {
    where: ElementScalarWhereInput
    data: XOR<ElementUpdateManyMutationInput, ElementUncheckedUpdateManyWithoutElementInput>
  }

  export type ElementScalarWhereInput = {
    AND?: Enumerable<ElementScalarWhereInput>
    OR?: Enumerable<ElementScalarWhereInput>
    NOT?: Enumerable<ElementScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringFilter | string
    mapelId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CoordinateCreateInput = {
    longitude: number
    latitude: number
  }

  export type KonsentrasiKeahlianCreateWithoutInstansiInput = {
    id?: string
    code: string
    name: string
    tahun: number
    createdAt?: Date | string
    updatedAt?: Date | string
    program: ProgramKeahlianCreateNestedOneWithoutKonsentrasiInput
    student?: StudentCreateNestedManyWithoutMajorInput
  }

  export type KonsentrasiKeahlianUncheckedCreateWithoutInstansiInput = {
    id?: string
    code: string
    name: string
    programId: string
    tahun: number
    createdAt?: Date | string
    updatedAt?: Date | string
    instansiIds?: KonsentrasiKeahlianCreateinstansiIdsInput | Enumerable<string>
    student?: StudentUncheckedCreateNestedManyWithoutMajorInput
  }

  export type KonsentrasiKeahlianCreateOrConnectWithoutInstansiInput = {
    where: KonsentrasiKeahlianWhereUniqueInput
    create: XOR<KonsentrasiKeahlianCreateWithoutInstansiInput, KonsentrasiKeahlianUncheckedCreateWithoutInstansiInput>
  }

  export type RoleCreateWithoutInstansiInput = {
    id?: string
    key: Roles
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutInstansiInput = {
    id?: string
    key: Roles
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutInstansiInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutInstansiInput, RoleUncheckedCreateWithoutInstansiInput>
  }

  export type RoleCreateManyInstansiInputEnvelope = {
    data: Enumerable<RoleCreateManyInstansiInput>
  }

  export type SchoolYearCreateWithoutInstansiInput = {
    id?: string
    year: number
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    classRoom?: ClassRoomCreateNestedManyWithoutYearInput
    studentsIn?: StudentCreateNestedManyWithoutStartYearInput
    calendar?: CalendarCreateNestedManyWithoutRefInput
  }

  export type SchoolYearUncheckedCreateWithoutInstansiInput = {
    id?: string
    year: number
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutYearInput
    studentsIn?: StudentUncheckedCreateNestedManyWithoutStartYearInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutRefInput
  }

  export type SchoolYearCreateOrConnectWithoutInstansiInput = {
    where: SchoolYearWhereUniqueInput
    create: XOR<SchoolYearCreateWithoutInstansiInput, SchoolYearUncheckedCreateWithoutInstansiInput>
  }

  export type SchoolYearCreateManyInstansiInputEnvelope = {
    data: Enumerable<SchoolYearCreateManyInstansiInput>
  }

  export type TeacherCreateWithoutInstansiInput = {
    id?: string
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: string | null
    tmtGol?: string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    user?: UserCreateNestedOneWithoutTeacherInput
    classRoom?: ClassRoomCreateNestedManyWithoutWaliInput
    event?: CalendarCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutInstansiInput = {
    id?: string
    userId?: string | null
    eventIds?: TeacherCreateeventIdsInput | Enumerable<string>
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: string | null
    tmtGol?: string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutWaliInput
    event?: CalendarUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutInstansiInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutInstansiInput, TeacherUncheckedCreateWithoutInstansiInput>
  }

  export type TeacherCreateManyInstansiInputEnvelope = {
    data: Enumerable<TeacherCreateManyInstansiInput>
  }

  export type StudentCreateWithoutInstansiInput = {
    id?: string
    user?: UserCreateNestedOneWithoutStudentInput
    major?: KonsentrasiKeahlianCreateNestedOneWithoutStudentInput
    classRoom?: ClassRoomCreateNestedManyWithoutStudentsInput
    startYear: SchoolYearCreateNestedOneWithoutStudentsInInput
    event?: CalendarCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutInstansiInput = {
    id?: string
    userId?: string | null
    majorId?: string | null
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    startYearId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutStudentsInput
    event?: CalendarUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutInstansiInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutInstansiInput, StudentUncheckedCreateWithoutInstansiInput>
  }

  export type StudentCreateManyInstansiInputEnvelope = {
    data: Enumerable<StudentCreateManyInstansiInput>
  }

  export type AddressUpdateInput = {
    provinsi?: StringFieldUpdateOperationsInput | string
    kabupaten?: StringFieldUpdateOperationsInput | string
    kecamatan?: StringFieldUpdateOperationsInput | string
    kelurahan?: StringFieldUpdateOperationsInput | string
    kodepos?: StringFieldUpdateOperationsInput | string
    coordinate?: XOR<CoordinateUpdateEnvelopeInput, CoordinateCreateInput>
  }

  export type KonsentrasiKeahlianUpsertWithWhereUniqueWithoutInstansiInput = {
    where: KonsentrasiKeahlianWhereUniqueInput
    update: XOR<KonsentrasiKeahlianUpdateWithoutInstansiInput, KonsentrasiKeahlianUncheckedUpdateWithoutInstansiInput>
    create: XOR<KonsentrasiKeahlianCreateWithoutInstansiInput, KonsentrasiKeahlianUncheckedCreateWithoutInstansiInput>
  }

  export type KonsentrasiKeahlianUpdateWithWhereUniqueWithoutInstansiInput = {
    where: KonsentrasiKeahlianWhereUniqueInput
    data: XOR<KonsentrasiKeahlianUpdateWithoutInstansiInput, KonsentrasiKeahlianUncheckedUpdateWithoutInstansiInput>
  }

  export type KonsentrasiKeahlianUpdateManyWithWhereWithoutInstansiInput = {
    where: KonsentrasiKeahlianScalarWhereInput
    data: XOR<KonsentrasiKeahlianUpdateManyMutationInput, KonsentrasiKeahlianUncheckedUpdateManyWithoutMajorsInput>
  }

  export type RoleUpsertWithWhereUniqueWithoutInstansiInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutInstansiInput, RoleUncheckedUpdateWithoutInstansiInput>
    create: XOR<RoleCreateWithoutInstansiInput, RoleUncheckedCreateWithoutInstansiInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutInstansiInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutInstansiInput, RoleUncheckedUpdateWithoutInstansiInput>
  }

  export type RoleUpdateManyWithWhereWithoutInstansiInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type RoleScalarWhereInput = {
    AND?: Enumerable<RoleScalarWhereInput>
    OR?: Enumerable<RoleScalarWhereInput>
    NOT?: Enumerable<RoleScalarWhereInput>
    id?: StringFilter | string
    key?: EnumRolesFilter | Roles
    instansiId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SchoolYearUpsertWithWhereUniqueWithoutInstansiInput = {
    where: SchoolYearWhereUniqueInput
    update: XOR<SchoolYearUpdateWithoutInstansiInput, SchoolYearUncheckedUpdateWithoutInstansiInput>
    create: XOR<SchoolYearCreateWithoutInstansiInput, SchoolYearUncheckedCreateWithoutInstansiInput>
  }

  export type SchoolYearUpdateWithWhereUniqueWithoutInstansiInput = {
    where: SchoolYearWhereUniqueInput
    data: XOR<SchoolYearUpdateWithoutInstansiInput, SchoolYearUncheckedUpdateWithoutInstansiInput>
  }

  export type SchoolYearUpdateManyWithWhereWithoutInstansiInput = {
    where: SchoolYearScalarWhereInput
    data: XOR<SchoolYearUpdateManyMutationInput, SchoolYearUncheckedUpdateManyWithoutSchoolYearInput>
  }

  export type SchoolYearScalarWhereInput = {
    AND?: Enumerable<SchoolYearScalarWhereInput>
    OR?: Enumerable<SchoolYearScalarWhereInput>
    NOT?: Enumerable<SchoolYearScalarWhereInput>
    id?: StringFilter | string
    year?: IntFilter | number
    instansiId?: StringFilter | string
  }

  export type TeacherUpsertWithWhereUniqueWithoutInstansiInput = {
    where: TeacherWhereUniqueInput
    update: XOR<TeacherUpdateWithoutInstansiInput, TeacherUncheckedUpdateWithoutInstansiInput>
    create: XOR<TeacherCreateWithoutInstansiInput, TeacherUncheckedCreateWithoutInstansiInput>
  }

  export type TeacherUpdateWithWhereUniqueWithoutInstansiInput = {
    where: TeacherWhereUniqueInput
    data: XOR<TeacherUpdateWithoutInstansiInput, TeacherUncheckedUpdateWithoutInstansiInput>
  }

  export type TeacherUpdateManyWithWhereWithoutInstansiInput = {
    where: TeacherScalarWhereInput
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TeacherScalarWhereInput = {
    AND?: Enumerable<TeacherScalarWhereInput>
    OR?: Enumerable<TeacherScalarWhereInput>
    NOT?: Enumerable<TeacherScalarWhereInput>
    id?: StringFilter | string
    userId?: StringNullableFilter | string | null
    instansiId?: StringFilter | string
    eventIds?: StringNullableListFilter
    nip?: StringNullableFilter | string | null
    nrg?: StringNullableFilter | string | null
    noKarpeg?: StringNullableFilter | string | null
    tmtTugas?: StringNullableFilter | string | null
    tmtGol?: StringNullableFilter | string | null
    position?: StringNullableFilter | string | null
    rank?: StringNullableFilter | string | null
    period?: StringNullableFilter | string | null
    certificate?: StringNullableFilter | string | null
  }

  export type StudentUpsertWithWhereUniqueWithoutInstansiInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutInstansiInput, StudentUncheckedUpdateWithoutInstansiInput>
    create: XOR<StudentCreateWithoutInstansiInput, StudentUncheckedCreateWithoutInstansiInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutInstansiInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutInstansiInput, StudentUncheckedUpdateWithoutInstansiInput>
  }

  export type StudentUpdateManyWithWhereWithoutInstansiInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutStudentInput>
  }

  export type InstansiCreateWithoutRoleInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    majors?: KonsentrasiKeahlianCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearCreateNestedManyWithoutInstansiInput
    teacher?: TeacherCreateNestedManyWithoutInstansiInput
    student?: StudentCreateNestedManyWithoutInstansiInput
  }

  export type InstansiUncheckedCreateWithoutRoleInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    majorIds?: InstansiCreatemajorIdsInput | Enumerable<string>
    createdAt?: Date | string
    updatedAt?: Date | string
    majors?: KonsentrasiKeahlianUncheckedCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearUncheckedCreateNestedManyWithoutInstansiInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutInstansiInput
    student?: StudentUncheckedCreateNestedManyWithoutInstansiInput
  }

  export type InstansiCreateOrConnectWithoutRoleInput = {
    where: InstansiWhereUniqueInput
    create: XOR<InstansiCreateWithoutRoleInput, InstansiUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateWithoutRoleInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personal?: PersonalCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personal?: PersonalUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: Enumerable<UserCreateManyRoleInput>
  }

  export type InstansiUpsertWithoutRoleInput = {
    update: XOR<InstansiUpdateWithoutRoleInput, InstansiUncheckedUpdateWithoutRoleInput>
    create: XOR<InstansiCreateWithoutRoleInput, InstansiUncheckedCreateWithoutRoleInput>
  }

  export type InstansiUpdateWithoutRoleInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    majors?: KonsentrasiKeahlianUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUpdateManyWithoutInstansiNestedInput
    student?: StudentUpdateManyWithoutInstansiNestedInput
  }

  export type InstansiUncheckedUpdateWithoutRoleInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    majorIds?: InstansiUpdatemajorIdsInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    majors?: KonsentrasiKeahlianUncheckedUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUncheckedUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutInstansiNestedInput
    student?: StudentUncheckedUpdateManyWithoutInstansiNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    picture?: StringNullableFilter | string | null
    username?: StringFilter | string
    active?: BoolFilter | boolean
    verify?: BoolFilter | boolean
    password?: StringFilter | string
    passhash?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    roleId?: StringNullableFilter | string | null
  }

  export type RoleCreateWithoutUsersInput = {
    id?: string
    key: Roles
    createdAt?: Date | string
    updatedAt?: Date | string
    instansi: InstansiCreateNestedOneWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: string
    key: Roles
    instansiId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type PersonalCreateWithoutUserInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign: boolean
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email: string
    belajarId?: string | null
    nophone: string
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    father?: FamilyTreeCreateNestedManyWithoutFatherInput
    mother?: FamilyTreeCreateNestedManyWithoutMotherInput
    wali?: FamilyTreeCreateNestedManyWithoutWaliInput
    child?: FamilyTreeChildCreateNestedOneWithoutPersonalInput
  }

  export type PersonalUncheckedCreateWithoutUserInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign: boolean
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email: string
    belajarId?: string | null
    nophone: string
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    father?: FamilyTreeUncheckedCreateNestedManyWithoutFatherInput
    mother?: FamilyTreeUncheckedCreateNestedManyWithoutMotherInput
    wali?: FamilyTreeUncheckedCreateNestedManyWithoutWaliInput
    child?: FamilyTreeChildUncheckedCreateNestedOneWithoutPersonalInput
  }

  export type PersonalCreateOrConnectWithoutUserInput = {
    where: PersonalWhereUniqueInput
    create: XOR<PersonalCreateWithoutUserInput, PersonalUncheckedCreateWithoutUserInput>
  }

  export type StudentCreateWithoutUserInput = {
    id?: string
    major?: KonsentrasiKeahlianCreateNestedOneWithoutStudentInput
    classRoom?: ClassRoomCreateNestedManyWithoutStudentsInput
    startYear: SchoolYearCreateNestedOneWithoutStudentsInInput
    instansi: InstansiCreateNestedOneWithoutStudentInput
    event?: CalendarCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutUserInput = {
    id?: string
    majorId?: string | null
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    startYearId: string
    instansiId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutStudentsInput
    event?: CalendarUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutUserInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type TeacherCreateWithoutUserInput = {
    id?: string
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: string | null
    tmtGol?: string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    classRoom?: ClassRoomCreateNestedManyWithoutWaliInput
    instansi: InstansiCreateNestedOneWithoutTeacherInput
    event?: CalendarCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutUserInput = {
    id?: string
    instansiId: string
    eventIds?: TeacherCreateeventIdsInput | Enumerable<string>
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: string | null
    tmtGol?: string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutWaliInput
    event?: CalendarUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutUserInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    key?: EnumRolesFieldUpdateOperationsInput | Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instansi?: InstansiUpdateOneRequiredWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    key?: EnumRolesFieldUpdateOperationsInput | Roles
    instansiId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalUpsertWithoutUserInput = {
    update: XOR<PersonalUpdateWithoutUserInput, PersonalUncheckedUpdateWithoutUserInput>
    create: XOR<PersonalCreateWithoutUserInput, PersonalUncheckedCreateWithoutUserInput>
  }

  export type PersonalUpdateWithoutUserInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: BoolFieldUpdateOperationsInput | boolean
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: StringFieldUpdateOperationsInput | string
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: StringFieldUpdateOperationsInput | string
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    father?: FamilyTreeUpdateManyWithoutFatherNestedInput
    mother?: FamilyTreeUpdateManyWithoutMotherNestedInput
    wali?: FamilyTreeUpdateManyWithoutWaliNestedInput
    child?: FamilyTreeChildUpdateOneWithoutPersonalNestedInput
  }

  export type PersonalUncheckedUpdateWithoutUserInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: BoolFieldUpdateOperationsInput | boolean
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: StringFieldUpdateOperationsInput | string
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: StringFieldUpdateOperationsInput | string
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    father?: FamilyTreeUncheckedUpdateManyWithoutFatherNestedInput
    mother?: FamilyTreeUncheckedUpdateManyWithoutMotherNestedInput
    wali?: FamilyTreeUncheckedUpdateManyWithoutWaliNestedInput
    child?: FamilyTreeChildUncheckedUpdateOneWithoutPersonalNestedInput
  }

  export type StudentUpsertWithoutUserInput = {
    update: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type StudentUpdateWithoutUserInput = {
    major?: KonsentrasiKeahlianUpdateOneWithoutStudentNestedInput
    classRoom?: ClassRoomUpdateManyWithoutStudentsNestedInput
    startYear?: SchoolYearUpdateOneRequiredWithoutStudentsInNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutStudentNestedInput
    event?: CalendarUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutUserInput = {
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomIds?: StudentUpdateclassRoomIdsInput | Enumerable<string>
    startYearId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: StudentUpdateeventIdsInput | Enumerable<string>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutStudentsNestedInput
    event?: CalendarUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type TeacherUpsertWithoutUserInput = {
    update: XOR<TeacherUpdateWithoutUserInput, TeacherUncheckedUpdateWithoutUserInput>
    create: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
  }

  export type TeacherUpdateWithoutUserInput = {
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableStringFieldUpdateOperationsInput | string | null
    tmtGol?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    classRoom?: ClassRoomUpdateManyWithoutWaliNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutTeacherNestedInput
    event?: CalendarUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutUserInput = {
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: TeacherUpdateeventIdsInput | Enumerable<string>
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableStringFieldUpdateOperationsInput | string | null
    tmtGol?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutWaliNestedInput
    event?: CalendarUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type UserCreateWithoutPersonalInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPersonalInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: string | null
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPersonalInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPersonalInput, UserUncheckedCreateWithoutPersonalInput>
  }

  export type FamilyTreeCreateWithoutFatherInput = {
    id?: string
    nokk: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    mother?: PersonalCreateNestedOneWithoutMotherInput
    wali?: PersonalCreateNestedOneWithoutWaliInput
    childs?: FamilyTreeChildCreateNestedManyWithoutKkInput
  }

  export type FamilyTreeUncheckedCreateWithoutFatherInput = {
    id?: string
    nokk: string
    motherId?: string | null
    waliId?: string | null
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    childs?: FamilyTreeChildUncheckedCreateNestedManyWithoutKkInput
  }

  export type FamilyTreeCreateOrConnectWithoutFatherInput = {
    where: FamilyTreeWhereUniqueInput
    create: XOR<FamilyTreeCreateWithoutFatherInput, FamilyTreeUncheckedCreateWithoutFatherInput>
  }

  export type FamilyTreeCreateManyFatherInputEnvelope = {
    data: Enumerable<FamilyTreeCreateManyFatherInput>
  }

  export type FamilyTreeCreateWithoutMotherInput = {
    id?: string
    nokk: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    father?: PersonalCreateNestedOneWithoutFatherInput
    wali?: PersonalCreateNestedOneWithoutWaliInput
    childs?: FamilyTreeChildCreateNestedManyWithoutKkInput
  }

  export type FamilyTreeUncheckedCreateWithoutMotherInput = {
    id?: string
    nokk: string
    fatherId?: string | null
    waliId?: string | null
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    childs?: FamilyTreeChildUncheckedCreateNestedManyWithoutKkInput
  }

  export type FamilyTreeCreateOrConnectWithoutMotherInput = {
    where: FamilyTreeWhereUniqueInput
    create: XOR<FamilyTreeCreateWithoutMotherInput, FamilyTreeUncheckedCreateWithoutMotherInput>
  }

  export type FamilyTreeCreateManyMotherInputEnvelope = {
    data: Enumerable<FamilyTreeCreateManyMotherInput>
  }

  export type FamilyTreeCreateWithoutWaliInput = {
    id?: string
    nokk: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    father?: PersonalCreateNestedOneWithoutFatherInput
    mother?: PersonalCreateNestedOneWithoutMotherInput
    childs?: FamilyTreeChildCreateNestedManyWithoutKkInput
  }

  export type FamilyTreeUncheckedCreateWithoutWaliInput = {
    id?: string
    nokk: string
    fatherId?: string | null
    motherId?: string | null
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    childs?: FamilyTreeChildUncheckedCreateNestedManyWithoutKkInput
  }

  export type FamilyTreeCreateOrConnectWithoutWaliInput = {
    where: FamilyTreeWhereUniqueInput
    create: XOR<FamilyTreeCreateWithoutWaliInput, FamilyTreeUncheckedCreateWithoutWaliInput>
  }

  export type FamilyTreeCreateManyWaliInputEnvelope = {
    data: Enumerable<FamilyTreeCreateManyWaliInput>
  }

  export type FamilyTreeChildCreateWithoutPersonalInput = {
    id?: string
    no: number
    type: ChildType
    kk: FamilyTreeCreateNestedOneWithoutChildsInput
  }

  export type FamilyTreeChildUncheckedCreateWithoutPersonalInput = {
    id?: string
    no: number
    type: ChildType
    kkId: string
  }

  export type FamilyTreeChildCreateOrConnectWithoutPersonalInput = {
    where: FamilyTreeChildWhereUniqueInput
    create: XOR<FamilyTreeChildCreateWithoutPersonalInput, FamilyTreeChildUncheckedCreateWithoutPersonalInput>
  }

  export type BornUpdateInput = {
    place?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUpsertInput = {
    set: AddressCreateInput | null
    update: AddressUpdateInput
  }

  export type UserUpsertWithoutPersonalInput = {
    update: XOR<UserUpdateWithoutPersonalInput, UserUncheckedUpdateWithoutPersonalInput>
    create: XOR<UserCreateWithoutPersonalInput, UserUncheckedCreateWithoutPersonalInput>
  }

  export type UserUpdateWithoutPersonalInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPersonalInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
  }

  export type FamilyTreeUpsertWithWhereUniqueWithoutFatherInput = {
    where: FamilyTreeWhereUniqueInput
    update: XOR<FamilyTreeUpdateWithoutFatherInput, FamilyTreeUncheckedUpdateWithoutFatherInput>
    create: XOR<FamilyTreeCreateWithoutFatherInput, FamilyTreeUncheckedCreateWithoutFatherInput>
  }

  export type FamilyTreeUpdateWithWhereUniqueWithoutFatherInput = {
    where: FamilyTreeWhereUniqueInput
    data: XOR<FamilyTreeUpdateWithoutFatherInput, FamilyTreeUncheckedUpdateWithoutFatherInput>
  }

  export type FamilyTreeUpdateManyWithWhereWithoutFatherInput = {
    where: FamilyTreeScalarWhereInput
    data: XOR<FamilyTreeUpdateManyMutationInput, FamilyTreeUncheckedUpdateManyWithoutFatherInput>
  }

  export type FamilyTreeScalarWhereInput = {
    AND?: Enumerable<FamilyTreeScalarWhereInput>
    OR?: Enumerable<FamilyTreeScalarWhereInput>
    NOT?: Enumerable<FamilyTreeScalarWhereInput>
    id?: StringFilter | string
    nokk?: StringFilter | string
    fatherId?: StringNullableFilter | string | null
    motherId?: StringNullableFilter | string | null
    waliId?: StringNullableFilter | string | null
  }

  export type FamilyTreeUpsertWithWhereUniqueWithoutMotherInput = {
    where: FamilyTreeWhereUniqueInput
    update: XOR<FamilyTreeUpdateWithoutMotherInput, FamilyTreeUncheckedUpdateWithoutMotherInput>
    create: XOR<FamilyTreeCreateWithoutMotherInput, FamilyTreeUncheckedCreateWithoutMotherInput>
  }

  export type FamilyTreeUpdateWithWhereUniqueWithoutMotherInput = {
    where: FamilyTreeWhereUniqueInput
    data: XOR<FamilyTreeUpdateWithoutMotherInput, FamilyTreeUncheckedUpdateWithoutMotherInput>
  }

  export type FamilyTreeUpdateManyWithWhereWithoutMotherInput = {
    where: FamilyTreeScalarWhereInput
    data: XOR<FamilyTreeUpdateManyMutationInput, FamilyTreeUncheckedUpdateManyWithoutMotherInput>
  }

  export type FamilyTreeUpsertWithWhereUniqueWithoutWaliInput = {
    where: FamilyTreeWhereUniqueInput
    update: XOR<FamilyTreeUpdateWithoutWaliInput, FamilyTreeUncheckedUpdateWithoutWaliInput>
    create: XOR<FamilyTreeCreateWithoutWaliInput, FamilyTreeUncheckedCreateWithoutWaliInput>
  }

  export type FamilyTreeUpdateWithWhereUniqueWithoutWaliInput = {
    where: FamilyTreeWhereUniqueInput
    data: XOR<FamilyTreeUpdateWithoutWaliInput, FamilyTreeUncheckedUpdateWithoutWaliInput>
  }

  export type FamilyTreeUpdateManyWithWhereWithoutWaliInput = {
    where: FamilyTreeScalarWhereInput
    data: XOR<FamilyTreeUpdateManyMutationInput, FamilyTreeUncheckedUpdateManyWithoutWaliInput>
  }

  export type FamilyTreeChildUpsertWithoutPersonalInput = {
    update: XOR<FamilyTreeChildUpdateWithoutPersonalInput, FamilyTreeChildUncheckedUpdateWithoutPersonalInput>
    create: XOR<FamilyTreeChildCreateWithoutPersonalInput, FamilyTreeChildUncheckedCreateWithoutPersonalInput>
  }

  export type FamilyTreeChildUpdateWithoutPersonalInput = {
    no?: IntFieldUpdateOperationsInput | number
    type?: EnumChildTypeFieldUpdateOperationsInput | ChildType
    kk?: FamilyTreeUpdateOneRequiredWithoutChildsNestedInput
  }

  export type FamilyTreeChildUncheckedUpdateWithoutPersonalInput = {
    no?: IntFieldUpdateOperationsInput | number
    type?: EnumChildTypeFieldUpdateOperationsInput | ChildType
    kkId?: StringFieldUpdateOperationsInput | string
  }

  export type PersonalCreateWithoutFatherInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign: boolean
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email: string
    belajarId?: string | null
    nophone: string
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    user?: UserCreateNestedOneWithoutPersonalInput
    mother?: FamilyTreeCreateNestedManyWithoutMotherInput
    wali?: FamilyTreeCreateNestedManyWithoutWaliInput
    child?: FamilyTreeChildCreateNestedOneWithoutPersonalInput
  }

  export type PersonalUncheckedCreateWithoutFatherInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    userId?: string | null
    fullname: string
    gender: Gender
    foreign: boolean
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email: string
    belajarId?: string | null
    nophone: string
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    mother?: FamilyTreeUncheckedCreateNestedManyWithoutMotherInput
    wali?: FamilyTreeUncheckedCreateNestedManyWithoutWaliInput
    child?: FamilyTreeChildUncheckedCreateNestedOneWithoutPersonalInput
  }

  export type PersonalCreateOrConnectWithoutFatherInput = {
    where: PersonalWhereUniqueInput
    create: XOR<PersonalCreateWithoutFatherInput, PersonalUncheckedCreateWithoutFatherInput>
  }

  export type PersonalCreateWithoutMotherInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign: boolean
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email: string
    belajarId?: string | null
    nophone: string
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    user?: UserCreateNestedOneWithoutPersonalInput
    father?: FamilyTreeCreateNestedManyWithoutFatherInput
    wali?: FamilyTreeCreateNestedManyWithoutWaliInput
    child?: FamilyTreeChildCreateNestedOneWithoutPersonalInput
  }

  export type PersonalUncheckedCreateWithoutMotherInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    userId?: string | null
    fullname: string
    gender: Gender
    foreign: boolean
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email: string
    belajarId?: string | null
    nophone: string
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    father?: FamilyTreeUncheckedCreateNestedManyWithoutFatherInput
    wali?: FamilyTreeUncheckedCreateNestedManyWithoutWaliInput
    child?: FamilyTreeChildUncheckedCreateNestedOneWithoutPersonalInput
  }

  export type PersonalCreateOrConnectWithoutMotherInput = {
    where: PersonalWhereUniqueInput
    create: XOR<PersonalCreateWithoutMotherInput, PersonalUncheckedCreateWithoutMotherInput>
  }

  export type PersonalCreateWithoutWaliInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign: boolean
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email: string
    belajarId?: string | null
    nophone: string
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    user?: UserCreateNestedOneWithoutPersonalInput
    father?: FamilyTreeCreateNestedManyWithoutFatherInput
    mother?: FamilyTreeCreateNestedManyWithoutMotherInput
    child?: FamilyTreeChildCreateNestedOneWithoutPersonalInput
  }

  export type PersonalUncheckedCreateWithoutWaliInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    userId?: string | null
    fullname: string
    gender: Gender
    foreign: boolean
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email: string
    belajarId?: string | null
    nophone: string
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    father?: FamilyTreeUncheckedCreateNestedManyWithoutFatherInput
    mother?: FamilyTreeUncheckedCreateNestedManyWithoutMotherInput
    child?: FamilyTreeChildUncheckedCreateNestedOneWithoutPersonalInput
  }

  export type PersonalCreateOrConnectWithoutWaliInput = {
    where: PersonalWhereUniqueInput
    create: XOR<PersonalCreateWithoutWaliInput, PersonalUncheckedCreateWithoutWaliInput>
  }

  export type FamilyTreeChildCreateWithoutKkInput = {
    id?: string
    no: number
    type: ChildType
    personal: PersonalCreateNestedOneWithoutChildInput
  }

  export type FamilyTreeChildUncheckedCreateWithoutKkInput = {
    id?: string
    no: number
    type: ChildType
    personalId: string
  }

  export type FamilyTreeChildCreateOrConnectWithoutKkInput = {
    where: FamilyTreeChildWhereUniqueInput
    create: XOR<FamilyTreeChildCreateWithoutKkInput, FamilyTreeChildUncheckedCreateWithoutKkInput>
  }

  export type FamilyTreeChildCreateManyKkInputEnvelope = {
    data: Enumerable<FamilyTreeChildCreateManyKkInput>
  }

  export type PersonalUpsertWithoutFatherInput = {
    update: XOR<PersonalUpdateWithoutFatherInput, PersonalUncheckedUpdateWithoutFatherInput>
    create: XOR<PersonalCreateWithoutFatherInput, PersonalUncheckedCreateWithoutFatherInput>
  }

  export type PersonalUpdateWithoutFatherInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: BoolFieldUpdateOperationsInput | boolean
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: StringFieldUpdateOperationsInput | string
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: StringFieldUpdateOperationsInput | string
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    user?: UserUpdateOneWithoutPersonalNestedInput
    mother?: FamilyTreeUpdateManyWithoutMotherNestedInput
    wali?: FamilyTreeUpdateManyWithoutWaliNestedInput
    child?: FamilyTreeChildUpdateOneWithoutPersonalNestedInput
  }

  export type PersonalUncheckedUpdateWithoutFatherInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: BoolFieldUpdateOperationsInput | boolean
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: StringFieldUpdateOperationsInput | string
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: StringFieldUpdateOperationsInput | string
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    mother?: FamilyTreeUncheckedUpdateManyWithoutMotherNestedInput
    wali?: FamilyTreeUncheckedUpdateManyWithoutWaliNestedInput
    child?: FamilyTreeChildUncheckedUpdateOneWithoutPersonalNestedInput
  }

  export type PersonalUpsertWithoutMotherInput = {
    update: XOR<PersonalUpdateWithoutMotherInput, PersonalUncheckedUpdateWithoutMotherInput>
    create: XOR<PersonalCreateWithoutMotherInput, PersonalUncheckedCreateWithoutMotherInput>
  }

  export type PersonalUpdateWithoutMotherInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: BoolFieldUpdateOperationsInput | boolean
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: StringFieldUpdateOperationsInput | string
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: StringFieldUpdateOperationsInput | string
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    user?: UserUpdateOneWithoutPersonalNestedInput
    father?: FamilyTreeUpdateManyWithoutFatherNestedInput
    wali?: FamilyTreeUpdateManyWithoutWaliNestedInput
    child?: FamilyTreeChildUpdateOneWithoutPersonalNestedInput
  }

  export type PersonalUncheckedUpdateWithoutMotherInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: BoolFieldUpdateOperationsInput | boolean
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: StringFieldUpdateOperationsInput | string
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: StringFieldUpdateOperationsInput | string
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    father?: FamilyTreeUncheckedUpdateManyWithoutFatherNestedInput
    wali?: FamilyTreeUncheckedUpdateManyWithoutWaliNestedInput
    child?: FamilyTreeChildUncheckedUpdateOneWithoutPersonalNestedInput
  }

  export type PersonalUpsertWithoutWaliInput = {
    update: XOR<PersonalUpdateWithoutWaliInput, PersonalUncheckedUpdateWithoutWaliInput>
    create: XOR<PersonalCreateWithoutWaliInput, PersonalUncheckedCreateWithoutWaliInput>
  }

  export type PersonalUpdateWithoutWaliInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: BoolFieldUpdateOperationsInput | boolean
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: StringFieldUpdateOperationsInput | string
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: StringFieldUpdateOperationsInput | string
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    user?: UserUpdateOneWithoutPersonalNestedInput
    father?: FamilyTreeUpdateManyWithoutFatherNestedInput
    mother?: FamilyTreeUpdateManyWithoutMotherNestedInput
    child?: FamilyTreeChildUpdateOneWithoutPersonalNestedInput
  }

  export type PersonalUncheckedUpdateWithoutWaliInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: BoolFieldUpdateOperationsInput | boolean
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: StringFieldUpdateOperationsInput | string
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: StringFieldUpdateOperationsInput | string
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    father?: FamilyTreeUncheckedUpdateManyWithoutFatherNestedInput
    mother?: FamilyTreeUncheckedUpdateManyWithoutMotherNestedInput
    child?: FamilyTreeChildUncheckedUpdateOneWithoutPersonalNestedInput
  }

  export type FamilyTreeChildUpsertWithWhereUniqueWithoutKkInput = {
    where: FamilyTreeChildWhereUniqueInput
    update: XOR<FamilyTreeChildUpdateWithoutKkInput, FamilyTreeChildUncheckedUpdateWithoutKkInput>
    create: XOR<FamilyTreeChildCreateWithoutKkInput, FamilyTreeChildUncheckedCreateWithoutKkInput>
  }

  export type FamilyTreeChildUpdateWithWhereUniqueWithoutKkInput = {
    where: FamilyTreeChildWhereUniqueInput
    data: XOR<FamilyTreeChildUpdateWithoutKkInput, FamilyTreeChildUncheckedUpdateWithoutKkInput>
  }

  export type FamilyTreeChildUpdateManyWithWhereWithoutKkInput = {
    where: FamilyTreeChildScalarWhereInput
    data: XOR<FamilyTreeChildUpdateManyMutationInput, FamilyTreeChildUncheckedUpdateManyWithoutChildsInput>
  }

  export type FamilyTreeChildScalarWhereInput = {
    AND?: Enumerable<FamilyTreeChildScalarWhereInput>
    OR?: Enumerable<FamilyTreeChildScalarWhereInput>
    NOT?: Enumerable<FamilyTreeChildScalarWhereInput>
    id?: StringFilter | string
    no?: IntFilter | number
    type?: EnumChildTypeFilter | ChildType
    kkId?: StringFilter | string
    personalId?: StringFilter | string
  }

  export type FamilyTreeCreateWithoutChildsInput = {
    id?: string
    nokk: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    father?: PersonalCreateNestedOneWithoutFatherInput
    mother?: PersonalCreateNestedOneWithoutMotherInput
    wali?: PersonalCreateNestedOneWithoutWaliInput
  }

  export type FamilyTreeUncheckedCreateWithoutChildsInput = {
    id?: string
    nokk: string
    fatherId?: string | null
    motherId?: string | null
    waliId?: string | null
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
  }

  export type FamilyTreeCreateOrConnectWithoutChildsInput = {
    where: FamilyTreeWhereUniqueInput
    create: XOR<FamilyTreeCreateWithoutChildsInput, FamilyTreeUncheckedCreateWithoutChildsInput>
  }

  export type PersonalCreateWithoutChildInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign: boolean
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email: string
    belajarId?: string | null
    nophone: string
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    user?: UserCreateNestedOneWithoutPersonalInput
    father?: FamilyTreeCreateNestedManyWithoutFatherInput
    mother?: FamilyTreeCreateNestedManyWithoutMotherInput
    wali?: FamilyTreeCreateNestedManyWithoutWaliInput
  }

  export type PersonalUncheckedCreateWithoutChildInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    userId?: string | null
    fullname: string
    gender: Gender
    foreign: boolean
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email: string
    belajarId?: string | null
    nophone: string
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    father?: FamilyTreeUncheckedCreateNestedManyWithoutFatherInput
    mother?: FamilyTreeUncheckedCreateNestedManyWithoutMotherInput
    wali?: FamilyTreeUncheckedCreateNestedManyWithoutWaliInput
  }

  export type PersonalCreateOrConnectWithoutChildInput = {
    where: PersonalWhereUniqueInput
    create: XOR<PersonalCreateWithoutChildInput, PersonalUncheckedCreateWithoutChildInput>
  }

  export type FamilyTreeUpsertWithoutChildsInput = {
    update: XOR<FamilyTreeUpdateWithoutChildsInput, FamilyTreeUncheckedUpdateWithoutChildsInput>
    create: XOR<FamilyTreeCreateWithoutChildsInput, FamilyTreeUncheckedCreateWithoutChildsInput>
  }

  export type FamilyTreeUpdateWithoutChildsInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    father?: PersonalUpdateOneWithoutFatherNestedInput
    mother?: PersonalUpdateOneWithoutMotherNestedInput
    wali?: PersonalUpdateOneWithoutWaliNestedInput
  }

  export type FamilyTreeUncheckedUpdateWithoutChildsInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    fatherId?: NullableStringFieldUpdateOperationsInput | string | null
    motherId?: NullableStringFieldUpdateOperationsInput | string | null
    waliId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
  }

  export type PersonalUpsertWithoutChildInput = {
    update: XOR<PersonalUpdateWithoutChildInput, PersonalUncheckedUpdateWithoutChildInput>
    create: XOR<PersonalCreateWithoutChildInput, PersonalUncheckedCreateWithoutChildInput>
  }

  export type PersonalUpdateWithoutChildInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: BoolFieldUpdateOperationsInput | boolean
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: StringFieldUpdateOperationsInput | string
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: StringFieldUpdateOperationsInput | string
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    user?: UserUpdateOneWithoutPersonalNestedInput
    father?: FamilyTreeUpdateManyWithoutFatherNestedInput
    mother?: FamilyTreeUpdateManyWithoutMotherNestedInput
    wali?: FamilyTreeUpdateManyWithoutWaliNestedInput
  }

  export type PersonalUncheckedUpdateWithoutChildInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: BoolFieldUpdateOperationsInput | boolean
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: StringFieldUpdateOperationsInput | string
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: StringFieldUpdateOperationsInput | string
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    father?: FamilyTreeUncheckedUpdateManyWithoutFatherNestedInput
    mother?: FamilyTreeUncheckedUpdateManyWithoutMotherNestedInput
    wali?: FamilyTreeUncheckedUpdateManyWithoutWaliNestedInput
  }

  export type UserCreateWithoutStudentInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    personal?: PersonalCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudentInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: string | null
    personal?: PersonalUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
  }

  export type KonsentrasiKeahlianCreateWithoutStudentInput = {
    id?: string
    code: string
    name: string
    tahun: number
    createdAt?: Date | string
    updatedAt?: Date | string
    program: ProgramKeahlianCreateNestedOneWithoutKonsentrasiInput
    instansi?: InstansiCreateNestedManyWithoutMajorsInput
  }

  export type KonsentrasiKeahlianUncheckedCreateWithoutStudentInput = {
    id?: string
    code: string
    name: string
    programId: string
    tahun: number
    createdAt?: Date | string
    updatedAt?: Date | string
    instansiIds?: KonsentrasiKeahlianCreateinstansiIdsInput | Enumerable<string>
    instansi?: InstansiUncheckedCreateNestedManyWithoutMajorsInput
  }

  export type KonsentrasiKeahlianCreateOrConnectWithoutStudentInput = {
    where: KonsentrasiKeahlianWhereUniqueInput
    create: XOR<KonsentrasiKeahlianCreateWithoutStudentInput, KonsentrasiKeahlianUncheckedCreateWithoutStudentInput>
  }

  export type ClassRoomCreateWithoutStudentsInput = {
    id?: string
    name: string
    year: SchoolYearCreateNestedOneWithoutClassRoomInput
    wali: TeacherCreateNestedOneWithoutClassRoomInput
    event?: CalendarCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    yearId: string
    waliId: string
    studentIds?: ClassRoomCreatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomCreateeventIdsInput | Enumerable<string>
    event?: CalendarUncheckedCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomCreateOrConnectWithoutStudentsInput = {
    where: ClassRoomWhereUniqueInput
    create: XOR<ClassRoomCreateWithoutStudentsInput, ClassRoomUncheckedCreateWithoutStudentsInput>
  }

  export type SchoolYearCreateWithoutStudentsInInput = {
    id?: string
    year: number
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    instansi: InstansiCreateNestedOneWithoutSchoolYearInput
    classRoom?: ClassRoomCreateNestedManyWithoutYearInput
    calendar?: CalendarCreateNestedManyWithoutRefInput
  }

  export type SchoolYearUncheckedCreateWithoutStudentsInInput = {
    id?: string
    year: number
    instansiId: string
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutYearInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutRefInput
  }

  export type SchoolYearCreateOrConnectWithoutStudentsInInput = {
    where: SchoolYearWhereUniqueInput
    create: XOR<SchoolYearCreateWithoutStudentsInInput, SchoolYearUncheckedCreateWithoutStudentsInInput>
  }

  export type InstansiCreateWithoutStudentInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    majors?: KonsentrasiKeahlianCreateNestedManyWithoutInstansiInput
    role?: RoleCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearCreateNestedManyWithoutInstansiInput
    teacher?: TeacherCreateNestedManyWithoutInstansiInput
  }

  export type InstansiUncheckedCreateWithoutStudentInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    majorIds?: InstansiCreatemajorIdsInput | Enumerable<string>
    createdAt?: Date | string
    updatedAt?: Date | string
    majors?: KonsentrasiKeahlianUncheckedCreateNestedManyWithoutInstansiInput
    role?: RoleUncheckedCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearUncheckedCreateNestedManyWithoutInstansiInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutInstansiInput
  }

  export type InstansiCreateOrConnectWithoutStudentInput = {
    where: InstansiWhereUniqueInput
    create: XOR<InstansiCreateWithoutStudentInput, InstansiUncheckedCreateWithoutStudentInput>
  }

  export type CalendarCreateWithoutStudentInput = {
    id?: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    ref: SchoolYearCreateNestedOneWithoutCalendarInput
    classRoom?: ClassRoomCreateNestedManyWithoutEventInput
    teacher?: TeacherCreateNestedManyWithoutEventInput
  }

  export type CalendarUncheckedCreateWithoutStudentInput = {
    id?: string
    refId: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    classRoomIds?: CalendarCreateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarCreatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarCreateteacherIdsInput | Enumerable<string>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutEventInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutEventInput
  }

  export type CalendarCreateOrConnectWithoutStudentInput = {
    where: CalendarWhereUniqueInput
    create: XOR<CalendarCreateWithoutStudentInput, CalendarUncheckedCreateWithoutStudentInput>
  }

  export type UserUpsertWithoutStudentInput = {
    update: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
  }

  export type UserUpdateWithoutStudentInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    personal?: PersonalUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    personal?: PersonalUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
  }

  export type KonsentrasiKeahlianUpsertWithoutStudentInput = {
    update: XOR<KonsentrasiKeahlianUpdateWithoutStudentInput, KonsentrasiKeahlianUncheckedUpdateWithoutStudentInput>
    create: XOR<KonsentrasiKeahlianCreateWithoutStudentInput, KonsentrasiKeahlianUncheckedCreateWithoutStudentInput>
  }

  export type KonsentrasiKeahlianUpdateWithoutStudentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramKeahlianUpdateOneRequiredWithoutKonsentrasiNestedInput
    instansi?: InstansiUpdateManyWithoutMajorsNestedInput
  }

  export type KonsentrasiKeahlianUncheckedUpdateWithoutStudentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instansiIds?: KonsentrasiKeahlianUpdateinstansiIdsInput | Enumerable<string>
    instansi?: InstansiUncheckedUpdateManyWithoutMajorsNestedInput
  }

  export type ClassRoomUpsertWithWhereUniqueWithoutStudentsInput = {
    where: ClassRoomWhereUniqueInput
    update: XOR<ClassRoomUpdateWithoutStudentsInput, ClassRoomUncheckedUpdateWithoutStudentsInput>
    create: XOR<ClassRoomCreateWithoutStudentsInput, ClassRoomUncheckedCreateWithoutStudentsInput>
  }

  export type ClassRoomUpdateWithWhereUniqueWithoutStudentsInput = {
    where: ClassRoomWhereUniqueInput
    data: XOR<ClassRoomUpdateWithoutStudentsInput, ClassRoomUncheckedUpdateWithoutStudentsInput>
  }

  export type ClassRoomUpdateManyWithWhereWithoutStudentsInput = {
    where: ClassRoomScalarWhereInput
    data: XOR<ClassRoomUpdateManyMutationInput, ClassRoomUncheckedUpdateManyWithoutClassRoomInput>
  }

  export type ClassRoomScalarWhereInput = {
    AND?: Enumerable<ClassRoomScalarWhereInput>
    OR?: Enumerable<ClassRoomScalarWhereInput>
    NOT?: Enumerable<ClassRoomScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    yearId?: StringFilter | string
    waliId?: StringFilter | string
    studentIds?: StringNullableListFilter
    eventIds?: StringNullableListFilter
  }

  export type SchoolYearUpsertWithoutStudentsInInput = {
    update: XOR<SchoolYearUpdateWithoutStudentsInInput, SchoolYearUncheckedUpdateWithoutStudentsInInput>
    create: XOR<SchoolYearCreateWithoutStudentsInInput, SchoolYearUncheckedCreateWithoutStudentsInInput>
  }

  export type SchoolYearUpdateWithoutStudentsInInput = {
    year?: IntFieldUpdateOperationsInput | number
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    instansi?: InstansiUpdateOneRequiredWithoutSchoolYearNestedInput
    classRoom?: ClassRoomUpdateManyWithoutYearNestedInput
    calendar?: CalendarUpdateManyWithoutRefNestedInput
  }

  export type SchoolYearUncheckedUpdateWithoutStudentsInInput = {
    year?: IntFieldUpdateOperationsInput | number
    instansiId?: StringFieldUpdateOperationsInput | string
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutYearNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutRefNestedInput
  }

  export type InstansiUpsertWithoutStudentInput = {
    update: XOR<InstansiUpdateWithoutStudentInput, InstansiUncheckedUpdateWithoutStudentInput>
    create: XOR<InstansiCreateWithoutStudentInput, InstansiUncheckedCreateWithoutStudentInput>
  }

  export type InstansiUpdateWithoutStudentInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    majors?: KonsentrasiKeahlianUpdateManyWithoutInstansiNestedInput
    role?: RoleUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUpdateManyWithoutInstansiNestedInput
  }

  export type InstansiUncheckedUpdateWithoutStudentInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    majorIds?: InstansiUpdatemajorIdsInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    majors?: KonsentrasiKeahlianUncheckedUpdateManyWithoutInstansiNestedInput
    role?: RoleUncheckedUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUncheckedUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutInstansiNestedInput
  }

  export type CalendarUpsertWithWhereUniqueWithoutStudentInput = {
    where: CalendarWhereUniqueInput
    update: XOR<CalendarUpdateWithoutStudentInput, CalendarUncheckedUpdateWithoutStudentInput>
    create: XOR<CalendarCreateWithoutStudentInput, CalendarUncheckedCreateWithoutStudentInput>
  }

  export type CalendarUpdateWithWhereUniqueWithoutStudentInput = {
    where: CalendarWhereUniqueInput
    data: XOR<CalendarUpdateWithoutStudentInput, CalendarUncheckedUpdateWithoutStudentInput>
  }

  export type CalendarUpdateManyWithWhereWithoutStudentInput = {
    where: CalendarScalarWhereInput
    data: XOR<CalendarUpdateManyMutationInput, CalendarUncheckedUpdateManyWithoutEventInput>
  }

  export type CalendarScalarWhereInput = {
    AND?: Enumerable<CalendarScalarWhereInput>
    OR?: Enumerable<CalendarScalarWhereInput>
    NOT?: Enumerable<CalendarScalarWhereInput>
    id?: StringFilter | string
    refId?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    start?: DateTimeFilter | Date | string
    end?: DateTimeNullableFilter | Date | string | null
    color?: StringFilter | string
    classRoomIds?: StringNullableListFilter
    studentIds?: StringNullableListFilter
    teacherIds?: StringNullableListFilter
  }

  export type UserCreateWithoutTeacherInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    personal?: PersonalCreateNestedOneWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeacherInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: string | null
    personal?: PersonalUncheckedCreateNestedOneWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeacherInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
  }

  export type ClassRoomCreateWithoutWaliInput = {
    id?: string
    name: string
    year: SchoolYearCreateNestedOneWithoutClassRoomInput
    students?: StudentCreateNestedManyWithoutClassRoomInput
    event?: CalendarCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomUncheckedCreateWithoutWaliInput = {
    id?: string
    name: string
    yearId: string
    studentIds?: ClassRoomCreatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomCreateeventIdsInput | Enumerable<string>
    students?: StudentUncheckedCreateNestedManyWithoutClassRoomInput
    event?: CalendarUncheckedCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomCreateOrConnectWithoutWaliInput = {
    where: ClassRoomWhereUniqueInput
    create: XOR<ClassRoomCreateWithoutWaliInput, ClassRoomUncheckedCreateWithoutWaliInput>
  }

  export type ClassRoomCreateManyWaliInputEnvelope = {
    data: Enumerable<ClassRoomCreateManyWaliInput>
  }

  export type InstansiCreateWithoutTeacherInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    majors?: KonsentrasiKeahlianCreateNestedManyWithoutInstansiInput
    role?: RoleCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearCreateNestedManyWithoutInstansiInput
    student?: StudentCreateNestedManyWithoutInstansiInput
  }

  export type InstansiUncheckedCreateWithoutTeacherInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    majorIds?: InstansiCreatemajorIdsInput | Enumerable<string>
    createdAt?: Date | string
    updatedAt?: Date | string
    majors?: KonsentrasiKeahlianUncheckedCreateNestedManyWithoutInstansiInput
    role?: RoleUncheckedCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearUncheckedCreateNestedManyWithoutInstansiInput
    student?: StudentUncheckedCreateNestedManyWithoutInstansiInput
  }

  export type InstansiCreateOrConnectWithoutTeacherInput = {
    where: InstansiWhereUniqueInput
    create: XOR<InstansiCreateWithoutTeacherInput, InstansiUncheckedCreateWithoutTeacherInput>
  }

  export type CalendarCreateWithoutTeacherInput = {
    id?: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    ref: SchoolYearCreateNestedOneWithoutCalendarInput
    classRoom?: ClassRoomCreateNestedManyWithoutEventInput
    student?: StudentCreateNestedManyWithoutEventInput
  }

  export type CalendarUncheckedCreateWithoutTeacherInput = {
    id?: string
    refId: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    classRoomIds?: CalendarCreateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarCreatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarCreateteacherIdsInput | Enumerable<string>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutEventInput
    student?: StudentUncheckedCreateNestedManyWithoutEventInput
  }

  export type CalendarCreateOrConnectWithoutTeacherInput = {
    where: CalendarWhereUniqueInput
    create: XOR<CalendarCreateWithoutTeacherInput, CalendarUncheckedCreateWithoutTeacherInput>
  }

  export type EducationUpdateManyInput = {
    where: EducationWhereInput
    data: EducationUpdateInput
  }

  export type EducationDeleteManyInput = {
    where: EducationWhereInput
  }

  export type TrainingUpdateManyInput = {
    where: TrainingWhereInput
    data: TrainingUpdateInput
  }

  export type TrainingDeleteManyInput = {
    where: TrainingWhereInput
  }

  export type EmploymentUpdateManyInput = {
    where: EmploymentWhereInput
    data: EmploymentUpdateInput
  }

  export type EmploymentDeleteManyInput = {
    where: EmploymentWhereInput
  }

  export type ProfessionUpdateManyInput = {
    where: ProfessionWhereInput
    data: ProfessionUpdateInput
  }

  export type ProfessionDeleteManyInput = {
    where: ProfessionWhereInput
  }

  export type OverseasUpdateManyInput = {
    where: OverseasWhereInput
    data: OverseasUpdateInput
  }

  export type OverseasDeleteManyInput = {
    where: OverseasWhereInput
  }

  export type ScientificUpdateManyInput = {
    where: ScientificWhereInput
    data: ScientificUpdateInput
  }

  export type ScientificDeleteManyInput = {
    where: ScientificWhereInput
  }

  export type OrganizationUpdateManyInput = {
    where: OrganizationWhereInput
    data: OrganizationUpdateInput
  }

  export type OrganizationDeleteManyInput = {
    where: OrganizationWhereInput
  }

  export type PapersUpdateManyInput = {
    where: PapersWhereInput
    data: PapersUpdateInput
  }

  export type PapersDeleteManyInput = {
    where: PapersWhereInput
  }

  export type InnovationUpdateManyInput = {
    where: InnovationWhereInput
    data: InnovationUpdateInput
  }

  export type InnovationDeleteManyInput = {
    where: InnovationWhereInput
  }

  export type AwardUpdateManyInput = {
    where: AwardWhereInput
    data: AwardUpdateInput
  }

  export type AwardDeleteManyInput = {
    where: AwardWhereInput
  }

  export type SourcePersonUpdateManyInput = {
    where: SourcePersonWhereInput
    data: SourcePersonUpdateInput
  }

  export type SourcePersonDeleteManyInput = {
    where: SourcePersonWhereInput
  }

  export type ContestUpdateManyInput = {
    where: ContestWhereInput
    data: ContestUpdateInput
  }

  export type ContestDeleteManyInput = {
    where: ContestWhereInput
  }

  export type DocumentsUpdateManyInput = {
    where: DocumentsWhereInput
    data: DocumentsUpdateInput
  }

  export type DocumentsDeleteManyInput = {
    where: DocumentsWhereInput
  }

  export type AdditionalUpdateManyInput = {
    where: AdditionalWhereInput
    data: AdditionalUpdateInput
  }

  export type AdditionalDeleteManyInput = {
    where: AdditionalWhereInput
  }

  export type UserUpsertWithoutTeacherInput = {
    update: XOR<UserUpdateWithoutTeacherInput, UserUncheckedUpdateWithoutTeacherInput>
    create: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
  }

  export type UserUpdateWithoutTeacherInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    personal?: PersonalUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeacherInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    personal?: PersonalUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ClassRoomUpsertWithWhereUniqueWithoutWaliInput = {
    where: ClassRoomWhereUniqueInput
    update: XOR<ClassRoomUpdateWithoutWaliInput, ClassRoomUncheckedUpdateWithoutWaliInput>
    create: XOR<ClassRoomCreateWithoutWaliInput, ClassRoomUncheckedCreateWithoutWaliInput>
  }

  export type ClassRoomUpdateWithWhereUniqueWithoutWaliInput = {
    where: ClassRoomWhereUniqueInput
    data: XOR<ClassRoomUpdateWithoutWaliInput, ClassRoomUncheckedUpdateWithoutWaliInput>
  }

  export type ClassRoomUpdateManyWithWhereWithoutWaliInput = {
    where: ClassRoomScalarWhereInput
    data: XOR<ClassRoomUpdateManyMutationInput, ClassRoomUncheckedUpdateManyWithoutClassRoomInput>
  }

  export type InstansiUpsertWithoutTeacherInput = {
    update: XOR<InstansiUpdateWithoutTeacherInput, InstansiUncheckedUpdateWithoutTeacherInput>
    create: XOR<InstansiCreateWithoutTeacherInput, InstansiUncheckedCreateWithoutTeacherInput>
  }

  export type InstansiUpdateWithoutTeacherInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    majors?: KonsentrasiKeahlianUpdateManyWithoutInstansiNestedInput
    role?: RoleUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUpdateManyWithoutInstansiNestedInput
    student?: StudentUpdateManyWithoutInstansiNestedInput
  }

  export type InstansiUncheckedUpdateWithoutTeacherInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    majorIds?: InstansiUpdatemajorIdsInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    majors?: KonsentrasiKeahlianUncheckedUpdateManyWithoutInstansiNestedInput
    role?: RoleUncheckedUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUncheckedUpdateManyWithoutInstansiNestedInput
    student?: StudentUncheckedUpdateManyWithoutInstansiNestedInput
  }

  export type CalendarUpsertWithWhereUniqueWithoutTeacherInput = {
    where: CalendarWhereUniqueInput
    update: XOR<CalendarUpdateWithoutTeacherInput, CalendarUncheckedUpdateWithoutTeacherInput>
    create: XOR<CalendarCreateWithoutTeacherInput, CalendarUncheckedCreateWithoutTeacherInput>
  }

  export type CalendarUpdateWithWhereUniqueWithoutTeacherInput = {
    where: CalendarWhereUniqueInput
    data: XOR<CalendarUpdateWithoutTeacherInput, CalendarUncheckedUpdateWithoutTeacherInput>
  }

  export type CalendarUpdateManyWithWhereWithoutTeacherInput = {
    where: CalendarScalarWhereInput
    data: XOR<CalendarUpdateManyMutationInput, CalendarUncheckedUpdateManyWithoutEventInput>
  }

  export type SchoolYearCreateWithoutClassRoomInput = {
    id?: string
    year: number
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    instansi: InstansiCreateNestedOneWithoutSchoolYearInput
    studentsIn?: StudentCreateNestedManyWithoutStartYearInput
    calendar?: CalendarCreateNestedManyWithoutRefInput
  }

  export type SchoolYearUncheckedCreateWithoutClassRoomInput = {
    id?: string
    year: number
    instansiId: string
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    studentsIn?: StudentUncheckedCreateNestedManyWithoutStartYearInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutRefInput
  }

  export type SchoolYearCreateOrConnectWithoutClassRoomInput = {
    where: SchoolYearWhereUniqueInput
    create: XOR<SchoolYearCreateWithoutClassRoomInput, SchoolYearUncheckedCreateWithoutClassRoomInput>
  }

  export type TeacherCreateWithoutClassRoomInput = {
    id?: string
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: string | null
    tmtGol?: string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    user?: UserCreateNestedOneWithoutTeacherInput
    instansi: InstansiCreateNestedOneWithoutTeacherInput
    event?: CalendarCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutClassRoomInput = {
    id?: string
    userId?: string | null
    instansiId: string
    eventIds?: TeacherCreateeventIdsInput | Enumerable<string>
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: string | null
    tmtGol?: string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    event?: CalendarUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutClassRoomInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutClassRoomInput, TeacherUncheckedCreateWithoutClassRoomInput>
  }

  export type StudentCreateWithoutClassRoomInput = {
    id?: string
    user?: UserCreateNestedOneWithoutStudentInput
    major?: KonsentrasiKeahlianCreateNestedOneWithoutStudentInput
    startYear: SchoolYearCreateNestedOneWithoutStudentsInInput
    instansi: InstansiCreateNestedOneWithoutStudentInput
    event?: CalendarCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutClassRoomInput = {
    id?: string
    userId?: string | null
    majorId?: string | null
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    startYearId: string
    instansiId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
    event?: CalendarUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutClassRoomInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutClassRoomInput, StudentUncheckedCreateWithoutClassRoomInput>
  }

  export type CalendarCreateWithoutClassRoomInput = {
    id?: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    ref: SchoolYearCreateNestedOneWithoutCalendarInput
    student?: StudentCreateNestedManyWithoutEventInput
    teacher?: TeacherCreateNestedManyWithoutEventInput
  }

  export type CalendarUncheckedCreateWithoutClassRoomInput = {
    id?: string
    refId: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    classRoomIds?: CalendarCreateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarCreatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarCreateteacherIdsInput | Enumerable<string>
    student?: StudentUncheckedCreateNestedManyWithoutEventInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutEventInput
  }

  export type CalendarCreateOrConnectWithoutClassRoomInput = {
    where: CalendarWhereUniqueInput
    create: XOR<CalendarCreateWithoutClassRoomInput, CalendarUncheckedCreateWithoutClassRoomInput>
  }

  export type SchoolYearUpsertWithoutClassRoomInput = {
    update: XOR<SchoolYearUpdateWithoutClassRoomInput, SchoolYearUncheckedUpdateWithoutClassRoomInput>
    create: XOR<SchoolYearCreateWithoutClassRoomInput, SchoolYearUncheckedCreateWithoutClassRoomInput>
  }

  export type SchoolYearUpdateWithoutClassRoomInput = {
    year?: IntFieldUpdateOperationsInput | number
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    instansi?: InstansiUpdateOneRequiredWithoutSchoolYearNestedInput
    studentsIn?: StudentUpdateManyWithoutStartYearNestedInput
    calendar?: CalendarUpdateManyWithoutRefNestedInput
  }

  export type SchoolYearUncheckedUpdateWithoutClassRoomInput = {
    year?: IntFieldUpdateOperationsInput | number
    instansiId?: StringFieldUpdateOperationsInput | string
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    studentsIn?: StudentUncheckedUpdateManyWithoutStartYearNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutRefNestedInput
  }

  export type TeacherUpsertWithoutClassRoomInput = {
    update: XOR<TeacherUpdateWithoutClassRoomInput, TeacherUncheckedUpdateWithoutClassRoomInput>
    create: XOR<TeacherCreateWithoutClassRoomInput, TeacherUncheckedCreateWithoutClassRoomInput>
  }

  export type TeacherUpdateWithoutClassRoomInput = {
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableStringFieldUpdateOperationsInput | string | null
    tmtGol?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    user?: UserUpdateOneWithoutTeacherNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutTeacherNestedInput
    event?: CalendarUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutClassRoomInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: TeacherUpdateeventIdsInput | Enumerable<string>
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableStringFieldUpdateOperationsInput | string | null
    tmtGol?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    event?: CalendarUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type StudentUpsertWithWhereUniqueWithoutClassRoomInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutClassRoomInput, StudentUncheckedUpdateWithoutClassRoomInput>
    create: XOR<StudentCreateWithoutClassRoomInput, StudentUncheckedCreateWithoutClassRoomInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutClassRoomInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutClassRoomInput, StudentUncheckedUpdateWithoutClassRoomInput>
  }

  export type StudentUpdateManyWithWhereWithoutClassRoomInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutStudentsInput>
  }

  export type CalendarUpsertWithWhereUniqueWithoutClassRoomInput = {
    where: CalendarWhereUniqueInput
    update: XOR<CalendarUpdateWithoutClassRoomInput, CalendarUncheckedUpdateWithoutClassRoomInput>
    create: XOR<CalendarCreateWithoutClassRoomInput, CalendarUncheckedCreateWithoutClassRoomInput>
  }

  export type CalendarUpdateWithWhereUniqueWithoutClassRoomInput = {
    where: CalendarWhereUniqueInput
    data: XOR<CalendarUpdateWithoutClassRoomInput, CalendarUncheckedUpdateWithoutClassRoomInput>
  }

  export type CalendarUpdateManyWithWhereWithoutClassRoomInput = {
    where: CalendarScalarWhereInput
    data: XOR<CalendarUpdateManyMutationInput, CalendarUncheckedUpdateManyWithoutEventInput>
  }

  export type InstansiCreateWithoutSchoolYearInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    majors?: KonsentrasiKeahlianCreateNestedManyWithoutInstansiInput
    role?: RoleCreateNestedManyWithoutInstansiInput
    teacher?: TeacherCreateNestedManyWithoutInstansiInput
    student?: StudentCreateNestedManyWithoutInstansiInput
  }

  export type InstansiUncheckedCreateWithoutSchoolYearInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    majorIds?: InstansiCreatemajorIdsInput | Enumerable<string>
    createdAt?: Date | string
    updatedAt?: Date | string
    majors?: KonsentrasiKeahlianUncheckedCreateNestedManyWithoutInstansiInput
    role?: RoleUncheckedCreateNestedManyWithoutInstansiInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutInstansiInput
    student?: StudentUncheckedCreateNestedManyWithoutInstansiInput
  }

  export type InstansiCreateOrConnectWithoutSchoolYearInput = {
    where: InstansiWhereUniqueInput
    create: XOR<InstansiCreateWithoutSchoolYearInput, InstansiUncheckedCreateWithoutSchoolYearInput>
  }

  export type ClassRoomCreateWithoutYearInput = {
    id?: string
    name: string
    wali: TeacherCreateNestedOneWithoutClassRoomInput
    students?: StudentCreateNestedManyWithoutClassRoomInput
    event?: CalendarCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomUncheckedCreateWithoutYearInput = {
    id?: string
    name: string
    waliId: string
    studentIds?: ClassRoomCreatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomCreateeventIdsInput | Enumerable<string>
    students?: StudentUncheckedCreateNestedManyWithoutClassRoomInput
    event?: CalendarUncheckedCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomCreateOrConnectWithoutYearInput = {
    where: ClassRoomWhereUniqueInput
    create: XOR<ClassRoomCreateWithoutYearInput, ClassRoomUncheckedCreateWithoutYearInput>
  }

  export type ClassRoomCreateManyYearInputEnvelope = {
    data: Enumerable<ClassRoomCreateManyYearInput>
  }

  export type StudentCreateWithoutStartYearInput = {
    id?: string
    user?: UserCreateNestedOneWithoutStudentInput
    major?: KonsentrasiKeahlianCreateNestedOneWithoutStudentInput
    classRoom?: ClassRoomCreateNestedManyWithoutStudentsInput
    instansi: InstansiCreateNestedOneWithoutStudentInput
    event?: CalendarCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStartYearInput = {
    id?: string
    userId?: string | null
    majorId?: string | null
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    instansiId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutStudentsInput
    event?: CalendarUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStartYearInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStartYearInput, StudentUncheckedCreateWithoutStartYearInput>
  }

  export type StudentCreateManyStartYearInputEnvelope = {
    data: Enumerable<StudentCreateManyStartYearInput>
  }

  export type CalendarCreateWithoutRefInput = {
    id?: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    classRoom?: ClassRoomCreateNestedManyWithoutEventInput
    student?: StudentCreateNestedManyWithoutEventInput
    teacher?: TeacherCreateNestedManyWithoutEventInput
  }

  export type CalendarUncheckedCreateWithoutRefInput = {
    id?: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    classRoomIds?: CalendarCreateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarCreatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarCreateteacherIdsInput | Enumerable<string>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutEventInput
    student?: StudentUncheckedCreateNestedManyWithoutEventInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutEventInput
  }

  export type CalendarCreateOrConnectWithoutRefInput = {
    where: CalendarWhereUniqueInput
    create: XOR<CalendarCreateWithoutRefInput, CalendarUncheckedCreateWithoutRefInput>
  }

  export type CalendarCreateManyRefInputEnvelope = {
    data: Enumerable<CalendarCreateManyRefInput>
  }

  export type OrganizationalUpdateInput = {
    kepsek?: StringFieldUpdateOperationsInput | string
    wakasek?: StringFieldUpdateOperationsInput | string
    wakakur?: StringFieldUpdateOperationsInput | string
    wakasiw?: StringFieldUpdateOperationsInput | string
    wakapra?: StringFieldUpdateOperationsInput | string
    wakahum?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InstansiUpsertWithoutSchoolYearInput = {
    update: XOR<InstansiUpdateWithoutSchoolYearInput, InstansiUncheckedUpdateWithoutSchoolYearInput>
    create: XOR<InstansiCreateWithoutSchoolYearInput, InstansiUncheckedCreateWithoutSchoolYearInput>
  }

  export type InstansiUpdateWithoutSchoolYearInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    majors?: KonsentrasiKeahlianUpdateManyWithoutInstansiNestedInput
    role?: RoleUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUpdateManyWithoutInstansiNestedInput
    student?: StudentUpdateManyWithoutInstansiNestedInput
  }

  export type InstansiUncheckedUpdateWithoutSchoolYearInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    majorIds?: InstansiUpdatemajorIdsInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    majors?: KonsentrasiKeahlianUncheckedUpdateManyWithoutInstansiNestedInput
    role?: RoleUncheckedUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutInstansiNestedInput
    student?: StudentUncheckedUpdateManyWithoutInstansiNestedInput
  }

  export type ClassRoomUpsertWithWhereUniqueWithoutYearInput = {
    where: ClassRoomWhereUniqueInput
    update: XOR<ClassRoomUpdateWithoutYearInput, ClassRoomUncheckedUpdateWithoutYearInput>
    create: XOR<ClassRoomCreateWithoutYearInput, ClassRoomUncheckedCreateWithoutYearInput>
  }

  export type ClassRoomUpdateWithWhereUniqueWithoutYearInput = {
    where: ClassRoomWhereUniqueInput
    data: XOR<ClassRoomUpdateWithoutYearInput, ClassRoomUncheckedUpdateWithoutYearInput>
  }

  export type ClassRoomUpdateManyWithWhereWithoutYearInput = {
    where: ClassRoomScalarWhereInput
    data: XOR<ClassRoomUpdateManyMutationInput, ClassRoomUncheckedUpdateManyWithoutClassRoomInput>
  }

  export type StudentUpsertWithWhereUniqueWithoutStartYearInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutStartYearInput, StudentUncheckedUpdateWithoutStartYearInput>
    create: XOR<StudentCreateWithoutStartYearInput, StudentUncheckedCreateWithoutStartYearInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutStartYearInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutStartYearInput, StudentUncheckedUpdateWithoutStartYearInput>
  }

  export type StudentUpdateManyWithWhereWithoutStartYearInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutStudentsInInput>
  }

  export type CalendarUpsertWithWhereUniqueWithoutRefInput = {
    where: CalendarWhereUniqueInput
    update: XOR<CalendarUpdateWithoutRefInput, CalendarUncheckedUpdateWithoutRefInput>
    create: XOR<CalendarCreateWithoutRefInput, CalendarUncheckedCreateWithoutRefInput>
  }

  export type CalendarUpdateWithWhereUniqueWithoutRefInput = {
    where: CalendarWhereUniqueInput
    data: XOR<CalendarUpdateWithoutRefInput, CalendarUncheckedUpdateWithoutRefInput>
  }

  export type CalendarUpdateManyWithWhereWithoutRefInput = {
    where: CalendarScalarWhereInput
    data: XOR<CalendarUpdateManyMutationInput, CalendarUncheckedUpdateManyWithoutCalendarInput>
  }

  export type SchoolYearCreateWithoutCalendarInput = {
    id?: string
    year: number
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    instansi: InstansiCreateNestedOneWithoutSchoolYearInput
    classRoom?: ClassRoomCreateNestedManyWithoutYearInput
    studentsIn?: StudentCreateNestedManyWithoutStartYearInput
  }

  export type SchoolYearUncheckedCreateWithoutCalendarInput = {
    id?: string
    year: number
    instansiId: string
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutYearInput
    studentsIn?: StudentUncheckedCreateNestedManyWithoutStartYearInput
  }

  export type SchoolYearCreateOrConnectWithoutCalendarInput = {
    where: SchoolYearWhereUniqueInput
    create: XOR<SchoolYearCreateWithoutCalendarInput, SchoolYearUncheckedCreateWithoutCalendarInput>
  }

  export type ClassRoomCreateWithoutEventInput = {
    id?: string
    name: string
    year: SchoolYearCreateNestedOneWithoutClassRoomInput
    wali: TeacherCreateNestedOneWithoutClassRoomInput
    students?: StudentCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomUncheckedCreateWithoutEventInput = {
    id?: string
    name: string
    yearId: string
    waliId: string
    studentIds?: ClassRoomCreatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomCreateeventIdsInput | Enumerable<string>
    students?: StudentUncheckedCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomCreateOrConnectWithoutEventInput = {
    where: ClassRoomWhereUniqueInput
    create: XOR<ClassRoomCreateWithoutEventInput, ClassRoomUncheckedCreateWithoutEventInput>
  }

  export type StudentCreateWithoutEventInput = {
    id?: string
    user?: UserCreateNestedOneWithoutStudentInput
    major?: KonsentrasiKeahlianCreateNestedOneWithoutStudentInput
    classRoom?: ClassRoomCreateNestedManyWithoutStudentsInput
    startYear: SchoolYearCreateNestedOneWithoutStudentsInInput
    instansi: InstansiCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutEventInput = {
    id?: string
    userId?: string | null
    majorId?: string | null
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    startYearId: string
    instansiId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type StudentCreateOrConnectWithoutEventInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutEventInput, StudentUncheckedCreateWithoutEventInput>
  }

  export type TeacherCreateWithoutEventInput = {
    id?: string
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: string | null
    tmtGol?: string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    user?: UserCreateNestedOneWithoutTeacherInput
    classRoom?: ClassRoomCreateNestedManyWithoutWaliInput
    instansi: InstansiCreateNestedOneWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutEventInput = {
    id?: string
    userId?: string | null
    instansiId: string
    eventIds?: TeacherCreateeventIdsInput | Enumerable<string>
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: string | null
    tmtGol?: string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutWaliInput
  }

  export type TeacherCreateOrConnectWithoutEventInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutEventInput, TeacherUncheckedCreateWithoutEventInput>
  }

  export type SchoolYearUpsertWithoutCalendarInput = {
    update: XOR<SchoolYearUpdateWithoutCalendarInput, SchoolYearUncheckedUpdateWithoutCalendarInput>
    create: XOR<SchoolYearCreateWithoutCalendarInput, SchoolYearUncheckedCreateWithoutCalendarInput>
  }

  export type SchoolYearUpdateWithoutCalendarInput = {
    year?: IntFieldUpdateOperationsInput | number
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    instansi?: InstansiUpdateOneRequiredWithoutSchoolYearNestedInput
    classRoom?: ClassRoomUpdateManyWithoutYearNestedInput
    studentsIn?: StudentUpdateManyWithoutStartYearNestedInput
  }

  export type SchoolYearUncheckedUpdateWithoutCalendarInput = {
    year?: IntFieldUpdateOperationsInput | number
    instansiId?: StringFieldUpdateOperationsInput | string
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutYearNestedInput
    studentsIn?: StudentUncheckedUpdateManyWithoutStartYearNestedInput
  }

  export type ClassRoomUpsertWithWhereUniqueWithoutEventInput = {
    where: ClassRoomWhereUniqueInput
    update: XOR<ClassRoomUpdateWithoutEventInput, ClassRoomUncheckedUpdateWithoutEventInput>
    create: XOR<ClassRoomCreateWithoutEventInput, ClassRoomUncheckedCreateWithoutEventInput>
  }

  export type ClassRoomUpdateWithWhereUniqueWithoutEventInput = {
    where: ClassRoomWhereUniqueInput
    data: XOR<ClassRoomUpdateWithoutEventInput, ClassRoomUncheckedUpdateWithoutEventInput>
  }

  export type ClassRoomUpdateManyWithWhereWithoutEventInput = {
    where: ClassRoomScalarWhereInput
    data: XOR<ClassRoomUpdateManyMutationInput, ClassRoomUncheckedUpdateManyWithoutClassRoomInput>
  }

  export type StudentUpsertWithWhereUniqueWithoutEventInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutEventInput, StudentUncheckedUpdateWithoutEventInput>
    create: XOR<StudentCreateWithoutEventInput, StudentUncheckedCreateWithoutEventInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutEventInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutEventInput, StudentUncheckedUpdateWithoutEventInput>
  }

  export type StudentUpdateManyWithWhereWithoutEventInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutStudentInput>
  }

  export type TeacherUpsertWithWhereUniqueWithoutEventInput = {
    where: TeacherWhereUniqueInput
    update: XOR<TeacherUpdateWithoutEventInput, TeacherUncheckedUpdateWithoutEventInput>
    create: XOR<TeacherCreateWithoutEventInput, TeacherUncheckedCreateWithoutEventInput>
  }

  export type TeacherUpdateWithWhereUniqueWithoutEventInput = {
    where: TeacherWhereUniqueInput
    data: XOR<TeacherUpdateWithoutEventInput, TeacherUncheckedUpdateWithoutEventInput>
  }

  export type TeacherUpdateManyWithWhereWithoutEventInput = {
    where: TeacherScalarWhereInput
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyWithoutTeacherInput>
  }

  export type CoordinateCompositeFilter = {
    equals?: CoordinateObjectEqualityInput
    is?: CoordinateWhereInput
    isNot?: CoordinateWhereInput
  }

  export type EnumLevelEduFilter = {
    equals?: LevelEdu
    in?: Enumerable<LevelEdu>
    notIn?: Enumerable<LevelEdu>
    not?: NestedEnumLevelEduFilter | LevelEdu
  }

  export type ProgramKeahlianCreateManyBidangInput = {
    id?: string
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramKeahlianUpdateWithoutBidangInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    konsentrasi?: KonsentrasiKeahlianUpdateManyWithoutProgramNestedInput
  }

  export type ProgramKeahlianUncheckedUpdateWithoutBidangInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    konsentrasi?: KonsentrasiKeahlianUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramKeahlianUncheckedUpdateManyWithoutProgramInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KonsentrasiKeahlianCreateManyProgramInput = {
    id?: string
    code: string
    name: string
    tahun: number
    createdAt?: Date | string
    updatedAt?: Date | string
    instansiIds?: KonsentrasiKeahlianCreateinstansiIdsInput | Enumerable<string>
  }

  export type KonsentrasiKeahlianUpdateWithoutProgramInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateManyWithoutMajorNestedInput
    instansi?: InstansiUpdateManyWithoutMajorsNestedInput
  }

  export type KonsentrasiKeahlianUncheckedUpdateWithoutProgramInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instansiIds?: KonsentrasiKeahlianUpdateinstansiIdsInput | Enumerable<string>
    student?: StudentUncheckedUpdateManyWithoutMajorNestedInput
    instansi?: InstansiUncheckedUpdateManyWithoutMajorsNestedInput
  }

  export type KonsentrasiKeahlianUncheckedUpdateManyWithoutKonsentrasiInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instansiIds?: KonsentrasiKeahlianUpdateinstansiIdsInput | Enumerable<string>
  }

  export type StudentCreateManyMajorInput = {
    id?: string
    userId?: string | null
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    startYearId: string
    instansiId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
  }

  export type StudentUpdateWithoutMajorInput = {
    user?: UserUpdateOneWithoutStudentNestedInput
    classRoom?: ClassRoomUpdateManyWithoutStudentsNestedInput
    startYear?: SchoolYearUpdateOneRequiredWithoutStudentsInNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutStudentNestedInput
    event?: CalendarUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutMajorInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomIds?: StudentUpdateclassRoomIdsInput | Enumerable<string>
    startYearId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: StudentUpdateeventIdsInput | Enumerable<string>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutStudentsNestedInput
    event?: CalendarUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutStudentInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomIds?: StudentUpdateclassRoomIdsInput | Enumerable<string>
    startYearId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: StudentUpdateeventIdsInput | Enumerable<string>
  }

  export type InstansiUpdateWithoutMajorsInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUpdateManyWithoutInstansiNestedInput
    student?: StudentUpdateManyWithoutInstansiNestedInput
  }

  export type InstansiUncheckedUpdateWithoutMajorsInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    majorIds?: InstansiUpdatemajorIdsInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUncheckedUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUncheckedUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutInstansiNestedInput
    student?: StudentUncheckedUpdateManyWithoutInstansiNestedInput
  }

  export type InstansiUncheckedUpdateManyWithoutInstansiInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    majorIds?: InstansiUpdatemajorIdsInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateManyElementInput = {
    id?: string
    fase?: Fase
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementUpdateWithoutElementInput = {
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateWithoutElementInput = {
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateManyWithoutAchievementInput = {
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElementCreateManyMapelInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ElementUpdateWithoutMapelInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: AchievementUpdateManyWithoutElementNestedInput
  }

  export type ElementUncheckedUpdateWithoutMapelInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: AchievementUncheckedUpdateManyWithoutElementNestedInput
  }

  export type ElementUncheckedUpdateManyWithoutElementInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateManyInstansiInput = {
    id?: string
    key: Roles
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolYearCreateManyInstansiInput = {
    id?: string
    year: number
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
  }

  export type TeacherCreateManyInstansiInput = {
    id?: string
    userId?: string | null
    eventIds?: TeacherCreateeventIdsInput | Enumerable<string>
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: string | null
    tmtGol?: string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
  }

  export type StudentCreateManyInstansiInput = {
    id?: string
    userId?: string | null
    majorId?: string | null
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    startYearId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
  }

  export type CoordinateUpdateEnvelopeInput = {
    set?: CoordinateCreateInput
    update?: CoordinateUpdateInput
  }

  export type KonsentrasiKeahlianUpdateWithoutInstansiInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramKeahlianUpdateOneRequiredWithoutKonsentrasiNestedInput
    student?: StudentUpdateManyWithoutMajorNestedInput
  }

  export type KonsentrasiKeahlianUncheckedUpdateWithoutInstansiInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instansiIds?: KonsentrasiKeahlianUpdateinstansiIdsInput | Enumerable<string>
    student?: StudentUncheckedUpdateManyWithoutMajorNestedInput
  }

  export type KonsentrasiKeahlianUncheckedUpdateManyWithoutMajorsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instansiIds?: KonsentrasiKeahlianUpdateinstansiIdsInput | Enumerable<string>
  }

  export type RoleUpdateWithoutInstansiInput = {
    key?: EnumRolesFieldUpdateOperationsInput | Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutInstansiInput = {
    key?: EnumRolesFieldUpdateOperationsInput | Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateManyWithoutRoleInput = {
    key?: EnumRolesFieldUpdateOperationsInput | Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolYearUpdateWithoutInstansiInput = {
    year?: IntFieldUpdateOperationsInput | number
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    classRoom?: ClassRoomUpdateManyWithoutYearNestedInput
    studentsIn?: StudentUpdateManyWithoutStartYearNestedInput
    calendar?: CalendarUpdateManyWithoutRefNestedInput
  }

  export type SchoolYearUncheckedUpdateWithoutInstansiInput = {
    year?: IntFieldUpdateOperationsInput | number
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutYearNestedInput
    studentsIn?: StudentUncheckedUpdateManyWithoutStartYearNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutRefNestedInput
  }

  export type SchoolYearUncheckedUpdateManyWithoutSchoolYearInput = {
    year?: IntFieldUpdateOperationsInput | number
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
  }

  export type TeacherUpdateWithoutInstansiInput = {
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableStringFieldUpdateOperationsInput | string | null
    tmtGol?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    user?: UserUpdateOneWithoutTeacherNestedInput
    classRoom?: ClassRoomUpdateManyWithoutWaliNestedInput
    event?: CalendarUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutInstansiInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventIds?: TeacherUpdateeventIdsInput | Enumerable<string>
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableStringFieldUpdateOperationsInput | string | null
    tmtGol?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutWaliNestedInput
    event?: CalendarUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateManyWithoutTeacherInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventIds?: TeacherUpdateeventIdsInput | Enumerable<string>
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableStringFieldUpdateOperationsInput | string | null
    tmtGol?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
  }

  export type StudentUpdateWithoutInstansiInput = {
    user?: UserUpdateOneWithoutStudentNestedInput
    major?: KonsentrasiKeahlianUpdateOneWithoutStudentNestedInput
    classRoom?: ClassRoomUpdateManyWithoutStudentsNestedInput
    startYear?: SchoolYearUpdateOneRequiredWithoutStudentsInNestedInput
    event?: CalendarUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutInstansiInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomIds?: StudentUpdateclassRoomIdsInput | Enumerable<string>
    startYearId?: StringFieldUpdateOperationsInput | string
    eventIds?: StudentUpdateeventIdsInput | Enumerable<string>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutStudentsNestedInput
    event?: CalendarUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UserCreateManyRoleInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutRoleInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personal?: PersonalUpdateOneWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personal?: PersonalUncheckedUpdateOneWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyTreeCreateManyFatherInput = {
    id?: string
    nokk: string
    motherId?: string | null
    waliId?: string | null
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
  }

  export type FamilyTreeCreateManyMotherInput = {
    id?: string
    nokk: string
    fatherId?: string | null
    waliId?: string | null
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
  }

  export type FamilyTreeCreateManyWaliInput = {
    id?: string
    nokk: string
    fatherId?: string | null
    motherId?: string | null
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
  }

  export type FamilyTreeUpdateWithoutFatherInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    mother?: PersonalUpdateOneWithoutMotherNestedInput
    wali?: PersonalUpdateOneWithoutWaliNestedInput
    childs?: FamilyTreeChildUpdateManyWithoutKkNestedInput
  }

  export type FamilyTreeUncheckedUpdateWithoutFatherInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    motherId?: NullableStringFieldUpdateOperationsInput | string | null
    waliId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    childs?: FamilyTreeChildUncheckedUpdateManyWithoutKkNestedInput
  }

  export type FamilyTreeUncheckedUpdateManyWithoutFatherInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    motherId?: NullableStringFieldUpdateOperationsInput | string | null
    waliId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
  }

  export type FamilyTreeUpdateWithoutMotherInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    father?: PersonalUpdateOneWithoutFatherNestedInput
    wali?: PersonalUpdateOneWithoutWaliNestedInput
    childs?: FamilyTreeChildUpdateManyWithoutKkNestedInput
  }

  export type FamilyTreeUncheckedUpdateWithoutMotherInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    fatherId?: NullableStringFieldUpdateOperationsInput | string | null
    waliId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    childs?: FamilyTreeChildUncheckedUpdateManyWithoutKkNestedInput
  }

  export type FamilyTreeUncheckedUpdateManyWithoutMotherInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    fatherId?: NullableStringFieldUpdateOperationsInput | string | null
    waliId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
  }

  export type FamilyTreeUpdateWithoutWaliInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    father?: PersonalUpdateOneWithoutFatherNestedInput
    mother?: PersonalUpdateOneWithoutMotherNestedInput
    childs?: FamilyTreeChildUpdateManyWithoutKkNestedInput
  }

  export type FamilyTreeUncheckedUpdateWithoutWaliInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    fatherId?: NullableStringFieldUpdateOperationsInput | string | null
    motherId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    childs?: FamilyTreeChildUncheckedUpdateManyWithoutKkNestedInput
  }

  export type FamilyTreeUncheckedUpdateManyWithoutWaliInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    fatherId?: NullableStringFieldUpdateOperationsInput | string | null
    motherId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
  }

  export type FamilyTreeChildCreateManyKkInput = {
    id?: string
    no: number
    type: ChildType
    personalId: string
  }

  export type FamilyTreeChildUpdateWithoutKkInput = {
    no?: IntFieldUpdateOperationsInput | number
    type?: EnumChildTypeFieldUpdateOperationsInput | ChildType
    personal?: PersonalUpdateOneRequiredWithoutChildNestedInput
  }

  export type FamilyTreeChildUncheckedUpdateWithoutKkInput = {
    no?: IntFieldUpdateOperationsInput | number
    type?: EnumChildTypeFieldUpdateOperationsInput | ChildType
    personalId?: StringFieldUpdateOperationsInput | string
  }

  export type FamilyTreeChildUncheckedUpdateManyWithoutChildsInput = {
    no?: IntFieldUpdateOperationsInput | number
    type?: EnumChildTypeFieldUpdateOperationsInput | ChildType
    personalId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassRoomUpdateWithoutStudentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    year?: SchoolYearUpdateOneRequiredWithoutClassRoomNestedInput
    wali?: TeacherUpdateOneRequiredWithoutClassRoomNestedInput
    event?: CalendarUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomUncheckedUpdateWithoutStudentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    waliId?: StringFieldUpdateOperationsInput | string
    studentIds?: ClassRoomUpdatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomUpdateeventIdsInput | Enumerable<string>
    event?: CalendarUncheckedUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomUncheckedUpdateManyWithoutClassRoomInput = {
    name?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    waliId?: StringFieldUpdateOperationsInput | string
    studentIds?: ClassRoomUpdatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomUpdateeventIdsInput | Enumerable<string>
  }

  export type CalendarUpdateWithoutStudentInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    ref?: SchoolYearUpdateOneRequiredWithoutCalendarNestedInput
    classRoom?: ClassRoomUpdateManyWithoutEventNestedInput
    teacher?: TeacherUpdateManyWithoutEventNestedInput
  }

  export type CalendarUncheckedUpdateWithoutStudentInput = {
    refId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    classRoomIds?: CalendarUpdateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarUpdatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarUpdateteacherIdsInput | Enumerable<string>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutEventNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutEventNestedInput
  }

  export type CalendarUncheckedUpdateManyWithoutEventInput = {
    refId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    classRoomIds?: CalendarUpdateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarUpdatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarUpdateteacherIdsInput | Enumerable<string>
  }

  export type ClassRoomCreateManyWaliInput = {
    id?: string
    name: string
    yearId: string
    studentIds?: ClassRoomCreatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomCreateeventIdsInput | Enumerable<string>
  }

  export type EducationUpdateInput = {
    instansi?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelEduFieldUpdateOperationsInput | LevelEdu
    major?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrainingUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    instansi?: StringFieldUpdateOperationsInput | string
    long?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    place?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmploymentUpdateInput = {
    position?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    place?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfessionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    instansi?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OverseasUpdateInput = {
    country?: StringFieldUpdateOperationsInput | string
    instansi?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    long?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScientificUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    instansi?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    place?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    leader?: StringFieldUpdateOperationsInput | string
    place?: StringFieldUpdateOperationsInput | string
  }

  export type PapersUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    published?: StringFieldUpdateOperationsInput | string
  }

  export type InnovationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    patent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AwardUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    instansi?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SourcePersonUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    instansi?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContestUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    instansi?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    instansi?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdditionalUpdateInput = {
    position?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    instansi?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassRoomUpdateWithoutWaliInput = {
    name?: StringFieldUpdateOperationsInput | string
    year?: SchoolYearUpdateOneRequiredWithoutClassRoomNestedInput
    students?: StudentUpdateManyWithoutClassRoomNestedInput
    event?: CalendarUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomUncheckedUpdateWithoutWaliInput = {
    name?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    studentIds?: ClassRoomUpdatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomUpdateeventIdsInput | Enumerable<string>
    students?: StudentUncheckedUpdateManyWithoutClassRoomNestedInput
    event?: CalendarUncheckedUpdateManyWithoutClassRoomNestedInput
  }

  export type CalendarUpdateWithoutTeacherInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    ref?: SchoolYearUpdateOneRequiredWithoutCalendarNestedInput
    classRoom?: ClassRoomUpdateManyWithoutEventNestedInput
    student?: StudentUpdateManyWithoutEventNestedInput
  }

  export type CalendarUncheckedUpdateWithoutTeacherInput = {
    refId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    classRoomIds?: CalendarUpdateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarUpdatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarUpdateteacherIdsInput | Enumerable<string>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutEventNestedInput
    student?: StudentUncheckedUpdateManyWithoutEventNestedInput
  }

  export type StudentUpdateWithoutClassRoomInput = {
    user?: UserUpdateOneWithoutStudentNestedInput
    major?: KonsentrasiKeahlianUpdateOneWithoutStudentNestedInput
    startYear?: SchoolYearUpdateOneRequiredWithoutStudentsInNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutStudentNestedInput
    event?: CalendarUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutClassRoomInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomIds?: StudentUpdateclassRoomIdsInput | Enumerable<string>
    startYearId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: StudentUpdateeventIdsInput | Enumerable<string>
    event?: CalendarUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutStudentsInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomIds?: StudentUpdateclassRoomIdsInput | Enumerable<string>
    startYearId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: StudentUpdateeventIdsInput | Enumerable<string>
  }

  export type CalendarUpdateWithoutClassRoomInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    ref?: SchoolYearUpdateOneRequiredWithoutCalendarNestedInput
    student?: StudentUpdateManyWithoutEventNestedInput
    teacher?: TeacherUpdateManyWithoutEventNestedInput
  }

  export type CalendarUncheckedUpdateWithoutClassRoomInput = {
    refId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    classRoomIds?: CalendarUpdateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarUpdatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarUpdateteacherIdsInput | Enumerable<string>
    student?: StudentUncheckedUpdateManyWithoutEventNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutEventNestedInput
  }

  export type ClassRoomCreateManyYearInput = {
    id?: string
    name: string
    waliId: string
    studentIds?: ClassRoomCreatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomCreateeventIdsInput | Enumerable<string>
  }

  export type StudentCreateManyStartYearInput = {
    id?: string
    userId?: string | null
    majorId?: string | null
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    instansiId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
  }

  export type CalendarCreateManyRefInput = {
    id?: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    classRoomIds?: CalendarCreateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarCreatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarCreateteacherIdsInput | Enumerable<string>
  }

  export type ClassRoomUpdateWithoutYearInput = {
    name?: StringFieldUpdateOperationsInput | string
    wali?: TeacherUpdateOneRequiredWithoutClassRoomNestedInput
    students?: StudentUpdateManyWithoutClassRoomNestedInput
    event?: CalendarUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomUncheckedUpdateWithoutYearInput = {
    name?: StringFieldUpdateOperationsInput | string
    waliId?: StringFieldUpdateOperationsInput | string
    studentIds?: ClassRoomUpdatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomUpdateeventIdsInput | Enumerable<string>
    students?: StudentUncheckedUpdateManyWithoutClassRoomNestedInput
    event?: CalendarUncheckedUpdateManyWithoutClassRoomNestedInput
  }

  export type StudentUpdateWithoutStartYearInput = {
    user?: UserUpdateOneWithoutStudentNestedInput
    major?: KonsentrasiKeahlianUpdateOneWithoutStudentNestedInput
    classRoom?: ClassRoomUpdateManyWithoutStudentsNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutStudentNestedInput
    event?: CalendarUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStartYearInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomIds?: StudentUpdateclassRoomIdsInput | Enumerable<string>
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: StudentUpdateeventIdsInput | Enumerable<string>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutStudentsNestedInput
    event?: CalendarUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutStudentsInInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomIds?: StudentUpdateclassRoomIdsInput | Enumerable<string>
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: StudentUpdateeventIdsInput | Enumerable<string>
  }

  export type CalendarUpdateWithoutRefInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    classRoom?: ClassRoomUpdateManyWithoutEventNestedInput
    student?: StudentUpdateManyWithoutEventNestedInput
    teacher?: TeacherUpdateManyWithoutEventNestedInput
  }

  export type CalendarUncheckedUpdateWithoutRefInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    classRoomIds?: CalendarUpdateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarUpdatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarUpdateteacherIdsInput | Enumerable<string>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutEventNestedInput
    student?: StudentUncheckedUpdateManyWithoutEventNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutEventNestedInput
  }

  export type CalendarUncheckedUpdateManyWithoutCalendarInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    classRoomIds?: CalendarUpdateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarUpdatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarUpdateteacherIdsInput | Enumerable<string>
  }

  export type ClassRoomUpdateWithoutEventInput = {
    name?: StringFieldUpdateOperationsInput | string
    year?: SchoolYearUpdateOneRequiredWithoutClassRoomNestedInput
    wali?: TeacherUpdateOneRequiredWithoutClassRoomNestedInput
    students?: StudentUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomUncheckedUpdateWithoutEventInput = {
    name?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    waliId?: StringFieldUpdateOperationsInput | string
    studentIds?: ClassRoomUpdatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomUpdateeventIdsInput | Enumerable<string>
    students?: StudentUncheckedUpdateManyWithoutClassRoomNestedInput
  }

  export type StudentUpdateWithoutEventInput = {
    user?: UserUpdateOneWithoutStudentNestedInput
    major?: KonsentrasiKeahlianUpdateOneWithoutStudentNestedInput
    classRoom?: ClassRoomUpdateManyWithoutStudentsNestedInput
    startYear?: SchoolYearUpdateOneRequiredWithoutStudentsInNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutEventInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomIds?: StudentUpdateclassRoomIdsInput | Enumerable<string>
    startYearId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: StudentUpdateeventIdsInput | Enumerable<string>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type TeacherUpdateWithoutEventInput = {
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableStringFieldUpdateOperationsInput | string | null
    tmtGol?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    user?: UserUpdateOneWithoutTeacherNestedInput
    classRoom?: ClassRoomUpdateManyWithoutWaliNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutEventInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: TeacherUpdateeventIdsInput | Enumerable<string>
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableStringFieldUpdateOperationsInput | string | null
    tmtGol?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutWaliNestedInput
  }

  export type CoordinateWhereInput = {
    AND?: Enumerable<CoordinateWhereInput>
    OR?: Enumerable<CoordinateWhereInput>
    NOT?: Enumerable<CoordinateWhereInput>
    longitude?: FloatFilter | number
    latitude?: FloatFilter | number
  }

  export type NestedEnumLevelEduFilter = {
    equals?: LevelEdu
    in?: Enumerable<LevelEdu>
    notIn?: Enumerable<LevelEdu>
    not?: NestedEnumLevelEduFilter | LevelEdu
  }

  export type CoordinateUpdateInput = {
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
  }

  export type EnumLevelEduFieldUpdateOperationsInput = {
    set?: LevelEdu
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}