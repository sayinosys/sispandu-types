
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model Coordinate
 * 
 */
export type Coordinate = {
  longitude: number
  latitude: number
}

/**
 * Model Address
 * 
 */
export type Address = {
  provinsi: string
  kabupaten: string
  kecamatan: string
  kelurahan: string
  kodepos: string
  coordinate: Coordinate
}

/**
 * Model Google
 * 
 */
export type Google = {
  scopes: string[]
  tokens: Prisma.JsonValue
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Born
 * 
 */
export type Born = {
  place: string
  date: Date
}

/**
 * Model Education
 * 
 */
export type Education = {
  instansi: string
  level: LevelEdu
  major: string | null
  year: number
  attachment: string | null
}

/**
 * Model Training
 * 
 */
export type Training = {
  name: string
  instansi: string
  long: number
  year: number
  place: string
  attachment: string | null
}

/**
 * Model Profession
 * 
 */
export type Profession = {
  name: string
  instansi: string
  year: number
  attachment: string | null
}

/**
 * Model Employment
 * 
 */
export type Employment = {
  position: string
  year: number
  place: string
  note: string | null
}

/**
 * Model Overseas
 * 
 */
export type Overseas = {
  country: string
  instansi: string
  objective: string
  long: number
  year: number
  attachment: string | null
}

/**
 * Model Scientific
 * 
 */
export type Scientific = {
  name: string
  instansi: string
  position: string
  place: string
  period: string
  attachment: string | null
}

/**
 * Model Organization
 * 
 */
export type Organization = {
  name: string
  position: string
  period: string
  leader: string
  place: string
}

/**
 * Model Papers
 * 
 */
export type Papers = {
  name: string
  year: number
  published: string
}

/**
 * Model Innovation
 * 
 */
export type Innovation = {
  name: string
  year: number
  patent: boolean
}

/**
 * Model Award
 * 
 */
export type Award = {
  name: string
  year: number
  instansi: string
  attachment: string | null
}

/**
 * Model SourcePerson
 * 
 */
export type SourcePerson = {
  name: string
  date: string
  instansi: string
  note: string | null
  attachment: string | null
}

/**
 * Model Contest
 * 
 */
export type Contest = {
  name: string
  date: string
  instansi: string
  level: string
  attachment: string | null
}

/**
 * Model Documents
 * 
 */
export type Documents = {
  name: string
  date: string
  instansi: string
  note: string | null
  attachment: string | null
}

/**
 * Model Additional
 * 
 */
export type Additional = {
  position: string
  date: string
  instansi: string
  note: string | null
  attachment: string | null
}

/**
 * Model Organizational
 * 
 */
export type Organizational = {
  kepsek: string
  wakasek: string
  wakakur: string
  wakasiw: string
  wakapra: string
  wakahum: string | null
}

/**
 * Model RoomProperty
 * 
 */
export type RoomProperty = {
  pkl: boolean | null
}

/**
 * Model TDevicePos
 * 
 */
export type TDevicePos = {
  mouth: number
  week: number
  active: boolean
}

/**
 * Model TDeviceProps
 * 
 */
export type TDeviceProps = {
  docDate: Date
  docAddr: string
  kepText: string
  kepUser: string
  ke3Text: string
  jabText: string
  ke3User: string
}

/**
 * Model ContactDudi
 * 
 */
export type ContactDudi = {
  name: string
  position: string
  email: string
  phone: string
}

/**
 * Model DudiTimeWork
 * 
 */
export type DudiTimeWork = {
  holidays: string[]
  timeIn: string
  timeOut: string
  actifity: boolean
}

/**
 * Model DudiIndicator
 * 
 */
export type DudiIndicator = {
  no: number
  code: string
  name: string
}

/**
 * Model Tracker
 * 
 */
export type Tracker = {
  id: string
  point: PointTracker
  type: TypeTracker
  userId: string
  refId: string
  instansiId: string | null
  createdAt: Date
  mapelId: string | null
  elementId: string | null
  cpId: string | null
  bidangId: string | null
  programId: string | null
  konsentrasiId: string | null
  tpId: string | null
  teacherId: string | null
  kelasId: string | null
  muridId: string | null
  jadwalId: string | null
  mengajarId: string | null
  tujuanId: string | null
  perangkatId: string | null
  kalenderId: string | null
  dudiId: string | null
  kkniId: string | null
}

/**
 * Model Instansi
 * 
 */
export type Instansi = {
  id: string
  npsn: string
  name: string
  isPrivate: boolean
  address: Address
  level: Level
  religion: Religion | null
  major: boolean | null
  majorIds: string[]
  disable: boolean
}

/**
 * Model MataPelajaran
 * 
 */
export type MataPelajaran = {
  id: string
  level: Level | null
  type: MataPelajaranType
  no: string
  code: string
  name: string
  religion: Religion | null
  programId: string | null
  keahlianid: string | null
  instansiId: string | null
  disable: boolean
}

/**
 * Model Element
 * 
 */
export type Element = {
  id: string
  no: number
  name: string
  description: string
  mapelId: string
  disable: boolean
  scheduleClassIds: string[]
}

/**
 * Model Achievement
 * 
 */
export type Achievement = {
  id: string
  no: number
  fase: Fase
  description: string
  elementId: string
  disable: boolean
}

/**
 * Model BidangKeahlian
 * 
 */
export type BidangKeahlian = {
  id: string
  code: string
  name: string
  disable: boolean
}

/**
 * Model ProgramKeahlian
 * 
 */
export type ProgramKeahlian = {
  id: string
  code: string
  name: string
  bidangId: string
  disable: boolean
}

/**
 * Model KonsentrasiKeahlian
 * 
 */
export type KonsentrasiKeahlian = {
  id: string
  code: string
  name: string
  programId: string
  tahun: number
  instansiIds: string[]
  disable: boolean
}

/**
 * Model Role
 * 
 */
export type Role = {
  id: string
  key: Roles
  instansiId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model User
 * 
 */
export type User = {
  id: string
  name: string
  picture: string | null
  username: string
  active: boolean
  verify: boolean
  password: string
  passhash: string
  roleId: string | null
  disable: boolean
  google: Google | null
}

/**
 * Model Upload
 * 
 */
export type Upload = {
  id: string
  type: UploadType
  name: string
  url: string
}

/**
 * Model Personal
 * 
 */
export type Personal = {
  id: string
  nik: string | null
  nisn: string | null
  type: TypePersonal
  fullname: string
  gender: Gender
  foreign: boolean | null
  country: string | null
  religion: Religion
  born: Born
  email: string | null
  belajarId: string | null
  nophone: string | null
  isLife: boolean | null
  address: Address | null
  education: Education[]
  training: Training[]
  employment: Employment[]
  profession: Profession[]
  overseas: Overseas[]
  scientific: Scientific[]
  organization: Organization[]
  papers: Papers[]
  innovation: Innovation[]
  award: Award[]
  sourcePerson: SourcePerson[]
  contest: Contest[]
  documents: Documents[]
  additional: Additional[]
  disable: boolean
}

/**
 * Model Auth
 * 
 */
export type Auth = {
  id: string
  userId: string
  personalId: string
}

/**
 * Model FamilyTree
 * 
 */
export type FamilyTree = {
  id: string
  nokk: string
  fatherId: string | null
  motherId: string | null
  waliId: string | null
  coupleId: string | null
  address: Address
}

/**
 * Model FamilyTreeChild
 * 
 */
export type FamilyTreeChild = {
  id: string
  no: number
  type: ChildType
  kkId: string
  personalId: string
}

/**
 * Model SchoolYear
 * 
 */
export type SchoolYear = {
  id: string
  year: number
  instansiId: string
  departments: string[]
  organizational: Organizational
  disable: boolean
}

/**
 * Model Teacher
 * 
 */
export type Teacher = {
  id: string
  personalId: string
  instansiId: string
  eventIds: string[]
  nip: string | null
  nrg: string | null
  noKarpeg: string | null
  tmtTugas: Date | null
  tmtGol: Date | null
  position: string | null
  rank: string | null
  period: string | null
  certificate: string | null
  disable: boolean
}

/**
 * Model ClassRoom
 * 
 */
export type ClassRoom = {
  id: string
  name: string
  yearId: string
  waliId: string
  level: number
  property: RoomProperty | null
  majorId: string | null
  studentIds: string[]
  eventIds: string[]
  disable: boolean
  teachingIds: string[]
  tDeviceIds: string[]
}

/**
 * Model Student
 * 
 */
export type Student = {
  id: string
  nis: string
  lastSchool: string
  personalId: string
  majorId: string | null
  classRoomIds: string[]
  startYearId: string
  instansiId: string
  eventIds: string[]
  disable: boolean
}

/**
 * Model Schedule
 * 
 */
export type Schedule = {
  id: string
  yearId: string
  mapelId: string
  disable: boolean
}

/**
 * Model Teaching
 * 
 */
export type Teaching = {
  id: string
  refId: string
  level: number
  hours: number
  semester: Semester
  teacherId: string
  classRoomIds: string[]
  elemenIds: string[]
  disable: boolean
}

/**
 * Model Link
 * 
 */
export type Link = {
  id: string
  url: string | null
  title: string
  description: string | null
  image: string | null
  width: number | null
  height: number | null
  userId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model OAssessment
 * 
 */
export type OAssessment = {
  id: string
  refId: string
  type: string
  techs: string[]
}

/**
 * Model Objective
 * 
 */
export type Objective = {
  id: string
  level: number
  fase: Fase
  userId: string
  instansiId: string
  yearId: string
  mapelId: string
  elementId: string
  achievementId: string
  code: string
  kkm: number
  steps: number
  subjectMatter: string
  competencie: string[]
  firstSkill: string[]
  triggerQuest: string[]
  disable: boolean
  toolIds: string[]
  mateIds: string[]
  methIds: string[]
  mediaIds: string[]
}

/**
 * Model OMaterial
 * 
 */
export type OMaterial = {
  id: string
  refId: string
  no: number
  content: string
  model: OMaterialModel
}

/**
 * Model OLearning
 * 
 */
export type OLearning = {
  id: string
  refId: string
  no: number
  content: string
  taksonomi: Taksonomi
  sentence: string
}

/**
 * Model Ohelper
 * 
 */
export type Ohelper = {
  id: string
  type: OhelperType
  name: string
  toolIds: string[]
  mateIds: string[]
  methIds: string[]
  mediaIds: string[]
}

/**
 * Model Oppp
 * 
 */
export type Oppp = {
  id: string
  refId: string
  name: string
  description: string | null
}

/**
 * Model Oresource
 * 
 */
export type Oresource = {
  id: string
  name: string
  type: OresourceType
  refId: string
  linkId: string | null
}

/**
 * Model Book
 * 
 */
export type Book = {
  id: string
  name: string
  description: string | null
  author: string | null
}

/**
 * Model TDevice
 * 
 */
export type TDevice = {
  id: string
  name: string
  level: number
  fase: Fase
  teachingId: string
  property: TDeviceProps
  yearId: string
  userId: string
  instansiId: string
  mapelId: string
  classRoomIds: string[]
  elemen: string[]
  disable: boolean
  parentId: string | null
  positions: TDevicePos[]
}

/**
 * Model TDeviceData
 * 
 */
export type TDeviceData = {
  id: string
  refId: string
  objectiveId: string
  positions: TDevicePos[]
}

/**
 * Model Calendar
 * 
 */
export type Calendar = {
  id: string
  refId: string
  name: string
  description: string | null
  start: Date
  end: Date | null
  color: string
  classRoomIds: string[]
  studentIds: string[]
  teacherIds: string[]
  disable: boolean
}

/**
 * Model Dudi
 * 
 */
export type Dudi = {
  id: string
  name: string
  street: string
  address: Address
  instansiId: string
  majorId: string
  contact: ContactDudi
  collabs: string[]
  timework: DudiTimeWork
  disable: boolean
  kkniId: string | null
}

/**
 * Model DudiLearning
 * 
 */
export type DudiLearning = {
  id: string
  no: number
  refId: string
  code: string
  name: string
  indicator: DudiIndicator[]
}

/**
 * Model Kkni
 * 
 */
export type Kkni = {
  id: string
  konsentrasiId: string
  no: number
  code: string
  name: string
  description: string | null
  disable: boolean
}


/**
 * Enums
 */

export const ChildType: {
  KANDUNG: 'KANDUNG',
  TIRI: 'TIRI',
  ANGKAT: 'ANGKAT'
};

export type ChildType = (typeof ChildType)[keyof typeof ChildType]


export const Fase: {
  A: 'A',
  B: 'B',
  C: 'C',
  D: 'D',
  E: 'E',
  F: 'F',
  FP: 'FP'
};

export type Fase = (typeof Fase)[keyof typeof Fase]


export const Gender: {
  L: 'L',
  P: 'P'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const Level: {
  SD: 'SD',
  SMP: 'SMP',
  SMA: 'SMA',
  SMK: 'SMK'
};

export type Level = (typeof Level)[keyof typeof Level]


export const LevelEdu: {
  SD: 'SD',
  SMP: 'SMP',
  SMA: 'SMA',
  D1: 'D1',
  D2: 'D2',
  D3: 'D3',
  D4: 'D4',
  S1: 'S1',
  S2: 'S2',
  S3: 'S3'
};

export type LevelEdu = (typeof LevelEdu)[keyof typeof LevelEdu]


export const MataPelajaranType: {
  UMUM: 'UMUM',
  PROGRAM: 'PROGRAM',
  KONSENTRASI: 'KONSENTRASI',
  MULOK: 'MULOK'
};

export type MataPelajaranType = (typeof MataPelajaranType)[keyof typeof MataPelajaranType]


export const OMaterialModel: {
  DL: 'DL',
  IL: 'IL',
  PBL: 'PBL',
  PjBL: 'PjBL',
  TF: 'TF',
  PSL: 'PSL'
};

export type OMaterialModel = (typeof OMaterialModel)[keyof typeof OMaterialModel]


export const OhelperType: {
  TOOL: 'TOOL',
  MATE: 'MATE',
  METH: 'METH',
  MEDIA: 'MEDIA'
};

export type OhelperType = (typeof OhelperType)[keyof typeof OhelperType]


export const OresourceType: {
  URL: 'URL',
  BOOK: 'BOOK'
};

export type OresourceType = (typeof OresourceType)[keyof typeof OresourceType]


export const PointTracker: {
  instansi: 'instansi',
  user: 'user',
  mapel: 'mapel',
  elemen: 'elemen',
  cp: 'cp',
  bidang: 'bidang',
  program: 'program',
  konsentrasi: 'konsentrasi',
  tp: 'tp',
  teacher: 'teacher',
  kelas: 'kelas',
  murid: 'murid',
  jadwal: 'jadwal',
  mengajar: 'mengajar',
  modul: 'modul',
  acp: 'acp',
  akm: 'akm',
  amp: 'amp',
  atp: 'atp',
  asp: 'asp',
  a_asesmen: 'a_asesmen',
  perangkat: 'perangkat',
  kalender: 'kalender',
  dudi: 'dudi',
  kkni: 'kkni'
};

export type PointTracker = (typeof PointTracker)[keyof typeof PointTracker]


export const Religion: {
  Islam: 'Islam',
  Kristen: 'Kristen',
  Katolik: 'Katolik',
  Hindu: 'Hindu',
  Buddha: 'Buddha',
  Khonghucu: 'Khonghucu'
};

export type Religion = (typeof Religion)[keyof typeof Religion]


export const Roles: {
  SU: 'SU',
  GURU: 'GURU',
  STAF: 'STAF',
  SISWA: 'SISWA'
};

export type Roles = (typeof Roles)[keyof typeof Roles]


export const Semester: {
  GA: 'GA',
  GE: 'GE',
  GG: 'GG'
};

export type Semester = (typeof Semester)[keyof typeof Semester]


export const Taksonomi: {
  C1: 'C1',
  C2: 'C2',
  C3: 'C3',
  C4: 'C4',
  C5: 'C5',
  C6: 'C6',
  P1: 'P1',
  P2: 'P2',
  P3: 'P3',
  P4: 'P4',
  P5: 'P5'
};

export type Taksonomi = (typeof Taksonomi)[keyof typeof Taksonomi]


export const TypePersonal: {
  ADMIN: 'ADMIN',
  GURU: 'GURU',
  SISWA: 'SISWA',
  IBU: 'IBU',
  AYAH: 'AYAH',
  WALI: 'WALI'
};

export type TypePersonal = (typeof TypePersonal)[keyof typeof TypePersonal]


export const TypeTracker: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DISABLE: 'DISABLE',
  RECOVER: 'RECOVER'
};

export type TypeTracker = (typeof TypeTracker)[keyof typeof TypeTracker]


export const UploadType: {
  DRIVE: 'DRIVE',
  STORAGE: 'STORAGE'
};

export type UploadType = (typeof UploadType)[keyof typeof UploadType]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Trackers
 * const trackers = await prisma.tracker.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Trackers
   * const trackers = await prisma.tracker.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number }): Promise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

      /**
   * `prisma.tracker`: Exposes CRUD operations for the **Tracker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trackers
    * const trackers = await prisma.tracker.findMany()
    * ```
    */
  get tracker(): Prisma.TrackerDelegate<GlobalReject>;

  /**
   * `prisma.instansi`: Exposes CRUD operations for the **Instansi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Instansis
    * const instansis = await prisma.instansi.findMany()
    * ```
    */
  get instansi(): Prisma.InstansiDelegate<GlobalReject>;

  /**
   * `prisma.mataPelajaran`: Exposes CRUD operations for the **MataPelajaran** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MataPelajarans
    * const mataPelajarans = await prisma.mataPelajaran.findMany()
    * ```
    */
  get mataPelajaran(): Prisma.MataPelajaranDelegate<GlobalReject>;

  /**
   * `prisma.element`: Exposes CRUD operations for the **Element** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Elements
    * const elements = await prisma.element.findMany()
    * ```
    */
  get element(): Prisma.ElementDelegate<GlobalReject>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<GlobalReject>;

  /**
   * `prisma.bidangKeahlian`: Exposes CRUD operations for the **BidangKeahlian** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BidangKeahlians
    * const bidangKeahlians = await prisma.bidangKeahlian.findMany()
    * ```
    */
  get bidangKeahlian(): Prisma.BidangKeahlianDelegate<GlobalReject>;

  /**
   * `prisma.programKeahlian`: Exposes CRUD operations for the **ProgramKeahlian** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgramKeahlians
    * const programKeahlians = await prisma.programKeahlian.findMany()
    * ```
    */
  get programKeahlian(): Prisma.ProgramKeahlianDelegate<GlobalReject>;

  /**
   * `prisma.konsentrasiKeahlian`: Exposes CRUD operations for the **KonsentrasiKeahlian** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KonsentrasiKeahlians
    * const konsentrasiKeahlians = await prisma.konsentrasiKeahlian.findMany()
    * ```
    */
  get konsentrasiKeahlian(): Prisma.KonsentrasiKeahlianDelegate<GlobalReject>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.upload`: Exposes CRUD operations for the **Upload** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Uploads
    * const uploads = await prisma.upload.findMany()
    * ```
    */
  get upload(): Prisma.UploadDelegate<GlobalReject>;

  /**
   * `prisma.personal`: Exposes CRUD operations for the **Personal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Personals
    * const personals = await prisma.personal.findMany()
    * ```
    */
  get personal(): Prisma.PersonalDelegate<GlobalReject>;

  /**
   * `prisma.auth`: Exposes CRUD operations for the **Auth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auths
    * const auths = await prisma.auth.findMany()
    * ```
    */
  get auth(): Prisma.AuthDelegate<GlobalReject>;

  /**
   * `prisma.familyTree`: Exposes CRUD operations for the **FamilyTree** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FamilyTrees
    * const familyTrees = await prisma.familyTree.findMany()
    * ```
    */
  get familyTree(): Prisma.FamilyTreeDelegate<GlobalReject>;

  /**
   * `prisma.familyTreeChild`: Exposes CRUD operations for the **FamilyTreeChild** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FamilyTreeChildren
    * const familyTreeChildren = await prisma.familyTreeChild.findMany()
    * ```
    */
  get familyTreeChild(): Prisma.FamilyTreeChildDelegate<GlobalReject>;

  /**
   * `prisma.schoolYear`: Exposes CRUD operations for the **SchoolYear** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolYears
    * const schoolYears = await prisma.schoolYear.findMany()
    * ```
    */
  get schoolYear(): Prisma.SchoolYearDelegate<GlobalReject>;

  /**
   * `prisma.teacher`: Exposes CRUD operations for the **Teacher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teacher.findMany()
    * ```
    */
  get teacher(): Prisma.TeacherDelegate<GlobalReject>;

  /**
   * `prisma.classRoom`: Exposes CRUD operations for the **ClassRoom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassRooms
    * const classRooms = await prisma.classRoom.findMany()
    * ```
    */
  get classRoom(): Prisma.ClassRoomDelegate<GlobalReject>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<GlobalReject>;

  /**
   * `prisma.schedule`: Exposes CRUD operations for the **Schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedules
    * const schedules = await prisma.schedule.findMany()
    * ```
    */
  get schedule(): Prisma.ScheduleDelegate<GlobalReject>;

  /**
   * `prisma.teaching`: Exposes CRUD operations for the **Teaching** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachings
    * const teachings = await prisma.teaching.findMany()
    * ```
    */
  get teaching(): Prisma.TeachingDelegate<GlobalReject>;

  /**
   * `prisma.link`: Exposes CRUD operations for the **Link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Links
    * const links = await prisma.link.findMany()
    * ```
    */
  get link(): Prisma.LinkDelegate<GlobalReject>;

  /**
   * `prisma.oAssessment`: Exposes CRUD operations for the **OAssessment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OAssessments
    * const oAssessments = await prisma.oAssessment.findMany()
    * ```
    */
  get oAssessment(): Prisma.OAssessmentDelegate<GlobalReject>;

  /**
   * `prisma.objective`: Exposes CRUD operations for the **Objective** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Objectives
    * const objectives = await prisma.objective.findMany()
    * ```
    */
  get objective(): Prisma.ObjectiveDelegate<GlobalReject>;

  /**
   * `prisma.oMaterial`: Exposes CRUD operations for the **OMaterial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OMaterials
    * const oMaterials = await prisma.oMaterial.findMany()
    * ```
    */
  get oMaterial(): Prisma.OMaterialDelegate<GlobalReject>;

  /**
   * `prisma.oLearning`: Exposes CRUD operations for the **OLearning** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OLearnings
    * const oLearnings = await prisma.oLearning.findMany()
    * ```
    */
  get oLearning(): Prisma.OLearningDelegate<GlobalReject>;

  /**
   * `prisma.ohelper`: Exposes CRUD operations for the **Ohelper** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ohelpers
    * const ohelpers = await prisma.ohelper.findMany()
    * ```
    */
  get ohelper(): Prisma.OhelperDelegate<GlobalReject>;

  /**
   * `prisma.oppp`: Exposes CRUD operations for the **Oppp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Oppps
    * const oppps = await prisma.oppp.findMany()
    * ```
    */
  get oppp(): Prisma.OpppDelegate<GlobalReject>;

  /**
   * `prisma.oresource`: Exposes CRUD operations for the **Oresource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Oresources
    * const oresources = await prisma.oresource.findMany()
    * ```
    */
  get oresource(): Prisma.OresourceDelegate<GlobalReject>;

  /**
   * `prisma.book`: Exposes CRUD operations for the **Book** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Books
    * const books = await prisma.book.findMany()
    * ```
    */
  get book(): Prisma.BookDelegate<GlobalReject>;

  /**
   * `prisma.tDevice`: Exposes CRUD operations for the **TDevice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TDevices
    * const tDevices = await prisma.tDevice.findMany()
    * ```
    */
  get tDevice(): Prisma.TDeviceDelegate<GlobalReject>;

  /**
   * `prisma.tDeviceData`: Exposes CRUD operations for the **TDeviceData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TDeviceData
    * const tDeviceData = await prisma.tDeviceData.findMany()
    * ```
    */
  get tDeviceData(): Prisma.TDeviceDataDelegate<GlobalReject>;

  /**
   * `prisma.calendar`: Exposes CRUD operations for the **Calendar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Calendars
    * const calendars = await prisma.calendar.findMany()
    * ```
    */
  get calendar(): Prisma.CalendarDelegate<GlobalReject>;

  /**
   * `prisma.dudi`: Exposes CRUD operations for the **Dudi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dudis
    * const dudis = await prisma.dudi.findMany()
    * ```
    */
  get dudi(): Prisma.DudiDelegate<GlobalReject>;

  /**
   * `prisma.dudiLearning`: Exposes CRUD operations for the **DudiLearning** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DudiLearnings
    * const dudiLearnings = await prisma.dudiLearning.findMany()
    * ```
    */
  get dudiLearning(): Prisma.DudiLearningDelegate<GlobalReject>;

  /**
   * `prisma.kkni`: Exposes CRUD operations for the **Kkni** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kknis
    * const kknis = await prisma.kkni.findMany()
    * ```
    */
  get kkni(): Prisma.KkniDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.15.0
   * Query Engine version: 8fbc245156db7124f997f4cecdd8d1219e360944
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tracker: 'Tracker',
    Instansi: 'Instansi',
    MataPelajaran: 'MataPelajaran',
    Element: 'Element',
    Achievement: 'Achievement',
    BidangKeahlian: 'BidangKeahlian',
    ProgramKeahlian: 'ProgramKeahlian',
    KonsentrasiKeahlian: 'KonsentrasiKeahlian',
    Role: 'Role',
    User: 'User',
    Upload: 'Upload',
    Personal: 'Personal',
    Auth: 'Auth',
    FamilyTree: 'FamilyTree',
    FamilyTreeChild: 'FamilyTreeChild',
    SchoolYear: 'SchoolYear',
    Teacher: 'Teacher',
    ClassRoom: 'ClassRoom',
    Student: 'Student',
    Schedule: 'Schedule',
    Teaching: 'Teaching',
    Link: 'Link',
    OAssessment: 'OAssessment',
    Objective: 'Objective',
    OMaterial: 'OMaterial',
    OLearning: 'OLearning',
    Ohelper: 'Ohelper',
    Oppp: 'Oppp',
    Oresource: 'Oresource',
    Book: 'Book',
    TDevice: 'TDevice',
    TDeviceData: 'TDeviceData',
    Calendar: 'Calendar',
    Dudi: 'Dudi',
    DudiLearning: 'DudiLearning',
    Kkni: 'Kkni'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type InstansiCountOutputType
   */


  export type InstansiCountOutputType = {
    majors: number
    role: number
    schoolYear: number
    teacher: number
    student: number
    tracker: number
    history: number
    unikMapels: number
    tDevice: number
    objective: number
    dudi: number
  }

  export type InstansiCountOutputTypeSelect = {
    majors?: boolean
    role?: boolean
    schoolYear?: boolean
    teacher?: boolean
    student?: boolean
    tracker?: boolean
    history?: boolean
    unikMapels?: boolean
    tDevice?: boolean
    objective?: boolean
    dudi?: boolean
  }

  export type InstansiCountOutputTypeGetPayload<S extends boolean | null | undefined | InstansiCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? InstansiCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (InstansiCountOutputTypeArgs)
    ? InstansiCountOutputType 
    : S extends { select: any } & (InstansiCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof InstansiCountOutputType ? InstansiCountOutputType[P] : never
  } 
      : InstansiCountOutputType




  // Custom InputTypes

  /**
   * InstansiCountOutputType without action
   */
  export type InstansiCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the InstansiCountOutputType
     */
    select?: InstansiCountOutputTypeSelect | null
  }



  /**
   * Count Type MataPelajaranCountOutputType
   */


  export type MataPelajaranCountOutputType = {
    element: number
    schedule: number
    tracker: number
    objective: number
    device: number
  }

  export type MataPelajaranCountOutputTypeSelect = {
    element?: boolean
    schedule?: boolean
    tracker?: boolean
    objective?: boolean
    device?: boolean
  }

  export type MataPelajaranCountOutputTypeGetPayload<S extends boolean | null | undefined | MataPelajaranCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MataPelajaranCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MataPelajaranCountOutputTypeArgs)
    ? MataPelajaranCountOutputType 
    : S extends { select: any } & (MataPelajaranCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MataPelajaranCountOutputType ? MataPelajaranCountOutputType[P] : never
  } 
      : MataPelajaranCountOutputType




  // Custom InputTypes

  /**
   * MataPelajaranCountOutputType without action
   */
  export type MataPelajaranCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MataPelajaranCountOutputType
     */
    select?: MataPelajaranCountOutputTypeSelect | null
  }



  /**
   * Count Type ElementCountOutputType
   */


  export type ElementCountOutputType = {
    achievement: number
    tracker: number
    scheduleClass: number
    objective: number
  }

  export type ElementCountOutputTypeSelect = {
    achievement?: boolean
    tracker?: boolean
    scheduleClass?: boolean
    objective?: boolean
  }

  export type ElementCountOutputTypeGetPayload<S extends boolean | null | undefined | ElementCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ElementCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ElementCountOutputTypeArgs)
    ? ElementCountOutputType 
    : S extends { select: any } & (ElementCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ElementCountOutputType ? ElementCountOutputType[P] : never
  } 
      : ElementCountOutputType




  // Custom InputTypes

  /**
   * ElementCountOutputType without action
   */
  export type ElementCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ElementCountOutputType
     */
    select?: ElementCountOutputTypeSelect | null
  }



  /**
   * Count Type AchievementCountOutputType
   */


  export type AchievementCountOutputType = {
    objective: number
    tracker: number
  }

  export type AchievementCountOutputTypeSelect = {
    objective?: boolean
    tracker?: boolean
  }

  export type AchievementCountOutputTypeGetPayload<S extends boolean | null | undefined | AchievementCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AchievementCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (AchievementCountOutputTypeArgs)
    ? AchievementCountOutputType 
    : S extends { select: any } & (AchievementCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof AchievementCountOutputType ? AchievementCountOutputType[P] : never
  } 
      : AchievementCountOutputType




  // Custom InputTypes

  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AchievementCountOutputType
     */
    select?: AchievementCountOutputTypeSelect | null
  }



  /**
   * Count Type BidangKeahlianCountOutputType
   */


  export type BidangKeahlianCountOutputType = {
    program: number
    tracker: number
  }

  export type BidangKeahlianCountOutputTypeSelect = {
    program?: boolean
    tracker?: boolean
  }

  export type BidangKeahlianCountOutputTypeGetPayload<S extends boolean | null | undefined | BidangKeahlianCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BidangKeahlianCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BidangKeahlianCountOutputTypeArgs)
    ? BidangKeahlianCountOutputType 
    : S extends { select: any } & (BidangKeahlianCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BidangKeahlianCountOutputType ? BidangKeahlianCountOutputType[P] : never
  } 
      : BidangKeahlianCountOutputType




  // Custom InputTypes

  /**
   * BidangKeahlianCountOutputType without action
   */
  export type BidangKeahlianCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BidangKeahlianCountOutputType
     */
    select?: BidangKeahlianCountOutputTypeSelect | null
  }



  /**
   * Count Type ProgramKeahlianCountOutputType
   */


  export type ProgramKeahlianCountOutputType = {
    konsentrasi: number
    tracker: number
    mapel: number
  }

  export type ProgramKeahlianCountOutputTypeSelect = {
    konsentrasi?: boolean
    tracker?: boolean
    mapel?: boolean
  }

  export type ProgramKeahlianCountOutputTypeGetPayload<S extends boolean | null | undefined | ProgramKeahlianCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProgramKeahlianCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProgramKeahlianCountOutputTypeArgs)
    ? ProgramKeahlianCountOutputType 
    : S extends { select: any } & (ProgramKeahlianCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProgramKeahlianCountOutputType ? ProgramKeahlianCountOutputType[P] : never
  } 
      : ProgramKeahlianCountOutputType




  // Custom InputTypes

  /**
   * ProgramKeahlianCountOutputType without action
   */
  export type ProgramKeahlianCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProgramKeahlianCountOutputType
     */
    select?: ProgramKeahlianCountOutputTypeSelect | null
  }



  /**
   * Count Type KonsentrasiKeahlianCountOutputType
   */


  export type KonsentrasiKeahlianCountOutputType = {
    student: number
    instansi: number
    classRoom: number
    tracker: number
    mapel: number
    dudi: number
    kkni: number
  }

  export type KonsentrasiKeahlianCountOutputTypeSelect = {
    student?: boolean
    instansi?: boolean
    classRoom?: boolean
    tracker?: boolean
    mapel?: boolean
    dudi?: boolean
    kkni?: boolean
  }

  export type KonsentrasiKeahlianCountOutputTypeGetPayload<S extends boolean | null | undefined | KonsentrasiKeahlianCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? KonsentrasiKeahlianCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (KonsentrasiKeahlianCountOutputTypeArgs)
    ? KonsentrasiKeahlianCountOutputType 
    : S extends { select: any } & (KonsentrasiKeahlianCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof KonsentrasiKeahlianCountOutputType ? KonsentrasiKeahlianCountOutputType[P] : never
  } 
      : KonsentrasiKeahlianCountOutputType




  // Custom InputTypes

  /**
   * KonsentrasiKeahlianCountOutputType without action
   */
  export type KonsentrasiKeahlianCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlianCountOutputType
     */
    select?: KonsentrasiKeahlianCountOutputTypeSelect | null
  }



  /**
   * Count Type RoleCountOutputType
   */


  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect = {
    users?: boolean
  }

  export type RoleCountOutputTypeGetPayload<S extends boolean | null | undefined | RoleCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RoleCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RoleCountOutputTypeArgs)
    ? RoleCountOutputType 
    : S extends { select: any } & (RoleCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RoleCountOutputType ? RoleCountOutputType[P] : never
  } 
      : RoleCountOutputType




  // Custom InputTypes

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    tracker: number
    objective: number
    link: number
    tDevice: number
  }

  export type UserCountOutputTypeSelect = {
    tracker?: boolean
    objective?: boolean
    link?: boolean
    tDevice?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type PersonalCountOutputType
   */


  export type PersonalCountOutputType = {
    father: number
    mother: number
    wali: number
    couple: number
    student: number
    teacher: number
  }

  export type PersonalCountOutputTypeSelect = {
    father?: boolean
    mother?: boolean
    wali?: boolean
    couple?: boolean
    student?: boolean
    teacher?: boolean
  }

  export type PersonalCountOutputTypeGetPayload<S extends boolean | null | undefined | PersonalCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PersonalCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PersonalCountOutputTypeArgs)
    ? PersonalCountOutputType 
    : S extends { select: any } & (PersonalCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PersonalCountOutputType ? PersonalCountOutputType[P] : never
  } 
      : PersonalCountOutputType




  // Custom InputTypes

  /**
   * PersonalCountOutputType without action
   */
  export type PersonalCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PersonalCountOutputType
     */
    select?: PersonalCountOutputTypeSelect | null
  }



  /**
   * Count Type FamilyTreeCountOutputType
   */


  export type FamilyTreeCountOutputType = {
    childs: number
  }

  export type FamilyTreeCountOutputTypeSelect = {
    childs?: boolean
  }

  export type FamilyTreeCountOutputTypeGetPayload<S extends boolean | null | undefined | FamilyTreeCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FamilyTreeCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FamilyTreeCountOutputTypeArgs)
    ? FamilyTreeCountOutputType 
    : S extends { select: any } & (FamilyTreeCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FamilyTreeCountOutputType ? FamilyTreeCountOutputType[P] : never
  } 
      : FamilyTreeCountOutputType




  // Custom InputTypes

  /**
   * FamilyTreeCountOutputType without action
   */
  export type FamilyTreeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FamilyTreeCountOutputType
     */
    select?: FamilyTreeCountOutputTypeSelect | null
  }



  /**
   * Count Type SchoolYearCountOutputType
   */


  export type SchoolYearCountOutputType = {
    classRoom: number
    students: number
    calendar: number
    schedule: number
    objective: number
    tracker: number
    TDevice: number
  }

  export type SchoolYearCountOutputTypeSelect = {
    classRoom?: boolean
    students?: boolean
    calendar?: boolean
    schedule?: boolean
    objective?: boolean
    tracker?: boolean
    TDevice?: boolean
  }

  export type SchoolYearCountOutputTypeGetPayload<S extends boolean | null | undefined | SchoolYearCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SchoolYearCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (SchoolYearCountOutputTypeArgs)
    ? SchoolYearCountOutputType 
    : S extends { select: any } & (SchoolYearCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SchoolYearCountOutputType ? SchoolYearCountOutputType[P] : never
  } 
      : SchoolYearCountOutputType




  // Custom InputTypes

  /**
   * SchoolYearCountOutputType without action
   */
  export type SchoolYearCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SchoolYearCountOutputType
     */
    select?: SchoolYearCountOutputTypeSelect | null
  }



  /**
   * Count Type TeacherCountOutputType
   */


  export type TeacherCountOutputType = {
    classRoom: number
    event: number
    tracker: number
    teaching: number
  }

  export type TeacherCountOutputTypeSelect = {
    classRoom?: boolean
    event?: boolean
    tracker?: boolean
    teaching?: boolean
  }

  export type TeacherCountOutputTypeGetPayload<S extends boolean | null | undefined | TeacherCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TeacherCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TeacherCountOutputTypeArgs)
    ? TeacherCountOutputType 
    : S extends { select: any } & (TeacherCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TeacherCountOutputType ? TeacherCountOutputType[P] : never
  } 
      : TeacherCountOutputType




  // Custom InputTypes

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TeacherCountOutputType
     */
    select?: TeacherCountOutputTypeSelect | null
  }



  /**
   * Count Type ClassRoomCountOutputType
   */


  export type ClassRoomCountOutputType = {
    students: number
    event: number
    tracker: number
    teaching: number
    tDevice: number
  }

  export type ClassRoomCountOutputTypeSelect = {
    students?: boolean
    event?: boolean
    tracker?: boolean
    teaching?: boolean
    tDevice?: boolean
  }

  export type ClassRoomCountOutputTypeGetPayload<S extends boolean | null | undefined | ClassRoomCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ClassRoomCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ClassRoomCountOutputTypeArgs)
    ? ClassRoomCountOutputType 
    : S extends { select: any } & (ClassRoomCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ClassRoomCountOutputType ? ClassRoomCountOutputType[P] : never
  } 
      : ClassRoomCountOutputType




  // Custom InputTypes

  /**
   * ClassRoomCountOutputType without action
   */
  export type ClassRoomCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ClassRoomCountOutputType
     */
    select?: ClassRoomCountOutputTypeSelect | null
  }



  /**
   * Count Type StudentCountOutputType
   */


  export type StudentCountOutputType = {
    classRoom: number
    event: number
    tracker: number
  }

  export type StudentCountOutputTypeSelect = {
    classRoom?: boolean
    event?: boolean
    tracker?: boolean
  }

  export type StudentCountOutputTypeGetPayload<S extends boolean | null | undefined | StudentCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? StudentCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (StudentCountOutputTypeArgs)
    ? StudentCountOutputType 
    : S extends { select: any } & (StudentCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof StudentCountOutputType ? StudentCountOutputType[P] : never
  } 
      : StudentCountOutputType




  // Custom InputTypes

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect | null
  }



  /**
   * Count Type ScheduleCountOutputType
   */


  export type ScheduleCountOutputType = {
    tracker: number
    teaching: number
  }

  export type ScheduleCountOutputTypeSelect = {
    tracker?: boolean
    teaching?: boolean
  }

  export type ScheduleCountOutputTypeGetPayload<S extends boolean | null | undefined | ScheduleCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ScheduleCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ScheduleCountOutputTypeArgs)
    ? ScheduleCountOutputType 
    : S extends { select: any } & (ScheduleCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ScheduleCountOutputType ? ScheduleCountOutputType[P] : never
  } 
      : ScheduleCountOutputType




  // Custom InputTypes

  /**
   * ScheduleCountOutputType without action
   */
  export type ScheduleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ScheduleCountOutputType
     */
    select?: ScheduleCountOutputTypeSelect | null
  }



  /**
   * Count Type TeachingCountOutputType
   */


  export type TeachingCountOutputType = {
    classRoom: number
    elemen: number
    tracker: number
    tDevice: number
  }

  export type TeachingCountOutputTypeSelect = {
    classRoom?: boolean
    elemen?: boolean
    tracker?: boolean
    tDevice?: boolean
  }

  export type TeachingCountOutputTypeGetPayload<S extends boolean | null | undefined | TeachingCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TeachingCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TeachingCountOutputTypeArgs)
    ? TeachingCountOutputType 
    : S extends { select: any } & (TeachingCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TeachingCountOutputType ? TeachingCountOutputType[P] : never
  } 
      : TeachingCountOutputType




  // Custom InputTypes

  /**
   * TeachingCountOutputType without action
   */
  export type TeachingCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TeachingCountOutputType
     */
    select?: TeachingCountOutputTypeSelect | null
  }



  /**
   * Count Type LinkCountOutputType
   */


  export type LinkCountOutputType = {
    objResource: number
  }

  export type LinkCountOutputTypeSelect = {
    objResource?: boolean
  }

  export type LinkCountOutputTypeGetPayload<S extends boolean | null | undefined | LinkCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LinkCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LinkCountOutputTypeArgs)
    ? LinkCountOutputType 
    : S extends { select: any } & (LinkCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LinkCountOutputType ? LinkCountOutputType[P] : never
  } 
      : LinkCountOutputType




  // Custom InputTypes

  /**
   * LinkCountOutputType without action
   */
  export type LinkCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LinkCountOutputType
     */
    select?: LinkCountOutputTypeSelect | null
  }



  /**
   * Count Type ObjectiveCountOutputType
   */


  export type ObjectiveCountOutputType = {
    material: number
    tracker: number
    resourse: number
    ppp: number
    tool: number
    mate: number
    meth: number
    media: number
    assessments: number
    devices: number
  }

  export type ObjectiveCountOutputTypeSelect = {
    material?: boolean
    tracker?: boolean
    resourse?: boolean
    ppp?: boolean
    tool?: boolean
    mate?: boolean
    meth?: boolean
    media?: boolean
    assessments?: boolean
    devices?: boolean
  }

  export type ObjectiveCountOutputTypeGetPayload<S extends boolean | null | undefined | ObjectiveCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ObjectiveCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ObjectiveCountOutputTypeArgs)
    ? ObjectiveCountOutputType 
    : S extends { select: any } & (ObjectiveCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ObjectiveCountOutputType ? ObjectiveCountOutputType[P] : never
  } 
      : ObjectiveCountOutputType




  // Custom InputTypes

  /**
   * ObjectiveCountOutputType without action
   */
  export type ObjectiveCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ObjectiveCountOutputType
     */
    select?: ObjectiveCountOutputTypeSelect | null
  }



  /**
   * Count Type OMaterialCountOutputType
   */


  export type OMaterialCountOutputType = {
    learning: number
  }

  export type OMaterialCountOutputTypeSelect = {
    learning?: boolean
  }

  export type OMaterialCountOutputTypeGetPayload<S extends boolean | null | undefined | OMaterialCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OMaterialCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (OMaterialCountOutputTypeArgs)
    ? OMaterialCountOutputType 
    : S extends { select: any } & (OMaterialCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof OMaterialCountOutputType ? OMaterialCountOutputType[P] : never
  } 
      : OMaterialCountOutputType




  // Custom InputTypes

  /**
   * OMaterialCountOutputType without action
   */
  export type OMaterialCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OMaterialCountOutputType
     */
    select?: OMaterialCountOutputTypeSelect | null
  }



  /**
   * Count Type OhelperCountOutputType
   */


  export type OhelperCountOutputType = {
    tool: number
    mate: number
    meth: number
    media: number
  }

  export type OhelperCountOutputTypeSelect = {
    tool?: boolean
    mate?: boolean
    meth?: boolean
    media?: boolean
  }

  export type OhelperCountOutputTypeGetPayload<S extends boolean | null | undefined | OhelperCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OhelperCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (OhelperCountOutputTypeArgs)
    ? OhelperCountOutputType 
    : S extends { select: any } & (OhelperCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof OhelperCountOutputType ? OhelperCountOutputType[P] : never
  } 
      : OhelperCountOutputType




  // Custom InputTypes

  /**
   * OhelperCountOutputType without action
   */
  export type OhelperCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OhelperCountOutputType
     */
    select?: OhelperCountOutputTypeSelect | null
  }



  /**
   * Count Type TDeviceCountOutputType
   */


  export type TDeviceCountOutputType = {
    classRoom: number
    tracker: number
    data: number
    children: number
  }

  export type TDeviceCountOutputTypeSelect = {
    classRoom?: boolean
    tracker?: boolean
    data?: boolean
    children?: boolean
  }

  export type TDeviceCountOutputTypeGetPayload<S extends boolean | null | undefined | TDeviceCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TDeviceCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TDeviceCountOutputTypeArgs)
    ? TDeviceCountOutputType 
    : S extends { select: any } & (TDeviceCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TDeviceCountOutputType ? TDeviceCountOutputType[P] : never
  } 
      : TDeviceCountOutputType




  // Custom InputTypes

  /**
   * TDeviceCountOutputType without action
   */
  export type TDeviceCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TDeviceCountOutputType
     */
    select?: TDeviceCountOutputTypeSelect | null
  }



  /**
   * Count Type CalendarCountOutputType
   */


  export type CalendarCountOutputType = {
    classRoom: number
    student: number
    teacher: number
    tracker: number
  }

  export type CalendarCountOutputTypeSelect = {
    classRoom?: boolean
    student?: boolean
    teacher?: boolean
    tracker?: boolean
  }

  export type CalendarCountOutputTypeGetPayload<S extends boolean | null | undefined | CalendarCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CalendarCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CalendarCountOutputTypeArgs)
    ? CalendarCountOutputType 
    : S extends { select: any } & (CalendarCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CalendarCountOutputType ? CalendarCountOutputType[P] : never
  } 
      : CalendarCountOutputType




  // Custom InputTypes

  /**
   * CalendarCountOutputType without action
   */
  export type CalendarCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CalendarCountOutputType
     */
    select?: CalendarCountOutputTypeSelect | null
  }



  /**
   * Count Type DudiCountOutputType
   */


  export type DudiCountOutputType = {
    learning: number
    tracker: number
  }

  export type DudiCountOutputTypeSelect = {
    learning?: boolean
    tracker?: boolean
  }

  export type DudiCountOutputTypeGetPayload<S extends boolean | null | undefined | DudiCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DudiCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (DudiCountOutputTypeArgs)
    ? DudiCountOutputType 
    : S extends { select: any } & (DudiCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DudiCountOutputType ? DudiCountOutputType[P] : never
  } 
      : DudiCountOutputType




  // Custom InputTypes

  /**
   * DudiCountOutputType without action
   */
  export type DudiCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DudiCountOutputType
     */
    select?: DudiCountOutputTypeSelect | null
  }



  /**
   * Count Type KkniCountOutputType
   */


  export type KkniCountOutputType = {
    dudi: number
    tracker: number
  }

  export type KkniCountOutputTypeSelect = {
    dudi?: boolean
    tracker?: boolean
  }

  export type KkniCountOutputTypeGetPayload<S extends boolean | null | undefined | KkniCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? KkniCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (KkniCountOutputTypeArgs)
    ? KkniCountOutputType 
    : S extends { select: any } & (KkniCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof KkniCountOutputType ? KkniCountOutputType[P] : never
  } 
      : KkniCountOutputType




  // Custom InputTypes

  /**
   * KkniCountOutputType without action
   */
  export type KkniCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the KkniCountOutputType
     */
    select?: KkniCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Coordinate
   */





  export type CoordinateSelect = {
    longitude?: boolean
    latitude?: boolean
  }


  export type CoordinateGetPayload<S extends boolean | null | undefined | CoordinateArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Coordinate :
    S extends undefined ? never :
    S extends { include: any } & (CoordinateArgs)
    ? Coordinate 
    : S extends { select: any } & (CoordinateArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Coordinate ? Coordinate[P] : never
  } 
      : Coordinate



  export interface CoordinateDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Coordinate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CoordinateClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Coordinate without action
   */
  export type CoordinateArgs = {
    /**
     * Select specific fields to fetch from the Coordinate
     */
    select?: CoordinateSelect | null
  }



  /**
   * Model Address
   */





  export type AddressSelect = {
    provinsi?: boolean
    kabupaten?: boolean
    kecamatan?: boolean
    kelurahan?: boolean
    kodepos?: boolean
    coordinate?: boolean | CoordinateArgs
  }


  export type AddressInclude = {}

  export type AddressGetPayload<S extends boolean | null | undefined | AddressArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Address :
    S extends undefined ? never :
    S extends { include: any } & (AddressArgs)
    ? Address 
    : S extends { select: any } & (AddressArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'coordinate' ? CoordinateGetPayload<S['select'][P]> :  P extends keyof Address ? Address[P] : never
  } 
      : Address



  export interface AddressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AddressClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    coordinate<T extends CoordinateArgs= {}>(args?: Subset<T, CoordinateArgs>): Prisma__CoordinateClient<CoordinateGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Address without action
   */
  export type AddressArgs = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude | null
  }



  /**
   * Model Google
   */





  export type GoogleSelect = {
    scopes?: boolean
    tokens?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type GoogleGetPayload<S extends boolean | null | undefined | GoogleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Google :
    S extends undefined ? never :
    S extends { include: any } & (GoogleArgs)
    ? Google 
    : S extends { select: any } & (GoogleArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Google ? Google[P] : never
  } 
      : Google



  export interface GoogleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Google.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GoogleClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Google without action
   */
  export type GoogleArgs = {
    /**
     * Select specific fields to fetch from the Google
     */
    select?: GoogleSelect | null
  }



  /**
   * Model Born
   */





  export type BornSelect = {
    place?: boolean
    date?: boolean
  }


  export type BornGetPayload<S extends boolean | null | undefined | BornArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Born :
    S extends undefined ? never :
    S extends { include: any } & (BornArgs)
    ? Born 
    : S extends { select: any } & (BornArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Born ? Born[P] : never
  } 
      : Born



  export interface BornDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Born.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BornClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Born without action
   */
  export type BornArgs = {
    /**
     * Select specific fields to fetch from the Born
     */
    select?: BornSelect | null
  }



  /**
   * Model Education
   */





  export type EducationSelect = {
    instansi?: boolean
    level?: boolean
    major?: boolean
    year?: boolean
    attachment?: boolean
  }


  export type EducationGetPayload<S extends boolean | null | undefined | EducationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Education :
    S extends undefined ? never :
    S extends { include: any } & (EducationArgs)
    ? Education 
    : S extends { select: any } & (EducationArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Education ? Education[P] : never
  } 
      : Education



  export interface EducationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Education.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EducationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Education without action
   */
  export type EducationArgs = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect | null
  }



  /**
   * Model Training
   */





  export type TrainingSelect = {
    name?: boolean
    instansi?: boolean
    long?: boolean
    year?: boolean
    place?: boolean
    attachment?: boolean
  }


  export type TrainingGetPayload<S extends boolean | null | undefined | TrainingArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Training :
    S extends undefined ? never :
    S extends { include: any } & (TrainingArgs)
    ? Training 
    : S extends { select: any } & (TrainingArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Training ? Training[P] : never
  } 
      : Training



  export interface TrainingDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Training.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TrainingClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Training without action
   */
  export type TrainingArgs = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect | null
  }



  /**
   * Model Profession
   */





  export type ProfessionSelect = {
    name?: boolean
    instansi?: boolean
    year?: boolean
    attachment?: boolean
  }


  export type ProfessionGetPayload<S extends boolean | null | undefined | ProfessionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Profession :
    S extends undefined ? never :
    S extends { include: any } & (ProfessionArgs)
    ? Profession 
    : S extends { select: any } & (ProfessionArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Profession ? Profession[P] : never
  } 
      : Profession



  export interface ProfessionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Profession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProfessionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Profession without action
   */
  export type ProfessionArgs = {
    /**
     * Select specific fields to fetch from the Profession
     */
    select?: ProfessionSelect | null
  }



  /**
   * Model Employment
   */





  export type EmploymentSelect = {
    position?: boolean
    year?: boolean
    place?: boolean
    note?: boolean
  }


  export type EmploymentGetPayload<S extends boolean | null | undefined | EmploymentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Employment :
    S extends undefined ? never :
    S extends { include: any } & (EmploymentArgs)
    ? Employment 
    : S extends { select: any } & (EmploymentArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Employment ? Employment[P] : never
  } 
      : Employment



  export interface EmploymentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Employment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EmploymentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Employment without action
   */
  export type EmploymentArgs = {
    /**
     * Select specific fields to fetch from the Employment
     */
    select?: EmploymentSelect | null
  }



  /**
   * Model Overseas
   */





  export type OverseasSelect = {
    country?: boolean
    instansi?: boolean
    objective?: boolean
    long?: boolean
    year?: boolean
    attachment?: boolean
  }


  export type OverseasGetPayload<S extends boolean | null | undefined | OverseasArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Overseas :
    S extends undefined ? never :
    S extends { include: any } & (OverseasArgs)
    ? Overseas 
    : S extends { select: any } & (OverseasArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Overseas ? Overseas[P] : never
  } 
      : Overseas



  export interface OverseasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Overseas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OverseasClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Overseas without action
   */
  export type OverseasArgs = {
    /**
     * Select specific fields to fetch from the Overseas
     */
    select?: OverseasSelect | null
  }



  /**
   * Model Scientific
   */





  export type ScientificSelect = {
    name?: boolean
    instansi?: boolean
    position?: boolean
    place?: boolean
    period?: boolean
    attachment?: boolean
  }


  export type ScientificGetPayload<S extends boolean | null | undefined | ScientificArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Scientific :
    S extends undefined ? never :
    S extends { include: any } & (ScientificArgs)
    ? Scientific 
    : S extends { select: any } & (ScientificArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Scientific ? Scientific[P] : never
  } 
      : Scientific



  export interface ScientificDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Scientific.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ScientificClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Scientific without action
   */
  export type ScientificArgs = {
    /**
     * Select specific fields to fetch from the Scientific
     */
    select?: ScientificSelect | null
  }



  /**
   * Model Organization
   */





  export type OrganizationSelect = {
    name?: boolean
    position?: boolean
    period?: boolean
    leader?: boolean
    place?: boolean
  }


  export type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Organization :
    S extends undefined ? never :
    S extends { include: any } & (OrganizationArgs)
    ? Organization 
    : S extends { select: any } & (OrganizationArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Organization ? Organization[P] : never
  } 
      : Organization



  export interface OrganizationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrganizationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Organization without action
   */
  export type OrganizationArgs = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect | null
  }



  /**
   * Model Papers
   */





  export type PapersSelect = {
    name?: boolean
    year?: boolean
    published?: boolean
  }


  export type PapersGetPayload<S extends boolean | null | undefined | PapersArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Papers :
    S extends undefined ? never :
    S extends { include: any } & (PapersArgs)
    ? Papers 
    : S extends { select: any } & (PapersArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Papers ? Papers[P] : never
  } 
      : Papers



  export interface PapersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Papers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PapersClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Papers without action
   */
  export type PapersArgs = {
    /**
     * Select specific fields to fetch from the Papers
     */
    select?: PapersSelect | null
  }



  /**
   * Model Innovation
   */





  export type InnovationSelect = {
    name?: boolean
    year?: boolean
    patent?: boolean
  }


  export type InnovationGetPayload<S extends boolean | null | undefined | InnovationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Innovation :
    S extends undefined ? never :
    S extends { include: any } & (InnovationArgs)
    ? Innovation 
    : S extends { select: any } & (InnovationArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Innovation ? Innovation[P] : never
  } 
      : Innovation



  export interface InnovationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Innovation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InnovationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Innovation without action
   */
  export type InnovationArgs = {
    /**
     * Select specific fields to fetch from the Innovation
     */
    select?: InnovationSelect | null
  }



  /**
   * Model Award
   */





  export type AwardSelect = {
    name?: boolean
    year?: boolean
    instansi?: boolean
    attachment?: boolean
  }


  export type AwardGetPayload<S extends boolean | null | undefined | AwardArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Award :
    S extends undefined ? never :
    S extends { include: any } & (AwardArgs)
    ? Award 
    : S extends { select: any } & (AwardArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Award ? Award[P] : never
  } 
      : Award



  export interface AwardDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Award.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AwardClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Award without action
   */
  export type AwardArgs = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect | null
  }



  /**
   * Model SourcePerson
   */





  export type SourcePersonSelect = {
    name?: boolean
    date?: boolean
    instansi?: boolean
    note?: boolean
    attachment?: boolean
  }


  export type SourcePersonGetPayload<S extends boolean | null | undefined | SourcePersonArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SourcePerson :
    S extends undefined ? never :
    S extends { include: any } & (SourcePersonArgs)
    ? SourcePerson 
    : S extends { select: any } & (SourcePersonArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SourcePerson ? SourcePerson[P] : never
  } 
      : SourcePerson



  export interface SourcePersonDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for SourcePerson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SourcePersonClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SourcePerson without action
   */
  export type SourcePersonArgs = {
    /**
     * Select specific fields to fetch from the SourcePerson
     */
    select?: SourcePersonSelect | null
  }



  /**
   * Model Contest
   */





  export type ContestSelect = {
    name?: boolean
    date?: boolean
    instansi?: boolean
    level?: boolean
    attachment?: boolean
  }


  export type ContestGetPayload<S extends boolean | null | undefined | ContestArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Contest :
    S extends undefined ? never :
    S extends { include: any } & (ContestArgs)
    ? Contest 
    : S extends { select: any } & (ContestArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Contest ? Contest[P] : never
  } 
      : Contest



  export interface ContestDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Contest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ContestClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Contest without action
   */
  export type ContestArgs = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect | null
  }



  /**
   * Model Documents
   */





  export type DocumentsSelect = {
    name?: boolean
    date?: boolean
    instansi?: boolean
    note?: boolean
    attachment?: boolean
  }


  export type DocumentsGetPayload<S extends boolean | null | undefined | DocumentsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Documents :
    S extends undefined ? never :
    S extends { include: any } & (DocumentsArgs)
    ? Documents 
    : S extends { select: any } & (DocumentsArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Documents ? Documents[P] : never
  } 
      : Documents



  export interface DocumentsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Documents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DocumentsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Documents without action
   */
  export type DocumentsArgs = {
    /**
     * Select specific fields to fetch from the Documents
     */
    select?: DocumentsSelect | null
  }



  /**
   * Model Additional
   */





  export type AdditionalSelect = {
    position?: boolean
    date?: boolean
    instansi?: boolean
    note?: boolean
    attachment?: boolean
  }


  export type AdditionalGetPayload<S extends boolean | null | undefined | AdditionalArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Additional :
    S extends undefined ? never :
    S extends { include: any } & (AdditionalArgs)
    ? Additional 
    : S extends { select: any } & (AdditionalArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Additional ? Additional[P] : never
  } 
      : Additional



  export interface AdditionalDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Additional.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AdditionalClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Additional without action
   */
  export type AdditionalArgs = {
    /**
     * Select specific fields to fetch from the Additional
     */
    select?: AdditionalSelect | null
  }



  /**
   * Model Organizational
   */





  export type OrganizationalSelect = {
    kepsek?: boolean
    wakasek?: boolean
    wakakur?: boolean
    wakasiw?: boolean
    wakapra?: boolean
    wakahum?: boolean
  }


  export type OrganizationalGetPayload<S extends boolean | null | undefined | OrganizationalArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Organizational :
    S extends undefined ? never :
    S extends { include: any } & (OrganizationalArgs)
    ? Organizational 
    : S extends { select: any } & (OrganizationalArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Organizational ? Organizational[P] : never
  } 
      : Organizational



  export interface OrganizationalDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Organizational.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrganizationalClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Organizational without action
   */
  export type OrganizationalArgs = {
    /**
     * Select specific fields to fetch from the Organizational
     */
    select?: OrganizationalSelect | null
  }



  /**
   * Model RoomProperty
   */





  export type RoomPropertySelect = {
    pkl?: boolean
  }


  export type RoomPropertyGetPayload<S extends boolean | null | undefined | RoomPropertyArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RoomProperty :
    S extends undefined ? never :
    S extends { include: any } & (RoomPropertyArgs)
    ? RoomProperty 
    : S extends { select: any } & (RoomPropertyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RoomProperty ? RoomProperty[P] : never
  } 
      : RoomProperty



  export interface RoomPropertyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomProperty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoomPropertyClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RoomProperty without action
   */
  export type RoomPropertyArgs = {
    /**
     * Select specific fields to fetch from the RoomProperty
     */
    select?: RoomPropertySelect | null
  }



  /**
   * Model TDevicePos
   */





  export type TDevicePosSelect = {
    mouth?: boolean
    week?: boolean
    active?: boolean
  }


  export type TDevicePosGetPayload<S extends boolean | null | undefined | TDevicePosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TDevicePos :
    S extends undefined ? never :
    S extends { include: any } & (TDevicePosArgs)
    ? TDevicePos 
    : S extends { select: any } & (TDevicePosArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TDevicePos ? TDevicePos[P] : never
  } 
      : TDevicePos



  export interface TDevicePosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for TDevicePos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TDevicePosClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TDevicePos without action
   */
  export type TDevicePosArgs = {
    /**
     * Select specific fields to fetch from the TDevicePos
     */
    select?: TDevicePosSelect | null
  }



  /**
   * Model TDeviceProps
   */





  export type TDevicePropsSelect = {
    docDate?: boolean
    docAddr?: boolean
    kepText?: boolean
    kepUser?: boolean
    ke3Text?: boolean
    jabText?: boolean
    ke3User?: boolean
  }


  export type TDevicePropsGetPayload<S extends boolean | null | undefined | TDevicePropsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TDeviceProps :
    S extends undefined ? never :
    S extends { include: any } & (TDevicePropsArgs)
    ? TDeviceProps 
    : S extends { select: any } & (TDevicePropsArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TDeviceProps ? TDeviceProps[P] : never
  } 
      : TDeviceProps



  export interface TDevicePropsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for TDeviceProps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TDevicePropsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TDeviceProps without action
   */
  export type TDevicePropsArgs = {
    /**
     * Select specific fields to fetch from the TDeviceProps
     */
    select?: TDevicePropsSelect | null
  }



  /**
   * Model ContactDudi
   */





  export type ContactDudiSelect = {
    name?: boolean
    position?: boolean
    email?: boolean
    phone?: boolean
  }


  export type ContactDudiGetPayload<S extends boolean | null | undefined | ContactDudiArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ContactDudi :
    S extends undefined ? never :
    S extends { include: any } & (ContactDudiArgs)
    ? ContactDudi 
    : S extends { select: any } & (ContactDudiArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ContactDudi ? ContactDudi[P] : never
  } 
      : ContactDudi



  export interface ContactDudiDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactDudi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ContactDudiClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ContactDudi without action
   */
  export type ContactDudiArgs = {
    /**
     * Select specific fields to fetch from the ContactDudi
     */
    select?: ContactDudiSelect | null
  }



  /**
   * Model DudiTimeWork
   */





  export type DudiTimeWorkSelect = {
    holidays?: boolean
    timeIn?: boolean
    timeOut?: boolean
    actifity?: boolean
  }


  export type DudiTimeWorkGetPayload<S extends boolean | null | undefined | DudiTimeWorkArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DudiTimeWork :
    S extends undefined ? never :
    S extends { include: any } & (DudiTimeWorkArgs)
    ? DudiTimeWork 
    : S extends { select: any } & (DudiTimeWorkArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DudiTimeWork ? DudiTimeWork[P] : never
  } 
      : DudiTimeWork



  export interface DudiTimeWorkDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for DudiTimeWork.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DudiTimeWorkClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DudiTimeWork without action
   */
  export type DudiTimeWorkArgs = {
    /**
     * Select specific fields to fetch from the DudiTimeWork
     */
    select?: DudiTimeWorkSelect | null
  }



  /**
   * Model DudiIndicator
   */





  export type DudiIndicatorSelect = {
    no?: boolean
    code?: boolean
    name?: boolean
  }


  export type DudiIndicatorGetPayload<S extends boolean | null | undefined | DudiIndicatorArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DudiIndicator :
    S extends undefined ? never :
    S extends { include: any } & (DudiIndicatorArgs)
    ? DudiIndicator 
    : S extends { select: any } & (DudiIndicatorArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DudiIndicator ? DudiIndicator[P] : never
  } 
      : DudiIndicator



  export interface DudiIndicatorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for DudiIndicator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DudiIndicatorClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DudiIndicator without action
   */
  export type DudiIndicatorArgs = {
    /**
     * Select specific fields to fetch from the DudiIndicator
     */
    select?: DudiIndicatorSelect | null
  }



  /**
   * Model Tracker
   */


  export type AggregateTracker = {
    _count: TrackerCountAggregateOutputType | null
    _min: TrackerMinAggregateOutputType | null
    _max: TrackerMaxAggregateOutputType | null
  }

  export type TrackerMinAggregateOutputType = {
    id: string | null
    point: PointTracker | null
    type: TypeTracker | null
    userId: string | null
    refId: string | null
    instansiId: string | null
    createdAt: Date | null
    mapelId: string | null
    elementId: string | null
    cpId: string | null
    bidangId: string | null
    programId: string | null
    konsentrasiId: string | null
    tpId: string | null
    teacherId: string | null
    kelasId: string | null
    muridId: string | null
    jadwalId: string | null
    mengajarId: string | null
    tujuanId: string | null
    perangkatId: string | null
    kalenderId: string | null
    dudiId: string | null
    kkniId: string | null
  }

  export type TrackerMaxAggregateOutputType = {
    id: string | null
    point: PointTracker | null
    type: TypeTracker | null
    userId: string | null
    refId: string | null
    instansiId: string | null
    createdAt: Date | null
    mapelId: string | null
    elementId: string | null
    cpId: string | null
    bidangId: string | null
    programId: string | null
    konsentrasiId: string | null
    tpId: string | null
    teacherId: string | null
    kelasId: string | null
    muridId: string | null
    jadwalId: string | null
    mengajarId: string | null
    tujuanId: string | null
    perangkatId: string | null
    kalenderId: string | null
    dudiId: string | null
    kkniId: string | null
  }

  export type TrackerCountAggregateOutputType = {
    id: number
    point: number
    type: number
    userId: number
    refId: number
    instansiId: number
    createdAt: number
    mapelId: number
    elementId: number
    cpId: number
    bidangId: number
    programId: number
    konsentrasiId: number
    tpId: number
    teacherId: number
    kelasId: number
    muridId: number
    jadwalId: number
    mengajarId: number
    tujuanId: number
    perangkatId: number
    kalenderId: number
    dudiId: number
    kkniId: number
    _all: number
  }


  export type TrackerMinAggregateInputType = {
    id?: true
    point?: true
    type?: true
    userId?: true
    refId?: true
    instansiId?: true
    createdAt?: true
    mapelId?: true
    elementId?: true
    cpId?: true
    bidangId?: true
    programId?: true
    konsentrasiId?: true
    tpId?: true
    teacherId?: true
    kelasId?: true
    muridId?: true
    jadwalId?: true
    mengajarId?: true
    tujuanId?: true
    perangkatId?: true
    kalenderId?: true
    dudiId?: true
    kkniId?: true
  }

  export type TrackerMaxAggregateInputType = {
    id?: true
    point?: true
    type?: true
    userId?: true
    refId?: true
    instansiId?: true
    createdAt?: true
    mapelId?: true
    elementId?: true
    cpId?: true
    bidangId?: true
    programId?: true
    konsentrasiId?: true
    tpId?: true
    teacherId?: true
    kelasId?: true
    muridId?: true
    jadwalId?: true
    mengajarId?: true
    tujuanId?: true
    perangkatId?: true
    kalenderId?: true
    dudiId?: true
    kkniId?: true
  }

  export type TrackerCountAggregateInputType = {
    id?: true
    point?: true
    type?: true
    userId?: true
    refId?: true
    instansiId?: true
    createdAt?: true
    mapelId?: true
    elementId?: true
    cpId?: true
    bidangId?: true
    programId?: true
    konsentrasiId?: true
    tpId?: true
    teacherId?: true
    kelasId?: true
    muridId?: true
    jadwalId?: true
    mengajarId?: true
    tujuanId?: true
    perangkatId?: true
    kalenderId?: true
    dudiId?: true
    kkniId?: true
    _all?: true
  }

  export type TrackerAggregateArgs = {
    /**
     * Filter which Tracker to aggregate.
     */
    where?: TrackerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trackers to fetch.
     */
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrackerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trackers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trackers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trackers
    **/
    _count?: true | TrackerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrackerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrackerMaxAggregateInputType
  }

  export type GetTrackerAggregateType<T extends TrackerAggregateArgs> = {
        [P in keyof T & keyof AggregateTracker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTracker[P]>
      : GetScalarType<T[P], AggregateTracker[P]>
  }




  export type TrackerGroupByArgs = {
    where?: TrackerWhereInput
    orderBy?: Enumerable<TrackerOrderByWithAggregationInput>
    by: TrackerScalarFieldEnum[]
    having?: TrackerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrackerCountAggregateInputType | true
    _min?: TrackerMinAggregateInputType
    _max?: TrackerMaxAggregateInputType
  }


  export type TrackerGroupByOutputType = {
    id: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId: string | null
    createdAt: Date
    mapelId: string | null
    elementId: string | null
    cpId: string | null
    bidangId: string | null
    programId: string | null
    konsentrasiId: string | null
    tpId: string | null
    teacherId: string | null
    kelasId: string | null
    muridId: string | null
    jadwalId: string | null
    mengajarId: string | null
    tujuanId: string | null
    perangkatId: string | null
    kalenderId: string | null
    dudiId: string | null
    kkniId: string | null
    _count: TrackerCountAggregateOutputType | null
    _min: TrackerMinAggregateOutputType | null
    _max: TrackerMaxAggregateOutputType | null
  }

  type GetTrackerGroupByPayload<T extends TrackerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TrackerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrackerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrackerGroupByOutputType[P]>
            : GetScalarType<T[P], TrackerGroupByOutputType[P]>
        }
      >
    >


  export type TrackerSelect = {
    id?: boolean
    point?: boolean
    type?: boolean
    userId?: boolean
    refId?: boolean
    instansiId?: boolean
    createdAt?: boolean
    mapelId?: boolean
    elementId?: boolean
    cpId?: boolean
    bidangId?: boolean
    programId?: boolean
    konsentrasiId?: boolean
    tpId?: boolean
    teacherId?: boolean
    kelasId?: boolean
    muridId?: boolean
    jadwalId?: boolean
    mengajarId?: boolean
    tujuanId?: boolean
    perangkatId?: boolean
    kalenderId?: boolean
    dudiId?: boolean
    kkniId?: boolean
    user?: boolean | UserArgs
    ref?: boolean | InstansiArgs
    instansi?: boolean | InstansiArgs
    mapel?: boolean | MataPelajaranArgs
    elemen?: boolean | ElementArgs
    cp?: boolean | AchievementArgs
    bidang?: boolean | BidangKeahlianArgs
    program?: boolean | ProgramKeahlianArgs
    konsentrasi?: boolean | KonsentrasiKeahlianArgs
    tp?: boolean | SchoolYearArgs
    teacher?: boolean | TeacherArgs
    kelas?: boolean | ClassRoomArgs
    murid?: boolean | StudentArgs
    jadwal?: boolean | ScheduleArgs
    mengajar?: boolean | TeachingArgs
    tujuan?: boolean | ObjectiveArgs
    perangkat?: boolean | TDeviceArgs
    kalender?: boolean | CalendarArgs
    dudi?: boolean | DudiArgs
    kkni?: boolean | KkniArgs
  }


  export type TrackerInclude = {
    user?: boolean | UserArgs
    ref?: boolean | InstansiArgs
    instansi?: boolean | InstansiArgs
    mapel?: boolean | MataPelajaranArgs
    elemen?: boolean | ElementArgs
    cp?: boolean | AchievementArgs
    bidang?: boolean | BidangKeahlianArgs
    program?: boolean | ProgramKeahlianArgs
    konsentrasi?: boolean | KonsentrasiKeahlianArgs
    tp?: boolean | SchoolYearArgs
    teacher?: boolean | TeacherArgs
    kelas?: boolean | ClassRoomArgs
    murid?: boolean | StudentArgs
    jadwal?: boolean | ScheduleArgs
    mengajar?: boolean | TeachingArgs
    tujuan?: boolean | ObjectiveArgs
    perangkat?: boolean | TDeviceArgs
    kalender?: boolean | CalendarArgs
    dudi?: boolean | DudiArgs
    kkni?: boolean | KkniArgs
  }

  export type TrackerGetPayload<S extends boolean | null | undefined | TrackerArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Tracker :
    S extends undefined ? never :
    S extends { include: any } & (TrackerArgs | TrackerFindManyArgs)
    ? Tracker  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'ref' ? InstansiGetPayload<S['include'][P]> :
        P extends 'instansi' ? InstansiGetPayload<S['include'][P]> | null :
        P extends 'mapel' ? MataPelajaranGetPayload<S['include'][P]> | null :
        P extends 'elemen' ? ElementGetPayload<S['include'][P]> | null :
        P extends 'cp' ? AchievementGetPayload<S['include'][P]> | null :
        P extends 'bidang' ? BidangKeahlianGetPayload<S['include'][P]> | null :
        P extends 'program' ? ProgramKeahlianGetPayload<S['include'][P]> | null :
        P extends 'konsentrasi' ? KonsentrasiKeahlianGetPayload<S['include'][P]> | null :
        P extends 'tp' ? SchoolYearGetPayload<S['include'][P]> | null :
        P extends 'teacher' ? TeacherGetPayload<S['include'][P]> | null :
        P extends 'kelas' ? ClassRoomGetPayload<S['include'][P]> | null :
        P extends 'murid' ? StudentGetPayload<S['include'][P]> | null :
        P extends 'jadwal' ? ScheduleGetPayload<S['include'][P]> | null :
        P extends 'mengajar' ? TeachingGetPayload<S['include'][P]> | null :
        P extends 'tujuan' ? ObjectiveGetPayload<S['include'][P]> | null :
        P extends 'perangkat' ? TDeviceGetPayload<S['include'][P]> | null :
        P extends 'kalender' ? CalendarGetPayload<S['include'][P]> | null :
        P extends 'dudi' ? DudiGetPayload<S['include'][P]> | null :
        P extends 'kkni' ? KkniGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (TrackerArgs | TrackerFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'ref' ? InstansiGetPayload<S['select'][P]> :
        P extends 'instansi' ? InstansiGetPayload<S['select'][P]> | null :
        P extends 'mapel' ? MataPelajaranGetPayload<S['select'][P]> | null :
        P extends 'elemen' ? ElementGetPayload<S['select'][P]> | null :
        P extends 'cp' ? AchievementGetPayload<S['select'][P]> | null :
        P extends 'bidang' ? BidangKeahlianGetPayload<S['select'][P]> | null :
        P extends 'program' ? ProgramKeahlianGetPayload<S['select'][P]> | null :
        P extends 'konsentrasi' ? KonsentrasiKeahlianGetPayload<S['select'][P]> | null :
        P extends 'tp' ? SchoolYearGetPayload<S['select'][P]> | null :
        P extends 'teacher' ? TeacherGetPayload<S['select'][P]> | null :
        P extends 'kelas' ? ClassRoomGetPayload<S['select'][P]> | null :
        P extends 'murid' ? StudentGetPayload<S['select'][P]> | null :
        P extends 'jadwal' ? ScheduleGetPayload<S['select'][P]> | null :
        P extends 'mengajar' ? TeachingGetPayload<S['select'][P]> | null :
        P extends 'tujuan' ? ObjectiveGetPayload<S['select'][P]> | null :
        P extends 'perangkat' ? TDeviceGetPayload<S['select'][P]> | null :
        P extends 'kalender' ? CalendarGetPayload<S['select'][P]> | null :
        P extends 'dudi' ? DudiGetPayload<S['select'][P]> | null :
        P extends 'kkni' ? KkniGetPayload<S['select'][P]> | null :  P extends keyof Tracker ? Tracker[P] : never
  } 
      : Tracker


  type TrackerCountArgs = 
    Omit<TrackerFindManyArgs, 'select' | 'include'> & {
      select?: TrackerCountAggregateInputType | true
    }

  export interface TrackerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tracker that matches the filter.
     * @param {TrackerFindUniqueArgs} args - Arguments to find a Tracker
     * @example
     * // Get one Tracker
     * const tracker = await prisma.tracker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TrackerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TrackerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Tracker'> extends True ? Prisma__TrackerClient<TrackerGetPayload<T>> : Prisma__TrackerClient<TrackerGetPayload<T> | null, null>

    /**
     * Find one Tracker that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TrackerFindUniqueOrThrowArgs} args - Arguments to find a Tracker
     * @example
     * // Get one Tracker
     * const tracker = await prisma.tracker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TrackerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TrackerFindUniqueOrThrowArgs>
    ): Prisma__TrackerClient<TrackerGetPayload<T>>

    /**
     * Find the first Tracker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackerFindFirstArgs} args - Arguments to find a Tracker
     * @example
     * // Get one Tracker
     * const tracker = await prisma.tracker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TrackerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TrackerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Tracker'> extends True ? Prisma__TrackerClient<TrackerGetPayload<T>> : Prisma__TrackerClient<TrackerGetPayload<T> | null, null>

    /**
     * Find the first Tracker that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackerFindFirstOrThrowArgs} args - Arguments to find a Tracker
     * @example
     * // Get one Tracker
     * const tracker = await prisma.tracker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TrackerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TrackerFindFirstOrThrowArgs>
    ): Prisma__TrackerClient<TrackerGetPayload<T>>

    /**
     * Find zero or more Trackers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trackers
     * const trackers = await prisma.tracker.findMany()
     * 
     * // Get first 10 Trackers
     * const trackers = await prisma.tracker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trackerWithIdOnly = await prisma.tracker.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TrackerFindManyArgs>(
      args?: SelectSubset<T, TrackerFindManyArgs>
    ): Prisma.PrismaPromise<Array<TrackerGetPayload<T>>>

    /**
     * Create a Tracker.
     * @param {TrackerCreateArgs} args - Arguments to create a Tracker.
     * @example
     * // Create one Tracker
     * const Tracker = await prisma.tracker.create({
     *   data: {
     *     // ... data to create a Tracker
     *   }
     * })
     * 
    **/
    create<T extends TrackerCreateArgs>(
      args: SelectSubset<T, TrackerCreateArgs>
    ): Prisma__TrackerClient<TrackerGetPayload<T>>

    /**
     * Create many Trackers.
     *     @param {TrackerCreateManyArgs} args - Arguments to create many Trackers.
     *     @example
     *     // Create many Trackers
     *     const tracker = await prisma.tracker.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TrackerCreateManyArgs>(
      args?: SelectSubset<T, TrackerCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tracker.
     * @param {TrackerDeleteArgs} args - Arguments to delete one Tracker.
     * @example
     * // Delete one Tracker
     * const Tracker = await prisma.tracker.delete({
     *   where: {
     *     // ... filter to delete one Tracker
     *   }
     * })
     * 
    **/
    delete<T extends TrackerDeleteArgs>(
      args: SelectSubset<T, TrackerDeleteArgs>
    ): Prisma__TrackerClient<TrackerGetPayload<T>>

    /**
     * Update one Tracker.
     * @param {TrackerUpdateArgs} args - Arguments to update one Tracker.
     * @example
     * // Update one Tracker
     * const tracker = await prisma.tracker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TrackerUpdateArgs>(
      args: SelectSubset<T, TrackerUpdateArgs>
    ): Prisma__TrackerClient<TrackerGetPayload<T>>

    /**
     * Delete zero or more Trackers.
     * @param {TrackerDeleteManyArgs} args - Arguments to filter Trackers to delete.
     * @example
     * // Delete a few Trackers
     * const { count } = await prisma.tracker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TrackerDeleteManyArgs>(
      args?: SelectSubset<T, TrackerDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trackers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trackers
     * const tracker = await prisma.tracker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TrackerUpdateManyArgs>(
      args: SelectSubset<T, TrackerUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tracker.
     * @param {TrackerUpsertArgs} args - Arguments to update or create a Tracker.
     * @example
     * // Update or create a Tracker
     * const tracker = await prisma.tracker.upsert({
     *   create: {
     *     // ... data to create a Tracker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tracker we want to update
     *   }
     * })
    **/
    upsert<T extends TrackerUpsertArgs>(
      args: SelectSubset<T, TrackerUpsertArgs>
    ): Prisma__TrackerClient<TrackerGetPayload<T>>

    /**
     * Find zero or more Trackers that matches the filter.
     * @param {TrackerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tracker = await prisma.tracker.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: TrackerFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Tracker.
     * @param {TrackerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tracker = await prisma.tracker.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: TrackerAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Trackers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackerCountArgs} args - Arguments to filter Trackers to count.
     * @example
     * // Count the number of Trackers
     * const count = await prisma.tracker.count({
     *   where: {
     *     // ... the filter for the Trackers we want to count
     *   }
     * })
    **/
    count<T extends TrackerCountArgs>(
      args?: Subset<T, TrackerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrackerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tracker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrackerAggregateArgs>(args: Subset<T, TrackerAggregateArgs>): Prisma.PrismaPromise<GetTrackerAggregateType<T>>

    /**
     * Group by Tracker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrackerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrackerGroupByArgs['orderBy'] }
        : { orderBy?: TrackerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrackerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrackerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Tracker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TrackerClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    ref<T extends InstansiArgs= {}>(args?: Subset<T, InstansiArgs>): Prisma__InstansiClient<InstansiGetPayload<T> | Null>;

    instansi<T extends InstansiArgs= {}>(args?: Subset<T, InstansiArgs>): Prisma__InstansiClient<InstansiGetPayload<T> | Null>;

    mapel<T extends MataPelajaranArgs= {}>(args?: Subset<T, MataPelajaranArgs>): Prisma__MataPelajaranClient<MataPelajaranGetPayload<T> | Null>;

    elemen<T extends ElementArgs= {}>(args?: Subset<T, ElementArgs>): Prisma__ElementClient<ElementGetPayload<T> | Null>;

    cp<T extends AchievementArgs= {}>(args?: Subset<T, AchievementArgs>): Prisma__AchievementClient<AchievementGetPayload<T> | Null>;

    bidang<T extends BidangKeahlianArgs= {}>(args?: Subset<T, BidangKeahlianArgs>): Prisma__BidangKeahlianClient<BidangKeahlianGetPayload<T> | Null>;

    program<T extends ProgramKeahlianArgs= {}>(args?: Subset<T, ProgramKeahlianArgs>): Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T> | Null>;

    konsentrasi<T extends KonsentrasiKeahlianArgs= {}>(args?: Subset<T, KonsentrasiKeahlianArgs>): Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T> | Null>;

    tp<T extends SchoolYearArgs= {}>(args?: Subset<T, SchoolYearArgs>): Prisma__SchoolYearClient<SchoolYearGetPayload<T> | Null>;

    teacher<T extends TeacherArgs= {}>(args?: Subset<T, TeacherArgs>): Prisma__TeacherClient<TeacherGetPayload<T> | Null>;

    kelas<T extends ClassRoomArgs= {}>(args?: Subset<T, ClassRoomArgs>): Prisma__ClassRoomClient<ClassRoomGetPayload<T> | Null>;

    murid<T extends StudentArgs= {}>(args?: Subset<T, StudentArgs>): Prisma__StudentClient<StudentGetPayload<T> | Null>;

    jadwal<T extends ScheduleArgs= {}>(args?: Subset<T, ScheduleArgs>): Prisma__ScheduleClient<ScheduleGetPayload<T> | Null>;

    mengajar<T extends TeachingArgs= {}>(args?: Subset<T, TeachingArgs>): Prisma__TeachingClient<TeachingGetPayload<T> | Null>;

    tujuan<T extends ObjectiveArgs= {}>(args?: Subset<T, ObjectiveArgs>): Prisma__ObjectiveClient<ObjectiveGetPayload<T> | Null>;

    perangkat<T extends TDeviceArgs= {}>(args?: Subset<T, TDeviceArgs>): Prisma__TDeviceClient<TDeviceGetPayload<T> | Null>;

    kalender<T extends CalendarArgs= {}>(args?: Subset<T, CalendarArgs>): Prisma__CalendarClient<CalendarGetPayload<T> | Null>;

    dudi<T extends DudiArgs= {}>(args?: Subset<T, DudiArgs>): Prisma__DudiClient<DudiGetPayload<T> | Null>;

    kkni<T extends KkniArgs= {}>(args?: Subset<T, KkniArgs>): Prisma__KkniClient<KkniGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Tracker base type for findUnique actions
   */
  export type TrackerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    /**
     * Filter, which Tracker to fetch.
     */
    where: TrackerWhereUniqueInput
  }

  /**
   * Tracker findUnique
   */
  export interface TrackerFindUniqueArgs extends TrackerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tracker findUniqueOrThrow
   */
  export type TrackerFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    /**
     * Filter, which Tracker to fetch.
     */
    where: TrackerWhereUniqueInput
  }


  /**
   * Tracker base type for findFirst actions
   */
  export type TrackerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    /**
     * Filter, which Tracker to fetch.
     */
    where?: TrackerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trackers to fetch.
     */
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trackers.
     */
    cursor?: TrackerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trackers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trackers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trackers.
     */
    distinct?: Enumerable<TrackerScalarFieldEnum>
  }

  /**
   * Tracker findFirst
   */
  export interface TrackerFindFirstArgs extends TrackerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tracker findFirstOrThrow
   */
  export type TrackerFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    /**
     * Filter, which Tracker to fetch.
     */
    where?: TrackerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trackers to fetch.
     */
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trackers.
     */
    cursor?: TrackerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trackers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trackers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trackers.
     */
    distinct?: Enumerable<TrackerScalarFieldEnum>
  }


  /**
   * Tracker findMany
   */
  export type TrackerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    /**
     * Filter, which Trackers to fetch.
     */
    where?: TrackerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trackers to fetch.
     */
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trackers.
     */
    cursor?: TrackerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trackers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trackers.
     */
    skip?: number
    distinct?: Enumerable<TrackerScalarFieldEnum>
  }


  /**
   * Tracker create
   */
  export type TrackerCreateArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    /**
     * The data needed to create a Tracker.
     */
    data: XOR<TrackerCreateInput, TrackerUncheckedCreateInput>
  }


  /**
   * Tracker createMany
   */
  export type TrackerCreateManyArgs = {
    /**
     * The data used to create many Trackers.
     */
    data: Enumerable<TrackerCreateManyInput>
  }


  /**
   * Tracker update
   */
  export type TrackerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    /**
     * The data needed to update a Tracker.
     */
    data: XOR<TrackerUpdateInput, TrackerUncheckedUpdateInput>
    /**
     * Choose, which Tracker to update.
     */
    where: TrackerWhereUniqueInput
  }


  /**
   * Tracker updateMany
   */
  export type TrackerUpdateManyArgs = {
    /**
     * The data used to update Trackers.
     */
    data: XOR<TrackerUpdateManyMutationInput, TrackerUncheckedUpdateManyInput>
    /**
     * Filter which Trackers to update
     */
    where?: TrackerWhereInput
  }


  /**
   * Tracker upsert
   */
  export type TrackerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    /**
     * The filter to search for the Tracker to update in case it exists.
     */
    where: TrackerWhereUniqueInput
    /**
     * In case the Tracker found by the `where` argument doesn't exist, create a new Tracker with this data.
     */
    create: XOR<TrackerCreateInput, TrackerUncheckedCreateInput>
    /**
     * In case the Tracker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrackerUpdateInput, TrackerUncheckedUpdateInput>
  }


  /**
   * Tracker delete
   */
  export type TrackerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    /**
     * Filter which Tracker to delete.
     */
    where: TrackerWhereUniqueInput
  }


  /**
   * Tracker deleteMany
   */
  export type TrackerDeleteManyArgs = {
    /**
     * Filter which Trackers to delete
     */
    where?: TrackerWhereInput
  }


  /**
   * Tracker findRaw
   */
  export type TrackerFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Tracker aggregateRaw
   */
  export type TrackerAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Tracker without action
   */
  export type TrackerArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
  }



  /**
   * Model Instansi
   */


  export type AggregateInstansi = {
    _count: InstansiCountAggregateOutputType | null
    _min: InstansiMinAggregateOutputType | null
    _max: InstansiMaxAggregateOutputType | null
  }

  export type InstansiMinAggregateOutputType = {
    id: string | null
    npsn: string | null
    name: string | null
    isPrivate: boolean | null
    level: Level | null
    religion: Religion | null
    major: boolean | null
    disable: boolean | null
  }

  export type InstansiMaxAggregateOutputType = {
    id: string | null
    npsn: string | null
    name: string | null
    isPrivate: boolean | null
    level: Level | null
    religion: Religion | null
    major: boolean | null
    disable: boolean | null
  }

  export type InstansiCountAggregateOutputType = {
    id: number
    npsn: number
    name: number
    isPrivate: number
    level: number
    religion: number
    major: number
    majorIds: number
    disable: number
    _all: number
  }


  export type InstansiMinAggregateInputType = {
    id?: true
    npsn?: true
    name?: true
    isPrivate?: true
    level?: true
    religion?: true
    major?: true
    disable?: true
  }

  export type InstansiMaxAggregateInputType = {
    id?: true
    npsn?: true
    name?: true
    isPrivate?: true
    level?: true
    religion?: true
    major?: true
    disable?: true
  }

  export type InstansiCountAggregateInputType = {
    id?: true
    npsn?: true
    name?: true
    isPrivate?: true
    level?: true
    religion?: true
    major?: true
    majorIds?: true
    disable?: true
    _all?: true
  }

  export type InstansiAggregateArgs = {
    /**
     * Filter which Instansi to aggregate.
     */
    where?: InstansiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instansis to fetch.
     */
    orderBy?: Enumerable<InstansiOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstansiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instansis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instansis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Instansis
    **/
    _count?: true | InstansiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstansiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstansiMaxAggregateInputType
  }

  export type GetInstansiAggregateType<T extends InstansiAggregateArgs> = {
        [P in keyof T & keyof AggregateInstansi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstansi[P]>
      : GetScalarType<T[P], AggregateInstansi[P]>
  }




  export type InstansiGroupByArgs = {
    where?: InstansiWhereInput
    orderBy?: Enumerable<InstansiOrderByWithAggregationInput>
    by: InstansiScalarFieldEnum[]
    having?: InstansiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstansiCountAggregateInputType | true
    _min?: InstansiMinAggregateInputType
    _max?: InstansiMaxAggregateInputType
  }


  export type InstansiGroupByOutputType = {
    id: string
    npsn: string
    name: string
    isPrivate: boolean
    level: Level
    religion: Religion | null
    major: boolean | null
    majorIds: string[]
    disable: boolean
    _count: InstansiCountAggregateOutputType | null
    _min: InstansiMinAggregateOutputType | null
    _max: InstansiMaxAggregateOutputType | null
  }

  type GetInstansiGroupByPayload<T extends InstansiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<InstansiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstansiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstansiGroupByOutputType[P]>
            : GetScalarType<T[P], InstansiGroupByOutputType[P]>
        }
      >
    >


  export type InstansiSelect = {
    id?: boolean
    npsn?: boolean
    name?: boolean
    isPrivate?: boolean
    address?: boolean | AddressArgs
    level?: boolean
    religion?: boolean
    major?: boolean
    majorIds?: boolean
    disable?: boolean
    majors?: boolean | Instansi$majorsArgs
    role?: boolean | Instansi$roleArgs
    schoolYear?: boolean | Instansi$schoolYearArgs
    teacher?: boolean | Instansi$teacherArgs
    student?: boolean | Instansi$studentArgs
    tracker?: boolean | Instansi$trackerArgs
    history?: boolean | Instansi$historyArgs
    unikMapels?: boolean | Instansi$unikMapelsArgs
    tDevice?: boolean | Instansi$tDeviceArgs
    objective?: boolean | Instansi$objectiveArgs
    dudi?: boolean | Instansi$dudiArgs
    _count?: boolean | InstansiCountOutputTypeArgs
  }


  export type InstansiInclude = {
    majors?: boolean | Instansi$majorsArgs
    role?: boolean | Instansi$roleArgs
    schoolYear?: boolean | Instansi$schoolYearArgs
    teacher?: boolean | Instansi$teacherArgs
    student?: boolean | Instansi$studentArgs
    tracker?: boolean | Instansi$trackerArgs
    history?: boolean | Instansi$historyArgs
    unikMapels?: boolean | Instansi$unikMapelsArgs
    tDevice?: boolean | Instansi$tDeviceArgs
    objective?: boolean | Instansi$objectiveArgs
    dudi?: boolean | Instansi$dudiArgs
    _count?: boolean | InstansiCountOutputTypeArgs
  }

  export type InstansiGetPayload<S extends boolean | null | undefined | InstansiArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Instansi :
    S extends undefined ? never :
    S extends { include: any } & (InstansiArgs | InstansiFindManyArgs)
    ? Instansi  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'majors' ? Array < KonsentrasiKeahlianGetPayload<S['include'][P]>>  :
        P extends 'role' ? Array < RoleGetPayload<S['include'][P]>>  :
        P extends 'schoolYear' ? Array < SchoolYearGetPayload<S['include'][P]>>  :
        P extends 'teacher' ? Array < TeacherGetPayload<S['include'][P]>>  :
        P extends 'student' ? Array < StudentGetPayload<S['include'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['include'][P]>>  :
        P extends 'history' ? Array < TrackerGetPayload<S['include'][P]>>  :
        P extends 'unikMapels' ? Array < MataPelajaranGetPayload<S['include'][P]>>  :
        P extends 'tDevice' ? Array < TDeviceGetPayload<S['include'][P]>>  :
        P extends 'objective' ? Array < ObjectiveGetPayload<S['include'][P]>>  :
        P extends 'dudi' ? Array < DudiGetPayload<S['include'][P]>>  :
        P extends '_count' ? InstansiCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (InstansiArgs | InstansiFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'address' ? AddressGetPayload<S['select'][P]> :
        P extends 'majors' ? Array < KonsentrasiKeahlianGetPayload<S['select'][P]>>  :
        P extends 'role' ? Array < RoleGetPayload<S['select'][P]>>  :
        P extends 'schoolYear' ? Array < SchoolYearGetPayload<S['select'][P]>>  :
        P extends 'teacher' ? Array < TeacherGetPayload<S['select'][P]>>  :
        P extends 'student' ? Array < StudentGetPayload<S['select'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['select'][P]>>  :
        P extends 'history' ? Array < TrackerGetPayload<S['select'][P]>>  :
        P extends 'unikMapels' ? Array < MataPelajaranGetPayload<S['select'][P]>>  :
        P extends 'tDevice' ? Array < TDeviceGetPayload<S['select'][P]>>  :
        P extends 'objective' ? Array < ObjectiveGetPayload<S['select'][P]>>  :
        P extends 'dudi' ? Array < DudiGetPayload<S['select'][P]>>  :
        P extends '_count' ? InstansiCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Instansi ? Instansi[P] : never
  } 
      : Instansi


  type InstansiCountArgs = 
    Omit<InstansiFindManyArgs, 'select' | 'include'> & {
      select?: InstansiCountAggregateInputType | true
    }

  export interface InstansiDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Instansi that matches the filter.
     * @param {InstansiFindUniqueArgs} args - Arguments to find a Instansi
     * @example
     * // Get one Instansi
     * const instansi = await prisma.instansi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InstansiFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InstansiFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Instansi'> extends True ? Prisma__InstansiClient<InstansiGetPayload<T>> : Prisma__InstansiClient<InstansiGetPayload<T> | null, null>

    /**
     * Find one Instansi that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InstansiFindUniqueOrThrowArgs} args - Arguments to find a Instansi
     * @example
     * // Get one Instansi
     * const instansi = await prisma.instansi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InstansiFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, InstansiFindUniqueOrThrowArgs>
    ): Prisma__InstansiClient<InstansiGetPayload<T>>

    /**
     * Find the first Instansi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstansiFindFirstArgs} args - Arguments to find a Instansi
     * @example
     * // Get one Instansi
     * const instansi = await prisma.instansi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InstansiFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InstansiFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Instansi'> extends True ? Prisma__InstansiClient<InstansiGetPayload<T>> : Prisma__InstansiClient<InstansiGetPayload<T> | null, null>

    /**
     * Find the first Instansi that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstansiFindFirstOrThrowArgs} args - Arguments to find a Instansi
     * @example
     * // Get one Instansi
     * const instansi = await prisma.instansi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InstansiFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InstansiFindFirstOrThrowArgs>
    ): Prisma__InstansiClient<InstansiGetPayload<T>>

    /**
     * Find zero or more Instansis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstansiFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Instansis
     * const instansis = await prisma.instansi.findMany()
     * 
     * // Get first 10 Instansis
     * const instansis = await prisma.instansi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instansiWithIdOnly = await prisma.instansi.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InstansiFindManyArgs>(
      args?: SelectSubset<T, InstansiFindManyArgs>
    ): Prisma.PrismaPromise<Array<InstansiGetPayload<T>>>

    /**
     * Create a Instansi.
     * @param {InstansiCreateArgs} args - Arguments to create a Instansi.
     * @example
     * // Create one Instansi
     * const Instansi = await prisma.instansi.create({
     *   data: {
     *     // ... data to create a Instansi
     *   }
     * })
     * 
    **/
    create<T extends InstansiCreateArgs>(
      args: SelectSubset<T, InstansiCreateArgs>
    ): Prisma__InstansiClient<InstansiGetPayload<T>>

    /**
     * Create many Instansis.
     *     @param {InstansiCreateManyArgs} args - Arguments to create many Instansis.
     *     @example
     *     // Create many Instansis
     *     const instansi = await prisma.instansi.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InstansiCreateManyArgs>(
      args?: SelectSubset<T, InstansiCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Instansi.
     * @param {InstansiDeleteArgs} args - Arguments to delete one Instansi.
     * @example
     * // Delete one Instansi
     * const Instansi = await prisma.instansi.delete({
     *   where: {
     *     // ... filter to delete one Instansi
     *   }
     * })
     * 
    **/
    delete<T extends InstansiDeleteArgs>(
      args: SelectSubset<T, InstansiDeleteArgs>
    ): Prisma__InstansiClient<InstansiGetPayload<T>>

    /**
     * Update one Instansi.
     * @param {InstansiUpdateArgs} args - Arguments to update one Instansi.
     * @example
     * // Update one Instansi
     * const instansi = await prisma.instansi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InstansiUpdateArgs>(
      args: SelectSubset<T, InstansiUpdateArgs>
    ): Prisma__InstansiClient<InstansiGetPayload<T>>

    /**
     * Delete zero or more Instansis.
     * @param {InstansiDeleteManyArgs} args - Arguments to filter Instansis to delete.
     * @example
     * // Delete a few Instansis
     * const { count } = await prisma.instansi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InstansiDeleteManyArgs>(
      args?: SelectSubset<T, InstansiDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instansis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstansiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Instansis
     * const instansi = await prisma.instansi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InstansiUpdateManyArgs>(
      args: SelectSubset<T, InstansiUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Instansi.
     * @param {InstansiUpsertArgs} args - Arguments to update or create a Instansi.
     * @example
     * // Update or create a Instansi
     * const instansi = await prisma.instansi.upsert({
     *   create: {
     *     // ... data to create a Instansi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Instansi we want to update
     *   }
     * })
    **/
    upsert<T extends InstansiUpsertArgs>(
      args: SelectSubset<T, InstansiUpsertArgs>
    ): Prisma__InstansiClient<InstansiGetPayload<T>>

    /**
     * Find zero or more Instansis that matches the filter.
     * @param {InstansiFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const instansi = await prisma.instansi.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: InstansiFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Instansi.
     * @param {InstansiAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const instansi = await prisma.instansi.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: InstansiAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Instansis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstansiCountArgs} args - Arguments to filter Instansis to count.
     * @example
     * // Count the number of Instansis
     * const count = await prisma.instansi.count({
     *   where: {
     *     // ... the filter for the Instansis we want to count
     *   }
     * })
    **/
    count<T extends InstansiCountArgs>(
      args?: Subset<T, InstansiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstansiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Instansi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstansiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstansiAggregateArgs>(args: Subset<T, InstansiAggregateArgs>): Prisma.PrismaPromise<GetInstansiAggregateType<T>>

    /**
     * Group by Instansi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstansiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstansiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstansiGroupByArgs['orderBy'] }
        : { orderBy?: InstansiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstansiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstansiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Instansi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InstansiClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    address<T extends AddressArgs= {}>(args?: Subset<T, AddressArgs>): Prisma__AddressClient<AddressGetPayload<T> | Null>;

    majors<T extends Instansi$majorsArgs= {}>(args?: Subset<T, Instansi$majorsArgs>): Prisma.PrismaPromise<Array<KonsentrasiKeahlianGetPayload<T>>| Null>;

    role<T extends Instansi$roleArgs= {}>(args?: Subset<T, Instansi$roleArgs>): Prisma.PrismaPromise<Array<RoleGetPayload<T>>| Null>;

    schoolYear<T extends Instansi$schoolYearArgs= {}>(args?: Subset<T, Instansi$schoolYearArgs>): Prisma.PrismaPromise<Array<SchoolYearGetPayload<T>>| Null>;

    teacher<T extends Instansi$teacherArgs= {}>(args?: Subset<T, Instansi$teacherArgs>): Prisma.PrismaPromise<Array<TeacherGetPayload<T>>| Null>;

    student<T extends Instansi$studentArgs= {}>(args?: Subset<T, Instansi$studentArgs>): Prisma.PrismaPromise<Array<StudentGetPayload<T>>| Null>;

    tracker<T extends Instansi$trackerArgs= {}>(args?: Subset<T, Instansi$trackerArgs>): Prisma.PrismaPromise<Array<TrackerGetPayload<T>>| Null>;

    history<T extends Instansi$historyArgs= {}>(args?: Subset<T, Instansi$historyArgs>): Prisma.PrismaPromise<Array<TrackerGetPayload<T>>| Null>;

    unikMapels<T extends Instansi$unikMapelsArgs= {}>(args?: Subset<T, Instansi$unikMapelsArgs>): Prisma.PrismaPromise<Array<MataPelajaranGetPayload<T>>| Null>;

    tDevice<T extends Instansi$tDeviceArgs= {}>(args?: Subset<T, Instansi$tDeviceArgs>): Prisma.PrismaPromise<Array<TDeviceGetPayload<T>>| Null>;

    objective<T extends Instansi$objectiveArgs= {}>(args?: Subset<T, Instansi$objectiveArgs>): Prisma.PrismaPromise<Array<ObjectiveGetPayload<T>>| Null>;

    dudi<T extends Instansi$dudiArgs= {}>(args?: Subset<T, Instansi$dudiArgs>): Prisma.PrismaPromise<Array<DudiGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Instansi base type for findUnique actions
   */
  export type InstansiFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Instansi
     */
    select?: InstansiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstansiInclude | null
    /**
     * Filter, which Instansi to fetch.
     */
    where: InstansiWhereUniqueInput
  }

  /**
   * Instansi findUnique
   */
  export interface InstansiFindUniqueArgs extends InstansiFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Instansi findUniqueOrThrow
   */
  export type InstansiFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Instansi
     */
    select?: InstansiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstansiInclude | null
    /**
     * Filter, which Instansi to fetch.
     */
    where: InstansiWhereUniqueInput
  }


  /**
   * Instansi base type for findFirst actions
   */
  export type InstansiFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Instansi
     */
    select?: InstansiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstansiInclude | null
    /**
     * Filter, which Instansi to fetch.
     */
    where?: InstansiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instansis to fetch.
     */
    orderBy?: Enumerable<InstansiOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instansis.
     */
    cursor?: InstansiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instansis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instansis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instansis.
     */
    distinct?: Enumerable<InstansiScalarFieldEnum>
  }

  /**
   * Instansi findFirst
   */
  export interface InstansiFindFirstArgs extends InstansiFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Instansi findFirstOrThrow
   */
  export type InstansiFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Instansi
     */
    select?: InstansiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstansiInclude | null
    /**
     * Filter, which Instansi to fetch.
     */
    where?: InstansiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instansis to fetch.
     */
    orderBy?: Enumerable<InstansiOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instansis.
     */
    cursor?: InstansiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instansis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instansis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instansis.
     */
    distinct?: Enumerable<InstansiScalarFieldEnum>
  }


  /**
   * Instansi findMany
   */
  export type InstansiFindManyArgs = {
    /**
     * Select specific fields to fetch from the Instansi
     */
    select?: InstansiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstansiInclude | null
    /**
     * Filter, which Instansis to fetch.
     */
    where?: InstansiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instansis to fetch.
     */
    orderBy?: Enumerable<InstansiOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Instansis.
     */
    cursor?: InstansiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instansis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instansis.
     */
    skip?: number
    distinct?: Enumerable<InstansiScalarFieldEnum>
  }


  /**
   * Instansi create
   */
  export type InstansiCreateArgs = {
    /**
     * Select specific fields to fetch from the Instansi
     */
    select?: InstansiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstansiInclude | null
    /**
     * The data needed to create a Instansi.
     */
    data: XOR<InstansiCreateInput, InstansiUncheckedCreateInput>
  }


  /**
   * Instansi createMany
   */
  export type InstansiCreateManyArgs = {
    /**
     * The data used to create many Instansis.
     */
    data: Enumerable<InstansiCreateManyInput>
  }


  /**
   * Instansi update
   */
  export type InstansiUpdateArgs = {
    /**
     * Select specific fields to fetch from the Instansi
     */
    select?: InstansiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstansiInclude | null
    /**
     * The data needed to update a Instansi.
     */
    data: XOR<InstansiUpdateInput, InstansiUncheckedUpdateInput>
    /**
     * Choose, which Instansi to update.
     */
    where: InstansiWhereUniqueInput
  }


  /**
   * Instansi updateMany
   */
  export type InstansiUpdateManyArgs = {
    /**
     * The data used to update Instansis.
     */
    data: XOR<InstansiUpdateManyMutationInput, InstansiUncheckedUpdateManyInput>
    /**
     * Filter which Instansis to update
     */
    where?: InstansiWhereInput
  }


  /**
   * Instansi upsert
   */
  export type InstansiUpsertArgs = {
    /**
     * Select specific fields to fetch from the Instansi
     */
    select?: InstansiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstansiInclude | null
    /**
     * The filter to search for the Instansi to update in case it exists.
     */
    where: InstansiWhereUniqueInput
    /**
     * In case the Instansi found by the `where` argument doesn't exist, create a new Instansi with this data.
     */
    create: XOR<InstansiCreateInput, InstansiUncheckedCreateInput>
    /**
     * In case the Instansi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstansiUpdateInput, InstansiUncheckedUpdateInput>
  }


  /**
   * Instansi delete
   */
  export type InstansiDeleteArgs = {
    /**
     * Select specific fields to fetch from the Instansi
     */
    select?: InstansiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstansiInclude | null
    /**
     * Filter which Instansi to delete.
     */
    where: InstansiWhereUniqueInput
  }


  /**
   * Instansi deleteMany
   */
  export type InstansiDeleteManyArgs = {
    /**
     * Filter which Instansis to delete
     */
    where?: InstansiWhereInput
  }


  /**
   * Instansi findRaw
   */
  export type InstansiFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Instansi aggregateRaw
   */
  export type InstansiAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Instansi.majors
   */
  export type Instansi$majorsArgs = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
    where?: KonsentrasiKeahlianWhereInput
    orderBy?: Enumerable<KonsentrasiKeahlianOrderByWithRelationInput>
    cursor?: KonsentrasiKeahlianWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<KonsentrasiKeahlianScalarFieldEnum>
  }


  /**
   * Instansi.role
   */
  export type Instansi$roleArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    where?: RoleWhereInput
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Instansi.schoolYear
   */
  export type Instansi$schoolYearArgs = {
    /**
     * Select specific fields to fetch from the SchoolYear
     */
    select?: SchoolYearSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolYearInclude | null
    where?: SchoolYearWhereInput
    orderBy?: Enumerable<SchoolYearOrderByWithRelationInput>
    cursor?: SchoolYearWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SchoolYearScalarFieldEnum>
  }


  /**
   * Instansi.teacher
   */
  export type Instansi$teacherArgs = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
    where?: TeacherWhereInput
    orderBy?: Enumerable<TeacherOrderByWithRelationInput>
    cursor?: TeacherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeacherScalarFieldEnum>
  }


  /**
   * Instansi.student
   */
  export type Instansi$studentArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    where?: StudentWhereInput
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * Instansi.tracker
   */
  export type Instansi$trackerArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    where?: TrackerWhereInput
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    cursor?: TrackerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TrackerScalarFieldEnum>
  }


  /**
   * Instansi.history
   */
  export type Instansi$historyArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    where?: TrackerWhereInput
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    cursor?: TrackerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TrackerScalarFieldEnum>
  }


  /**
   * Instansi.unikMapels
   */
  export type Instansi$unikMapelsArgs = {
    /**
     * Select specific fields to fetch from the MataPelajaran
     */
    select?: MataPelajaranSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MataPelajaranInclude | null
    where?: MataPelajaranWhereInput
    orderBy?: Enumerable<MataPelajaranOrderByWithRelationInput>
    cursor?: MataPelajaranWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MataPelajaranScalarFieldEnum>
  }


  /**
   * Instansi.tDevice
   */
  export type Instansi$tDeviceArgs = {
    /**
     * Select specific fields to fetch from the TDevice
     */
    select?: TDeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceInclude | null
    where?: TDeviceWhereInput
    orderBy?: Enumerable<TDeviceOrderByWithRelationInput>
    cursor?: TDeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TDeviceScalarFieldEnum>
  }


  /**
   * Instansi.objective
   */
  export type Instansi$objectiveArgs = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectiveInclude | null
    where?: ObjectiveWhereInput
    orderBy?: Enumerable<ObjectiveOrderByWithRelationInput>
    cursor?: ObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ObjectiveScalarFieldEnum>
  }


  /**
   * Instansi.dudi
   */
  export type Instansi$dudiArgs = {
    /**
     * Select specific fields to fetch from the Dudi
     */
    select?: DudiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiInclude | null
    where?: DudiWhereInput
    orderBy?: Enumerable<DudiOrderByWithRelationInput>
    cursor?: DudiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DudiScalarFieldEnum>
  }


  /**
   * Instansi without action
   */
  export type InstansiArgs = {
    /**
     * Select specific fields to fetch from the Instansi
     */
    select?: InstansiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstansiInclude | null
  }



  /**
   * Model MataPelajaran
   */


  export type AggregateMataPelajaran = {
    _count: MataPelajaranCountAggregateOutputType | null
    _min: MataPelajaranMinAggregateOutputType | null
    _max: MataPelajaranMaxAggregateOutputType | null
  }

  export type MataPelajaranMinAggregateOutputType = {
    id: string | null
    level: Level | null
    type: MataPelajaranType | null
    no: string | null
    code: string | null
    name: string | null
    religion: Religion | null
    programId: string | null
    keahlianid: string | null
    instansiId: string | null
    disable: boolean | null
  }

  export type MataPelajaranMaxAggregateOutputType = {
    id: string | null
    level: Level | null
    type: MataPelajaranType | null
    no: string | null
    code: string | null
    name: string | null
    religion: Religion | null
    programId: string | null
    keahlianid: string | null
    instansiId: string | null
    disable: boolean | null
  }

  export type MataPelajaranCountAggregateOutputType = {
    id: number
    level: number
    type: number
    no: number
    code: number
    name: number
    religion: number
    programId: number
    keahlianid: number
    instansiId: number
    disable: number
    _all: number
  }


  export type MataPelajaranMinAggregateInputType = {
    id?: true
    level?: true
    type?: true
    no?: true
    code?: true
    name?: true
    religion?: true
    programId?: true
    keahlianid?: true
    instansiId?: true
    disable?: true
  }

  export type MataPelajaranMaxAggregateInputType = {
    id?: true
    level?: true
    type?: true
    no?: true
    code?: true
    name?: true
    religion?: true
    programId?: true
    keahlianid?: true
    instansiId?: true
    disable?: true
  }

  export type MataPelajaranCountAggregateInputType = {
    id?: true
    level?: true
    type?: true
    no?: true
    code?: true
    name?: true
    religion?: true
    programId?: true
    keahlianid?: true
    instansiId?: true
    disable?: true
    _all?: true
  }

  export type MataPelajaranAggregateArgs = {
    /**
     * Filter which MataPelajaran to aggregate.
     */
    where?: MataPelajaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MataPelajarans to fetch.
     */
    orderBy?: Enumerable<MataPelajaranOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MataPelajaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MataPelajarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MataPelajarans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MataPelajarans
    **/
    _count?: true | MataPelajaranCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MataPelajaranMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MataPelajaranMaxAggregateInputType
  }

  export type GetMataPelajaranAggregateType<T extends MataPelajaranAggregateArgs> = {
        [P in keyof T & keyof AggregateMataPelajaran]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMataPelajaran[P]>
      : GetScalarType<T[P], AggregateMataPelajaran[P]>
  }




  export type MataPelajaranGroupByArgs = {
    where?: MataPelajaranWhereInput
    orderBy?: Enumerable<MataPelajaranOrderByWithAggregationInput>
    by: MataPelajaranScalarFieldEnum[]
    having?: MataPelajaranScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MataPelajaranCountAggregateInputType | true
    _min?: MataPelajaranMinAggregateInputType
    _max?: MataPelajaranMaxAggregateInputType
  }


  export type MataPelajaranGroupByOutputType = {
    id: string
    level: Level | null
    type: MataPelajaranType
    no: string
    code: string
    name: string
    religion: Religion | null
    programId: string | null
    keahlianid: string | null
    instansiId: string | null
    disable: boolean
    _count: MataPelajaranCountAggregateOutputType | null
    _min: MataPelajaranMinAggregateOutputType | null
    _max: MataPelajaranMaxAggregateOutputType | null
  }

  type GetMataPelajaranGroupByPayload<T extends MataPelajaranGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MataPelajaranGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MataPelajaranGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MataPelajaranGroupByOutputType[P]>
            : GetScalarType<T[P], MataPelajaranGroupByOutputType[P]>
        }
      >
    >


  export type MataPelajaranSelect = {
    id?: boolean
    level?: boolean
    type?: boolean
    no?: boolean
    code?: boolean
    name?: boolean
    religion?: boolean
    programId?: boolean
    keahlianid?: boolean
    instansiId?: boolean
    disable?: boolean
    program?: boolean | ProgramKeahlianArgs
    keahlian?: boolean | KonsentrasiKeahlianArgs
    instansi?: boolean | InstansiArgs
    element?: boolean | MataPelajaran$elementArgs
    schedule?: boolean | MataPelajaran$scheduleArgs
    tracker?: boolean | MataPelajaran$trackerArgs
    objective?: boolean | MataPelajaran$objectiveArgs
    device?: boolean | MataPelajaran$deviceArgs
    _count?: boolean | MataPelajaranCountOutputTypeArgs
  }


  export type MataPelajaranInclude = {
    program?: boolean | ProgramKeahlianArgs
    keahlian?: boolean | KonsentrasiKeahlianArgs
    instansi?: boolean | InstansiArgs
    element?: boolean | MataPelajaran$elementArgs
    schedule?: boolean | MataPelajaran$scheduleArgs
    tracker?: boolean | MataPelajaran$trackerArgs
    objective?: boolean | MataPelajaran$objectiveArgs
    device?: boolean | MataPelajaran$deviceArgs
    _count?: boolean | MataPelajaranCountOutputTypeArgs
  }

  export type MataPelajaranGetPayload<S extends boolean | null | undefined | MataPelajaranArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MataPelajaran :
    S extends undefined ? never :
    S extends { include: any } & (MataPelajaranArgs | MataPelajaranFindManyArgs)
    ? MataPelajaran  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'program' ? ProgramKeahlianGetPayload<S['include'][P]> | null :
        P extends 'keahlian' ? KonsentrasiKeahlianGetPayload<S['include'][P]> | null :
        P extends 'instansi' ? InstansiGetPayload<S['include'][P]> | null :
        P extends 'element' ? Array < ElementGetPayload<S['include'][P]>>  :
        P extends 'schedule' ? Array < ScheduleGetPayload<S['include'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['include'][P]>>  :
        P extends 'objective' ? Array < ObjectiveGetPayload<S['include'][P]>>  :
        P extends 'device' ? Array < TDeviceGetPayload<S['include'][P]>>  :
        P extends '_count' ? MataPelajaranCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MataPelajaranArgs | MataPelajaranFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'program' ? ProgramKeahlianGetPayload<S['select'][P]> | null :
        P extends 'keahlian' ? KonsentrasiKeahlianGetPayload<S['select'][P]> | null :
        P extends 'instansi' ? InstansiGetPayload<S['select'][P]> | null :
        P extends 'element' ? Array < ElementGetPayload<S['select'][P]>>  :
        P extends 'schedule' ? Array < ScheduleGetPayload<S['select'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['select'][P]>>  :
        P extends 'objective' ? Array < ObjectiveGetPayload<S['select'][P]>>  :
        P extends 'device' ? Array < TDeviceGetPayload<S['select'][P]>>  :
        P extends '_count' ? MataPelajaranCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof MataPelajaran ? MataPelajaran[P] : never
  } 
      : MataPelajaran


  type MataPelajaranCountArgs = 
    Omit<MataPelajaranFindManyArgs, 'select' | 'include'> & {
      select?: MataPelajaranCountAggregateInputType | true
    }

  export interface MataPelajaranDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MataPelajaran that matches the filter.
     * @param {MataPelajaranFindUniqueArgs} args - Arguments to find a MataPelajaran
     * @example
     * // Get one MataPelajaran
     * const mataPelajaran = await prisma.mataPelajaran.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MataPelajaranFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MataPelajaranFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MataPelajaran'> extends True ? Prisma__MataPelajaranClient<MataPelajaranGetPayload<T>> : Prisma__MataPelajaranClient<MataPelajaranGetPayload<T> | null, null>

    /**
     * Find one MataPelajaran that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MataPelajaranFindUniqueOrThrowArgs} args - Arguments to find a MataPelajaran
     * @example
     * // Get one MataPelajaran
     * const mataPelajaran = await prisma.mataPelajaran.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MataPelajaranFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MataPelajaranFindUniqueOrThrowArgs>
    ): Prisma__MataPelajaranClient<MataPelajaranGetPayload<T>>

    /**
     * Find the first MataPelajaran that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MataPelajaranFindFirstArgs} args - Arguments to find a MataPelajaran
     * @example
     * // Get one MataPelajaran
     * const mataPelajaran = await prisma.mataPelajaran.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MataPelajaranFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MataPelajaranFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MataPelajaran'> extends True ? Prisma__MataPelajaranClient<MataPelajaranGetPayload<T>> : Prisma__MataPelajaranClient<MataPelajaranGetPayload<T> | null, null>

    /**
     * Find the first MataPelajaran that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MataPelajaranFindFirstOrThrowArgs} args - Arguments to find a MataPelajaran
     * @example
     * // Get one MataPelajaran
     * const mataPelajaran = await prisma.mataPelajaran.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MataPelajaranFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MataPelajaranFindFirstOrThrowArgs>
    ): Prisma__MataPelajaranClient<MataPelajaranGetPayload<T>>

    /**
     * Find zero or more MataPelajarans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MataPelajaranFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MataPelajarans
     * const mataPelajarans = await prisma.mataPelajaran.findMany()
     * 
     * // Get first 10 MataPelajarans
     * const mataPelajarans = await prisma.mataPelajaran.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mataPelajaranWithIdOnly = await prisma.mataPelajaran.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MataPelajaranFindManyArgs>(
      args?: SelectSubset<T, MataPelajaranFindManyArgs>
    ): Prisma.PrismaPromise<Array<MataPelajaranGetPayload<T>>>

    /**
     * Create a MataPelajaran.
     * @param {MataPelajaranCreateArgs} args - Arguments to create a MataPelajaran.
     * @example
     * // Create one MataPelajaran
     * const MataPelajaran = await prisma.mataPelajaran.create({
     *   data: {
     *     // ... data to create a MataPelajaran
     *   }
     * })
     * 
    **/
    create<T extends MataPelajaranCreateArgs>(
      args: SelectSubset<T, MataPelajaranCreateArgs>
    ): Prisma__MataPelajaranClient<MataPelajaranGetPayload<T>>

    /**
     * Create many MataPelajarans.
     *     @param {MataPelajaranCreateManyArgs} args - Arguments to create many MataPelajarans.
     *     @example
     *     // Create many MataPelajarans
     *     const mataPelajaran = await prisma.mataPelajaran.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MataPelajaranCreateManyArgs>(
      args?: SelectSubset<T, MataPelajaranCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MataPelajaran.
     * @param {MataPelajaranDeleteArgs} args - Arguments to delete one MataPelajaran.
     * @example
     * // Delete one MataPelajaran
     * const MataPelajaran = await prisma.mataPelajaran.delete({
     *   where: {
     *     // ... filter to delete one MataPelajaran
     *   }
     * })
     * 
    **/
    delete<T extends MataPelajaranDeleteArgs>(
      args: SelectSubset<T, MataPelajaranDeleteArgs>
    ): Prisma__MataPelajaranClient<MataPelajaranGetPayload<T>>

    /**
     * Update one MataPelajaran.
     * @param {MataPelajaranUpdateArgs} args - Arguments to update one MataPelajaran.
     * @example
     * // Update one MataPelajaran
     * const mataPelajaran = await prisma.mataPelajaran.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MataPelajaranUpdateArgs>(
      args: SelectSubset<T, MataPelajaranUpdateArgs>
    ): Prisma__MataPelajaranClient<MataPelajaranGetPayload<T>>

    /**
     * Delete zero or more MataPelajarans.
     * @param {MataPelajaranDeleteManyArgs} args - Arguments to filter MataPelajarans to delete.
     * @example
     * // Delete a few MataPelajarans
     * const { count } = await prisma.mataPelajaran.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MataPelajaranDeleteManyArgs>(
      args?: SelectSubset<T, MataPelajaranDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MataPelajarans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MataPelajaranUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MataPelajarans
     * const mataPelajaran = await prisma.mataPelajaran.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MataPelajaranUpdateManyArgs>(
      args: SelectSubset<T, MataPelajaranUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MataPelajaran.
     * @param {MataPelajaranUpsertArgs} args - Arguments to update or create a MataPelajaran.
     * @example
     * // Update or create a MataPelajaran
     * const mataPelajaran = await prisma.mataPelajaran.upsert({
     *   create: {
     *     // ... data to create a MataPelajaran
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MataPelajaran we want to update
     *   }
     * })
    **/
    upsert<T extends MataPelajaranUpsertArgs>(
      args: SelectSubset<T, MataPelajaranUpsertArgs>
    ): Prisma__MataPelajaranClient<MataPelajaranGetPayload<T>>

    /**
     * Find zero or more MataPelajarans that matches the filter.
     * @param {MataPelajaranFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const mataPelajaran = await prisma.mataPelajaran.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: MataPelajaranFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a MataPelajaran.
     * @param {MataPelajaranAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const mataPelajaran = await prisma.mataPelajaran.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: MataPelajaranAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of MataPelajarans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MataPelajaranCountArgs} args - Arguments to filter MataPelajarans to count.
     * @example
     * // Count the number of MataPelajarans
     * const count = await prisma.mataPelajaran.count({
     *   where: {
     *     // ... the filter for the MataPelajarans we want to count
     *   }
     * })
    **/
    count<T extends MataPelajaranCountArgs>(
      args?: Subset<T, MataPelajaranCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MataPelajaranCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MataPelajaran.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MataPelajaranAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MataPelajaranAggregateArgs>(args: Subset<T, MataPelajaranAggregateArgs>): Prisma.PrismaPromise<GetMataPelajaranAggregateType<T>>

    /**
     * Group by MataPelajaran.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MataPelajaranGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MataPelajaranGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MataPelajaranGroupByArgs['orderBy'] }
        : { orderBy?: MataPelajaranGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MataPelajaranGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMataPelajaranGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MataPelajaran.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MataPelajaranClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    program<T extends ProgramKeahlianArgs= {}>(args?: Subset<T, ProgramKeahlianArgs>): Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T> | Null>;

    keahlian<T extends KonsentrasiKeahlianArgs= {}>(args?: Subset<T, KonsentrasiKeahlianArgs>): Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T> | Null>;

    instansi<T extends InstansiArgs= {}>(args?: Subset<T, InstansiArgs>): Prisma__InstansiClient<InstansiGetPayload<T> | Null>;

    element<T extends MataPelajaran$elementArgs= {}>(args?: Subset<T, MataPelajaran$elementArgs>): Prisma.PrismaPromise<Array<ElementGetPayload<T>>| Null>;

    schedule<T extends MataPelajaran$scheduleArgs= {}>(args?: Subset<T, MataPelajaran$scheduleArgs>): Prisma.PrismaPromise<Array<ScheduleGetPayload<T>>| Null>;

    tracker<T extends MataPelajaran$trackerArgs= {}>(args?: Subset<T, MataPelajaran$trackerArgs>): Prisma.PrismaPromise<Array<TrackerGetPayload<T>>| Null>;

    objective<T extends MataPelajaran$objectiveArgs= {}>(args?: Subset<T, MataPelajaran$objectiveArgs>): Prisma.PrismaPromise<Array<ObjectiveGetPayload<T>>| Null>;

    device<T extends MataPelajaran$deviceArgs= {}>(args?: Subset<T, MataPelajaran$deviceArgs>): Prisma.PrismaPromise<Array<TDeviceGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MataPelajaran base type for findUnique actions
   */
  export type MataPelajaranFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MataPelajaran
     */
    select?: MataPelajaranSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MataPelajaranInclude | null
    /**
     * Filter, which MataPelajaran to fetch.
     */
    where: MataPelajaranWhereUniqueInput
  }

  /**
   * MataPelajaran findUnique
   */
  export interface MataPelajaranFindUniqueArgs extends MataPelajaranFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MataPelajaran findUniqueOrThrow
   */
  export type MataPelajaranFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MataPelajaran
     */
    select?: MataPelajaranSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MataPelajaranInclude | null
    /**
     * Filter, which MataPelajaran to fetch.
     */
    where: MataPelajaranWhereUniqueInput
  }


  /**
   * MataPelajaran base type for findFirst actions
   */
  export type MataPelajaranFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MataPelajaran
     */
    select?: MataPelajaranSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MataPelajaranInclude | null
    /**
     * Filter, which MataPelajaran to fetch.
     */
    where?: MataPelajaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MataPelajarans to fetch.
     */
    orderBy?: Enumerable<MataPelajaranOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MataPelajarans.
     */
    cursor?: MataPelajaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MataPelajarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MataPelajarans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MataPelajarans.
     */
    distinct?: Enumerable<MataPelajaranScalarFieldEnum>
  }

  /**
   * MataPelajaran findFirst
   */
  export interface MataPelajaranFindFirstArgs extends MataPelajaranFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MataPelajaran findFirstOrThrow
   */
  export type MataPelajaranFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MataPelajaran
     */
    select?: MataPelajaranSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MataPelajaranInclude | null
    /**
     * Filter, which MataPelajaran to fetch.
     */
    where?: MataPelajaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MataPelajarans to fetch.
     */
    orderBy?: Enumerable<MataPelajaranOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MataPelajarans.
     */
    cursor?: MataPelajaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MataPelajarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MataPelajarans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MataPelajarans.
     */
    distinct?: Enumerable<MataPelajaranScalarFieldEnum>
  }


  /**
   * MataPelajaran findMany
   */
  export type MataPelajaranFindManyArgs = {
    /**
     * Select specific fields to fetch from the MataPelajaran
     */
    select?: MataPelajaranSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MataPelajaranInclude | null
    /**
     * Filter, which MataPelajarans to fetch.
     */
    where?: MataPelajaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MataPelajarans to fetch.
     */
    orderBy?: Enumerable<MataPelajaranOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MataPelajarans.
     */
    cursor?: MataPelajaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MataPelajarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MataPelajarans.
     */
    skip?: number
    distinct?: Enumerable<MataPelajaranScalarFieldEnum>
  }


  /**
   * MataPelajaran create
   */
  export type MataPelajaranCreateArgs = {
    /**
     * Select specific fields to fetch from the MataPelajaran
     */
    select?: MataPelajaranSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MataPelajaranInclude | null
    /**
     * The data needed to create a MataPelajaran.
     */
    data: XOR<MataPelajaranCreateInput, MataPelajaranUncheckedCreateInput>
  }


  /**
   * MataPelajaran createMany
   */
  export type MataPelajaranCreateManyArgs = {
    /**
     * The data used to create many MataPelajarans.
     */
    data: Enumerable<MataPelajaranCreateManyInput>
  }


  /**
   * MataPelajaran update
   */
  export type MataPelajaranUpdateArgs = {
    /**
     * Select specific fields to fetch from the MataPelajaran
     */
    select?: MataPelajaranSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MataPelajaranInclude | null
    /**
     * The data needed to update a MataPelajaran.
     */
    data: XOR<MataPelajaranUpdateInput, MataPelajaranUncheckedUpdateInput>
    /**
     * Choose, which MataPelajaran to update.
     */
    where: MataPelajaranWhereUniqueInput
  }


  /**
   * MataPelajaran updateMany
   */
  export type MataPelajaranUpdateManyArgs = {
    /**
     * The data used to update MataPelajarans.
     */
    data: XOR<MataPelajaranUpdateManyMutationInput, MataPelajaranUncheckedUpdateManyInput>
    /**
     * Filter which MataPelajarans to update
     */
    where?: MataPelajaranWhereInput
  }


  /**
   * MataPelajaran upsert
   */
  export type MataPelajaranUpsertArgs = {
    /**
     * Select specific fields to fetch from the MataPelajaran
     */
    select?: MataPelajaranSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MataPelajaranInclude | null
    /**
     * The filter to search for the MataPelajaran to update in case it exists.
     */
    where: MataPelajaranWhereUniqueInput
    /**
     * In case the MataPelajaran found by the `where` argument doesn't exist, create a new MataPelajaran with this data.
     */
    create: XOR<MataPelajaranCreateInput, MataPelajaranUncheckedCreateInput>
    /**
     * In case the MataPelajaran was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MataPelajaranUpdateInput, MataPelajaranUncheckedUpdateInput>
  }


  /**
   * MataPelajaran delete
   */
  export type MataPelajaranDeleteArgs = {
    /**
     * Select specific fields to fetch from the MataPelajaran
     */
    select?: MataPelajaranSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MataPelajaranInclude | null
    /**
     * Filter which MataPelajaran to delete.
     */
    where: MataPelajaranWhereUniqueInput
  }


  /**
   * MataPelajaran deleteMany
   */
  export type MataPelajaranDeleteManyArgs = {
    /**
     * Filter which MataPelajarans to delete
     */
    where?: MataPelajaranWhereInput
  }


  /**
   * MataPelajaran findRaw
   */
  export type MataPelajaranFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * MataPelajaran aggregateRaw
   */
  export type MataPelajaranAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * MataPelajaran.element
   */
  export type MataPelajaran$elementArgs = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ElementInclude | null
    where?: ElementWhereInput
    orderBy?: Enumerable<ElementOrderByWithRelationInput>
    cursor?: ElementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ElementScalarFieldEnum>
  }


  /**
   * MataPelajaran.schedule
   */
  export type MataPelajaran$scheduleArgs = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScheduleInclude | null
    where?: ScheduleWhereInput
    orderBy?: Enumerable<ScheduleOrderByWithRelationInput>
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ScheduleScalarFieldEnum>
  }


  /**
   * MataPelajaran.tracker
   */
  export type MataPelajaran$trackerArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    where?: TrackerWhereInput
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    cursor?: TrackerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TrackerScalarFieldEnum>
  }


  /**
   * MataPelajaran.objective
   */
  export type MataPelajaran$objectiveArgs = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectiveInclude | null
    where?: ObjectiveWhereInput
    orderBy?: Enumerable<ObjectiveOrderByWithRelationInput>
    cursor?: ObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ObjectiveScalarFieldEnum>
  }


  /**
   * MataPelajaran.device
   */
  export type MataPelajaran$deviceArgs = {
    /**
     * Select specific fields to fetch from the TDevice
     */
    select?: TDeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceInclude | null
    where?: TDeviceWhereInput
    orderBy?: Enumerable<TDeviceOrderByWithRelationInput>
    cursor?: TDeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TDeviceScalarFieldEnum>
  }


  /**
   * MataPelajaran without action
   */
  export type MataPelajaranArgs = {
    /**
     * Select specific fields to fetch from the MataPelajaran
     */
    select?: MataPelajaranSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MataPelajaranInclude | null
  }



  /**
   * Model Element
   */


  export type AggregateElement = {
    _count: ElementCountAggregateOutputType | null
    _avg: ElementAvgAggregateOutputType | null
    _sum: ElementSumAggregateOutputType | null
    _min: ElementMinAggregateOutputType | null
    _max: ElementMaxAggregateOutputType | null
  }

  export type ElementAvgAggregateOutputType = {
    no: number | null
  }

  export type ElementSumAggregateOutputType = {
    no: number | null
  }

  export type ElementMinAggregateOutputType = {
    id: string | null
    no: number | null
    name: string | null
    description: string | null
    mapelId: string | null
    disable: boolean | null
  }

  export type ElementMaxAggregateOutputType = {
    id: string | null
    no: number | null
    name: string | null
    description: string | null
    mapelId: string | null
    disable: boolean | null
  }

  export type ElementCountAggregateOutputType = {
    id: number
    no: number
    name: number
    description: number
    mapelId: number
    disable: number
    scheduleClassIds: number
    _all: number
  }


  export type ElementAvgAggregateInputType = {
    no?: true
  }

  export type ElementSumAggregateInputType = {
    no?: true
  }

  export type ElementMinAggregateInputType = {
    id?: true
    no?: true
    name?: true
    description?: true
    mapelId?: true
    disable?: true
  }

  export type ElementMaxAggregateInputType = {
    id?: true
    no?: true
    name?: true
    description?: true
    mapelId?: true
    disable?: true
  }

  export type ElementCountAggregateInputType = {
    id?: true
    no?: true
    name?: true
    description?: true
    mapelId?: true
    disable?: true
    scheduleClassIds?: true
    _all?: true
  }

  export type ElementAggregateArgs = {
    /**
     * Filter which Element to aggregate.
     */
    where?: ElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Elements to fetch.
     */
    orderBy?: Enumerable<ElementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Elements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Elements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Elements
    **/
    _count?: true | ElementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ElementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ElementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ElementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ElementMaxAggregateInputType
  }

  export type GetElementAggregateType<T extends ElementAggregateArgs> = {
        [P in keyof T & keyof AggregateElement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateElement[P]>
      : GetScalarType<T[P], AggregateElement[P]>
  }




  export type ElementGroupByArgs = {
    where?: ElementWhereInput
    orderBy?: Enumerable<ElementOrderByWithAggregationInput>
    by: ElementScalarFieldEnum[]
    having?: ElementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ElementCountAggregateInputType | true
    _avg?: ElementAvgAggregateInputType
    _sum?: ElementSumAggregateInputType
    _min?: ElementMinAggregateInputType
    _max?: ElementMaxAggregateInputType
  }


  export type ElementGroupByOutputType = {
    id: string
    no: number
    name: string
    description: string
    mapelId: string
    disable: boolean
    scheduleClassIds: string[]
    _count: ElementCountAggregateOutputType | null
    _avg: ElementAvgAggregateOutputType | null
    _sum: ElementSumAggregateOutputType | null
    _min: ElementMinAggregateOutputType | null
    _max: ElementMaxAggregateOutputType | null
  }

  type GetElementGroupByPayload<T extends ElementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ElementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ElementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ElementGroupByOutputType[P]>
            : GetScalarType<T[P], ElementGroupByOutputType[P]>
        }
      >
    >


  export type ElementSelect = {
    id?: boolean
    no?: boolean
    name?: boolean
    description?: boolean
    mapelId?: boolean
    disable?: boolean
    scheduleClassIds?: boolean
    achievement?: boolean | Element$achievementArgs
    mapel?: boolean | MataPelajaranArgs
    tracker?: boolean | Element$trackerArgs
    scheduleClass?: boolean | Element$scheduleClassArgs
    objective?: boolean | Element$objectiveArgs
    _count?: boolean | ElementCountOutputTypeArgs
  }


  export type ElementInclude = {
    achievement?: boolean | Element$achievementArgs
    mapel?: boolean | MataPelajaranArgs
    tracker?: boolean | Element$trackerArgs
    scheduleClass?: boolean | Element$scheduleClassArgs
    objective?: boolean | Element$objectiveArgs
    _count?: boolean | ElementCountOutputTypeArgs
  }

  export type ElementGetPayload<S extends boolean | null | undefined | ElementArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Element :
    S extends undefined ? never :
    S extends { include: any } & (ElementArgs | ElementFindManyArgs)
    ? Element  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'achievement' ? Array < AchievementGetPayload<S['include'][P]>>  :
        P extends 'mapel' ? MataPelajaranGetPayload<S['include'][P]> :
        P extends 'tracker' ? Array < TrackerGetPayload<S['include'][P]>>  :
        P extends 'scheduleClass' ? Array < TeachingGetPayload<S['include'][P]>>  :
        P extends 'objective' ? Array < ObjectiveGetPayload<S['include'][P]>>  :
        P extends '_count' ? ElementCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ElementArgs | ElementFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'achievement' ? Array < AchievementGetPayload<S['select'][P]>>  :
        P extends 'mapel' ? MataPelajaranGetPayload<S['select'][P]> :
        P extends 'tracker' ? Array < TrackerGetPayload<S['select'][P]>>  :
        P extends 'scheduleClass' ? Array < TeachingGetPayload<S['select'][P]>>  :
        P extends 'objective' ? Array < ObjectiveGetPayload<S['select'][P]>>  :
        P extends '_count' ? ElementCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Element ? Element[P] : never
  } 
      : Element


  type ElementCountArgs = 
    Omit<ElementFindManyArgs, 'select' | 'include'> & {
      select?: ElementCountAggregateInputType | true
    }

  export interface ElementDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Element that matches the filter.
     * @param {ElementFindUniqueArgs} args - Arguments to find a Element
     * @example
     * // Get one Element
     * const element = await prisma.element.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ElementFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ElementFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Element'> extends True ? Prisma__ElementClient<ElementGetPayload<T>> : Prisma__ElementClient<ElementGetPayload<T> | null, null>

    /**
     * Find one Element that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ElementFindUniqueOrThrowArgs} args - Arguments to find a Element
     * @example
     * // Get one Element
     * const element = await prisma.element.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ElementFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ElementFindUniqueOrThrowArgs>
    ): Prisma__ElementClient<ElementGetPayload<T>>

    /**
     * Find the first Element that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementFindFirstArgs} args - Arguments to find a Element
     * @example
     * // Get one Element
     * const element = await prisma.element.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ElementFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ElementFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Element'> extends True ? Prisma__ElementClient<ElementGetPayload<T>> : Prisma__ElementClient<ElementGetPayload<T> | null, null>

    /**
     * Find the first Element that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementFindFirstOrThrowArgs} args - Arguments to find a Element
     * @example
     * // Get one Element
     * const element = await prisma.element.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ElementFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ElementFindFirstOrThrowArgs>
    ): Prisma__ElementClient<ElementGetPayload<T>>

    /**
     * Find zero or more Elements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Elements
     * const elements = await prisma.element.findMany()
     * 
     * // Get first 10 Elements
     * const elements = await prisma.element.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const elementWithIdOnly = await prisma.element.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ElementFindManyArgs>(
      args?: SelectSubset<T, ElementFindManyArgs>
    ): Prisma.PrismaPromise<Array<ElementGetPayload<T>>>

    /**
     * Create a Element.
     * @param {ElementCreateArgs} args - Arguments to create a Element.
     * @example
     * // Create one Element
     * const Element = await prisma.element.create({
     *   data: {
     *     // ... data to create a Element
     *   }
     * })
     * 
    **/
    create<T extends ElementCreateArgs>(
      args: SelectSubset<T, ElementCreateArgs>
    ): Prisma__ElementClient<ElementGetPayload<T>>

    /**
     * Create many Elements.
     *     @param {ElementCreateManyArgs} args - Arguments to create many Elements.
     *     @example
     *     // Create many Elements
     *     const element = await prisma.element.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ElementCreateManyArgs>(
      args?: SelectSubset<T, ElementCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Element.
     * @param {ElementDeleteArgs} args - Arguments to delete one Element.
     * @example
     * // Delete one Element
     * const Element = await prisma.element.delete({
     *   where: {
     *     // ... filter to delete one Element
     *   }
     * })
     * 
    **/
    delete<T extends ElementDeleteArgs>(
      args: SelectSubset<T, ElementDeleteArgs>
    ): Prisma__ElementClient<ElementGetPayload<T>>

    /**
     * Update one Element.
     * @param {ElementUpdateArgs} args - Arguments to update one Element.
     * @example
     * // Update one Element
     * const element = await prisma.element.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ElementUpdateArgs>(
      args: SelectSubset<T, ElementUpdateArgs>
    ): Prisma__ElementClient<ElementGetPayload<T>>

    /**
     * Delete zero or more Elements.
     * @param {ElementDeleteManyArgs} args - Arguments to filter Elements to delete.
     * @example
     * // Delete a few Elements
     * const { count } = await prisma.element.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ElementDeleteManyArgs>(
      args?: SelectSubset<T, ElementDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Elements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Elements
     * const element = await prisma.element.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ElementUpdateManyArgs>(
      args: SelectSubset<T, ElementUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Element.
     * @param {ElementUpsertArgs} args - Arguments to update or create a Element.
     * @example
     * // Update or create a Element
     * const element = await prisma.element.upsert({
     *   create: {
     *     // ... data to create a Element
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Element we want to update
     *   }
     * })
    **/
    upsert<T extends ElementUpsertArgs>(
      args: SelectSubset<T, ElementUpsertArgs>
    ): Prisma__ElementClient<ElementGetPayload<T>>

    /**
     * Find zero or more Elements that matches the filter.
     * @param {ElementFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const element = await prisma.element.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ElementFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Element.
     * @param {ElementAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const element = await prisma.element.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ElementAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Elements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementCountArgs} args - Arguments to filter Elements to count.
     * @example
     * // Count the number of Elements
     * const count = await prisma.element.count({
     *   where: {
     *     // ... the filter for the Elements we want to count
     *   }
     * })
    **/
    count<T extends ElementCountArgs>(
      args?: Subset<T, ElementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ElementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Element.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ElementAggregateArgs>(args: Subset<T, ElementAggregateArgs>): Prisma.PrismaPromise<GetElementAggregateType<T>>

    /**
     * Group by Element.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ElementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ElementGroupByArgs['orderBy'] }
        : { orderBy?: ElementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ElementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetElementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Element.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ElementClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    achievement<T extends Element$achievementArgs= {}>(args?: Subset<T, Element$achievementArgs>): Prisma.PrismaPromise<Array<AchievementGetPayload<T>>| Null>;

    mapel<T extends MataPelajaranArgs= {}>(args?: Subset<T, MataPelajaranArgs>): Prisma__MataPelajaranClient<MataPelajaranGetPayload<T> | Null>;

    tracker<T extends Element$trackerArgs= {}>(args?: Subset<T, Element$trackerArgs>): Prisma.PrismaPromise<Array<TrackerGetPayload<T>>| Null>;

    scheduleClass<T extends Element$scheduleClassArgs= {}>(args?: Subset<T, Element$scheduleClassArgs>): Prisma.PrismaPromise<Array<TeachingGetPayload<T>>| Null>;

    objective<T extends Element$objectiveArgs= {}>(args?: Subset<T, Element$objectiveArgs>): Prisma.PrismaPromise<Array<ObjectiveGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Element base type for findUnique actions
   */
  export type ElementFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ElementInclude | null
    /**
     * Filter, which Element to fetch.
     */
    where: ElementWhereUniqueInput
  }

  /**
   * Element findUnique
   */
  export interface ElementFindUniqueArgs extends ElementFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Element findUniqueOrThrow
   */
  export type ElementFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ElementInclude | null
    /**
     * Filter, which Element to fetch.
     */
    where: ElementWhereUniqueInput
  }


  /**
   * Element base type for findFirst actions
   */
  export type ElementFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ElementInclude | null
    /**
     * Filter, which Element to fetch.
     */
    where?: ElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Elements to fetch.
     */
    orderBy?: Enumerable<ElementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Elements.
     */
    cursor?: ElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Elements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Elements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Elements.
     */
    distinct?: Enumerable<ElementScalarFieldEnum>
  }

  /**
   * Element findFirst
   */
  export interface ElementFindFirstArgs extends ElementFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Element findFirstOrThrow
   */
  export type ElementFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ElementInclude | null
    /**
     * Filter, which Element to fetch.
     */
    where?: ElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Elements to fetch.
     */
    orderBy?: Enumerable<ElementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Elements.
     */
    cursor?: ElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Elements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Elements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Elements.
     */
    distinct?: Enumerable<ElementScalarFieldEnum>
  }


  /**
   * Element findMany
   */
  export type ElementFindManyArgs = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ElementInclude | null
    /**
     * Filter, which Elements to fetch.
     */
    where?: ElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Elements to fetch.
     */
    orderBy?: Enumerable<ElementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Elements.
     */
    cursor?: ElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Elements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Elements.
     */
    skip?: number
    distinct?: Enumerable<ElementScalarFieldEnum>
  }


  /**
   * Element create
   */
  export type ElementCreateArgs = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ElementInclude | null
    /**
     * The data needed to create a Element.
     */
    data: XOR<ElementCreateInput, ElementUncheckedCreateInput>
  }


  /**
   * Element createMany
   */
  export type ElementCreateManyArgs = {
    /**
     * The data used to create many Elements.
     */
    data: Enumerable<ElementCreateManyInput>
  }


  /**
   * Element update
   */
  export type ElementUpdateArgs = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ElementInclude | null
    /**
     * The data needed to update a Element.
     */
    data: XOR<ElementUpdateInput, ElementUncheckedUpdateInput>
    /**
     * Choose, which Element to update.
     */
    where: ElementWhereUniqueInput
  }


  /**
   * Element updateMany
   */
  export type ElementUpdateManyArgs = {
    /**
     * The data used to update Elements.
     */
    data: XOR<ElementUpdateManyMutationInput, ElementUncheckedUpdateManyInput>
    /**
     * Filter which Elements to update
     */
    where?: ElementWhereInput
  }


  /**
   * Element upsert
   */
  export type ElementUpsertArgs = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ElementInclude | null
    /**
     * The filter to search for the Element to update in case it exists.
     */
    where: ElementWhereUniqueInput
    /**
     * In case the Element found by the `where` argument doesn't exist, create a new Element with this data.
     */
    create: XOR<ElementCreateInput, ElementUncheckedCreateInput>
    /**
     * In case the Element was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ElementUpdateInput, ElementUncheckedUpdateInput>
  }


  /**
   * Element delete
   */
  export type ElementDeleteArgs = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ElementInclude | null
    /**
     * Filter which Element to delete.
     */
    where: ElementWhereUniqueInput
  }


  /**
   * Element deleteMany
   */
  export type ElementDeleteManyArgs = {
    /**
     * Filter which Elements to delete
     */
    where?: ElementWhereInput
  }


  /**
   * Element findRaw
   */
  export type ElementFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Element aggregateRaw
   */
  export type ElementAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Element.achievement
   */
  export type Element$achievementArgs = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AchievementInclude | null
    where?: AchievementWhereInput
    orderBy?: Enumerable<AchievementOrderByWithRelationInput>
    cursor?: AchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AchievementScalarFieldEnum>
  }


  /**
   * Element.tracker
   */
  export type Element$trackerArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    where?: TrackerWhereInput
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    cursor?: TrackerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TrackerScalarFieldEnum>
  }


  /**
   * Element.scheduleClass
   */
  export type Element$scheduleClassArgs = {
    /**
     * Select specific fields to fetch from the Teaching
     */
    select?: TeachingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachingInclude | null
    where?: TeachingWhereInput
    orderBy?: Enumerable<TeachingOrderByWithRelationInput>
    cursor?: TeachingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeachingScalarFieldEnum>
  }


  /**
   * Element.objective
   */
  export type Element$objectiveArgs = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectiveInclude | null
    where?: ObjectiveWhereInput
    orderBy?: Enumerable<ObjectiveOrderByWithRelationInput>
    cursor?: ObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ObjectiveScalarFieldEnum>
  }


  /**
   * Element without action
   */
  export type ElementArgs = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ElementInclude | null
  }



  /**
   * Model Achievement
   */


  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    no: number | null
  }

  export type AchievementSumAggregateOutputType = {
    no: number | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    no: number | null
    fase: Fase | null
    description: string | null
    elementId: string | null
    disable: boolean | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    no: number | null
    fase: Fase | null
    description: string | null
    elementId: string | null
    disable: boolean | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    no: number
    fase: number
    description: number
    elementId: number
    disable: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    no?: true
  }

  export type AchievementSumAggregateInputType = {
    no?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    no?: true
    fase?: true
    description?: true
    elementId?: true
    disable?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    no?: true
    fase?: true
    description?: true
    elementId?: true
    disable?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    no?: true
    fase?: true
    description?: true
    elementId?: true
    disable?: true
    _all?: true
  }

  export type AchievementAggregateArgs = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: Enumerable<AchievementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs = {
    where?: AchievementWhereInput
    orderBy?: Enumerable<AchievementOrderByWithAggregationInput>
    by: AchievementScalarFieldEnum[]
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }


  export type AchievementGroupByOutputType = {
    id: string
    no: number
    fase: Fase
    description: string
    elementId: string
    disable: boolean
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect = {
    id?: boolean
    no?: boolean
    fase?: boolean
    description?: boolean
    elementId?: boolean
    disable?: boolean
    element?: boolean | ElementArgs
    objective?: boolean | Achievement$objectiveArgs
    tracker?: boolean | Achievement$trackerArgs
    _count?: boolean | AchievementCountOutputTypeArgs
  }


  export type AchievementInclude = {
    element?: boolean | ElementArgs
    objective?: boolean | Achievement$objectiveArgs
    tracker?: boolean | Achievement$trackerArgs
    _count?: boolean | AchievementCountOutputTypeArgs
  }

  export type AchievementGetPayload<S extends boolean | null | undefined | AchievementArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Achievement :
    S extends undefined ? never :
    S extends { include: any } & (AchievementArgs | AchievementFindManyArgs)
    ? Achievement  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'element' ? ElementGetPayload<S['include'][P]> :
        P extends 'objective' ? Array < ObjectiveGetPayload<S['include'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['include'][P]>>  :
        P extends '_count' ? AchievementCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AchievementArgs | AchievementFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'element' ? ElementGetPayload<S['select'][P]> :
        P extends 'objective' ? Array < ObjectiveGetPayload<S['select'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['select'][P]>>  :
        P extends '_count' ? AchievementCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Achievement ? Achievement[P] : never
  } 
      : Achievement


  type AchievementCountArgs = 
    Omit<AchievementFindManyArgs, 'select' | 'include'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AchievementFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AchievementFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Achievement'> extends True ? Prisma__AchievementClient<AchievementGetPayload<T>> : Prisma__AchievementClient<AchievementGetPayload<T> | null, null>

    /**
     * Find one Achievement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AchievementFindUniqueOrThrowArgs>
    ): Prisma__AchievementClient<AchievementGetPayload<T>>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AchievementFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AchievementFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Achievement'> extends True ? Prisma__AchievementClient<AchievementGetPayload<T>> : Prisma__AchievementClient<AchievementGetPayload<T> | null, null>

    /**
     * Find the first Achievement that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AchievementFindFirstOrThrowArgs>
    ): Prisma__AchievementClient<AchievementGetPayload<T>>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AchievementFindManyArgs>(
      args?: SelectSubset<T, AchievementFindManyArgs>
    ): Prisma.PrismaPromise<Array<AchievementGetPayload<T>>>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
    **/
    create<T extends AchievementCreateArgs>(
      args: SelectSubset<T, AchievementCreateArgs>
    ): Prisma__AchievementClient<AchievementGetPayload<T>>

    /**
     * Create many Achievements.
     *     @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     *     @example
     *     // Create many Achievements
     *     const achievement = await prisma.achievement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AchievementCreateManyArgs>(
      args?: SelectSubset<T, AchievementCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
    **/
    delete<T extends AchievementDeleteArgs>(
      args: SelectSubset<T, AchievementDeleteArgs>
    ): Prisma__AchievementClient<AchievementGetPayload<T>>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AchievementUpdateArgs>(
      args: SelectSubset<T, AchievementUpdateArgs>
    ): Prisma__AchievementClient<AchievementGetPayload<T>>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AchievementDeleteManyArgs>(
      args?: SelectSubset<T, AchievementDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AchievementUpdateManyArgs>(
      args: SelectSubset<T, AchievementUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
    **/
    upsert<T extends AchievementUpsertArgs>(
      args: SelectSubset<T, AchievementUpsertArgs>
    ): Prisma__AchievementClient<AchievementGetPayload<T>>

    /**
     * Find zero or more Achievements that matches the filter.
     * @param {AchievementFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const achievement = await prisma.achievement.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: AchievementFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Achievement.
     * @param {AchievementAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const achievement = await prisma.achievement.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: AchievementAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AchievementClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    element<T extends ElementArgs= {}>(args?: Subset<T, ElementArgs>): Prisma__ElementClient<ElementGetPayload<T> | Null>;

    objective<T extends Achievement$objectiveArgs= {}>(args?: Subset<T, Achievement$objectiveArgs>): Prisma.PrismaPromise<Array<ObjectiveGetPayload<T>>| Null>;

    tracker<T extends Achievement$trackerArgs= {}>(args?: Subset<T, Achievement$trackerArgs>): Prisma.PrismaPromise<Array<TrackerGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Achievement base type for findUnique actions
   */
  export type AchievementFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AchievementInclude | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUnique
   */
  export interface AchievementFindUniqueArgs extends AchievementFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AchievementInclude | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }


  /**
   * Achievement base type for findFirst actions
   */
  export type AchievementFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AchievementInclude | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: Enumerable<AchievementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: Enumerable<AchievementScalarFieldEnum>
  }

  /**
   * Achievement findFirst
   */
  export interface AchievementFindFirstArgs extends AchievementFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AchievementInclude | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: Enumerable<AchievementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: Enumerable<AchievementScalarFieldEnum>
  }


  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AchievementInclude | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: Enumerable<AchievementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: Enumerable<AchievementScalarFieldEnum>
  }


  /**
   * Achievement create
   */
  export type AchievementCreateArgs = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AchievementInclude | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }


  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs = {
    /**
     * The data used to create many Achievements.
     */
    data: Enumerable<AchievementCreateManyInput>
  }


  /**
   * Achievement update
   */
  export type AchievementUpdateArgs = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AchievementInclude | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }


  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
  }


  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AchievementInclude | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }


  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AchievementInclude | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }


  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
  }


  /**
   * Achievement findRaw
   */
  export type AchievementFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Achievement aggregateRaw
   */
  export type AchievementAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Achievement.objective
   */
  export type Achievement$objectiveArgs = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectiveInclude | null
    where?: ObjectiveWhereInput
    orderBy?: Enumerable<ObjectiveOrderByWithRelationInput>
    cursor?: ObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ObjectiveScalarFieldEnum>
  }


  /**
   * Achievement.tracker
   */
  export type Achievement$trackerArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    where?: TrackerWhereInput
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    cursor?: TrackerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TrackerScalarFieldEnum>
  }


  /**
   * Achievement without action
   */
  export type AchievementArgs = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AchievementInclude | null
  }



  /**
   * Model BidangKeahlian
   */


  export type AggregateBidangKeahlian = {
    _count: BidangKeahlianCountAggregateOutputType | null
    _min: BidangKeahlianMinAggregateOutputType | null
    _max: BidangKeahlianMaxAggregateOutputType | null
  }

  export type BidangKeahlianMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    disable: boolean | null
  }

  export type BidangKeahlianMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    disable: boolean | null
  }

  export type BidangKeahlianCountAggregateOutputType = {
    id: number
    code: number
    name: number
    disable: number
    _all: number
  }


  export type BidangKeahlianMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    disable?: true
  }

  export type BidangKeahlianMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    disable?: true
  }

  export type BidangKeahlianCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    disable?: true
    _all?: true
  }

  export type BidangKeahlianAggregateArgs = {
    /**
     * Filter which BidangKeahlian to aggregate.
     */
    where?: BidangKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidangKeahlians to fetch.
     */
    orderBy?: Enumerable<BidangKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BidangKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidangKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidangKeahlians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BidangKeahlians
    **/
    _count?: true | BidangKeahlianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BidangKeahlianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BidangKeahlianMaxAggregateInputType
  }

  export type GetBidangKeahlianAggregateType<T extends BidangKeahlianAggregateArgs> = {
        [P in keyof T & keyof AggregateBidangKeahlian]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBidangKeahlian[P]>
      : GetScalarType<T[P], AggregateBidangKeahlian[P]>
  }




  export type BidangKeahlianGroupByArgs = {
    where?: BidangKeahlianWhereInput
    orderBy?: Enumerable<BidangKeahlianOrderByWithAggregationInput>
    by: BidangKeahlianScalarFieldEnum[]
    having?: BidangKeahlianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BidangKeahlianCountAggregateInputType | true
    _min?: BidangKeahlianMinAggregateInputType
    _max?: BidangKeahlianMaxAggregateInputType
  }


  export type BidangKeahlianGroupByOutputType = {
    id: string
    code: string
    name: string
    disable: boolean
    _count: BidangKeahlianCountAggregateOutputType | null
    _min: BidangKeahlianMinAggregateOutputType | null
    _max: BidangKeahlianMaxAggregateOutputType | null
  }

  type GetBidangKeahlianGroupByPayload<T extends BidangKeahlianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BidangKeahlianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BidangKeahlianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BidangKeahlianGroupByOutputType[P]>
            : GetScalarType<T[P], BidangKeahlianGroupByOutputType[P]>
        }
      >
    >


  export type BidangKeahlianSelect = {
    id?: boolean
    code?: boolean
    name?: boolean
    disable?: boolean
    program?: boolean | BidangKeahlian$programArgs
    tracker?: boolean | BidangKeahlian$trackerArgs
    _count?: boolean | BidangKeahlianCountOutputTypeArgs
  }


  export type BidangKeahlianInclude = {
    program?: boolean | BidangKeahlian$programArgs
    tracker?: boolean | BidangKeahlian$trackerArgs
    _count?: boolean | BidangKeahlianCountOutputTypeArgs
  }

  export type BidangKeahlianGetPayload<S extends boolean | null | undefined | BidangKeahlianArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BidangKeahlian :
    S extends undefined ? never :
    S extends { include: any } & (BidangKeahlianArgs | BidangKeahlianFindManyArgs)
    ? BidangKeahlian  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'program' ? Array < ProgramKeahlianGetPayload<S['include'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['include'][P]>>  :
        P extends '_count' ? BidangKeahlianCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BidangKeahlianArgs | BidangKeahlianFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'program' ? Array < ProgramKeahlianGetPayload<S['select'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['select'][P]>>  :
        P extends '_count' ? BidangKeahlianCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BidangKeahlian ? BidangKeahlian[P] : never
  } 
      : BidangKeahlian


  type BidangKeahlianCountArgs = 
    Omit<BidangKeahlianFindManyArgs, 'select' | 'include'> & {
      select?: BidangKeahlianCountAggregateInputType | true
    }

  export interface BidangKeahlianDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BidangKeahlian that matches the filter.
     * @param {BidangKeahlianFindUniqueArgs} args - Arguments to find a BidangKeahlian
     * @example
     * // Get one BidangKeahlian
     * const bidangKeahlian = await prisma.bidangKeahlian.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BidangKeahlianFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BidangKeahlianFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BidangKeahlian'> extends True ? Prisma__BidangKeahlianClient<BidangKeahlianGetPayload<T>> : Prisma__BidangKeahlianClient<BidangKeahlianGetPayload<T> | null, null>

    /**
     * Find one BidangKeahlian that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BidangKeahlianFindUniqueOrThrowArgs} args - Arguments to find a BidangKeahlian
     * @example
     * // Get one BidangKeahlian
     * const bidangKeahlian = await prisma.bidangKeahlian.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BidangKeahlianFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BidangKeahlianFindUniqueOrThrowArgs>
    ): Prisma__BidangKeahlianClient<BidangKeahlianGetPayload<T>>

    /**
     * Find the first BidangKeahlian that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidangKeahlianFindFirstArgs} args - Arguments to find a BidangKeahlian
     * @example
     * // Get one BidangKeahlian
     * const bidangKeahlian = await prisma.bidangKeahlian.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BidangKeahlianFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BidangKeahlianFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BidangKeahlian'> extends True ? Prisma__BidangKeahlianClient<BidangKeahlianGetPayload<T>> : Prisma__BidangKeahlianClient<BidangKeahlianGetPayload<T> | null, null>

    /**
     * Find the first BidangKeahlian that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidangKeahlianFindFirstOrThrowArgs} args - Arguments to find a BidangKeahlian
     * @example
     * // Get one BidangKeahlian
     * const bidangKeahlian = await prisma.bidangKeahlian.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BidangKeahlianFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BidangKeahlianFindFirstOrThrowArgs>
    ): Prisma__BidangKeahlianClient<BidangKeahlianGetPayload<T>>

    /**
     * Find zero or more BidangKeahlians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidangKeahlianFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BidangKeahlians
     * const bidangKeahlians = await prisma.bidangKeahlian.findMany()
     * 
     * // Get first 10 BidangKeahlians
     * const bidangKeahlians = await prisma.bidangKeahlian.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bidangKeahlianWithIdOnly = await prisma.bidangKeahlian.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BidangKeahlianFindManyArgs>(
      args?: SelectSubset<T, BidangKeahlianFindManyArgs>
    ): Prisma.PrismaPromise<Array<BidangKeahlianGetPayload<T>>>

    /**
     * Create a BidangKeahlian.
     * @param {BidangKeahlianCreateArgs} args - Arguments to create a BidangKeahlian.
     * @example
     * // Create one BidangKeahlian
     * const BidangKeahlian = await prisma.bidangKeahlian.create({
     *   data: {
     *     // ... data to create a BidangKeahlian
     *   }
     * })
     * 
    **/
    create<T extends BidangKeahlianCreateArgs>(
      args: SelectSubset<T, BidangKeahlianCreateArgs>
    ): Prisma__BidangKeahlianClient<BidangKeahlianGetPayload<T>>

    /**
     * Create many BidangKeahlians.
     *     @param {BidangKeahlianCreateManyArgs} args - Arguments to create many BidangKeahlians.
     *     @example
     *     // Create many BidangKeahlians
     *     const bidangKeahlian = await prisma.bidangKeahlian.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BidangKeahlianCreateManyArgs>(
      args?: SelectSubset<T, BidangKeahlianCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BidangKeahlian.
     * @param {BidangKeahlianDeleteArgs} args - Arguments to delete one BidangKeahlian.
     * @example
     * // Delete one BidangKeahlian
     * const BidangKeahlian = await prisma.bidangKeahlian.delete({
     *   where: {
     *     // ... filter to delete one BidangKeahlian
     *   }
     * })
     * 
    **/
    delete<T extends BidangKeahlianDeleteArgs>(
      args: SelectSubset<T, BidangKeahlianDeleteArgs>
    ): Prisma__BidangKeahlianClient<BidangKeahlianGetPayload<T>>

    /**
     * Update one BidangKeahlian.
     * @param {BidangKeahlianUpdateArgs} args - Arguments to update one BidangKeahlian.
     * @example
     * // Update one BidangKeahlian
     * const bidangKeahlian = await prisma.bidangKeahlian.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BidangKeahlianUpdateArgs>(
      args: SelectSubset<T, BidangKeahlianUpdateArgs>
    ): Prisma__BidangKeahlianClient<BidangKeahlianGetPayload<T>>

    /**
     * Delete zero or more BidangKeahlians.
     * @param {BidangKeahlianDeleteManyArgs} args - Arguments to filter BidangKeahlians to delete.
     * @example
     * // Delete a few BidangKeahlians
     * const { count } = await prisma.bidangKeahlian.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BidangKeahlianDeleteManyArgs>(
      args?: SelectSubset<T, BidangKeahlianDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BidangKeahlians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidangKeahlianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BidangKeahlians
     * const bidangKeahlian = await prisma.bidangKeahlian.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BidangKeahlianUpdateManyArgs>(
      args: SelectSubset<T, BidangKeahlianUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BidangKeahlian.
     * @param {BidangKeahlianUpsertArgs} args - Arguments to update or create a BidangKeahlian.
     * @example
     * // Update or create a BidangKeahlian
     * const bidangKeahlian = await prisma.bidangKeahlian.upsert({
     *   create: {
     *     // ... data to create a BidangKeahlian
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BidangKeahlian we want to update
     *   }
     * })
    **/
    upsert<T extends BidangKeahlianUpsertArgs>(
      args: SelectSubset<T, BidangKeahlianUpsertArgs>
    ): Prisma__BidangKeahlianClient<BidangKeahlianGetPayload<T>>

    /**
     * Find zero or more BidangKeahlians that matches the filter.
     * @param {BidangKeahlianFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const bidangKeahlian = await prisma.bidangKeahlian.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: BidangKeahlianFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a BidangKeahlian.
     * @param {BidangKeahlianAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const bidangKeahlian = await prisma.bidangKeahlian.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: BidangKeahlianAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of BidangKeahlians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidangKeahlianCountArgs} args - Arguments to filter BidangKeahlians to count.
     * @example
     * // Count the number of BidangKeahlians
     * const count = await prisma.bidangKeahlian.count({
     *   where: {
     *     // ... the filter for the BidangKeahlians we want to count
     *   }
     * })
    **/
    count<T extends BidangKeahlianCountArgs>(
      args?: Subset<T, BidangKeahlianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BidangKeahlianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BidangKeahlian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidangKeahlianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BidangKeahlianAggregateArgs>(args: Subset<T, BidangKeahlianAggregateArgs>): Prisma.PrismaPromise<GetBidangKeahlianAggregateType<T>>

    /**
     * Group by BidangKeahlian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidangKeahlianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BidangKeahlianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BidangKeahlianGroupByArgs['orderBy'] }
        : { orderBy?: BidangKeahlianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BidangKeahlianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBidangKeahlianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BidangKeahlian.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BidangKeahlianClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    program<T extends BidangKeahlian$programArgs= {}>(args?: Subset<T, BidangKeahlian$programArgs>): Prisma.PrismaPromise<Array<ProgramKeahlianGetPayload<T>>| Null>;

    tracker<T extends BidangKeahlian$trackerArgs= {}>(args?: Subset<T, BidangKeahlian$trackerArgs>): Prisma.PrismaPromise<Array<TrackerGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BidangKeahlian base type for findUnique actions
   */
  export type BidangKeahlianFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BidangKeahlian
     */
    select?: BidangKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BidangKeahlianInclude | null
    /**
     * Filter, which BidangKeahlian to fetch.
     */
    where: BidangKeahlianWhereUniqueInput
  }

  /**
   * BidangKeahlian findUnique
   */
  export interface BidangKeahlianFindUniqueArgs extends BidangKeahlianFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BidangKeahlian findUniqueOrThrow
   */
  export type BidangKeahlianFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BidangKeahlian
     */
    select?: BidangKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BidangKeahlianInclude | null
    /**
     * Filter, which BidangKeahlian to fetch.
     */
    where: BidangKeahlianWhereUniqueInput
  }


  /**
   * BidangKeahlian base type for findFirst actions
   */
  export type BidangKeahlianFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BidangKeahlian
     */
    select?: BidangKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BidangKeahlianInclude | null
    /**
     * Filter, which BidangKeahlian to fetch.
     */
    where?: BidangKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidangKeahlians to fetch.
     */
    orderBy?: Enumerable<BidangKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BidangKeahlians.
     */
    cursor?: BidangKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidangKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidangKeahlians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BidangKeahlians.
     */
    distinct?: Enumerable<BidangKeahlianScalarFieldEnum>
  }

  /**
   * BidangKeahlian findFirst
   */
  export interface BidangKeahlianFindFirstArgs extends BidangKeahlianFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BidangKeahlian findFirstOrThrow
   */
  export type BidangKeahlianFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BidangKeahlian
     */
    select?: BidangKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BidangKeahlianInclude | null
    /**
     * Filter, which BidangKeahlian to fetch.
     */
    where?: BidangKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidangKeahlians to fetch.
     */
    orderBy?: Enumerable<BidangKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BidangKeahlians.
     */
    cursor?: BidangKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidangKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidangKeahlians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BidangKeahlians.
     */
    distinct?: Enumerable<BidangKeahlianScalarFieldEnum>
  }


  /**
   * BidangKeahlian findMany
   */
  export type BidangKeahlianFindManyArgs = {
    /**
     * Select specific fields to fetch from the BidangKeahlian
     */
    select?: BidangKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BidangKeahlianInclude | null
    /**
     * Filter, which BidangKeahlians to fetch.
     */
    where?: BidangKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidangKeahlians to fetch.
     */
    orderBy?: Enumerable<BidangKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BidangKeahlians.
     */
    cursor?: BidangKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidangKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidangKeahlians.
     */
    skip?: number
    distinct?: Enumerable<BidangKeahlianScalarFieldEnum>
  }


  /**
   * BidangKeahlian create
   */
  export type BidangKeahlianCreateArgs = {
    /**
     * Select specific fields to fetch from the BidangKeahlian
     */
    select?: BidangKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BidangKeahlianInclude | null
    /**
     * The data needed to create a BidangKeahlian.
     */
    data: XOR<BidangKeahlianCreateInput, BidangKeahlianUncheckedCreateInput>
  }


  /**
   * BidangKeahlian createMany
   */
  export type BidangKeahlianCreateManyArgs = {
    /**
     * The data used to create many BidangKeahlians.
     */
    data: Enumerable<BidangKeahlianCreateManyInput>
  }


  /**
   * BidangKeahlian update
   */
  export type BidangKeahlianUpdateArgs = {
    /**
     * Select specific fields to fetch from the BidangKeahlian
     */
    select?: BidangKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BidangKeahlianInclude | null
    /**
     * The data needed to update a BidangKeahlian.
     */
    data: XOR<BidangKeahlianUpdateInput, BidangKeahlianUncheckedUpdateInput>
    /**
     * Choose, which BidangKeahlian to update.
     */
    where: BidangKeahlianWhereUniqueInput
  }


  /**
   * BidangKeahlian updateMany
   */
  export type BidangKeahlianUpdateManyArgs = {
    /**
     * The data used to update BidangKeahlians.
     */
    data: XOR<BidangKeahlianUpdateManyMutationInput, BidangKeahlianUncheckedUpdateManyInput>
    /**
     * Filter which BidangKeahlians to update
     */
    where?: BidangKeahlianWhereInput
  }


  /**
   * BidangKeahlian upsert
   */
  export type BidangKeahlianUpsertArgs = {
    /**
     * Select specific fields to fetch from the BidangKeahlian
     */
    select?: BidangKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BidangKeahlianInclude | null
    /**
     * The filter to search for the BidangKeahlian to update in case it exists.
     */
    where: BidangKeahlianWhereUniqueInput
    /**
     * In case the BidangKeahlian found by the `where` argument doesn't exist, create a new BidangKeahlian with this data.
     */
    create: XOR<BidangKeahlianCreateInput, BidangKeahlianUncheckedCreateInput>
    /**
     * In case the BidangKeahlian was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BidangKeahlianUpdateInput, BidangKeahlianUncheckedUpdateInput>
  }


  /**
   * BidangKeahlian delete
   */
  export type BidangKeahlianDeleteArgs = {
    /**
     * Select specific fields to fetch from the BidangKeahlian
     */
    select?: BidangKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BidangKeahlianInclude | null
    /**
     * Filter which BidangKeahlian to delete.
     */
    where: BidangKeahlianWhereUniqueInput
  }


  /**
   * BidangKeahlian deleteMany
   */
  export type BidangKeahlianDeleteManyArgs = {
    /**
     * Filter which BidangKeahlians to delete
     */
    where?: BidangKeahlianWhereInput
  }


  /**
   * BidangKeahlian findRaw
   */
  export type BidangKeahlianFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * BidangKeahlian aggregateRaw
   */
  export type BidangKeahlianAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * BidangKeahlian.program
   */
  export type BidangKeahlian$programArgs = {
    /**
     * Select specific fields to fetch from the ProgramKeahlian
     */
    select?: ProgramKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramKeahlianInclude | null
    where?: ProgramKeahlianWhereInput
    orderBy?: Enumerable<ProgramKeahlianOrderByWithRelationInput>
    cursor?: ProgramKeahlianWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProgramKeahlianScalarFieldEnum>
  }


  /**
   * BidangKeahlian.tracker
   */
  export type BidangKeahlian$trackerArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    where?: TrackerWhereInput
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    cursor?: TrackerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TrackerScalarFieldEnum>
  }


  /**
   * BidangKeahlian without action
   */
  export type BidangKeahlianArgs = {
    /**
     * Select specific fields to fetch from the BidangKeahlian
     */
    select?: BidangKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BidangKeahlianInclude | null
  }



  /**
   * Model ProgramKeahlian
   */


  export type AggregateProgramKeahlian = {
    _count: ProgramKeahlianCountAggregateOutputType | null
    _min: ProgramKeahlianMinAggregateOutputType | null
    _max: ProgramKeahlianMaxAggregateOutputType | null
  }

  export type ProgramKeahlianMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    bidangId: string | null
    disable: boolean | null
  }

  export type ProgramKeahlianMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    bidangId: string | null
    disable: boolean | null
  }

  export type ProgramKeahlianCountAggregateOutputType = {
    id: number
    code: number
    name: number
    bidangId: number
    disable: number
    _all: number
  }


  export type ProgramKeahlianMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    bidangId?: true
    disable?: true
  }

  export type ProgramKeahlianMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    bidangId?: true
    disable?: true
  }

  export type ProgramKeahlianCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    bidangId?: true
    disable?: true
    _all?: true
  }

  export type ProgramKeahlianAggregateArgs = {
    /**
     * Filter which ProgramKeahlian to aggregate.
     */
    where?: ProgramKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramKeahlians to fetch.
     */
    orderBy?: Enumerable<ProgramKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramKeahlians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgramKeahlians
    **/
    _count?: true | ProgramKeahlianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramKeahlianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramKeahlianMaxAggregateInputType
  }

  export type GetProgramKeahlianAggregateType<T extends ProgramKeahlianAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramKeahlian]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramKeahlian[P]>
      : GetScalarType<T[P], AggregateProgramKeahlian[P]>
  }




  export type ProgramKeahlianGroupByArgs = {
    where?: ProgramKeahlianWhereInput
    orderBy?: Enumerable<ProgramKeahlianOrderByWithAggregationInput>
    by: ProgramKeahlianScalarFieldEnum[]
    having?: ProgramKeahlianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramKeahlianCountAggregateInputType | true
    _min?: ProgramKeahlianMinAggregateInputType
    _max?: ProgramKeahlianMaxAggregateInputType
  }


  export type ProgramKeahlianGroupByOutputType = {
    id: string
    code: string
    name: string
    bidangId: string
    disable: boolean
    _count: ProgramKeahlianCountAggregateOutputType | null
    _min: ProgramKeahlianMinAggregateOutputType | null
    _max: ProgramKeahlianMaxAggregateOutputType | null
  }

  type GetProgramKeahlianGroupByPayload<T extends ProgramKeahlianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProgramKeahlianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramKeahlianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramKeahlianGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramKeahlianGroupByOutputType[P]>
        }
      >
    >


  export type ProgramKeahlianSelect = {
    id?: boolean
    code?: boolean
    name?: boolean
    bidangId?: boolean
    disable?: boolean
    bidang?: boolean | BidangKeahlianArgs
    konsentrasi?: boolean | ProgramKeahlian$konsentrasiArgs
    tracker?: boolean | ProgramKeahlian$trackerArgs
    mapel?: boolean | ProgramKeahlian$mapelArgs
    _count?: boolean | ProgramKeahlianCountOutputTypeArgs
  }


  export type ProgramKeahlianInclude = {
    bidang?: boolean | BidangKeahlianArgs
    konsentrasi?: boolean | ProgramKeahlian$konsentrasiArgs
    tracker?: boolean | ProgramKeahlian$trackerArgs
    mapel?: boolean | ProgramKeahlian$mapelArgs
    _count?: boolean | ProgramKeahlianCountOutputTypeArgs
  }

  export type ProgramKeahlianGetPayload<S extends boolean | null | undefined | ProgramKeahlianArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProgramKeahlian :
    S extends undefined ? never :
    S extends { include: any } & (ProgramKeahlianArgs | ProgramKeahlianFindManyArgs)
    ? ProgramKeahlian  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'bidang' ? BidangKeahlianGetPayload<S['include'][P]> :
        P extends 'konsentrasi' ? Array < KonsentrasiKeahlianGetPayload<S['include'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['include'][P]>>  :
        P extends 'mapel' ? Array < MataPelajaranGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProgramKeahlianCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProgramKeahlianArgs | ProgramKeahlianFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'bidang' ? BidangKeahlianGetPayload<S['select'][P]> :
        P extends 'konsentrasi' ? Array < KonsentrasiKeahlianGetPayload<S['select'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['select'][P]>>  :
        P extends 'mapel' ? Array < MataPelajaranGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProgramKeahlianCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ProgramKeahlian ? ProgramKeahlian[P] : never
  } 
      : ProgramKeahlian


  type ProgramKeahlianCountArgs = 
    Omit<ProgramKeahlianFindManyArgs, 'select' | 'include'> & {
      select?: ProgramKeahlianCountAggregateInputType | true
    }

  export interface ProgramKeahlianDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ProgramKeahlian that matches the filter.
     * @param {ProgramKeahlianFindUniqueArgs} args - Arguments to find a ProgramKeahlian
     * @example
     * // Get one ProgramKeahlian
     * const programKeahlian = await prisma.programKeahlian.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProgramKeahlianFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProgramKeahlianFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProgramKeahlian'> extends True ? Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T>> : Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T> | null, null>

    /**
     * Find one ProgramKeahlian that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProgramKeahlianFindUniqueOrThrowArgs} args - Arguments to find a ProgramKeahlian
     * @example
     * // Get one ProgramKeahlian
     * const programKeahlian = await prisma.programKeahlian.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProgramKeahlianFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProgramKeahlianFindUniqueOrThrowArgs>
    ): Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T>>

    /**
     * Find the first ProgramKeahlian that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramKeahlianFindFirstArgs} args - Arguments to find a ProgramKeahlian
     * @example
     * // Get one ProgramKeahlian
     * const programKeahlian = await prisma.programKeahlian.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProgramKeahlianFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProgramKeahlianFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProgramKeahlian'> extends True ? Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T>> : Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T> | null, null>

    /**
     * Find the first ProgramKeahlian that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramKeahlianFindFirstOrThrowArgs} args - Arguments to find a ProgramKeahlian
     * @example
     * // Get one ProgramKeahlian
     * const programKeahlian = await prisma.programKeahlian.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProgramKeahlianFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProgramKeahlianFindFirstOrThrowArgs>
    ): Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T>>

    /**
     * Find zero or more ProgramKeahlians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramKeahlianFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgramKeahlians
     * const programKeahlians = await prisma.programKeahlian.findMany()
     * 
     * // Get first 10 ProgramKeahlians
     * const programKeahlians = await prisma.programKeahlian.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programKeahlianWithIdOnly = await prisma.programKeahlian.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProgramKeahlianFindManyArgs>(
      args?: SelectSubset<T, ProgramKeahlianFindManyArgs>
    ): Prisma.PrismaPromise<Array<ProgramKeahlianGetPayload<T>>>

    /**
     * Create a ProgramKeahlian.
     * @param {ProgramKeahlianCreateArgs} args - Arguments to create a ProgramKeahlian.
     * @example
     * // Create one ProgramKeahlian
     * const ProgramKeahlian = await prisma.programKeahlian.create({
     *   data: {
     *     // ... data to create a ProgramKeahlian
     *   }
     * })
     * 
    **/
    create<T extends ProgramKeahlianCreateArgs>(
      args: SelectSubset<T, ProgramKeahlianCreateArgs>
    ): Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T>>

    /**
     * Create many ProgramKeahlians.
     *     @param {ProgramKeahlianCreateManyArgs} args - Arguments to create many ProgramKeahlians.
     *     @example
     *     // Create many ProgramKeahlians
     *     const programKeahlian = await prisma.programKeahlian.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProgramKeahlianCreateManyArgs>(
      args?: SelectSubset<T, ProgramKeahlianCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProgramKeahlian.
     * @param {ProgramKeahlianDeleteArgs} args - Arguments to delete one ProgramKeahlian.
     * @example
     * // Delete one ProgramKeahlian
     * const ProgramKeahlian = await prisma.programKeahlian.delete({
     *   where: {
     *     // ... filter to delete one ProgramKeahlian
     *   }
     * })
     * 
    **/
    delete<T extends ProgramKeahlianDeleteArgs>(
      args: SelectSubset<T, ProgramKeahlianDeleteArgs>
    ): Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T>>

    /**
     * Update one ProgramKeahlian.
     * @param {ProgramKeahlianUpdateArgs} args - Arguments to update one ProgramKeahlian.
     * @example
     * // Update one ProgramKeahlian
     * const programKeahlian = await prisma.programKeahlian.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProgramKeahlianUpdateArgs>(
      args: SelectSubset<T, ProgramKeahlianUpdateArgs>
    ): Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T>>

    /**
     * Delete zero or more ProgramKeahlians.
     * @param {ProgramKeahlianDeleteManyArgs} args - Arguments to filter ProgramKeahlians to delete.
     * @example
     * // Delete a few ProgramKeahlians
     * const { count } = await prisma.programKeahlian.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProgramKeahlianDeleteManyArgs>(
      args?: SelectSubset<T, ProgramKeahlianDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramKeahlians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramKeahlianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgramKeahlians
     * const programKeahlian = await prisma.programKeahlian.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProgramKeahlianUpdateManyArgs>(
      args: SelectSubset<T, ProgramKeahlianUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProgramKeahlian.
     * @param {ProgramKeahlianUpsertArgs} args - Arguments to update or create a ProgramKeahlian.
     * @example
     * // Update or create a ProgramKeahlian
     * const programKeahlian = await prisma.programKeahlian.upsert({
     *   create: {
     *     // ... data to create a ProgramKeahlian
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgramKeahlian we want to update
     *   }
     * })
    **/
    upsert<T extends ProgramKeahlianUpsertArgs>(
      args: SelectSubset<T, ProgramKeahlianUpsertArgs>
    ): Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T>>

    /**
     * Find zero or more ProgramKeahlians that matches the filter.
     * @param {ProgramKeahlianFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const programKeahlian = await prisma.programKeahlian.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ProgramKeahlianFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ProgramKeahlian.
     * @param {ProgramKeahlianAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const programKeahlian = await prisma.programKeahlian.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ProgramKeahlianAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of ProgramKeahlians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramKeahlianCountArgs} args - Arguments to filter ProgramKeahlians to count.
     * @example
     * // Count the number of ProgramKeahlians
     * const count = await prisma.programKeahlian.count({
     *   where: {
     *     // ... the filter for the ProgramKeahlians we want to count
     *   }
     * })
    **/
    count<T extends ProgramKeahlianCountArgs>(
      args?: Subset<T, ProgramKeahlianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramKeahlianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgramKeahlian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramKeahlianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramKeahlianAggregateArgs>(args: Subset<T, ProgramKeahlianAggregateArgs>): Prisma.PrismaPromise<GetProgramKeahlianAggregateType<T>>

    /**
     * Group by ProgramKeahlian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramKeahlianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramKeahlianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramKeahlianGroupByArgs['orderBy'] }
        : { orderBy?: ProgramKeahlianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramKeahlianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramKeahlianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgramKeahlian.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProgramKeahlianClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    bidang<T extends BidangKeahlianArgs= {}>(args?: Subset<T, BidangKeahlianArgs>): Prisma__BidangKeahlianClient<BidangKeahlianGetPayload<T> | Null>;

    konsentrasi<T extends ProgramKeahlian$konsentrasiArgs= {}>(args?: Subset<T, ProgramKeahlian$konsentrasiArgs>): Prisma.PrismaPromise<Array<KonsentrasiKeahlianGetPayload<T>>| Null>;

    tracker<T extends ProgramKeahlian$trackerArgs= {}>(args?: Subset<T, ProgramKeahlian$trackerArgs>): Prisma.PrismaPromise<Array<TrackerGetPayload<T>>| Null>;

    mapel<T extends ProgramKeahlian$mapelArgs= {}>(args?: Subset<T, ProgramKeahlian$mapelArgs>): Prisma.PrismaPromise<Array<MataPelajaranGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProgramKeahlian base type for findUnique actions
   */
  export type ProgramKeahlianFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ProgramKeahlian
     */
    select?: ProgramKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramKeahlianInclude | null
    /**
     * Filter, which ProgramKeahlian to fetch.
     */
    where: ProgramKeahlianWhereUniqueInput
  }

  /**
   * ProgramKeahlian findUnique
   */
  export interface ProgramKeahlianFindUniqueArgs extends ProgramKeahlianFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProgramKeahlian findUniqueOrThrow
   */
  export type ProgramKeahlianFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProgramKeahlian
     */
    select?: ProgramKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramKeahlianInclude | null
    /**
     * Filter, which ProgramKeahlian to fetch.
     */
    where: ProgramKeahlianWhereUniqueInput
  }


  /**
   * ProgramKeahlian base type for findFirst actions
   */
  export type ProgramKeahlianFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ProgramKeahlian
     */
    select?: ProgramKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramKeahlianInclude | null
    /**
     * Filter, which ProgramKeahlian to fetch.
     */
    where?: ProgramKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramKeahlians to fetch.
     */
    orderBy?: Enumerable<ProgramKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramKeahlians.
     */
    cursor?: ProgramKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramKeahlians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramKeahlians.
     */
    distinct?: Enumerable<ProgramKeahlianScalarFieldEnum>
  }

  /**
   * ProgramKeahlian findFirst
   */
  export interface ProgramKeahlianFindFirstArgs extends ProgramKeahlianFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProgramKeahlian findFirstOrThrow
   */
  export type ProgramKeahlianFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ProgramKeahlian
     */
    select?: ProgramKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramKeahlianInclude | null
    /**
     * Filter, which ProgramKeahlian to fetch.
     */
    where?: ProgramKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramKeahlians to fetch.
     */
    orderBy?: Enumerable<ProgramKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramKeahlians.
     */
    cursor?: ProgramKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramKeahlians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramKeahlians.
     */
    distinct?: Enumerable<ProgramKeahlianScalarFieldEnum>
  }


  /**
   * ProgramKeahlian findMany
   */
  export type ProgramKeahlianFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProgramKeahlian
     */
    select?: ProgramKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramKeahlianInclude | null
    /**
     * Filter, which ProgramKeahlians to fetch.
     */
    where?: ProgramKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramKeahlians to fetch.
     */
    orderBy?: Enumerable<ProgramKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgramKeahlians.
     */
    cursor?: ProgramKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramKeahlians.
     */
    skip?: number
    distinct?: Enumerable<ProgramKeahlianScalarFieldEnum>
  }


  /**
   * ProgramKeahlian create
   */
  export type ProgramKeahlianCreateArgs = {
    /**
     * Select specific fields to fetch from the ProgramKeahlian
     */
    select?: ProgramKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramKeahlianInclude | null
    /**
     * The data needed to create a ProgramKeahlian.
     */
    data: XOR<ProgramKeahlianCreateInput, ProgramKeahlianUncheckedCreateInput>
  }


  /**
   * ProgramKeahlian createMany
   */
  export type ProgramKeahlianCreateManyArgs = {
    /**
     * The data used to create many ProgramKeahlians.
     */
    data: Enumerable<ProgramKeahlianCreateManyInput>
  }


  /**
   * ProgramKeahlian update
   */
  export type ProgramKeahlianUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProgramKeahlian
     */
    select?: ProgramKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramKeahlianInclude | null
    /**
     * The data needed to update a ProgramKeahlian.
     */
    data: XOR<ProgramKeahlianUpdateInput, ProgramKeahlianUncheckedUpdateInput>
    /**
     * Choose, which ProgramKeahlian to update.
     */
    where: ProgramKeahlianWhereUniqueInput
  }


  /**
   * ProgramKeahlian updateMany
   */
  export type ProgramKeahlianUpdateManyArgs = {
    /**
     * The data used to update ProgramKeahlians.
     */
    data: XOR<ProgramKeahlianUpdateManyMutationInput, ProgramKeahlianUncheckedUpdateManyInput>
    /**
     * Filter which ProgramKeahlians to update
     */
    where?: ProgramKeahlianWhereInput
  }


  /**
   * ProgramKeahlian upsert
   */
  export type ProgramKeahlianUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProgramKeahlian
     */
    select?: ProgramKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramKeahlianInclude | null
    /**
     * The filter to search for the ProgramKeahlian to update in case it exists.
     */
    where: ProgramKeahlianWhereUniqueInput
    /**
     * In case the ProgramKeahlian found by the `where` argument doesn't exist, create a new ProgramKeahlian with this data.
     */
    create: XOR<ProgramKeahlianCreateInput, ProgramKeahlianUncheckedCreateInput>
    /**
     * In case the ProgramKeahlian was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramKeahlianUpdateInput, ProgramKeahlianUncheckedUpdateInput>
  }


  /**
   * ProgramKeahlian delete
   */
  export type ProgramKeahlianDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProgramKeahlian
     */
    select?: ProgramKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramKeahlianInclude | null
    /**
     * Filter which ProgramKeahlian to delete.
     */
    where: ProgramKeahlianWhereUniqueInput
  }


  /**
   * ProgramKeahlian deleteMany
   */
  export type ProgramKeahlianDeleteManyArgs = {
    /**
     * Filter which ProgramKeahlians to delete
     */
    where?: ProgramKeahlianWhereInput
  }


  /**
   * ProgramKeahlian findRaw
   */
  export type ProgramKeahlianFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * ProgramKeahlian aggregateRaw
   */
  export type ProgramKeahlianAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * ProgramKeahlian.konsentrasi
   */
  export type ProgramKeahlian$konsentrasiArgs = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
    where?: KonsentrasiKeahlianWhereInput
    orderBy?: Enumerable<KonsentrasiKeahlianOrderByWithRelationInput>
    cursor?: KonsentrasiKeahlianWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<KonsentrasiKeahlianScalarFieldEnum>
  }


  /**
   * ProgramKeahlian.tracker
   */
  export type ProgramKeahlian$trackerArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    where?: TrackerWhereInput
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    cursor?: TrackerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TrackerScalarFieldEnum>
  }


  /**
   * ProgramKeahlian.mapel
   */
  export type ProgramKeahlian$mapelArgs = {
    /**
     * Select specific fields to fetch from the MataPelajaran
     */
    select?: MataPelajaranSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MataPelajaranInclude | null
    where?: MataPelajaranWhereInput
    orderBy?: Enumerable<MataPelajaranOrderByWithRelationInput>
    cursor?: MataPelajaranWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MataPelajaranScalarFieldEnum>
  }


  /**
   * ProgramKeahlian without action
   */
  export type ProgramKeahlianArgs = {
    /**
     * Select specific fields to fetch from the ProgramKeahlian
     */
    select?: ProgramKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramKeahlianInclude | null
  }



  /**
   * Model KonsentrasiKeahlian
   */


  export type AggregateKonsentrasiKeahlian = {
    _count: KonsentrasiKeahlianCountAggregateOutputType | null
    _avg: KonsentrasiKeahlianAvgAggregateOutputType | null
    _sum: KonsentrasiKeahlianSumAggregateOutputType | null
    _min: KonsentrasiKeahlianMinAggregateOutputType | null
    _max: KonsentrasiKeahlianMaxAggregateOutputType | null
  }

  export type KonsentrasiKeahlianAvgAggregateOutputType = {
    tahun: number | null
  }

  export type KonsentrasiKeahlianSumAggregateOutputType = {
    tahun: number | null
  }

  export type KonsentrasiKeahlianMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    programId: string | null
    tahun: number | null
    disable: boolean | null
  }

  export type KonsentrasiKeahlianMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    programId: string | null
    tahun: number | null
    disable: boolean | null
  }

  export type KonsentrasiKeahlianCountAggregateOutputType = {
    id: number
    code: number
    name: number
    programId: number
    tahun: number
    instansiIds: number
    disable: number
    _all: number
  }


  export type KonsentrasiKeahlianAvgAggregateInputType = {
    tahun?: true
  }

  export type KonsentrasiKeahlianSumAggregateInputType = {
    tahun?: true
  }

  export type KonsentrasiKeahlianMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    programId?: true
    tahun?: true
    disable?: true
  }

  export type KonsentrasiKeahlianMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    programId?: true
    tahun?: true
    disable?: true
  }

  export type KonsentrasiKeahlianCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    programId?: true
    tahun?: true
    instansiIds?: true
    disable?: true
    _all?: true
  }

  export type KonsentrasiKeahlianAggregateArgs = {
    /**
     * Filter which KonsentrasiKeahlian to aggregate.
     */
    where?: KonsentrasiKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KonsentrasiKeahlians to fetch.
     */
    orderBy?: Enumerable<KonsentrasiKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KonsentrasiKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KonsentrasiKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KonsentrasiKeahlians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KonsentrasiKeahlians
    **/
    _count?: true | KonsentrasiKeahlianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KonsentrasiKeahlianAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KonsentrasiKeahlianSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KonsentrasiKeahlianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KonsentrasiKeahlianMaxAggregateInputType
  }

  export type GetKonsentrasiKeahlianAggregateType<T extends KonsentrasiKeahlianAggregateArgs> = {
        [P in keyof T & keyof AggregateKonsentrasiKeahlian]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKonsentrasiKeahlian[P]>
      : GetScalarType<T[P], AggregateKonsentrasiKeahlian[P]>
  }




  export type KonsentrasiKeahlianGroupByArgs = {
    where?: KonsentrasiKeahlianWhereInput
    orderBy?: Enumerable<KonsentrasiKeahlianOrderByWithAggregationInput>
    by: KonsentrasiKeahlianScalarFieldEnum[]
    having?: KonsentrasiKeahlianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KonsentrasiKeahlianCountAggregateInputType | true
    _avg?: KonsentrasiKeahlianAvgAggregateInputType
    _sum?: KonsentrasiKeahlianSumAggregateInputType
    _min?: KonsentrasiKeahlianMinAggregateInputType
    _max?: KonsentrasiKeahlianMaxAggregateInputType
  }


  export type KonsentrasiKeahlianGroupByOutputType = {
    id: string
    code: string
    name: string
    programId: string
    tahun: number
    instansiIds: string[]
    disable: boolean
    _count: KonsentrasiKeahlianCountAggregateOutputType | null
    _avg: KonsentrasiKeahlianAvgAggregateOutputType | null
    _sum: KonsentrasiKeahlianSumAggregateOutputType | null
    _min: KonsentrasiKeahlianMinAggregateOutputType | null
    _max: KonsentrasiKeahlianMaxAggregateOutputType | null
  }

  type GetKonsentrasiKeahlianGroupByPayload<T extends KonsentrasiKeahlianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<KonsentrasiKeahlianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KonsentrasiKeahlianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KonsentrasiKeahlianGroupByOutputType[P]>
            : GetScalarType<T[P], KonsentrasiKeahlianGroupByOutputType[P]>
        }
      >
    >


  export type KonsentrasiKeahlianSelect = {
    id?: boolean
    code?: boolean
    name?: boolean
    programId?: boolean
    tahun?: boolean
    instansiIds?: boolean
    disable?: boolean
    program?: boolean | ProgramKeahlianArgs
    student?: boolean | KonsentrasiKeahlian$studentArgs
    instansi?: boolean | KonsentrasiKeahlian$instansiArgs
    classRoom?: boolean | KonsentrasiKeahlian$classRoomArgs
    tracker?: boolean | KonsentrasiKeahlian$trackerArgs
    mapel?: boolean | KonsentrasiKeahlian$mapelArgs
    dudi?: boolean | KonsentrasiKeahlian$dudiArgs
    kkni?: boolean | KonsentrasiKeahlian$kkniArgs
    _count?: boolean | KonsentrasiKeahlianCountOutputTypeArgs
  }


  export type KonsentrasiKeahlianInclude = {
    program?: boolean | ProgramKeahlianArgs
    student?: boolean | KonsentrasiKeahlian$studentArgs
    instansi?: boolean | KonsentrasiKeahlian$instansiArgs
    classRoom?: boolean | KonsentrasiKeahlian$classRoomArgs
    tracker?: boolean | KonsentrasiKeahlian$trackerArgs
    mapel?: boolean | KonsentrasiKeahlian$mapelArgs
    dudi?: boolean | KonsentrasiKeahlian$dudiArgs
    kkni?: boolean | KonsentrasiKeahlian$kkniArgs
    _count?: boolean | KonsentrasiKeahlianCountOutputTypeArgs
  }

  export type KonsentrasiKeahlianGetPayload<S extends boolean | null | undefined | KonsentrasiKeahlianArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? KonsentrasiKeahlian :
    S extends undefined ? never :
    S extends { include: any } & (KonsentrasiKeahlianArgs | KonsentrasiKeahlianFindManyArgs)
    ? KonsentrasiKeahlian  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'program' ? ProgramKeahlianGetPayload<S['include'][P]> :
        P extends 'student' ? Array < StudentGetPayload<S['include'][P]>>  :
        P extends 'instansi' ? Array < InstansiGetPayload<S['include'][P]>>  :
        P extends 'classRoom' ? Array < ClassRoomGetPayload<S['include'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['include'][P]>>  :
        P extends 'mapel' ? Array < MataPelajaranGetPayload<S['include'][P]>>  :
        P extends 'dudi' ? Array < DudiGetPayload<S['include'][P]>>  :
        P extends 'kkni' ? Array < KkniGetPayload<S['include'][P]>>  :
        P extends '_count' ? KonsentrasiKeahlianCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (KonsentrasiKeahlianArgs | KonsentrasiKeahlianFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'program' ? ProgramKeahlianGetPayload<S['select'][P]> :
        P extends 'student' ? Array < StudentGetPayload<S['select'][P]>>  :
        P extends 'instansi' ? Array < InstansiGetPayload<S['select'][P]>>  :
        P extends 'classRoom' ? Array < ClassRoomGetPayload<S['select'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['select'][P]>>  :
        P extends 'mapel' ? Array < MataPelajaranGetPayload<S['select'][P]>>  :
        P extends 'dudi' ? Array < DudiGetPayload<S['select'][P]>>  :
        P extends 'kkni' ? Array < KkniGetPayload<S['select'][P]>>  :
        P extends '_count' ? KonsentrasiKeahlianCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof KonsentrasiKeahlian ? KonsentrasiKeahlian[P] : never
  } 
      : KonsentrasiKeahlian


  type KonsentrasiKeahlianCountArgs = 
    Omit<KonsentrasiKeahlianFindManyArgs, 'select' | 'include'> & {
      select?: KonsentrasiKeahlianCountAggregateInputType | true
    }

  export interface KonsentrasiKeahlianDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one KonsentrasiKeahlian that matches the filter.
     * @param {KonsentrasiKeahlianFindUniqueArgs} args - Arguments to find a KonsentrasiKeahlian
     * @example
     * // Get one KonsentrasiKeahlian
     * const konsentrasiKeahlian = await prisma.konsentrasiKeahlian.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends KonsentrasiKeahlianFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, KonsentrasiKeahlianFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'KonsentrasiKeahlian'> extends True ? Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T>> : Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T> | null, null>

    /**
     * Find one KonsentrasiKeahlian that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {KonsentrasiKeahlianFindUniqueOrThrowArgs} args - Arguments to find a KonsentrasiKeahlian
     * @example
     * // Get one KonsentrasiKeahlian
     * const konsentrasiKeahlian = await prisma.konsentrasiKeahlian.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends KonsentrasiKeahlianFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, KonsentrasiKeahlianFindUniqueOrThrowArgs>
    ): Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T>>

    /**
     * Find the first KonsentrasiKeahlian that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KonsentrasiKeahlianFindFirstArgs} args - Arguments to find a KonsentrasiKeahlian
     * @example
     * // Get one KonsentrasiKeahlian
     * const konsentrasiKeahlian = await prisma.konsentrasiKeahlian.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends KonsentrasiKeahlianFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, KonsentrasiKeahlianFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'KonsentrasiKeahlian'> extends True ? Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T>> : Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T> | null, null>

    /**
     * Find the first KonsentrasiKeahlian that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KonsentrasiKeahlianFindFirstOrThrowArgs} args - Arguments to find a KonsentrasiKeahlian
     * @example
     * // Get one KonsentrasiKeahlian
     * const konsentrasiKeahlian = await prisma.konsentrasiKeahlian.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends KonsentrasiKeahlianFindFirstOrThrowArgs>(
      args?: SelectSubset<T, KonsentrasiKeahlianFindFirstOrThrowArgs>
    ): Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T>>

    /**
     * Find zero or more KonsentrasiKeahlians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KonsentrasiKeahlianFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KonsentrasiKeahlians
     * const konsentrasiKeahlians = await prisma.konsentrasiKeahlian.findMany()
     * 
     * // Get first 10 KonsentrasiKeahlians
     * const konsentrasiKeahlians = await prisma.konsentrasiKeahlian.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const konsentrasiKeahlianWithIdOnly = await prisma.konsentrasiKeahlian.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends KonsentrasiKeahlianFindManyArgs>(
      args?: SelectSubset<T, KonsentrasiKeahlianFindManyArgs>
    ): Prisma.PrismaPromise<Array<KonsentrasiKeahlianGetPayload<T>>>

    /**
     * Create a KonsentrasiKeahlian.
     * @param {KonsentrasiKeahlianCreateArgs} args - Arguments to create a KonsentrasiKeahlian.
     * @example
     * // Create one KonsentrasiKeahlian
     * const KonsentrasiKeahlian = await prisma.konsentrasiKeahlian.create({
     *   data: {
     *     // ... data to create a KonsentrasiKeahlian
     *   }
     * })
     * 
    **/
    create<T extends KonsentrasiKeahlianCreateArgs>(
      args: SelectSubset<T, KonsentrasiKeahlianCreateArgs>
    ): Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T>>

    /**
     * Create many KonsentrasiKeahlians.
     *     @param {KonsentrasiKeahlianCreateManyArgs} args - Arguments to create many KonsentrasiKeahlians.
     *     @example
     *     // Create many KonsentrasiKeahlians
     *     const konsentrasiKeahlian = await prisma.konsentrasiKeahlian.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends KonsentrasiKeahlianCreateManyArgs>(
      args?: SelectSubset<T, KonsentrasiKeahlianCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KonsentrasiKeahlian.
     * @param {KonsentrasiKeahlianDeleteArgs} args - Arguments to delete one KonsentrasiKeahlian.
     * @example
     * // Delete one KonsentrasiKeahlian
     * const KonsentrasiKeahlian = await prisma.konsentrasiKeahlian.delete({
     *   where: {
     *     // ... filter to delete one KonsentrasiKeahlian
     *   }
     * })
     * 
    **/
    delete<T extends KonsentrasiKeahlianDeleteArgs>(
      args: SelectSubset<T, KonsentrasiKeahlianDeleteArgs>
    ): Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T>>

    /**
     * Update one KonsentrasiKeahlian.
     * @param {KonsentrasiKeahlianUpdateArgs} args - Arguments to update one KonsentrasiKeahlian.
     * @example
     * // Update one KonsentrasiKeahlian
     * const konsentrasiKeahlian = await prisma.konsentrasiKeahlian.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends KonsentrasiKeahlianUpdateArgs>(
      args: SelectSubset<T, KonsentrasiKeahlianUpdateArgs>
    ): Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T>>

    /**
     * Delete zero or more KonsentrasiKeahlians.
     * @param {KonsentrasiKeahlianDeleteManyArgs} args - Arguments to filter KonsentrasiKeahlians to delete.
     * @example
     * // Delete a few KonsentrasiKeahlians
     * const { count } = await prisma.konsentrasiKeahlian.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends KonsentrasiKeahlianDeleteManyArgs>(
      args?: SelectSubset<T, KonsentrasiKeahlianDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KonsentrasiKeahlians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KonsentrasiKeahlianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KonsentrasiKeahlians
     * const konsentrasiKeahlian = await prisma.konsentrasiKeahlian.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends KonsentrasiKeahlianUpdateManyArgs>(
      args: SelectSubset<T, KonsentrasiKeahlianUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KonsentrasiKeahlian.
     * @param {KonsentrasiKeahlianUpsertArgs} args - Arguments to update or create a KonsentrasiKeahlian.
     * @example
     * // Update or create a KonsentrasiKeahlian
     * const konsentrasiKeahlian = await prisma.konsentrasiKeahlian.upsert({
     *   create: {
     *     // ... data to create a KonsentrasiKeahlian
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KonsentrasiKeahlian we want to update
     *   }
     * })
    **/
    upsert<T extends KonsentrasiKeahlianUpsertArgs>(
      args: SelectSubset<T, KonsentrasiKeahlianUpsertArgs>
    ): Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T>>

    /**
     * Find zero or more KonsentrasiKeahlians that matches the filter.
     * @param {KonsentrasiKeahlianFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const konsentrasiKeahlian = await prisma.konsentrasiKeahlian.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: KonsentrasiKeahlianFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a KonsentrasiKeahlian.
     * @param {KonsentrasiKeahlianAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const konsentrasiKeahlian = await prisma.konsentrasiKeahlian.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: KonsentrasiKeahlianAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of KonsentrasiKeahlians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KonsentrasiKeahlianCountArgs} args - Arguments to filter KonsentrasiKeahlians to count.
     * @example
     * // Count the number of KonsentrasiKeahlians
     * const count = await prisma.konsentrasiKeahlian.count({
     *   where: {
     *     // ... the filter for the KonsentrasiKeahlians we want to count
     *   }
     * })
    **/
    count<T extends KonsentrasiKeahlianCountArgs>(
      args?: Subset<T, KonsentrasiKeahlianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KonsentrasiKeahlianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KonsentrasiKeahlian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KonsentrasiKeahlianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KonsentrasiKeahlianAggregateArgs>(args: Subset<T, KonsentrasiKeahlianAggregateArgs>): Prisma.PrismaPromise<GetKonsentrasiKeahlianAggregateType<T>>

    /**
     * Group by KonsentrasiKeahlian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KonsentrasiKeahlianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KonsentrasiKeahlianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KonsentrasiKeahlianGroupByArgs['orderBy'] }
        : { orderBy?: KonsentrasiKeahlianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KonsentrasiKeahlianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKonsentrasiKeahlianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for KonsentrasiKeahlian.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__KonsentrasiKeahlianClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    program<T extends ProgramKeahlianArgs= {}>(args?: Subset<T, ProgramKeahlianArgs>): Prisma__ProgramKeahlianClient<ProgramKeahlianGetPayload<T> | Null>;

    student<T extends KonsentrasiKeahlian$studentArgs= {}>(args?: Subset<T, KonsentrasiKeahlian$studentArgs>): Prisma.PrismaPromise<Array<StudentGetPayload<T>>| Null>;

    instansi<T extends KonsentrasiKeahlian$instansiArgs= {}>(args?: Subset<T, KonsentrasiKeahlian$instansiArgs>): Prisma.PrismaPromise<Array<InstansiGetPayload<T>>| Null>;

    classRoom<T extends KonsentrasiKeahlian$classRoomArgs= {}>(args?: Subset<T, KonsentrasiKeahlian$classRoomArgs>): Prisma.PrismaPromise<Array<ClassRoomGetPayload<T>>| Null>;

    tracker<T extends KonsentrasiKeahlian$trackerArgs= {}>(args?: Subset<T, KonsentrasiKeahlian$trackerArgs>): Prisma.PrismaPromise<Array<TrackerGetPayload<T>>| Null>;

    mapel<T extends KonsentrasiKeahlian$mapelArgs= {}>(args?: Subset<T, KonsentrasiKeahlian$mapelArgs>): Prisma.PrismaPromise<Array<MataPelajaranGetPayload<T>>| Null>;

    dudi<T extends KonsentrasiKeahlian$dudiArgs= {}>(args?: Subset<T, KonsentrasiKeahlian$dudiArgs>): Prisma.PrismaPromise<Array<DudiGetPayload<T>>| Null>;

    kkni<T extends KonsentrasiKeahlian$kkniArgs= {}>(args?: Subset<T, KonsentrasiKeahlian$kkniArgs>): Prisma.PrismaPromise<Array<KkniGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * KonsentrasiKeahlian base type for findUnique actions
   */
  export type KonsentrasiKeahlianFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
    /**
     * Filter, which KonsentrasiKeahlian to fetch.
     */
    where: KonsentrasiKeahlianWhereUniqueInput
  }

  /**
   * KonsentrasiKeahlian findUnique
   */
  export interface KonsentrasiKeahlianFindUniqueArgs extends KonsentrasiKeahlianFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * KonsentrasiKeahlian findUniqueOrThrow
   */
  export type KonsentrasiKeahlianFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
    /**
     * Filter, which KonsentrasiKeahlian to fetch.
     */
    where: KonsentrasiKeahlianWhereUniqueInput
  }


  /**
   * KonsentrasiKeahlian base type for findFirst actions
   */
  export type KonsentrasiKeahlianFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
    /**
     * Filter, which KonsentrasiKeahlian to fetch.
     */
    where?: KonsentrasiKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KonsentrasiKeahlians to fetch.
     */
    orderBy?: Enumerable<KonsentrasiKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KonsentrasiKeahlians.
     */
    cursor?: KonsentrasiKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KonsentrasiKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KonsentrasiKeahlians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KonsentrasiKeahlians.
     */
    distinct?: Enumerable<KonsentrasiKeahlianScalarFieldEnum>
  }

  /**
   * KonsentrasiKeahlian findFirst
   */
  export interface KonsentrasiKeahlianFindFirstArgs extends KonsentrasiKeahlianFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * KonsentrasiKeahlian findFirstOrThrow
   */
  export type KonsentrasiKeahlianFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
    /**
     * Filter, which KonsentrasiKeahlian to fetch.
     */
    where?: KonsentrasiKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KonsentrasiKeahlians to fetch.
     */
    orderBy?: Enumerable<KonsentrasiKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KonsentrasiKeahlians.
     */
    cursor?: KonsentrasiKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KonsentrasiKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KonsentrasiKeahlians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KonsentrasiKeahlians.
     */
    distinct?: Enumerable<KonsentrasiKeahlianScalarFieldEnum>
  }


  /**
   * KonsentrasiKeahlian findMany
   */
  export type KonsentrasiKeahlianFindManyArgs = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
    /**
     * Filter, which KonsentrasiKeahlians to fetch.
     */
    where?: KonsentrasiKeahlianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KonsentrasiKeahlians to fetch.
     */
    orderBy?: Enumerable<KonsentrasiKeahlianOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KonsentrasiKeahlians.
     */
    cursor?: KonsentrasiKeahlianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KonsentrasiKeahlians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KonsentrasiKeahlians.
     */
    skip?: number
    distinct?: Enumerable<KonsentrasiKeahlianScalarFieldEnum>
  }


  /**
   * KonsentrasiKeahlian create
   */
  export type KonsentrasiKeahlianCreateArgs = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
    /**
     * The data needed to create a KonsentrasiKeahlian.
     */
    data: XOR<KonsentrasiKeahlianCreateInput, KonsentrasiKeahlianUncheckedCreateInput>
  }


  /**
   * KonsentrasiKeahlian createMany
   */
  export type KonsentrasiKeahlianCreateManyArgs = {
    /**
     * The data used to create many KonsentrasiKeahlians.
     */
    data: Enumerable<KonsentrasiKeahlianCreateManyInput>
  }


  /**
   * KonsentrasiKeahlian update
   */
  export type KonsentrasiKeahlianUpdateArgs = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
    /**
     * The data needed to update a KonsentrasiKeahlian.
     */
    data: XOR<KonsentrasiKeahlianUpdateInput, KonsentrasiKeahlianUncheckedUpdateInput>
    /**
     * Choose, which KonsentrasiKeahlian to update.
     */
    where: KonsentrasiKeahlianWhereUniqueInput
  }


  /**
   * KonsentrasiKeahlian updateMany
   */
  export type KonsentrasiKeahlianUpdateManyArgs = {
    /**
     * The data used to update KonsentrasiKeahlians.
     */
    data: XOR<KonsentrasiKeahlianUpdateManyMutationInput, KonsentrasiKeahlianUncheckedUpdateManyInput>
    /**
     * Filter which KonsentrasiKeahlians to update
     */
    where?: KonsentrasiKeahlianWhereInput
  }


  /**
   * KonsentrasiKeahlian upsert
   */
  export type KonsentrasiKeahlianUpsertArgs = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
    /**
     * The filter to search for the KonsentrasiKeahlian to update in case it exists.
     */
    where: KonsentrasiKeahlianWhereUniqueInput
    /**
     * In case the KonsentrasiKeahlian found by the `where` argument doesn't exist, create a new KonsentrasiKeahlian with this data.
     */
    create: XOR<KonsentrasiKeahlianCreateInput, KonsentrasiKeahlianUncheckedCreateInput>
    /**
     * In case the KonsentrasiKeahlian was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KonsentrasiKeahlianUpdateInput, KonsentrasiKeahlianUncheckedUpdateInput>
  }


  /**
   * KonsentrasiKeahlian delete
   */
  export type KonsentrasiKeahlianDeleteArgs = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
    /**
     * Filter which KonsentrasiKeahlian to delete.
     */
    where: KonsentrasiKeahlianWhereUniqueInput
  }


  /**
   * KonsentrasiKeahlian deleteMany
   */
  export type KonsentrasiKeahlianDeleteManyArgs = {
    /**
     * Filter which KonsentrasiKeahlians to delete
     */
    where?: KonsentrasiKeahlianWhereInput
  }


  /**
   * KonsentrasiKeahlian findRaw
   */
  export type KonsentrasiKeahlianFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * KonsentrasiKeahlian aggregateRaw
   */
  export type KonsentrasiKeahlianAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * KonsentrasiKeahlian.student
   */
  export type KonsentrasiKeahlian$studentArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    where?: StudentWhereInput
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * KonsentrasiKeahlian.instansi
   */
  export type KonsentrasiKeahlian$instansiArgs = {
    /**
     * Select specific fields to fetch from the Instansi
     */
    select?: InstansiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstansiInclude | null
    where?: InstansiWhereInput
    orderBy?: Enumerable<InstansiOrderByWithRelationInput>
    cursor?: InstansiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InstansiScalarFieldEnum>
  }


  /**
   * KonsentrasiKeahlian.classRoom
   */
  export type KonsentrasiKeahlian$classRoomArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    where?: ClassRoomWhereInput
    orderBy?: Enumerable<ClassRoomOrderByWithRelationInput>
    cursor?: ClassRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ClassRoomScalarFieldEnum>
  }


  /**
   * KonsentrasiKeahlian.tracker
   */
  export type KonsentrasiKeahlian$trackerArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    where?: TrackerWhereInput
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    cursor?: TrackerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TrackerScalarFieldEnum>
  }


  /**
   * KonsentrasiKeahlian.mapel
   */
  export type KonsentrasiKeahlian$mapelArgs = {
    /**
     * Select specific fields to fetch from the MataPelajaran
     */
    select?: MataPelajaranSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MataPelajaranInclude | null
    where?: MataPelajaranWhereInput
    orderBy?: Enumerable<MataPelajaranOrderByWithRelationInput>
    cursor?: MataPelajaranWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MataPelajaranScalarFieldEnum>
  }


  /**
   * KonsentrasiKeahlian.dudi
   */
  export type KonsentrasiKeahlian$dudiArgs = {
    /**
     * Select specific fields to fetch from the Dudi
     */
    select?: DudiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiInclude | null
    where?: DudiWhereInput
    orderBy?: Enumerable<DudiOrderByWithRelationInput>
    cursor?: DudiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DudiScalarFieldEnum>
  }


  /**
   * KonsentrasiKeahlian.kkni
   */
  export type KonsentrasiKeahlian$kkniArgs = {
    /**
     * Select specific fields to fetch from the Kkni
     */
    select?: KkniSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KkniInclude | null
    where?: KkniWhereInput
    orderBy?: Enumerable<KkniOrderByWithRelationInput>
    cursor?: KkniWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<KkniScalarFieldEnum>
  }


  /**
   * KonsentrasiKeahlian without action
   */
  export type KonsentrasiKeahlianArgs = {
    /**
     * Select specific fields to fetch from the KonsentrasiKeahlian
     */
    select?: KonsentrasiKeahlianSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KonsentrasiKeahlianInclude | null
  }



  /**
   * Model Role
   */


  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    key: Roles | null
    instansiId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    key: Roles | null
    instansiId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    key: number
    instansiId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    key?: true
    instansiId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    key?: true
    instansiId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    key?: true
    instansiId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs = {
    where?: RoleWhereInput
    orderBy?: Enumerable<RoleOrderByWithAggregationInput>
    by: RoleScalarFieldEnum[]
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }


  export type RoleGroupByOutputType = {
    id: string
    key: Roles
    instansiId: string
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect = {
    id?: boolean
    key?: boolean
    instansiId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instansi?: boolean | InstansiArgs
    users?: boolean | Role$usersArgs
    _count?: boolean | RoleCountOutputTypeArgs
  }


  export type RoleInclude = {
    instansi?: boolean | InstansiArgs
    users?: boolean | Role$usersArgs
    _count?: boolean | RoleCountOutputTypeArgs
  }

  export type RoleGetPayload<S extends boolean | null | undefined | RoleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Role :
    S extends undefined ? never :
    S extends { include: any } & (RoleArgs | RoleFindManyArgs)
    ? Role  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'instansi' ? InstansiGetPayload<S['include'][P]> :
        P extends 'users' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends '_count' ? RoleCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RoleArgs | RoleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'instansi' ? InstansiGetPayload<S['select'][P]> :
        P extends 'users' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends '_count' ? RoleCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Role ? Role[P] : never
  } 
      : Role


  type RoleCountArgs = 
    Omit<RoleFindManyArgs, 'select' | 'include'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RoleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Role'> extends True ? Prisma__RoleClient<RoleGetPayload<T>> : Prisma__RoleClient<RoleGetPayload<T> | null, null>

    /**
     * Find one Role that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RoleFindUniqueOrThrowArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RoleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Role'> extends True ? Prisma__RoleClient<RoleGetPayload<T>> : Prisma__RoleClient<RoleGetPayload<T> | null, null>

    /**
     * Find the first Role that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RoleFindFirstOrThrowArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoleFindManyArgs>(
      args?: SelectSubset<T, RoleFindManyArgs>
    ): Prisma.PrismaPromise<Array<RoleGetPayload<T>>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
    **/
    create<T extends RoleCreateArgs>(
      args: SelectSubset<T, RoleCreateArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Create many Roles.
     *     @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const role = await prisma.role.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoleCreateManyArgs>(
      args?: SelectSubset<T, RoleCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
    **/
    delete<T extends RoleDeleteArgs>(
      args: SelectSubset<T, RoleDeleteArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoleUpdateArgs>(
      args: SelectSubset<T, RoleUpdateArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoleDeleteManyArgs>(
      args?: SelectSubset<T, RoleDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoleUpdateManyArgs>(
      args: SelectSubset<T, RoleUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
    **/
    upsert<T extends RoleUpsertArgs>(
      args: SelectSubset<T, RoleUpsertArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Find zero or more Roles that matches the filter.
     * @param {RoleFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const role = await prisma.role.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: RoleFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Role.
     * @param {RoleAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const role = await prisma.role.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: RoleAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoleClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    instansi<T extends InstansiArgs= {}>(args?: Subset<T, InstansiArgs>): Prisma__InstansiClient<InstansiGetPayload<T> | Null>;

    users<T extends Role$usersArgs= {}>(args?: Subset<T, Role$usersArgs>): Prisma.PrismaPromise<Array<UserGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Role base type for findUnique actions
   */
  export type RoleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUnique
   */
  export interface RoleFindUniqueArgs extends RoleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role base type for findFirst actions
   */
  export type RoleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: Enumerable<RoleScalarFieldEnum>
  }

  /**
   * Role findFirst
   */
  export interface RoleFindFirstArgs extends RoleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role findMany
   */
  export type RoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role create
   */
  export type RoleCreateArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }


  /**
   * Role createMany
   */
  export type RoleCreateManyArgs = {
    /**
     * The data used to create many Roles.
     */
    data: Enumerable<RoleCreateManyInput>
  }


  /**
   * Role update
   */
  export type RoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }


  /**
   * Role upsert
   */
  export type RoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }


  /**
   * Role delete
   */
  export type RoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }


  /**
   * Role findRaw
   */
  export type RoleFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Role aggregateRaw
   */
  export type RoleAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Role.users
   */
  export type Role$usersArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * Role without action
   */
  export type RoleArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    picture: string | null
    username: string | null
    active: boolean | null
    verify: boolean | null
    password: string | null
    passhash: string | null
    roleId: string | null
    disable: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    picture: string | null
    username: string | null
    active: boolean | null
    verify: boolean | null
    password: string | null
    passhash: string | null
    roleId: string | null
    disable: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    picture: number
    username: number
    active: number
    verify: number
    password: number
    passhash: number
    roleId: number
    disable: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    picture?: true
    username?: true
    active?: true
    verify?: true
    password?: true
    passhash?: true
    roleId?: true
    disable?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    picture?: true
    username?: true
    active?: true
    verify?: true
    password?: true
    passhash?: true
    roleId?: true
    disable?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    picture?: true
    username?: true
    active?: true
    verify?: true
    password?: true
    passhash?: true
    roleId?: true
    disable?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    name: string
    picture: string | null
    username: string
    active: boolean
    verify: boolean
    password: string
    passhash: string
    roleId: string | null
    disable: boolean
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    name?: boolean
    picture?: boolean
    username?: boolean
    active?: boolean
    verify?: boolean
    password?: boolean
    passhash?: boolean
    roleId?: boolean
    disable?: boolean
    google?: boolean | GoogleArgs
    role?: boolean | RoleArgs
    auth?: boolean | AuthArgs
    tracker?: boolean | User$trackerArgs
    objective?: boolean | User$objectiveArgs
    link?: boolean | User$linkArgs
    tDevice?: boolean | User$tDeviceArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    role?: boolean | RoleArgs
    auth?: boolean | AuthArgs
    tracker?: boolean | User$trackerArgs
    objective?: boolean | User$objectiveArgs
    link?: boolean | User$linkArgs
    tDevice?: boolean | User$tDeviceArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'role' ? RoleGetPayload<S['include'][P]> | null :
        P extends 'auth' ? AuthGetPayload<S['include'][P]> | null :
        P extends 'tracker' ? Array < TrackerGetPayload<S['include'][P]>>  :
        P extends 'objective' ? Array < ObjectiveGetPayload<S['include'][P]>>  :
        P extends 'link' ? Array < LinkGetPayload<S['include'][P]>>  :
        P extends 'tDevice' ? Array < TDeviceGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'google' ? GoogleGetPayload<S['select'][P]> | null :
        P extends 'role' ? RoleGetPayload<S['select'][P]> | null :
        P extends 'auth' ? AuthGetPayload<S['select'][P]> | null :
        P extends 'tracker' ? Array < TrackerGetPayload<S['select'][P]>>  :
        P extends 'objective' ? Array < ObjectiveGetPayload<S['select'][P]>>  :
        P extends 'link' ? Array < LinkGetPayload<S['select'][P]>>  :
        P extends 'tDevice' ? Array < TDeviceGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: UserFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: UserAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    google<T extends GoogleArgs= {}>(args?: Subset<T, GoogleArgs>): Prisma__GoogleClient<GoogleGetPayload<T> | Null>;

    role<T extends RoleArgs= {}>(args?: Subset<T, RoleArgs>): Prisma__RoleClient<RoleGetPayload<T> | Null>;

    auth<T extends AuthArgs= {}>(args?: Subset<T, AuthArgs>): Prisma__AuthClient<AuthGetPayload<T> | Null>;

    tracker<T extends User$trackerArgs= {}>(args?: Subset<T, User$trackerArgs>): Prisma.PrismaPromise<Array<TrackerGetPayload<T>>| Null>;

    objective<T extends User$objectiveArgs= {}>(args?: Subset<T, User$objectiveArgs>): Prisma.PrismaPromise<Array<ObjectiveGetPayload<T>>| Null>;

    link<T extends User$linkArgs= {}>(args?: Subset<T, User$linkArgs>): Prisma.PrismaPromise<Array<LinkGetPayload<T>>| Null>;

    tDevice<T extends User$tDeviceArgs= {}>(args?: Subset<T, User$tDeviceArgs>): Prisma.PrismaPromise<Array<TDeviceGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User findRaw
   */
  export type UserFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * User.tracker
   */
  export type User$trackerArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    where?: TrackerWhereInput
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    cursor?: TrackerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TrackerScalarFieldEnum>
  }


  /**
   * User.objective
   */
  export type User$objectiveArgs = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectiveInclude | null
    where?: ObjectiveWhereInput
    orderBy?: Enumerable<ObjectiveOrderByWithRelationInput>
    cursor?: ObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ObjectiveScalarFieldEnum>
  }


  /**
   * User.link
   */
  export type User$linkArgs = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
    where?: LinkWhereInput
    orderBy?: Enumerable<LinkOrderByWithRelationInput>
    cursor?: LinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LinkScalarFieldEnum>
  }


  /**
   * User.tDevice
   */
  export type User$tDeviceArgs = {
    /**
     * Select specific fields to fetch from the TDevice
     */
    select?: TDeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceInclude | null
    where?: TDeviceWhereInput
    orderBy?: Enumerable<TDeviceOrderByWithRelationInput>
    cursor?: TDeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TDeviceScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
  }



  /**
   * Model Upload
   */


  export type AggregateUpload = {
    _count: UploadCountAggregateOutputType | null
    _min: UploadMinAggregateOutputType | null
    _max: UploadMaxAggregateOutputType | null
  }

  export type UploadMinAggregateOutputType = {
    id: string | null
    type: UploadType | null
    name: string | null
    url: string | null
  }

  export type UploadMaxAggregateOutputType = {
    id: string | null
    type: UploadType | null
    name: string | null
    url: string | null
  }

  export type UploadCountAggregateOutputType = {
    id: number
    type: number
    name: number
    url: number
    _all: number
  }


  export type UploadMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    url?: true
  }

  export type UploadMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    url?: true
  }

  export type UploadCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    url?: true
    _all?: true
  }

  export type UploadAggregateArgs = {
    /**
     * Filter which Upload to aggregate.
     */
    where?: UploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Uploads to fetch.
     */
    orderBy?: Enumerable<UploadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Uploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Uploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Uploads
    **/
    _count?: true | UploadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UploadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UploadMaxAggregateInputType
  }

  export type GetUploadAggregateType<T extends UploadAggregateArgs> = {
        [P in keyof T & keyof AggregateUpload]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUpload[P]>
      : GetScalarType<T[P], AggregateUpload[P]>
  }




  export type UploadGroupByArgs = {
    where?: UploadWhereInput
    orderBy?: Enumerable<UploadOrderByWithAggregationInput>
    by: UploadScalarFieldEnum[]
    having?: UploadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UploadCountAggregateInputType | true
    _min?: UploadMinAggregateInputType
    _max?: UploadMaxAggregateInputType
  }


  export type UploadGroupByOutputType = {
    id: string
    type: UploadType
    name: string
    url: string
    _count: UploadCountAggregateOutputType | null
    _min: UploadMinAggregateOutputType | null
    _max: UploadMaxAggregateOutputType | null
  }

  type GetUploadGroupByPayload<T extends UploadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UploadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UploadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UploadGroupByOutputType[P]>
            : GetScalarType<T[P], UploadGroupByOutputType[P]>
        }
      >
    >


  export type UploadSelect = {
    id?: boolean
    type?: boolean
    name?: boolean
    url?: boolean
  }


  export type UploadGetPayload<S extends boolean | null | undefined | UploadArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Upload :
    S extends undefined ? never :
    S extends { include: any } & (UploadArgs | UploadFindManyArgs)
    ? Upload 
    : S extends { select: any } & (UploadArgs | UploadFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Upload ? Upload[P] : never
  } 
      : Upload


  type UploadCountArgs = 
    Omit<UploadFindManyArgs, 'select' | 'include'> & {
      select?: UploadCountAggregateInputType | true
    }

  export interface UploadDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Upload that matches the filter.
     * @param {UploadFindUniqueArgs} args - Arguments to find a Upload
     * @example
     * // Get one Upload
     * const upload = await prisma.upload.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UploadFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UploadFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Upload'> extends True ? Prisma__UploadClient<UploadGetPayload<T>> : Prisma__UploadClient<UploadGetPayload<T> | null, null>

    /**
     * Find one Upload that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UploadFindUniqueOrThrowArgs} args - Arguments to find a Upload
     * @example
     * // Get one Upload
     * const upload = await prisma.upload.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UploadFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UploadFindUniqueOrThrowArgs>
    ): Prisma__UploadClient<UploadGetPayload<T>>

    /**
     * Find the first Upload that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadFindFirstArgs} args - Arguments to find a Upload
     * @example
     * // Get one Upload
     * const upload = await prisma.upload.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UploadFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UploadFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Upload'> extends True ? Prisma__UploadClient<UploadGetPayload<T>> : Prisma__UploadClient<UploadGetPayload<T> | null, null>

    /**
     * Find the first Upload that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadFindFirstOrThrowArgs} args - Arguments to find a Upload
     * @example
     * // Get one Upload
     * const upload = await prisma.upload.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UploadFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UploadFindFirstOrThrowArgs>
    ): Prisma__UploadClient<UploadGetPayload<T>>

    /**
     * Find zero or more Uploads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Uploads
     * const uploads = await prisma.upload.findMany()
     * 
     * // Get first 10 Uploads
     * const uploads = await prisma.upload.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const uploadWithIdOnly = await prisma.upload.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UploadFindManyArgs>(
      args?: SelectSubset<T, UploadFindManyArgs>
    ): Prisma.PrismaPromise<Array<UploadGetPayload<T>>>

    /**
     * Create a Upload.
     * @param {UploadCreateArgs} args - Arguments to create a Upload.
     * @example
     * // Create one Upload
     * const Upload = await prisma.upload.create({
     *   data: {
     *     // ... data to create a Upload
     *   }
     * })
     * 
    **/
    create<T extends UploadCreateArgs>(
      args: SelectSubset<T, UploadCreateArgs>
    ): Prisma__UploadClient<UploadGetPayload<T>>

    /**
     * Create many Uploads.
     *     @param {UploadCreateManyArgs} args - Arguments to create many Uploads.
     *     @example
     *     // Create many Uploads
     *     const upload = await prisma.upload.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UploadCreateManyArgs>(
      args?: SelectSubset<T, UploadCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Upload.
     * @param {UploadDeleteArgs} args - Arguments to delete one Upload.
     * @example
     * // Delete one Upload
     * const Upload = await prisma.upload.delete({
     *   where: {
     *     // ... filter to delete one Upload
     *   }
     * })
     * 
    **/
    delete<T extends UploadDeleteArgs>(
      args: SelectSubset<T, UploadDeleteArgs>
    ): Prisma__UploadClient<UploadGetPayload<T>>

    /**
     * Update one Upload.
     * @param {UploadUpdateArgs} args - Arguments to update one Upload.
     * @example
     * // Update one Upload
     * const upload = await prisma.upload.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UploadUpdateArgs>(
      args: SelectSubset<T, UploadUpdateArgs>
    ): Prisma__UploadClient<UploadGetPayload<T>>

    /**
     * Delete zero or more Uploads.
     * @param {UploadDeleteManyArgs} args - Arguments to filter Uploads to delete.
     * @example
     * // Delete a few Uploads
     * const { count } = await prisma.upload.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UploadDeleteManyArgs>(
      args?: SelectSubset<T, UploadDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Uploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Uploads
     * const upload = await prisma.upload.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UploadUpdateManyArgs>(
      args: SelectSubset<T, UploadUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Upload.
     * @param {UploadUpsertArgs} args - Arguments to update or create a Upload.
     * @example
     * // Update or create a Upload
     * const upload = await prisma.upload.upsert({
     *   create: {
     *     // ... data to create a Upload
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Upload we want to update
     *   }
     * })
    **/
    upsert<T extends UploadUpsertArgs>(
      args: SelectSubset<T, UploadUpsertArgs>
    ): Prisma__UploadClient<UploadGetPayload<T>>

    /**
     * Find zero or more Uploads that matches the filter.
     * @param {UploadFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const upload = await prisma.upload.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: UploadFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Upload.
     * @param {UploadAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const upload = await prisma.upload.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: UploadAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Uploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadCountArgs} args - Arguments to filter Uploads to count.
     * @example
     * // Count the number of Uploads
     * const count = await prisma.upload.count({
     *   where: {
     *     // ... the filter for the Uploads we want to count
     *   }
     * })
    **/
    count<T extends UploadCountArgs>(
      args?: Subset<T, UploadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UploadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Upload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UploadAggregateArgs>(args: Subset<T, UploadAggregateArgs>): Prisma.PrismaPromise<GetUploadAggregateType<T>>

    /**
     * Group by Upload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UploadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UploadGroupByArgs['orderBy'] }
        : { orderBy?: UploadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UploadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUploadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Upload.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UploadClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Upload base type for findUnique actions
   */
  export type UploadFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect | null
    /**
     * Filter, which Upload to fetch.
     */
    where: UploadWhereUniqueInput
  }

  /**
   * Upload findUnique
   */
  export interface UploadFindUniqueArgs extends UploadFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Upload findUniqueOrThrow
   */
  export type UploadFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect | null
    /**
     * Filter, which Upload to fetch.
     */
    where: UploadWhereUniqueInput
  }


  /**
   * Upload base type for findFirst actions
   */
  export type UploadFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect | null
    /**
     * Filter, which Upload to fetch.
     */
    where?: UploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Uploads to fetch.
     */
    orderBy?: Enumerable<UploadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Uploads.
     */
    cursor?: UploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Uploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Uploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Uploads.
     */
    distinct?: Enumerable<UploadScalarFieldEnum>
  }

  /**
   * Upload findFirst
   */
  export interface UploadFindFirstArgs extends UploadFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Upload findFirstOrThrow
   */
  export type UploadFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect | null
    /**
     * Filter, which Upload to fetch.
     */
    where?: UploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Uploads to fetch.
     */
    orderBy?: Enumerable<UploadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Uploads.
     */
    cursor?: UploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Uploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Uploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Uploads.
     */
    distinct?: Enumerable<UploadScalarFieldEnum>
  }


  /**
   * Upload findMany
   */
  export type UploadFindManyArgs = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect | null
    /**
     * Filter, which Uploads to fetch.
     */
    where?: UploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Uploads to fetch.
     */
    orderBy?: Enumerable<UploadOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Uploads.
     */
    cursor?: UploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Uploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Uploads.
     */
    skip?: number
    distinct?: Enumerable<UploadScalarFieldEnum>
  }


  /**
   * Upload create
   */
  export type UploadCreateArgs = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect | null
    /**
     * The data needed to create a Upload.
     */
    data: XOR<UploadCreateInput, UploadUncheckedCreateInput>
  }


  /**
   * Upload createMany
   */
  export type UploadCreateManyArgs = {
    /**
     * The data used to create many Uploads.
     */
    data: Enumerable<UploadCreateManyInput>
  }


  /**
   * Upload update
   */
  export type UploadUpdateArgs = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect | null
    /**
     * The data needed to update a Upload.
     */
    data: XOR<UploadUpdateInput, UploadUncheckedUpdateInput>
    /**
     * Choose, which Upload to update.
     */
    where: UploadWhereUniqueInput
  }


  /**
   * Upload updateMany
   */
  export type UploadUpdateManyArgs = {
    /**
     * The data used to update Uploads.
     */
    data: XOR<UploadUpdateManyMutationInput, UploadUncheckedUpdateManyInput>
    /**
     * Filter which Uploads to update
     */
    where?: UploadWhereInput
  }


  /**
   * Upload upsert
   */
  export type UploadUpsertArgs = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect | null
    /**
     * The filter to search for the Upload to update in case it exists.
     */
    where: UploadWhereUniqueInput
    /**
     * In case the Upload found by the `where` argument doesn't exist, create a new Upload with this data.
     */
    create: XOR<UploadCreateInput, UploadUncheckedCreateInput>
    /**
     * In case the Upload was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UploadUpdateInput, UploadUncheckedUpdateInput>
  }


  /**
   * Upload delete
   */
  export type UploadDeleteArgs = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect | null
    /**
     * Filter which Upload to delete.
     */
    where: UploadWhereUniqueInput
  }


  /**
   * Upload deleteMany
   */
  export type UploadDeleteManyArgs = {
    /**
     * Filter which Uploads to delete
     */
    where?: UploadWhereInput
  }


  /**
   * Upload findRaw
   */
  export type UploadFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Upload aggregateRaw
   */
  export type UploadAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Upload without action
   */
  export type UploadArgs = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect | null
  }



  /**
   * Model Personal
   */


  export type AggregatePersonal = {
    _count: PersonalCountAggregateOutputType | null
    _min: PersonalMinAggregateOutputType | null
    _max: PersonalMaxAggregateOutputType | null
  }

  export type PersonalMinAggregateOutputType = {
    id: string | null
    nik: string | null
    nisn: string | null
    type: TypePersonal | null
    fullname: string | null
    gender: Gender | null
    foreign: boolean | null
    country: string | null
    religion: Religion | null
    email: string | null
    belajarId: string | null
    nophone: string | null
    isLife: boolean | null
    disable: boolean | null
  }

  export type PersonalMaxAggregateOutputType = {
    id: string | null
    nik: string | null
    nisn: string | null
    type: TypePersonal | null
    fullname: string | null
    gender: Gender | null
    foreign: boolean | null
    country: string | null
    religion: Religion | null
    email: string | null
    belajarId: string | null
    nophone: string | null
    isLife: boolean | null
    disable: boolean | null
  }

  export type PersonalCountAggregateOutputType = {
    id: number
    nik: number
    nisn: number
    type: number
    fullname: number
    gender: number
    foreign: number
    country: number
    religion: number
    email: number
    belajarId: number
    nophone: number
    isLife: number
    disable: number
    _all: number
  }


  export type PersonalMinAggregateInputType = {
    id?: true
    nik?: true
    nisn?: true
    type?: true
    fullname?: true
    gender?: true
    foreign?: true
    country?: true
    religion?: true
    email?: true
    belajarId?: true
    nophone?: true
    isLife?: true
    disable?: true
  }

  export type PersonalMaxAggregateInputType = {
    id?: true
    nik?: true
    nisn?: true
    type?: true
    fullname?: true
    gender?: true
    foreign?: true
    country?: true
    religion?: true
    email?: true
    belajarId?: true
    nophone?: true
    isLife?: true
    disable?: true
  }

  export type PersonalCountAggregateInputType = {
    id?: true
    nik?: true
    nisn?: true
    type?: true
    fullname?: true
    gender?: true
    foreign?: true
    country?: true
    religion?: true
    email?: true
    belajarId?: true
    nophone?: true
    isLife?: true
    disable?: true
    _all?: true
  }

  export type PersonalAggregateArgs = {
    /**
     * Filter which Personal to aggregate.
     */
    where?: PersonalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personals to fetch.
     */
    orderBy?: Enumerable<PersonalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Personals
    **/
    _count?: true | PersonalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonalMaxAggregateInputType
  }

  export type GetPersonalAggregateType<T extends PersonalAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonal[P]>
      : GetScalarType<T[P], AggregatePersonal[P]>
  }




  export type PersonalGroupByArgs = {
    where?: PersonalWhereInput
    orderBy?: Enumerable<PersonalOrderByWithAggregationInput>
    by: PersonalScalarFieldEnum[]
    having?: PersonalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonalCountAggregateInputType | true
    _min?: PersonalMinAggregateInputType
    _max?: PersonalMaxAggregateInputType
  }


  export type PersonalGroupByOutputType = {
    id: string
    nik: string | null
    nisn: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign: boolean | null
    country: string | null
    religion: Religion
    email: string | null
    belajarId: string | null
    nophone: string | null
    isLife: boolean | null
    disable: boolean
    _count: PersonalCountAggregateOutputType | null
    _min: PersonalMinAggregateOutputType | null
    _max: PersonalMaxAggregateOutputType | null
  }

  type GetPersonalGroupByPayload<T extends PersonalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PersonalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonalGroupByOutputType[P]>
            : GetScalarType<T[P], PersonalGroupByOutputType[P]>
        }
      >
    >


  export type PersonalSelect = {
    id?: boolean
    nik?: boolean
    nisn?: boolean
    type?: boolean
    fullname?: boolean
    gender?: boolean
    foreign?: boolean
    country?: boolean
    religion?: boolean
    born?: boolean | BornArgs
    email?: boolean
    belajarId?: boolean
    nophone?: boolean
    isLife?: boolean
    address?: boolean | AddressArgs
    education?: boolean | EducationArgs
    training?: boolean | TrainingArgs
    employment?: boolean | EmploymentArgs
    profession?: boolean | ProfessionArgs
    overseas?: boolean | OverseasArgs
    scientific?: boolean | ScientificArgs
    organization?: boolean | OrganizationArgs
    papers?: boolean | PapersArgs
    innovation?: boolean | InnovationArgs
    award?: boolean | AwardArgs
    sourcePerson?: boolean | SourcePersonArgs
    contest?: boolean | ContestArgs
    documents?: boolean | DocumentsArgs
    additional?: boolean | AdditionalArgs
    disable?: boolean
    auth?: boolean | AuthArgs
    father?: boolean | Personal$fatherArgs
    mother?: boolean | Personal$motherArgs
    wali?: boolean | Personal$waliArgs
    couple?: boolean | Personal$coupleArgs
    child?: boolean | FamilyTreeChildArgs
    student?: boolean | Personal$studentArgs
    teacher?: boolean | Personal$teacherArgs
    _count?: boolean | PersonalCountOutputTypeArgs
  }


  export type PersonalInclude = {
    auth?: boolean | AuthArgs
    father?: boolean | Personal$fatherArgs
    mother?: boolean | Personal$motherArgs
    wali?: boolean | Personal$waliArgs
    couple?: boolean | Personal$coupleArgs
    child?: boolean | FamilyTreeChildArgs
    student?: boolean | Personal$studentArgs
    teacher?: boolean | Personal$teacherArgs
    _count?: boolean | PersonalCountOutputTypeArgs
  }

  export type PersonalGetPayload<S extends boolean | null | undefined | PersonalArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Personal :
    S extends undefined ? never :
    S extends { include: any } & (PersonalArgs | PersonalFindManyArgs)
    ? Personal  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'auth' ? AuthGetPayload<S['include'][P]> | null :
        P extends 'father' ? Array < FamilyTreeGetPayload<S['include'][P]>>  :
        P extends 'mother' ? Array < FamilyTreeGetPayload<S['include'][P]>>  :
        P extends 'wali' ? Array < FamilyTreeGetPayload<S['include'][P]>>  :
        P extends 'couple' ? Array < FamilyTreeGetPayload<S['include'][P]>>  :
        P extends 'child' ? FamilyTreeChildGetPayload<S['include'][P]> | null :
        P extends 'student' ? Array < StudentGetPayload<S['include'][P]>>  :
        P extends 'teacher' ? Array < TeacherGetPayload<S['include'][P]>>  :
        P extends '_count' ? PersonalCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PersonalArgs | PersonalFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'born' ? BornGetPayload<S['select'][P]> :
        P extends 'address' ? AddressGetPayload<S['select'][P]> | null :
        P extends 'education' ? Array < EducationGetPayload<S['select'][P]>>  :
        P extends 'training' ? Array < TrainingGetPayload<S['select'][P]>>  :
        P extends 'employment' ? Array < EmploymentGetPayload<S['select'][P]>>  :
        P extends 'profession' ? Array < ProfessionGetPayload<S['select'][P]>>  :
        P extends 'overseas' ? Array < OverseasGetPayload<S['select'][P]>>  :
        P extends 'scientific' ? Array < ScientificGetPayload<S['select'][P]>>  :
        P extends 'organization' ? Array < OrganizationGetPayload<S['select'][P]>>  :
        P extends 'papers' ? Array < PapersGetPayload<S['select'][P]>>  :
        P extends 'innovation' ? Array < InnovationGetPayload<S['select'][P]>>  :
        P extends 'award' ? Array < AwardGetPayload<S['select'][P]>>  :
        P extends 'sourcePerson' ? Array < SourcePersonGetPayload<S['select'][P]>>  :
        P extends 'contest' ? Array < ContestGetPayload<S['select'][P]>>  :
        P extends 'documents' ? Array < DocumentsGetPayload<S['select'][P]>>  :
        P extends 'additional' ? Array < AdditionalGetPayload<S['select'][P]>>  :
        P extends 'auth' ? AuthGetPayload<S['select'][P]> | null :
        P extends 'father' ? Array < FamilyTreeGetPayload<S['select'][P]>>  :
        P extends 'mother' ? Array < FamilyTreeGetPayload<S['select'][P]>>  :
        P extends 'wali' ? Array < FamilyTreeGetPayload<S['select'][P]>>  :
        P extends 'couple' ? Array < FamilyTreeGetPayload<S['select'][P]>>  :
        P extends 'child' ? FamilyTreeChildGetPayload<S['select'][P]> | null :
        P extends 'student' ? Array < StudentGetPayload<S['select'][P]>>  :
        P extends 'teacher' ? Array < TeacherGetPayload<S['select'][P]>>  :
        P extends '_count' ? PersonalCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Personal ? Personal[P] : never
  } 
      : Personal


  type PersonalCountArgs = 
    Omit<PersonalFindManyArgs, 'select' | 'include'> & {
      select?: PersonalCountAggregateInputType | true
    }

  export interface PersonalDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Personal that matches the filter.
     * @param {PersonalFindUniqueArgs} args - Arguments to find a Personal
     * @example
     * // Get one Personal
     * const personal = await prisma.personal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PersonalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PersonalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Personal'> extends True ? Prisma__PersonalClient<PersonalGetPayload<T>> : Prisma__PersonalClient<PersonalGetPayload<T> | null, null>

    /**
     * Find one Personal that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PersonalFindUniqueOrThrowArgs} args - Arguments to find a Personal
     * @example
     * // Get one Personal
     * const personal = await prisma.personal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PersonalFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PersonalFindUniqueOrThrowArgs>
    ): Prisma__PersonalClient<PersonalGetPayload<T>>

    /**
     * Find the first Personal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalFindFirstArgs} args - Arguments to find a Personal
     * @example
     * // Get one Personal
     * const personal = await prisma.personal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PersonalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PersonalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Personal'> extends True ? Prisma__PersonalClient<PersonalGetPayload<T>> : Prisma__PersonalClient<PersonalGetPayload<T> | null, null>

    /**
     * Find the first Personal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalFindFirstOrThrowArgs} args - Arguments to find a Personal
     * @example
     * // Get one Personal
     * const personal = await prisma.personal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PersonalFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PersonalFindFirstOrThrowArgs>
    ): Prisma__PersonalClient<PersonalGetPayload<T>>

    /**
     * Find zero or more Personals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Personals
     * const personals = await prisma.personal.findMany()
     * 
     * // Get first 10 Personals
     * const personals = await prisma.personal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personalWithIdOnly = await prisma.personal.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PersonalFindManyArgs>(
      args?: SelectSubset<T, PersonalFindManyArgs>
    ): Prisma.PrismaPromise<Array<PersonalGetPayload<T>>>

    /**
     * Create a Personal.
     * @param {PersonalCreateArgs} args - Arguments to create a Personal.
     * @example
     * // Create one Personal
     * const Personal = await prisma.personal.create({
     *   data: {
     *     // ... data to create a Personal
     *   }
     * })
     * 
    **/
    create<T extends PersonalCreateArgs>(
      args: SelectSubset<T, PersonalCreateArgs>
    ): Prisma__PersonalClient<PersonalGetPayload<T>>

    /**
     * Create many Personals.
     *     @param {PersonalCreateManyArgs} args - Arguments to create many Personals.
     *     @example
     *     // Create many Personals
     *     const personal = await prisma.personal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PersonalCreateManyArgs>(
      args?: SelectSubset<T, PersonalCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Personal.
     * @param {PersonalDeleteArgs} args - Arguments to delete one Personal.
     * @example
     * // Delete one Personal
     * const Personal = await prisma.personal.delete({
     *   where: {
     *     // ... filter to delete one Personal
     *   }
     * })
     * 
    **/
    delete<T extends PersonalDeleteArgs>(
      args: SelectSubset<T, PersonalDeleteArgs>
    ): Prisma__PersonalClient<PersonalGetPayload<T>>

    /**
     * Update one Personal.
     * @param {PersonalUpdateArgs} args - Arguments to update one Personal.
     * @example
     * // Update one Personal
     * const personal = await prisma.personal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PersonalUpdateArgs>(
      args: SelectSubset<T, PersonalUpdateArgs>
    ): Prisma__PersonalClient<PersonalGetPayload<T>>

    /**
     * Delete zero or more Personals.
     * @param {PersonalDeleteManyArgs} args - Arguments to filter Personals to delete.
     * @example
     * // Delete a few Personals
     * const { count } = await prisma.personal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PersonalDeleteManyArgs>(
      args?: SelectSubset<T, PersonalDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Personals
     * const personal = await prisma.personal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PersonalUpdateManyArgs>(
      args: SelectSubset<T, PersonalUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Personal.
     * @param {PersonalUpsertArgs} args - Arguments to update or create a Personal.
     * @example
     * // Update or create a Personal
     * const personal = await prisma.personal.upsert({
     *   create: {
     *     // ... data to create a Personal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Personal we want to update
     *   }
     * })
    **/
    upsert<T extends PersonalUpsertArgs>(
      args: SelectSubset<T, PersonalUpsertArgs>
    ): Prisma__PersonalClient<PersonalGetPayload<T>>

    /**
     * Find zero or more Personals that matches the filter.
     * @param {PersonalFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const personal = await prisma.personal.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: PersonalFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Personal.
     * @param {PersonalAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const personal = await prisma.personal.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: PersonalAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Personals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalCountArgs} args - Arguments to filter Personals to count.
     * @example
     * // Count the number of Personals
     * const count = await prisma.personal.count({
     *   where: {
     *     // ... the filter for the Personals we want to count
     *   }
     * })
    **/
    count<T extends PersonalCountArgs>(
      args?: Subset<T, PersonalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Personal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonalAggregateArgs>(args: Subset<T, PersonalAggregateArgs>): Prisma.PrismaPromise<GetPersonalAggregateType<T>>

    /**
     * Group by Personal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonalGroupByArgs['orderBy'] }
        : { orderBy?: PersonalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Personal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PersonalClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    born<T extends BornArgs= {}>(args?: Subset<T, BornArgs>): Prisma__BornClient<BornGetPayload<T> | Null>;

    address<T extends AddressArgs= {}>(args?: Subset<T, AddressArgs>): Prisma__AddressClient<AddressGetPayload<T> | Null>;

    education<T extends EducationArgs= {}>(args?: Subset<T, EducationArgs>): Prisma.PrismaPromise<Array<EducationGetPayload<T>>| Null>;

    training<T extends TrainingArgs= {}>(args?: Subset<T, TrainingArgs>): Prisma.PrismaPromise<Array<TrainingGetPayload<T>>| Null>;

    employment<T extends EmploymentArgs= {}>(args?: Subset<T, EmploymentArgs>): Prisma.PrismaPromise<Array<EmploymentGetPayload<T>>| Null>;

    profession<T extends ProfessionArgs= {}>(args?: Subset<T, ProfessionArgs>): Prisma.PrismaPromise<Array<ProfessionGetPayload<T>>| Null>;

    overseas<T extends OverseasArgs= {}>(args?: Subset<T, OverseasArgs>): Prisma.PrismaPromise<Array<OverseasGetPayload<T>>| Null>;

    scientific<T extends ScientificArgs= {}>(args?: Subset<T, ScientificArgs>): Prisma.PrismaPromise<Array<ScientificGetPayload<T>>| Null>;

    organization<T extends OrganizationArgs= {}>(args?: Subset<T, OrganizationArgs>): Prisma.PrismaPromise<Array<OrganizationGetPayload<T>>| Null>;

    papers<T extends PapersArgs= {}>(args?: Subset<T, PapersArgs>): Prisma.PrismaPromise<Array<PapersGetPayload<T>>| Null>;

    innovation<T extends InnovationArgs= {}>(args?: Subset<T, InnovationArgs>): Prisma.PrismaPromise<Array<InnovationGetPayload<T>>| Null>;

    award<T extends AwardArgs= {}>(args?: Subset<T, AwardArgs>): Prisma.PrismaPromise<Array<AwardGetPayload<T>>| Null>;

    sourcePerson<T extends SourcePersonArgs= {}>(args?: Subset<T, SourcePersonArgs>): Prisma.PrismaPromise<Array<SourcePersonGetPayload<T>>| Null>;

    contest<T extends ContestArgs= {}>(args?: Subset<T, ContestArgs>): Prisma.PrismaPromise<Array<ContestGetPayload<T>>| Null>;

    documents<T extends DocumentsArgs= {}>(args?: Subset<T, DocumentsArgs>): Prisma.PrismaPromise<Array<DocumentsGetPayload<T>>| Null>;

    additional<T extends AdditionalArgs= {}>(args?: Subset<T, AdditionalArgs>): Prisma.PrismaPromise<Array<AdditionalGetPayload<T>>| Null>;

    auth<T extends AuthArgs= {}>(args?: Subset<T, AuthArgs>): Prisma__AuthClient<AuthGetPayload<T> | Null>;

    father<T extends Personal$fatherArgs= {}>(args?: Subset<T, Personal$fatherArgs>): Prisma.PrismaPromise<Array<FamilyTreeGetPayload<T>>| Null>;

    mother<T extends Personal$motherArgs= {}>(args?: Subset<T, Personal$motherArgs>): Prisma.PrismaPromise<Array<FamilyTreeGetPayload<T>>| Null>;

    wali<T extends Personal$waliArgs= {}>(args?: Subset<T, Personal$waliArgs>): Prisma.PrismaPromise<Array<FamilyTreeGetPayload<T>>| Null>;

    couple<T extends Personal$coupleArgs= {}>(args?: Subset<T, Personal$coupleArgs>): Prisma.PrismaPromise<Array<FamilyTreeGetPayload<T>>| Null>;

    child<T extends FamilyTreeChildArgs= {}>(args?: Subset<T, FamilyTreeChildArgs>): Prisma__FamilyTreeChildClient<FamilyTreeChildGetPayload<T> | Null>;

    student<T extends Personal$studentArgs= {}>(args?: Subset<T, Personal$studentArgs>): Prisma.PrismaPromise<Array<StudentGetPayload<T>>| Null>;

    teacher<T extends Personal$teacherArgs= {}>(args?: Subset<T, Personal$teacherArgs>): Prisma.PrismaPromise<Array<TeacherGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Personal base type for findUnique actions
   */
  export type PersonalFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * Filter, which Personal to fetch.
     */
    where: PersonalWhereUniqueInput
  }

  /**
   * Personal findUnique
   */
  export interface PersonalFindUniqueArgs extends PersonalFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Personal findUniqueOrThrow
   */
  export type PersonalFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * Filter, which Personal to fetch.
     */
    where: PersonalWhereUniqueInput
  }


  /**
   * Personal base type for findFirst actions
   */
  export type PersonalFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * Filter, which Personal to fetch.
     */
    where?: PersonalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personals to fetch.
     */
    orderBy?: Enumerable<PersonalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personals.
     */
    cursor?: PersonalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personals.
     */
    distinct?: Enumerable<PersonalScalarFieldEnum>
  }

  /**
   * Personal findFirst
   */
  export interface PersonalFindFirstArgs extends PersonalFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Personal findFirstOrThrow
   */
  export type PersonalFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * Filter, which Personal to fetch.
     */
    where?: PersonalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personals to fetch.
     */
    orderBy?: Enumerable<PersonalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personals.
     */
    cursor?: PersonalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personals.
     */
    distinct?: Enumerable<PersonalScalarFieldEnum>
  }


  /**
   * Personal findMany
   */
  export type PersonalFindManyArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * Filter, which Personals to fetch.
     */
    where?: PersonalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personals to fetch.
     */
    orderBy?: Enumerable<PersonalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Personals.
     */
    cursor?: PersonalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personals.
     */
    skip?: number
    distinct?: Enumerable<PersonalScalarFieldEnum>
  }


  /**
   * Personal create
   */
  export type PersonalCreateArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * The data needed to create a Personal.
     */
    data: XOR<PersonalCreateInput, PersonalUncheckedCreateInput>
  }


  /**
   * Personal createMany
   */
  export type PersonalCreateManyArgs = {
    /**
     * The data used to create many Personals.
     */
    data: Enumerable<PersonalCreateManyInput>
  }


  /**
   * Personal update
   */
  export type PersonalUpdateArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * The data needed to update a Personal.
     */
    data: XOR<PersonalUpdateInput, PersonalUncheckedUpdateInput>
    /**
     * Choose, which Personal to update.
     */
    where: PersonalWhereUniqueInput
  }


  /**
   * Personal updateMany
   */
  export type PersonalUpdateManyArgs = {
    /**
     * The data used to update Personals.
     */
    data: XOR<PersonalUpdateManyMutationInput, PersonalUncheckedUpdateManyInput>
    /**
     * Filter which Personals to update
     */
    where?: PersonalWhereInput
  }


  /**
   * Personal upsert
   */
  export type PersonalUpsertArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * The filter to search for the Personal to update in case it exists.
     */
    where: PersonalWhereUniqueInput
    /**
     * In case the Personal found by the `where` argument doesn't exist, create a new Personal with this data.
     */
    create: XOR<PersonalCreateInput, PersonalUncheckedCreateInput>
    /**
     * In case the Personal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonalUpdateInput, PersonalUncheckedUpdateInput>
  }


  /**
   * Personal delete
   */
  export type PersonalDeleteArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * Filter which Personal to delete.
     */
    where: PersonalWhereUniqueInput
  }


  /**
   * Personal deleteMany
   */
  export type PersonalDeleteManyArgs = {
    /**
     * Filter which Personals to delete
     */
    where?: PersonalWhereInput
  }


  /**
   * Personal findRaw
   */
  export type PersonalFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Personal aggregateRaw
   */
  export type PersonalAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Personal.father
   */
  export type Personal$fatherArgs = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    where?: FamilyTreeWhereInput
    orderBy?: Enumerable<FamilyTreeOrderByWithRelationInput>
    cursor?: FamilyTreeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FamilyTreeScalarFieldEnum>
  }


  /**
   * Personal.mother
   */
  export type Personal$motherArgs = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    where?: FamilyTreeWhereInput
    orderBy?: Enumerable<FamilyTreeOrderByWithRelationInput>
    cursor?: FamilyTreeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FamilyTreeScalarFieldEnum>
  }


  /**
   * Personal.wali
   */
  export type Personal$waliArgs = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    where?: FamilyTreeWhereInput
    orderBy?: Enumerable<FamilyTreeOrderByWithRelationInput>
    cursor?: FamilyTreeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FamilyTreeScalarFieldEnum>
  }


  /**
   * Personal.couple
   */
  export type Personal$coupleArgs = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    where?: FamilyTreeWhereInput
    orderBy?: Enumerable<FamilyTreeOrderByWithRelationInput>
    cursor?: FamilyTreeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FamilyTreeScalarFieldEnum>
  }


  /**
   * Personal.student
   */
  export type Personal$studentArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    where?: StudentWhereInput
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * Personal.teacher
   */
  export type Personal$teacherArgs = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
    where?: TeacherWhereInput
    orderBy?: Enumerable<TeacherOrderByWithRelationInput>
    cursor?: TeacherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeacherScalarFieldEnum>
  }


  /**
   * Personal without action
   */
  export type PersonalArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
  }



  /**
   * Model Auth
   */


  export type AggregateAuth = {
    _count: AuthCountAggregateOutputType | null
    _min: AuthMinAggregateOutputType | null
    _max: AuthMaxAggregateOutputType | null
  }

  export type AuthMinAggregateOutputType = {
    id: string | null
    userId: string | null
    personalId: string | null
  }

  export type AuthMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    personalId: string | null
  }

  export type AuthCountAggregateOutputType = {
    id: number
    userId: number
    personalId: number
    _all: number
  }


  export type AuthMinAggregateInputType = {
    id?: true
    userId?: true
    personalId?: true
  }

  export type AuthMaxAggregateInputType = {
    id?: true
    userId?: true
    personalId?: true
  }

  export type AuthCountAggregateInputType = {
    id?: true
    userId?: true
    personalId?: true
    _all?: true
  }

  export type AuthAggregateArgs = {
    /**
     * Filter which Auth to aggregate.
     */
    where?: AuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auths to fetch.
     */
    orderBy?: Enumerable<AuthOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Auths
    **/
    _count?: true | AuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthMaxAggregateInputType
  }

  export type GetAuthAggregateType<T extends AuthAggregateArgs> = {
        [P in keyof T & keyof AggregateAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuth[P]>
      : GetScalarType<T[P], AggregateAuth[P]>
  }




  export type AuthGroupByArgs = {
    where?: AuthWhereInput
    orderBy?: Enumerable<AuthOrderByWithAggregationInput>
    by: AuthScalarFieldEnum[]
    having?: AuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthCountAggregateInputType | true
    _min?: AuthMinAggregateInputType
    _max?: AuthMaxAggregateInputType
  }


  export type AuthGroupByOutputType = {
    id: string
    userId: string
    personalId: string
    _count: AuthCountAggregateOutputType | null
    _min: AuthMinAggregateOutputType | null
    _max: AuthMaxAggregateOutputType | null
  }

  type GetAuthGroupByPayload<T extends AuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthGroupByOutputType[P]>
            : GetScalarType<T[P], AuthGroupByOutputType[P]>
        }
      >
    >


  export type AuthSelect = {
    id?: boolean
    userId?: boolean
    personalId?: boolean
    user?: boolean | UserArgs
    personal?: boolean | PersonalArgs
  }


  export type AuthInclude = {
    user?: boolean | UserArgs
    personal?: boolean | PersonalArgs
  }

  export type AuthGetPayload<S extends boolean | null | undefined | AuthArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Auth :
    S extends undefined ? never :
    S extends { include: any } & (AuthArgs | AuthFindManyArgs)
    ? Auth  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'personal' ? PersonalGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AuthArgs | AuthFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'personal' ? PersonalGetPayload<S['select'][P]> :  P extends keyof Auth ? Auth[P] : never
  } 
      : Auth


  type AuthCountArgs = 
    Omit<AuthFindManyArgs, 'select' | 'include'> & {
      select?: AuthCountAggregateInputType | true
    }

  export interface AuthDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Auth that matches the filter.
     * @param {AuthFindUniqueArgs} args - Arguments to find a Auth
     * @example
     * // Get one Auth
     * const auth = await prisma.auth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AuthFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AuthFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Auth'> extends True ? Prisma__AuthClient<AuthGetPayload<T>> : Prisma__AuthClient<AuthGetPayload<T> | null, null>

    /**
     * Find one Auth that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AuthFindUniqueOrThrowArgs} args - Arguments to find a Auth
     * @example
     * // Get one Auth
     * const auth = await prisma.auth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AuthFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AuthFindUniqueOrThrowArgs>
    ): Prisma__AuthClient<AuthGetPayload<T>>

    /**
     * Find the first Auth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthFindFirstArgs} args - Arguments to find a Auth
     * @example
     * // Get one Auth
     * const auth = await prisma.auth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AuthFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AuthFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Auth'> extends True ? Prisma__AuthClient<AuthGetPayload<T>> : Prisma__AuthClient<AuthGetPayload<T> | null, null>

    /**
     * Find the first Auth that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthFindFirstOrThrowArgs} args - Arguments to find a Auth
     * @example
     * // Get one Auth
     * const auth = await prisma.auth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AuthFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AuthFindFirstOrThrowArgs>
    ): Prisma__AuthClient<AuthGetPayload<T>>

    /**
     * Find zero or more Auths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auths
     * const auths = await prisma.auth.findMany()
     * 
     * // Get first 10 Auths
     * const auths = await prisma.auth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authWithIdOnly = await prisma.auth.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AuthFindManyArgs>(
      args?: SelectSubset<T, AuthFindManyArgs>
    ): Prisma.PrismaPromise<Array<AuthGetPayload<T>>>

    /**
     * Create a Auth.
     * @param {AuthCreateArgs} args - Arguments to create a Auth.
     * @example
     * // Create one Auth
     * const Auth = await prisma.auth.create({
     *   data: {
     *     // ... data to create a Auth
     *   }
     * })
     * 
    **/
    create<T extends AuthCreateArgs>(
      args: SelectSubset<T, AuthCreateArgs>
    ): Prisma__AuthClient<AuthGetPayload<T>>

    /**
     * Create many Auths.
     *     @param {AuthCreateManyArgs} args - Arguments to create many Auths.
     *     @example
     *     // Create many Auths
     *     const auth = await prisma.auth.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AuthCreateManyArgs>(
      args?: SelectSubset<T, AuthCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Auth.
     * @param {AuthDeleteArgs} args - Arguments to delete one Auth.
     * @example
     * // Delete one Auth
     * const Auth = await prisma.auth.delete({
     *   where: {
     *     // ... filter to delete one Auth
     *   }
     * })
     * 
    **/
    delete<T extends AuthDeleteArgs>(
      args: SelectSubset<T, AuthDeleteArgs>
    ): Prisma__AuthClient<AuthGetPayload<T>>

    /**
     * Update one Auth.
     * @param {AuthUpdateArgs} args - Arguments to update one Auth.
     * @example
     * // Update one Auth
     * const auth = await prisma.auth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AuthUpdateArgs>(
      args: SelectSubset<T, AuthUpdateArgs>
    ): Prisma__AuthClient<AuthGetPayload<T>>

    /**
     * Delete zero or more Auths.
     * @param {AuthDeleteManyArgs} args - Arguments to filter Auths to delete.
     * @example
     * // Delete a few Auths
     * const { count } = await prisma.auth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AuthDeleteManyArgs>(
      args?: SelectSubset<T, AuthDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auths
     * const auth = await prisma.auth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AuthUpdateManyArgs>(
      args: SelectSubset<T, AuthUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Auth.
     * @param {AuthUpsertArgs} args - Arguments to update or create a Auth.
     * @example
     * // Update or create a Auth
     * const auth = await prisma.auth.upsert({
     *   create: {
     *     // ... data to create a Auth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auth we want to update
     *   }
     * })
    **/
    upsert<T extends AuthUpsertArgs>(
      args: SelectSubset<T, AuthUpsertArgs>
    ): Prisma__AuthClient<AuthGetPayload<T>>

    /**
     * Find zero or more Auths that matches the filter.
     * @param {AuthFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const auth = await prisma.auth.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: AuthFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Auth.
     * @param {AuthAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const auth = await prisma.auth.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: AuthAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Auths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthCountArgs} args - Arguments to filter Auths to count.
     * @example
     * // Count the number of Auths
     * const count = await prisma.auth.count({
     *   where: {
     *     // ... the filter for the Auths we want to count
     *   }
     * })
    **/
    count<T extends AuthCountArgs>(
      args?: Subset<T, AuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthAggregateArgs>(args: Subset<T, AuthAggregateArgs>): Prisma.PrismaPromise<GetAuthAggregateType<T>>

    /**
     * Group by Auth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthGroupByArgs['orderBy'] }
        : { orderBy?: AuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Auth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AuthClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    personal<T extends PersonalArgs= {}>(args?: Subset<T, PersonalArgs>): Prisma__PersonalClient<PersonalGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Auth base type for findUnique actions
   */
  export type AuthFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthInclude | null
    /**
     * Filter, which Auth to fetch.
     */
    where: AuthWhereUniqueInput
  }

  /**
   * Auth findUnique
   */
  export interface AuthFindUniqueArgs extends AuthFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Auth findUniqueOrThrow
   */
  export type AuthFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthInclude | null
    /**
     * Filter, which Auth to fetch.
     */
    where: AuthWhereUniqueInput
  }


  /**
   * Auth base type for findFirst actions
   */
  export type AuthFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthInclude | null
    /**
     * Filter, which Auth to fetch.
     */
    where?: AuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auths to fetch.
     */
    orderBy?: Enumerable<AuthOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Auths.
     */
    cursor?: AuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Auths.
     */
    distinct?: Enumerable<AuthScalarFieldEnum>
  }

  /**
   * Auth findFirst
   */
  export interface AuthFindFirstArgs extends AuthFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Auth findFirstOrThrow
   */
  export type AuthFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthInclude | null
    /**
     * Filter, which Auth to fetch.
     */
    where?: AuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auths to fetch.
     */
    orderBy?: Enumerable<AuthOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Auths.
     */
    cursor?: AuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Auths.
     */
    distinct?: Enumerable<AuthScalarFieldEnum>
  }


  /**
   * Auth findMany
   */
  export type AuthFindManyArgs = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthInclude | null
    /**
     * Filter, which Auths to fetch.
     */
    where?: AuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auths to fetch.
     */
    orderBy?: Enumerable<AuthOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Auths.
     */
    cursor?: AuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auths.
     */
    skip?: number
    distinct?: Enumerable<AuthScalarFieldEnum>
  }


  /**
   * Auth create
   */
  export type AuthCreateArgs = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthInclude | null
    /**
     * The data needed to create a Auth.
     */
    data: XOR<AuthCreateInput, AuthUncheckedCreateInput>
  }


  /**
   * Auth createMany
   */
  export type AuthCreateManyArgs = {
    /**
     * The data used to create many Auths.
     */
    data: Enumerable<AuthCreateManyInput>
  }


  /**
   * Auth update
   */
  export type AuthUpdateArgs = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthInclude | null
    /**
     * The data needed to update a Auth.
     */
    data: XOR<AuthUpdateInput, AuthUncheckedUpdateInput>
    /**
     * Choose, which Auth to update.
     */
    where: AuthWhereUniqueInput
  }


  /**
   * Auth updateMany
   */
  export type AuthUpdateManyArgs = {
    /**
     * The data used to update Auths.
     */
    data: XOR<AuthUpdateManyMutationInput, AuthUncheckedUpdateManyInput>
    /**
     * Filter which Auths to update
     */
    where?: AuthWhereInput
  }


  /**
   * Auth upsert
   */
  export type AuthUpsertArgs = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthInclude | null
    /**
     * The filter to search for the Auth to update in case it exists.
     */
    where: AuthWhereUniqueInput
    /**
     * In case the Auth found by the `where` argument doesn't exist, create a new Auth with this data.
     */
    create: XOR<AuthCreateInput, AuthUncheckedCreateInput>
    /**
     * In case the Auth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthUpdateInput, AuthUncheckedUpdateInput>
  }


  /**
   * Auth delete
   */
  export type AuthDeleteArgs = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthInclude | null
    /**
     * Filter which Auth to delete.
     */
    where: AuthWhereUniqueInput
  }


  /**
   * Auth deleteMany
   */
  export type AuthDeleteManyArgs = {
    /**
     * Filter which Auths to delete
     */
    where?: AuthWhereInput
  }


  /**
   * Auth findRaw
   */
  export type AuthFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Auth aggregateRaw
   */
  export type AuthAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Auth without action
   */
  export type AuthArgs = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthInclude | null
  }



  /**
   * Model FamilyTree
   */


  export type AggregateFamilyTree = {
    _count: FamilyTreeCountAggregateOutputType | null
    _min: FamilyTreeMinAggregateOutputType | null
    _max: FamilyTreeMaxAggregateOutputType | null
  }

  export type FamilyTreeMinAggregateOutputType = {
    id: string | null
    nokk: string | null
    fatherId: string | null
    motherId: string | null
    waliId: string | null
    coupleId: string | null
  }

  export type FamilyTreeMaxAggregateOutputType = {
    id: string | null
    nokk: string | null
    fatherId: string | null
    motherId: string | null
    waliId: string | null
    coupleId: string | null
  }

  export type FamilyTreeCountAggregateOutputType = {
    id: number
    nokk: number
    fatherId: number
    motherId: number
    waliId: number
    coupleId: number
    _all: number
  }


  export type FamilyTreeMinAggregateInputType = {
    id?: true
    nokk?: true
    fatherId?: true
    motherId?: true
    waliId?: true
    coupleId?: true
  }

  export type FamilyTreeMaxAggregateInputType = {
    id?: true
    nokk?: true
    fatherId?: true
    motherId?: true
    waliId?: true
    coupleId?: true
  }

  export type FamilyTreeCountAggregateInputType = {
    id?: true
    nokk?: true
    fatherId?: true
    motherId?: true
    waliId?: true
    coupleId?: true
    _all?: true
  }

  export type FamilyTreeAggregateArgs = {
    /**
     * Filter which FamilyTree to aggregate.
     */
    where?: FamilyTreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyTrees to fetch.
     */
    orderBy?: Enumerable<FamilyTreeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FamilyTreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyTrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyTrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FamilyTrees
    **/
    _count?: true | FamilyTreeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FamilyTreeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FamilyTreeMaxAggregateInputType
  }

  export type GetFamilyTreeAggregateType<T extends FamilyTreeAggregateArgs> = {
        [P in keyof T & keyof AggregateFamilyTree]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFamilyTree[P]>
      : GetScalarType<T[P], AggregateFamilyTree[P]>
  }




  export type FamilyTreeGroupByArgs = {
    where?: FamilyTreeWhereInput
    orderBy?: Enumerable<FamilyTreeOrderByWithAggregationInput>
    by: FamilyTreeScalarFieldEnum[]
    having?: FamilyTreeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FamilyTreeCountAggregateInputType | true
    _min?: FamilyTreeMinAggregateInputType
    _max?: FamilyTreeMaxAggregateInputType
  }


  export type FamilyTreeGroupByOutputType = {
    id: string
    nokk: string
    fatherId: string | null
    motherId: string | null
    waliId: string | null
    coupleId: string | null
    _count: FamilyTreeCountAggregateOutputType | null
    _min: FamilyTreeMinAggregateOutputType | null
    _max: FamilyTreeMaxAggregateOutputType | null
  }

  type GetFamilyTreeGroupByPayload<T extends FamilyTreeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FamilyTreeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FamilyTreeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FamilyTreeGroupByOutputType[P]>
            : GetScalarType<T[P], FamilyTreeGroupByOutputType[P]>
        }
      >
    >


  export type FamilyTreeSelect = {
    id?: boolean
    nokk?: boolean
    fatherId?: boolean
    motherId?: boolean
    waliId?: boolean
    coupleId?: boolean
    address?: boolean | AddressArgs
    father?: boolean | PersonalArgs
    mother?: boolean | PersonalArgs
    wali?: boolean | PersonalArgs
    couple?: boolean | PersonalArgs
    childs?: boolean | FamilyTree$childsArgs
    _count?: boolean | FamilyTreeCountOutputTypeArgs
  }


  export type FamilyTreeInclude = {
    father?: boolean | PersonalArgs
    mother?: boolean | PersonalArgs
    wali?: boolean | PersonalArgs
    couple?: boolean | PersonalArgs
    childs?: boolean | FamilyTree$childsArgs
    _count?: boolean | FamilyTreeCountOutputTypeArgs
  }

  export type FamilyTreeGetPayload<S extends boolean | null | undefined | FamilyTreeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FamilyTree :
    S extends undefined ? never :
    S extends { include: any } & (FamilyTreeArgs | FamilyTreeFindManyArgs)
    ? FamilyTree  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'father' ? PersonalGetPayload<S['include'][P]> | null :
        P extends 'mother' ? PersonalGetPayload<S['include'][P]> | null :
        P extends 'wali' ? PersonalGetPayload<S['include'][P]> | null :
        P extends 'couple' ? PersonalGetPayload<S['include'][P]> | null :
        P extends 'childs' ? Array < FamilyTreeChildGetPayload<S['include'][P]>>  :
        P extends '_count' ? FamilyTreeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FamilyTreeArgs | FamilyTreeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'address' ? AddressGetPayload<S['select'][P]> :
        P extends 'father' ? PersonalGetPayload<S['select'][P]> | null :
        P extends 'mother' ? PersonalGetPayload<S['select'][P]> | null :
        P extends 'wali' ? PersonalGetPayload<S['select'][P]> | null :
        P extends 'couple' ? PersonalGetPayload<S['select'][P]> | null :
        P extends 'childs' ? Array < FamilyTreeChildGetPayload<S['select'][P]>>  :
        P extends '_count' ? FamilyTreeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FamilyTree ? FamilyTree[P] : never
  } 
      : FamilyTree


  type FamilyTreeCountArgs = 
    Omit<FamilyTreeFindManyArgs, 'select' | 'include'> & {
      select?: FamilyTreeCountAggregateInputType | true
    }

  export interface FamilyTreeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FamilyTree that matches the filter.
     * @param {FamilyTreeFindUniqueArgs} args - Arguments to find a FamilyTree
     * @example
     * // Get one FamilyTree
     * const familyTree = await prisma.familyTree.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FamilyTreeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FamilyTreeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FamilyTree'> extends True ? Prisma__FamilyTreeClient<FamilyTreeGetPayload<T>> : Prisma__FamilyTreeClient<FamilyTreeGetPayload<T> | null, null>

    /**
     * Find one FamilyTree that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FamilyTreeFindUniqueOrThrowArgs} args - Arguments to find a FamilyTree
     * @example
     * // Get one FamilyTree
     * const familyTree = await prisma.familyTree.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FamilyTreeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FamilyTreeFindUniqueOrThrowArgs>
    ): Prisma__FamilyTreeClient<FamilyTreeGetPayload<T>>

    /**
     * Find the first FamilyTree that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeFindFirstArgs} args - Arguments to find a FamilyTree
     * @example
     * // Get one FamilyTree
     * const familyTree = await prisma.familyTree.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FamilyTreeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FamilyTreeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FamilyTree'> extends True ? Prisma__FamilyTreeClient<FamilyTreeGetPayload<T>> : Prisma__FamilyTreeClient<FamilyTreeGetPayload<T> | null, null>

    /**
     * Find the first FamilyTree that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeFindFirstOrThrowArgs} args - Arguments to find a FamilyTree
     * @example
     * // Get one FamilyTree
     * const familyTree = await prisma.familyTree.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FamilyTreeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FamilyTreeFindFirstOrThrowArgs>
    ): Prisma__FamilyTreeClient<FamilyTreeGetPayload<T>>

    /**
     * Find zero or more FamilyTrees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FamilyTrees
     * const familyTrees = await prisma.familyTree.findMany()
     * 
     * // Get first 10 FamilyTrees
     * const familyTrees = await prisma.familyTree.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const familyTreeWithIdOnly = await prisma.familyTree.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FamilyTreeFindManyArgs>(
      args?: SelectSubset<T, FamilyTreeFindManyArgs>
    ): Prisma.PrismaPromise<Array<FamilyTreeGetPayload<T>>>

    /**
     * Create a FamilyTree.
     * @param {FamilyTreeCreateArgs} args - Arguments to create a FamilyTree.
     * @example
     * // Create one FamilyTree
     * const FamilyTree = await prisma.familyTree.create({
     *   data: {
     *     // ... data to create a FamilyTree
     *   }
     * })
     * 
    **/
    create<T extends FamilyTreeCreateArgs>(
      args: SelectSubset<T, FamilyTreeCreateArgs>
    ): Prisma__FamilyTreeClient<FamilyTreeGetPayload<T>>

    /**
     * Create many FamilyTrees.
     *     @param {FamilyTreeCreateManyArgs} args - Arguments to create many FamilyTrees.
     *     @example
     *     // Create many FamilyTrees
     *     const familyTree = await prisma.familyTree.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FamilyTreeCreateManyArgs>(
      args?: SelectSubset<T, FamilyTreeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FamilyTree.
     * @param {FamilyTreeDeleteArgs} args - Arguments to delete one FamilyTree.
     * @example
     * // Delete one FamilyTree
     * const FamilyTree = await prisma.familyTree.delete({
     *   where: {
     *     // ... filter to delete one FamilyTree
     *   }
     * })
     * 
    **/
    delete<T extends FamilyTreeDeleteArgs>(
      args: SelectSubset<T, FamilyTreeDeleteArgs>
    ): Prisma__FamilyTreeClient<FamilyTreeGetPayload<T>>

    /**
     * Update one FamilyTree.
     * @param {FamilyTreeUpdateArgs} args - Arguments to update one FamilyTree.
     * @example
     * // Update one FamilyTree
     * const familyTree = await prisma.familyTree.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FamilyTreeUpdateArgs>(
      args: SelectSubset<T, FamilyTreeUpdateArgs>
    ): Prisma__FamilyTreeClient<FamilyTreeGetPayload<T>>

    /**
     * Delete zero or more FamilyTrees.
     * @param {FamilyTreeDeleteManyArgs} args - Arguments to filter FamilyTrees to delete.
     * @example
     * // Delete a few FamilyTrees
     * const { count } = await prisma.familyTree.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FamilyTreeDeleteManyArgs>(
      args?: SelectSubset<T, FamilyTreeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FamilyTrees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FamilyTrees
     * const familyTree = await prisma.familyTree.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FamilyTreeUpdateManyArgs>(
      args: SelectSubset<T, FamilyTreeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FamilyTree.
     * @param {FamilyTreeUpsertArgs} args - Arguments to update or create a FamilyTree.
     * @example
     * // Update or create a FamilyTree
     * const familyTree = await prisma.familyTree.upsert({
     *   create: {
     *     // ... data to create a FamilyTree
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FamilyTree we want to update
     *   }
     * })
    **/
    upsert<T extends FamilyTreeUpsertArgs>(
      args: SelectSubset<T, FamilyTreeUpsertArgs>
    ): Prisma__FamilyTreeClient<FamilyTreeGetPayload<T>>

    /**
     * Find zero or more FamilyTrees that matches the filter.
     * @param {FamilyTreeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const familyTree = await prisma.familyTree.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: FamilyTreeFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a FamilyTree.
     * @param {FamilyTreeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const familyTree = await prisma.familyTree.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: FamilyTreeAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of FamilyTrees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeCountArgs} args - Arguments to filter FamilyTrees to count.
     * @example
     * // Count the number of FamilyTrees
     * const count = await prisma.familyTree.count({
     *   where: {
     *     // ... the filter for the FamilyTrees we want to count
     *   }
     * })
    **/
    count<T extends FamilyTreeCountArgs>(
      args?: Subset<T, FamilyTreeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FamilyTreeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FamilyTree.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FamilyTreeAggregateArgs>(args: Subset<T, FamilyTreeAggregateArgs>): Prisma.PrismaPromise<GetFamilyTreeAggregateType<T>>

    /**
     * Group by FamilyTree.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FamilyTreeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FamilyTreeGroupByArgs['orderBy'] }
        : { orderBy?: FamilyTreeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FamilyTreeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFamilyTreeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FamilyTree.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FamilyTreeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    address<T extends AddressArgs= {}>(args?: Subset<T, AddressArgs>): Prisma__AddressClient<AddressGetPayload<T> | Null>;

    father<T extends PersonalArgs= {}>(args?: Subset<T, PersonalArgs>): Prisma__PersonalClient<PersonalGetPayload<T> | Null>;

    mother<T extends PersonalArgs= {}>(args?: Subset<T, PersonalArgs>): Prisma__PersonalClient<PersonalGetPayload<T> | Null>;

    wali<T extends PersonalArgs= {}>(args?: Subset<T, PersonalArgs>): Prisma__PersonalClient<PersonalGetPayload<T> | Null>;

    couple<T extends PersonalArgs= {}>(args?: Subset<T, PersonalArgs>): Prisma__PersonalClient<PersonalGetPayload<T> | Null>;

    childs<T extends FamilyTree$childsArgs= {}>(args?: Subset<T, FamilyTree$childsArgs>): Prisma.PrismaPromise<Array<FamilyTreeChildGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FamilyTree base type for findUnique actions
   */
  export type FamilyTreeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    /**
     * Filter, which FamilyTree to fetch.
     */
    where: FamilyTreeWhereUniqueInput
  }

  /**
   * FamilyTree findUnique
   */
  export interface FamilyTreeFindUniqueArgs extends FamilyTreeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FamilyTree findUniqueOrThrow
   */
  export type FamilyTreeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    /**
     * Filter, which FamilyTree to fetch.
     */
    where: FamilyTreeWhereUniqueInput
  }


  /**
   * FamilyTree base type for findFirst actions
   */
  export type FamilyTreeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    /**
     * Filter, which FamilyTree to fetch.
     */
    where?: FamilyTreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyTrees to fetch.
     */
    orderBy?: Enumerable<FamilyTreeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyTrees.
     */
    cursor?: FamilyTreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyTrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyTrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyTrees.
     */
    distinct?: Enumerable<FamilyTreeScalarFieldEnum>
  }

  /**
   * FamilyTree findFirst
   */
  export interface FamilyTreeFindFirstArgs extends FamilyTreeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FamilyTree findFirstOrThrow
   */
  export type FamilyTreeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    /**
     * Filter, which FamilyTree to fetch.
     */
    where?: FamilyTreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyTrees to fetch.
     */
    orderBy?: Enumerable<FamilyTreeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyTrees.
     */
    cursor?: FamilyTreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyTrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyTrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyTrees.
     */
    distinct?: Enumerable<FamilyTreeScalarFieldEnum>
  }


  /**
   * FamilyTree findMany
   */
  export type FamilyTreeFindManyArgs = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    /**
     * Filter, which FamilyTrees to fetch.
     */
    where?: FamilyTreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyTrees to fetch.
     */
    orderBy?: Enumerable<FamilyTreeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FamilyTrees.
     */
    cursor?: FamilyTreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyTrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyTrees.
     */
    skip?: number
    distinct?: Enumerable<FamilyTreeScalarFieldEnum>
  }


  /**
   * FamilyTree create
   */
  export type FamilyTreeCreateArgs = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    /**
     * The data needed to create a FamilyTree.
     */
    data: XOR<FamilyTreeCreateInput, FamilyTreeUncheckedCreateInput>
  }


  /**
   * FamilyTree createMany
   */
  export type FamilyTreeCreateManyArgs = {
    /**
     * The data used to create many FamilyTrees.
     */
    data: Enumerable<FamilyTreeCreateManyInput>
  }


  /**
   * FamilyTree update
   */
  export type FamilyTreeUpdateArgs = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    /**
     * The data needed to update a FamilyTree.
     */
    data: XOR<FamilyTreeUpdateInput, FamilyTreeUncheckedUpdateInput>
    /**
     * Choose, which FamilyTree to update.
     */
    where: FamilyTreeWhereUniqueInput
  }


  /**
   * FamilyTree updateMany
   */
  export type FamilyTreeUpdateManyArgs = {
    /**
     * The data used to update FamilyTrees.
     */
    data: XOR<FamilyTreeUpdateManyMutationInput, FamilyTreeUncheckedUpdateManyInput>
    /**
     * Filter which FamilyTrees to update
     */
    where?: FamilyTreeWhereInput
  }


  /**
   * FamilyTree upsert
   */
  export type FamilyTreeUpsertArgs = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    /**
     * The filter to search for the FamilyTree to update in case it exists.
     */
    where: FamilyTreeWhereUniqueInput
    /**
     * In case the FamilyTree found by the `where` argument doesn't exist, create a new FamilyTree with this data.
     */
    create: XOR<FamilyTreeCreateInput, FamilyTreeUncheckedCreateInput>
    /**
     * In case the FamilyTree was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FamilyTreeUpdateInput, FamilyTreeUncheckedUpdateInput>
  }


  /**
   * FamilyTree delete
   */
  export type FamilyTreeDeleteArgs = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
    /**
     * Filter which FamilyTree to delete.
     */
    where: FamilyTreeWhereUniqueInput
  }


  /**
   * FamilyTree deleteMany
   */
  export type FamilyTreeDeleteManyArgs = {
    /**
     * Filter which FamilyTrees to delete
     */
    where?: FamilyTreeWhereInput
  }


  /**
   * FamilyTree findRaw
   */
  export type FamilyTreeFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * FamilyTree aggregateRaw
   */
  export type FamilyTreeAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * FamilyTree.childs
   */
  export type FamilyTree$childsArgs = {
    /**
     * Select specific fields to fetch from the FamilyTreeChild
     */
    select?: FamilyTreeChildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeChildInclude | null
    where?: FamilyTreeChildWhereInput
    orderBy?: Enumerable<FamilyTreeChildOrderByWithRelationInput>
    cursor?: FamilyTreeChildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FamilyTreeChildScalarFieldEnum>
  }


  /**
   * FamilyTree without action
   */
  export type FamilyTreeArgs = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeInclude | null
  }



  /**
   * Model FamilyTreeChild
   */


  export type AggregateFamilyTreeChild = {
    _count: FamilyTreeChildCountAggregateOutputType | null
    _avg: FamilyTreeChildAvgAggregateOutputType | null
    _sum: FamilyTreeChildSumAggregateOutputType | null
    _min: FamilyTreeChildMinAggregateOutputType | null
    _max: FamilyTreeChildMaxAggregateOutputType | null
  }

  export type FamilyTreeChildAvgAggregateOutputType = {
    no: number | null
  }

  export type FamilyTreeChildSumAggregateOutputType = {
    no: number | null
  }

  export type FamilyTreeChildMinAggregateOutputType = {
    id: string | null
    no: number | null
    type: ChildType | null
    kkId: string | null
    personalId: string | null
  }

  export type FamilyTreeChildMaxAggregateOutputType = {
    id: string | null
    no: number | null
    type: ChildType | null
    kkId: string | null
    personalId: string | null
  }

  export type FamilyTreeChildCountAggregateOutputType = {
    id: number
    no: number
    type: number
    kkId: number
    personalId: number
    _all: number
  }


  export type FamilyTreeChildAvgAggregateInputType = {
    no?: true
  }

  export type FamilyTreeChildSumAggregateInputType = {
    no?: true
  }

  export type FamilyTreeChildMinAggregateInputType = {
    id?: true
    no?: true
    type?: true
    kkId?: true
    personalId?: true
  }

  export type FamilyTreeChildMaxAggregateInputType = {
    id?: true
    no?: true
    type?: true
    kkId?: true
    personalId?: true
  }

  export type FamilyTreeChildCountAggregateInputType = {
    id?: true
    no?: true
    type?: true
    kkId?: true
    personalId?: true
    _all?: true
  }

  export type FamilyTreeChildAggregateArgs = {
    /**
     * Filter which FamilyTreeChild to aggregate.
     */
    where?: FamilyTreeChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyTreeChildren to fetch.
     */
    orderBy?: Enumerable<FamilyTreeChildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FamilyTreeChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyTreeChildren from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyTreeChildren.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FamilyTreeChildren
    **/
    _count?: true | FamilyTreeChildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FamilyTreeChildAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FamilyTreeChildSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FamilyTreeChildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FamilyTreeChildMaxAggregateInputType
  }

  export type GetFamilyTreeChildAggregateType<T extends FamilyTreeChildAggregateArgs> = {
        [P in keyof T & keyof AggregateFamilyTreeChild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFamilyTreeChild[P]>
      : GetScalarType<T[P], AggregateFamilyTreeChild[P]>
  }




  export type FamilyTreeChildGroupByArgs = {
    where?: FamilyTreeChildWhereInput
    orderBy?: Enumerable<FamilyTreeChildOrderByWithAggregationInput>
    by: FamilyTreeChildScalarFieldEnum[]
    having?: FamilyTreeChildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FamilyTreeChildCountAggregateInputType | true
    _avg?: FamilyTreeChildAvgAggregateInputType
    _sum?: FamilyTreeChildSumAggregateInputType
    _min?: FamilyTreeChildMinAggregateInputType
    _max?: FamilyTreeChildMaxAggregateInputType
  }


  export type FamilyTreeChildGroupByOutputType = {
    id: string
    no: number
    type: ChildType
    kkId: string
    personalId: string
    _count: FamilyTreeChildCountAggregateOutputType | null
    _avg: FamilyTreeChildAvgAggregateOutputType | null
    _sum: FamilyTreeChildSumAggregateOutputType | null
    _min: FamilyTreeChildMinAggregateOutputType | null
    _max: FamilyTreeChildMaxAggregateOutputType | null
  }

  type GetFamilyTreeChildGroupByPayload<T extends FamilyTreeChildGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FamilyTreeChildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FamilyTreeChildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FamilyTreeChildGroupByOutputType[P]>
            : GetScalarType<T[P], FamilyTreeChildGroupByOutputType[P]>
        }
      >
    >


  export type FamilyTreeChildSelect = {
    id?: boolean
    no?: boolean
    type?: boolean
    kkId?: boolean
    personalId?: boolean
    kk?: boolean | FamilyTreeArgs
    personal?: boolean | PersonalArgs
  }


  export type FamilyTreeChildInclude = {
    kk?: boolean | FamilyTreeArgs
    personal?: boolean | PersonalArgs
  }

  export type FamilyTreeChildGetPayload<S extends boolean | null | undefined | FamilyTreeChildArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FamilyTreeChild :
    S extends undefined ? never :
    S extends { include: any } & (FamilyTreeChildArgs | FamilyTreeChildFindManyArgs)
    ? FamilyTreeChild  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'kk' ? FamilyTreeGetPayload<S['include'][P]> :
        P extends 'personal' ? PersonalGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FamilyTreeChildArgs | FamilyTreeChildFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'kk' ? FamilyTreeGetPayload<S['select'][P]> :
        P extends 'personal' ? PersonalGetPayload<S['select'][P]> :  P extends keyof FamilyTreeChild ? FamilyTreeChild[P] : never
  } 
      : FamilyTreeChild


  type FamilyTreeChildCountArgs = 
    Omit<FamilyTreeChildFindManyArgs, 'select' | 'include'> & {
      select?: FamilyTreeChildCountAggregateInputType | true
    }

  export interface FamilyTreeChildDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FamilyTreeChild that matches the filter.
     * @param {FamilyTreeChildFindUniqueArgs} args - Arguments to find a FamilyTreeChild
     * @example
     * // Get one FamilyTreeChild
     * const familyTreeChild = await prisma.familyTreeChild.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FamilyTreeChildFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FamilyTreeChildFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FamilyTreeChild'> extends True ? Prisma__FamilyTreeChildClient<FamilyTreeChildGetPayload<T>> : Prisma__FamilyTreeChildClient<FamilyTreeChildGetPayload<T> | null, null>

    /**
     * Find one FamilyTreeChild that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FamilyTreeChildFindUniqueOrThrowArgs} args - Arguments to find a FamilyTreeChild
     * @example
     * // Get one FamilyTreeChild
     * const familyTreeChild = await prisma.familyTreeChild.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FamilyTreeChildFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FamilyTreeChildFindUniqueOrThrowArgs>
    ): Prisma__FamilyTreeChildClient<FamilyTreeChildGetPayload<T>>

    /**
     * Find the first FamilyTreeChild that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeChildFindFirstArgs} args - Arguments to find a FamilyTreeChild
     * @example
     * // Get one FamilyTreeChild
     * const familyTreeChild = await prisma.familyTreeChild.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FamilyTreeChildFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FamilyTreeChildFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FamilyTreeChild'> extends True ? Prisma__FamilyTreeChildClient<FamilyTreeChildGetPayload<T>> : Prisma__FamilyTreeChildClient<FamilyTreeChildGetPayload<T> | null, null>

    /**
     * Find the first FamilyTreeChild that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeChildFindFirstOrThrowArgs} args - Arguments to find a FamilyTreeChild
     * @example
     * // Get one FamilyTreeChild
     * const familyTreeChild = await prisma.familyTreeChild.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FamilyTreeChildFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FamilyTreeChildFindFirstOrThrowArgs>
    ): Prisma__FamilyTreeChildClient<FamilyTreeChildGetPayload<T>>

    /**
     * Find zero or more FamilyTreeChildren that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeChildFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FamilyTreeChildren
     * const familyTreeChildren = await prisma.familyTreeChild.findMany()
     * 
     * // Get first 10 FamilyTreeChildren
     * const familyTreeChildren = await prisma.familyTreeChild.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const familyTreeChildWithIdOnly = await prisma.familyTreeChild.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FamilyTreeChildFindManyArgs>(
      args?: SelectSubset<T, FamilyTreeChildFindManyArgs>
    ): Prisma.PrismaPromise<Array<FamilyTreeChildGetPayload<T>>>

    /**
     * Create a FamilyTreeChild.
     * @param {FamilyTreeChildCreateArgs} args - Arguments to create a FamilyTreeChild.
     * @example
     * // Create one FamilyTreeChild
     * const FamilyTreeChild = await prisma.familyTreeChild.create({
     *   data: {
     *     // ... data to create a FamilyTreeChild
     *   }
     * })
     * 
    **/
    create<T extends FamilyTreeChildCreateArgs>(
      args: SelectSubset<T, FamilyTreeChildCreateArgs>
    ): Prisma__FamilyTreeChildClient<FamilyTreeChildGetPayload<T>>

    /**
     * Create many FamilyTreeChildren.
     *     @param {FamilyTreeChildCreateManyArgs} args - Arguments to create many FamilyTreeChildren.
     *     @example
     *     // Create many FamilyTreeChildren
     *     const familyTreeChild = await prisma.familyTreeChild.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FamilyTreeChildCreateManyArgs>(
      args?: SelectSubset<T, FamilyTreeChildCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FamilyTreeChild.
     * @param {FamilyTreeChildDeleteArgs} args - Arguments to delete one FamilyTreeChild.
     * @example
     * // Delete one FamilyTreeChild
     * const FamilyTreeChild = await prisma.familyTreeChild.delete({
     *   where: {
     *     // ... filter to delete one FamilyTreeChild
     *   }
     * })
     * 
    **/
    delete<T extends FamilyTreeChildDeleteArgs>(
      args: SelectSubset<T, FamilyTreeChildDeleteArgs>
    ): Prisma__FamilyTreeChildClient<FamilyTreeChildGetPayload<T>>

    /**
     * Update one FamilyTreeChild.
     * @param {FamilyTreeChildUpdateArgs} args - Arguments to update one FamilyTreeChild.
     * @example
     * // Update one FamilyTreeChild
     * const familyTreeChild = await prisma.familyTreeChild.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FamilyTreeChildUpdateArgs>(
      args: SelectSubset<T, FamilyTreeChildUpdateArgs>
    ): Prisma__FamilyTreeChildClient<FamilyTreeChildGetPayload<T>>

    /**
     * Delete zero or more FamilyTreeChildren.
     * @param {FamilyTreeChildDeleteManyArgs} args - Arguments to filter FamilyTreeChildren to delete.
     * @example
     * // Delete a few FamilyTreeChildren
     * const { count } = await prisma.familyTreeChild.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FamilyTreeChildDeleteManyArgs>(
      args?: SelectSubset<T, FamilyTreeChildDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FamilyTreeChildren.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeChildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FamilyTreeChildren
     * const familyTreeChild = await prisma.familyTreeChild.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FamilyTreeChildUpdateManyArgs>(
      args: SelectSubset<T, FamilyTreeChildUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FamilyTreeChild.
     * @param {FamilyTreeChildUpsertArgs} args - Arguments to update or create a FamilyTreeChild.
     * @example
     * // Update or create a FamilyTreeChild
     * const familyTreeChild = await prisma.familyTreeChild.upsert({
     *   create: {
     *     // ... data to create a FamilyTreeChild
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FamilyTreeChild we want to update
     *   }
     * })
    **/
    upsert<T extends FamilyTreeChildUpsertArgs>(
      args: SelectSubset<T, FamilyTreeChildUpsertArgs>
    ): Prisma__FamilyTreeChildClient<FamilyTreeChildGetPayload<T>>

    /**
     * Find zero or more FamilyTreeChildren that matches the filter.
     * @param {FamilyTreeChildFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const familyTreeChild = await prisma.familyTreeChild.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: FamilyTreeChildFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a FamilyTreeChild.
     * @param {FamilyTreeChildAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const familyTreeChild = await prisma.familyTreeChild.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: FamilyTreeChildAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of FamilyTreeChildren.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeChildCountArgs} args - Arguments to filter FamilyTreeChildren to count.
     * @example
     * // Count the number of FamilyTreeChildren
     * const count = await prisma.familyTreeChild.count({
     *   where: {
     *     // ... the filter for the FamilyTreeChildren we want to count
     *   }
     * })
    **/
    count<T extends FamilyTreeChildCountArgs>(
      args?: Subset<T, FamilyTreeChildCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FamilyTreeChildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FamilyTreeChild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeChildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FamilyTreeChildAggregateArgs>(args: Subset<T, FamilyTreeChildAggregateArgs>): Prisma.PrismaPromise<GetFamilyTreeChildAggregateType<T>>

    /**
     * Group by FamilyTreeChild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeChildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FamilyTreeChildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FamilyTreeChildGroupByArgs['orderBy'] }
        : { orderBy?: FamilyTreeChildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FamilyTreeChildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFamilyTreeChildGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FamilyTreeChild.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FamilyTreeChildClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    kk<T extends FamilyTreeArgs= {}>(args?: Subset<T, FamilyTreeArgs>): Prisma__FamilyTreeClient<FamilyTreeGetPayload<T> | Null>;

    personal<T extends PersonalArgs= {}>(args?: Subset<T, PersonalArgs>): Prisma__PersonalClient<PersonalGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FamilyTreeChild base type for findUnique actions
   */
  export type FamilyTreeChildFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FamilyTreeChild
     */
    select?: FamilyTreeChildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeChildInclude | null
    /**
     * Filter, which FamilyTreeChild to fetch.
     */
    where: FamilyTreeChildWhereUniqueInput
  }

  /**
   * FamilyTreeChild findUnique
   */
  export interface FamilyTreeChildFindUniqueArgs extends FamilyTreeChildFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FamilyTreeChild findUniqueOrThrow
   */
  export type FamilyTreeChildFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FamilyTreeChild
     */
    select?: FamilyTreeChildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeChildInclude | null
    /**
     * Filter, which FamilyTreeChild to fetch.
     */
    where: FamilyTreeChildWhereUniqueInput
  }


  /**
   * FamilyTreeChild base type for findFirst actions
   */
  export type FamilyTreeChildFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FamilyTreeChild
     */
    select?: FamilyTreeChildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeChildInclude | null
    /**
     * Filter, which FamilyTreeChild to fetch.
     */
    where?: FamilyTreeChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyTreeChildren to fetch.
     */
    orderBy?: Enumerable<FamilyTreeChildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyTreeChildren.
     */
    cursor?: FamilyTreeChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyTreeChildren from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyTreeChildren.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyTreeChildren.
     */
    distinct?: Enumerable<FamilyTreeChildScalarFieldEnum>
  }

  /**
   * FamilyTreeChild findFirst
   */
  export interface FamilyTreeChildFindFirstArgs extends FamilyTreeChildFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FamilyTreeChild findFirstOrThrow
   */
  export type FamilyTreeChildFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FamilyTreeChild
     */
    select?: FamilyTreeChildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeChildInclude | null
    /**
     * Filter, which FamilyTreeChild to fetch.
     */
    where?: FamilyTreeChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyTreeChildren to fetch.
     */
    orderBy?: Enumerable<FamilyTreeChildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyTreeChildren.
     */
    cursor?: FamilyTreeChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyTreeChildren from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyTreeChildren.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyTreeChildren.
     */
    distinct?: Enumerable<FamilyTreeChildScalarFieldEnum>
  }


  /**
   * FamilyTreeChild findMany
   */
  export type FamilyTreeChildFindManyArgs = {
    /**
     * Select specific fields to fetch from the FamilyTreeChild
     */
    select?: FamilyTreeChildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeChildInclude | null
    /**
     * Filter, which FamilyTreeChildren to fetch.
     */
    where?: FamilyTreeChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyTreeChildren to fetch.
     */
    orderBy?: Enumerable<FamilyTreeChildOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FamilyTreeChildren.
     */
    cursor?: FamilyTreeChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyTreeChildren from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyTreeChildren.
     */
    skip?: number
    distinct?: Enumerable<FamilyTreeChildScalarFieldEnum>
  }


  /**
   * FamilyTreeChild create
   */
  export type FamilyTreeChildCreateArgs = {
    /**
     * Select specific fields to fetch from the FamilyTreeChild
     */
    select?: FamilyTreeChildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeChildInclude | null
    /**
     * The data needed to create a FamilyTreeChild.
     */
    data: XOR<FamilyTreeChildCreateInput, FamilyTreeChildUncheckedCreateInput>
  }


  /**
   * FamilyTreeChild createMany
   */
  export type FamilyTreeChildCreateManyArgs = {
    /**
     * The data used to create many FamilyTreeChildren.
     */
    data: Enumerable<FamilyTreeChildCreateManyInput>
  }


  /**
   * FamilyTreeChild update
   */
  export type FamilyTreeChildUpdateArgs = {
    /**
     * Select specific fields to fetch from the FamilyTreeChild
     */
    select?: FamilyTreeChildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeChildInclude | null
    /**
     * The data needed to update a FamilyTreeChild.
     */
    data: XOR<FamilyTreeChildUpdateInput, FamilyTreeChildUncheckedUpdateInput>
    /**
     * Choose, which FamilyTreeChild to update.
     */
    where: FamilyTreeChildWhereUniqueInput
  }


  /**
   * FamilyTreeChild updateMany
   */
  export type FamilyTreeChildUpdateManyArgs = {
    /**
     * The data used to update FamilyTreeChildren.
     */
    data: XOR<FamilyTreeChildUpdateManyMutationInput, FamilyTreeChildUncheckedUpdateManyInput>
    /**
     * Filter which FamilyTreeChildren to update
     */
    where?: FamilyTreeChildWhereInput
  }


  /**
   * FamilyTreeChild upsert
   */
  export type FamilyTreeChildUpsertArgs = {
    /**
     * Select specific fields to fetch from the FamilyTreeChild
     */
    select?: FamilyTreeChildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeChildInclude | null
    /**
     * The filter to search for the FamilyTreeChild to update in case it exists.
     */
    where: FamilyTreeChildWhereUniqueInput
    /**
     * In case the FamilyTreeChild found by the `where` argument doesn't exist, create a new FamilyTreeChild with this data.
     */
    create: XOR<FamilyTreeChildCreateInput, FamilyTreeChildUncheckedCreateInput>
    /**
     * In case the FamilyTreeChild was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FamilyTreeChildUpdateInput, FamilyTreeChildUncheckedUpdateInput>
  }


  /**
   * FamilyTreeChild delete
   */
  export type FamilyTreeChildDeleteArgs = {
    /**
     * Select specific fields to fetch from the FamilyTreeChild
     */
    select?: FamilyTreeChildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeChildInclude | null
    /**
     * Filter which FamilyTreeChild to delete.
     */
    where: FamilyTreeChildWhereUniqueInput
  }


  /**
   * FamilyTreeChild deleteMany
   */
  export type FamilyTreeChildDeleteManyArgs = {
    /**
     * Filter which FamilyTreeChildren to delete
     */
    where?: FamilyTreeChildWhereInput
  }


  /**
   * FamilyTreeChild findRaw
   */
  export type FamilyTreeChildFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * FamilyTreeChild aggregateRaw
   */
  export type FamilyTreeChildAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * FamilyTreeChild without action
   */
  export type FamilyTreeChildArgs = {
    /**
     * Select specific fields to fetch from the FamilyTreeChild
     */
    select?: FamilyTreeChildSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FamilyTreeChildInclude | null
  }



  /**
   * Model SchoolYear
   */


  export type AggregateSchoolYear = {
    _count: SchoolYearCountAggregateOutputType | null
    _avg: SchoolYearAvgAggregateOutputType | null
    _sum: SchoolYearSumAggregateOutputType | null
    _min: SchoolYearMinAggregateOutputType | null
    _max: SchoolYearMaxAggregateOutputType | null
  }

  export type SchoolYearAvgAggregateOutputType = {
    year: number | null
  }

  export type SchoolYearSumAggregateOutputType = {
    year: number | null
  }

  export type SchoolYearMinAggregateOutputType = {
    id: string | null
    year: number | null
    instansiId: string | null
    disable: boolean | null
  }

  export type SchoolYearMaxAggregateOutputType = {
    id: string | null
    year: number | null
    instansiId: string | null
    disable: boolean | null
  }

  export type SchoolYearCountAggregateOutputType = {
    id: number
    year: number
    instansiId: number
    departments: number
    disable: number
    _all: number
  }


  export type SchoolYearAvgAggregateInputType = {
    year?: true
  }

  export type SchoolYearSumAggregateInputType = {
    year?: true
  }

  export type SchoolYearMinAggregateInputType = {
    id?: true
    year?: true
    instansiId?: true
    disable?: true
  }

  export type SchoolYearMaxAggregateInputType = {
    id?: true
    year?: true
    instansiId?: true
    disable?: true
  }

  export type SchoolYearCountAggregateInputType = {
    id?: true
    year?: true
    instansiId?: true
    departments?: true
    disable?: true
    _all?: true
  }

  export type SchoolYearAggregateArgs = {
    /**
     * Filter which SchoolYear to aggregate.
     */
    where?: SchoolYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolYears to fetch.
     */
    orderBy?: Enumerable<SchoolYearOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolYears
    **/
    _count?: true | SchoolYearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SchoolYearAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SchoolYearSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolYearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolYearMaxAggregateInputType
  }

  export type GetSchoolYearAggregateType<T extends SchoolYearAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolYear]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolYear[P]>
      : GetScalarType<T[P], AggregateSchoolYear[P]>
  }




  export type SchoolYearGroupByArgs = {
    where?: SchoolYearWhereInput
    orderBy?: Enumerable<SchoolYearOrderByWithAggregationInput>
    by: SchoolYearScalarFieldEnum[]
    having?: SchoolYearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolYearCountAggregateInputType | true
    _avg?: SchoolYearAvgAggregateInputType
    _sum?: SchoolYearSumAggregateInputType
    _min?: SchoolYearMinAggregateInputType
    _max?: SchoolYearMaxAggregateInputType
  }


  export type SchoolYearGroupByOutputType = {
    id: string
    year: number
    instansiId: string
    departments: string[]
    disable: boolean
    _count: SchoolYearCountAggregateOutputType | null
    _avg: SchoolYearAvgAggregateOutputType | null
    _sum: SchoolYearSumAggregateOutputType | null
    _min: SchoolYearMinAggregateOutputType | null
    _max: SchoolYearMaxAggregateOutputType | null
  }

  type GetSchoolYearGroupByPayload<T extends SchoolYearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SchoolYearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolYearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolYearGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolYearGroupByOutputType[P]>
        }
      >
    >


  export type SchoolYearSelect = {
    id?: boolean
    year?: boolean
    instansiId?: boolean
    departments?: boolean
    organizational?: boolean | OrganizationalArgs
    disable?: boolean
    instansi?: boolean | InstansiArgs
    classRoom?: boolean | SchoolYear$classRoomArgs
    students?: boolean | SchoolYear$studentsArgs
    calendar?: boolean | SchoolYear$calendarArgs
    schedule?: boolean | SchoolYear$scheduleArgs
    objective?: boolean | SchoolYear$objectiveArgs
    tracker?: boolean | SchoolYear$trackerArgs
    TDevice?: boolean | SchoolYear$TDeviceArgs
    _count?: boolean | SchoolYearCountOutputTypeArgs
  }


  export type SchoolYearInclude = {
    instansi?: boolean | InstansiArgs
    classRoom?: boolean | SchoolYear$classRoomArgs
    students?: boolean | SchoolYear$studentsArgs
    calendar?: boolean | SchoolYear$calendarArgs
    schedule?: boolean | SchoolYear$scheduleArgs
    objective?: boolean | SchoolYear$objectiveArgs
    tracker?: boolean | SchoolYear$trackerArgs
    TDevice?: boolean | SchoolYear$TDeviceArgs
    _count?: boolean | SchoolYearCountOutputTypeArgs
  }

  export type SchoolYearGetPayload<S extends boolean | null | undefined | SchoolYearArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SchoolYear :
    S extends undefined ? never :
    S extends { include: any } & (SchoolYearArgs | SchoolYearFindManyArgs)
    ? SchoolYear  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'instansi' ? InstansiGetPayload<S['include'][P]> :
        P extends 'classRoom' ? Array < ClassRoomGetPayload<S['include'][P]>>  :
        P extends 'students' ? Array < StudentGetPayload<S['include'][P]>>  :
        P extends 'calendar' ? Array < CalendarGetPayload<S['include'][P]>>  :
        P extends 'schedule' ? Array < ScheduleGetPayload<S['include'][P]>>  :
        P extends 'objective' ? Array < ObjectiveGetPayload<S['include'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['include'][P]>>  :
        P extends 'TDevice' ? Array < TDeviceGetPayload<S['include'][P]>>  :
        P extends '_count' ? SchoolYearCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SchoolYearArgs | SchoolYearFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'organizational' ? OrganizationalGetPayload<S['select'][P]> :
        P extends 'instansi' ? InstansiGetPayload<S['select'][P]> :
        P extends 'classRoom' ? Array < ClassRoomGetPayload<S['select'][P]>>  :
        P extends 'students' ? Array < StudentGetPayload<S['select'][P]>>  :
        P extends 'calendar' ? Array < CalendarGetPayload<S['select'][P]>>  :
        P extends 'schedule' ? Array < ScheduleGetPayload<S['select'][P]>>  :
        P extends 'objective' ? Array < ObjectiveGetPayload<S['select'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['select'][P]>>  :
        P extends 'TDevice' ? Array < TDeviceGetPayload<S['select'][P]>>  :
        P extends '_count' ? SchoolYearCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof SchoolYear ? SchoolYear[P] : never
  } 
      : SchoolYear


  type SchoolYearCountArgs = 
    Omit<SchoolYearFindManyArgs, 'select' | 'include'> & {
      select?: SchoolYearCountAggregateInputType | true
    }

  export interface SchoolYearDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SchoolYear that matches the filter.
     * @param {SchoolYearFindUniqueArgs} args - Arguments to find a SchoolYear
     * @example
     * // Get one SchoolYear
     * const schoolYear = await prisma.schoolYear.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SchoolYearFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SchoolYearFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SchoolYear'> extends True ? Prisma__SchoolYearClient<SchoolYearGetPayload<T>> : Prisma__SchoolYearClient<SchoolYearGetPayload<T> | null, null>

    /**
     * Find one SchoolYear that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SchoolYearFindUniqueOrThrowArgs} args - Arguments to find a SchoolYear
     * @example
     * // Get one SchoolYear
     * const schoolYear = await prisma.schoolYear.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SchoolYearFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SchoolYearFindUniqueOrThrowArgs>
    ): Prisma__SchoolYearClient<SchoolYearGetPayload<T>>

    /**
     * Find the first SchoolYear that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolYearFindFirstArgs} args - Arguments to find a SchoolYear
     * @example
     * // Get one SchoolYear
     * const schoolYear = await prisma.schoolYear.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SchoolYearFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SchoolYearFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SchoolYear'> extends True ? Prisma__SchoolYearClient<SchoolYearGetPayload<T>> : Prisma__SchoolYearClient<SchoolYearGetPayload<T> | null, null>

    /**
     * Find the first SchoolYear that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolYearFindFirstOrThrowArgs} args - Arguments to find a SchoolYear
     * @example
     * // Get one SchoolYear
     * const schoolYear = await prisma.schoolYear.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SchoolYearFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SchoolYearFindFirstOrThrowArgs>
    ): Prisma__SchoolYearClient<SchoolYearGetPayload<T>>

    /**
     * Find zero or more SchoolYears that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolYearFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolYears
     * const schoolYears = await prisma.schoolYear.findMany()
     * 
     * // Get first 10 SchoolYears
     * const schoolYears = await prisma.schoolYear.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolYearWithIdOnly = await prisma.schoolYear.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SchoolYearFindManyArgs>(
      args?: SelectSubset<T, SchoolYearFindManyArgs>
    ): Prisma.PrismaPromise<Array<SchoolYearGetPayload<T>>>

    /**
     * Create a SchoolYear.
     * @param {SchoolYearCreateArgs} args - Arguments to create a SchoolYear.
     * @example
     * // Create one SchoolYear
     * const SchoolYear = await prisma.schoolYear.create({
     *   data: {
     *     // ... data to create a SchoolYear
     *   }
     * })
     * 
    **/
    create<T extends SchoolYearCreateArgs>(
      args: SelectSubset<T, SchoolYearCreateArgs>
    ): Prisma__SchoolYearClient<SchoolYearGetPayload<T>>

    /**
     * Create many SchoolYears.
     *     @param {SchoolYearCreateManyArgs} args - Arguments to create many SchoolYears.
     *     @example
     *     // Create many SchoolYears
     *     const schoolYear = await prisma.schoolYear.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SchoolYearCreateManyArgs>(
      args?: SelectSubset<T, SchoolYearCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SchoolYear.
     * @param {SchoolYearDeleteArgs} args - Arguments to delete one SchoolYear.
     * @example
     * // Delete one SchoolYear
     * const SchoolYear = await prisma.schoolYear.delete({
     *   where: {
     *     // ... filter to delete one SchoolYear
     *   }
     * })
     * 
    **/
    delete<T extends SchoolYearDeleteArgs>(
      args: SelectSubset<T, SchoolYearDeleteArgs>
    ): Prisma__SchoolYearClient<SchoolYearGetPayload<T>>

    /**
     * Update one SchoolYear.
     * @param {SchoolYearUpdateArgs} args - Arguments to update one SchoolYear.
     * @example
     * // Update one SchoolYear
     * const schoolYear = await prisma.schoolYear.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SchoolYearUpdateArgs>(
      args: SelectSubset<T, SchoolYearUpdateArgs>
    ): Prisma__SchoolYearClient<SchoolYearGetPayload<T>>

    /**
     * Delete zero or more SchoolYears.
     * @param {SchoolYearDeleteManyArgs} args - Arguments to filter SchoolYears to delete.
     * @example
     * // Delete a few SchoolYears
     * const { count } = await prisma.schoolYear.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SchoolYearDeleteManyArgs>(
      args?: SelectSubset<T, SchoolYearDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolYearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolYears
     * const schoolYear = await prisma.schoolYear.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SchoolYearUpdateManyArgs>(
      args: SelectSubset<T, SchoolYearUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SchoolYear.
     * @param {SchoolYearUpsertArgs} args - Arguments to update or create a SchoolYear.
     * @example
     * // Update or create a SchoolYear
     * const schoolYear = await prisma.schoolYear.upsert({
     *   create: {
     *     // ... data to create a SchoolYear
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolYear we want to update
     *   }
     * })
    **/
    upsert<T extends SchoolYearUpsertArgs>(
      args: SelectSubset<T, SchoolYearUpsertArgs>
    ): Prisma__SchoolYearClient<SchoolYearGetPayload<T>>

    /**
     * Find zero or more SchoolYears that matches the filter.
     * @param {SchoolYearFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const schoolYear = await prisma.schoolYear.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: SchoolYearFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SchoolYear.
     * @param {SchoolYearAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const schoolYear = await prisma.schoolYear.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: SchoolYearAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of SchoolYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolYearCountArgs} args - Arguments to filter SchoolYears to count.
     * @example
     * // Count the number of SchoolYears
     * const count = await prisma.schoolYear.count({
     *   where: {
     *     // ... the filter for the SchoolYears we want to count
     *   }
     * })
    **/
    count<T extends SchoolYearCountArgs>(
      args?: Subset<T, SchoolYearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolYearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolYearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolYearAggregateArgs>(args: Subset<T, SchoolYearAggregateArgs>): Prisma.PrismaPromise<GetSchoolYearAggregateType<T>>

    /**
     * Group by SchoolYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolYearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolYearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolYearGroupByArgs['orderBy'] }
        : { orderBy?: SchoolYearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolYearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolYearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolYear.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SchoolYearClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    organizational<T extends OrganizationalArgs= {}>(args?: Subset<T, OrganizationalArgs>): Prisma__OrganizationalClient<OrganizationalGetPayload<T> | Null>;

    instansi<T extends InstansiArgs= {}>(args?: Subset<T, InstansiArgs>): Prisma__InstansiClient<InstansiGetPayload<T> | Null>;

    classRoom<T extends SchoolYear$classRoomArgs= {}>(args?: Subset<T, SchoolYear$classRoomArgs>): Prisma.PrismaPromise<Array<ClassRoomGetPayload<T>>| Null>;

    students<T extends SchoolYear$studentsArgs= {}>(args?: Subset<T, SchoolYear$studentsArgs>): Prisma.PrismaPromise<Array<StudentGetPayload<T>>| Null>;

    calendar<T extends SchoolYear$calendarArgs= {}>(args?: Subset<T, SchoolYear$calendarArgs>): Prisma.PrismaPromise<Array<CalendarGetPayload<T>>| Null>;

    schedule<T extends SchoolYear$scheduleArgs= {}>(args?: Subset<T, SchoolYear$scheduleArgs>): Prisma.PrismaPromise<Array<ScheduleGetPayload<T>>| Null>;

    objective<T extends SchoolYear$objectiveArgs= {}>(args?: Subset<T, SchoolYear$objectiveArgs>): Prisma.PrismaPromise<Array<ObjectiveGetPayload<T>>| Null>;

    tracker<T extends SchoolYear$trackerArgs= {}>(args?: Subset<T, SchoolYear$trackerArgs>): Prisma.PrismaPromise<Array<TrackerGetPayload<T>>| Null>;

    TDevice<T extends SchoolYear$TDeviceArgs= {}>(args?: Subset<T, SchoolYear$TDeviceArgs>): Prisma.PrismaPromise<Array<TDeviceGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SchoolYear base type for findUnique actions
   */
  export type SchoolYearFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SchoolYear
     */
    select?: SchoolYearSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolYearInclude | null
    /**
     * Filter, which SchoolYear to fetch.
     */
    where: SchoolYearWhereUniqueInput
  }

  /**
   * SchoolYear findUnique
   */
  export interface SchoolYearFindUniqueArgs extends SchoolYearFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SchoolYear findUniqueOrThrow
   */
  export type SchoolYearFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SchoolYear
     */
    select?: SchoolYearSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolYearInclude | null
    /**
     * Filter, which SchoolYear to fetch.
     */
    where: SchoolYearWhereUniqueInput
  }


  /**
   * SchoolYear base type for findFirst actions
   */
  export type SchoolYearFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SchoolYear
     */
    select?: SchoolYearSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolYearInclude | null
    /**
     * Filter, which SchoolYear to fetch.
     */
    where?: SchoolYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolYears to fetch.
     */
    orderBy?: Enumerable<SchoolYearOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolYears.
     */
    cursor?: SchoolYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolYears.
     */
    distinct?: Enumerable<SchoolYearScalarFieldEnum>
  }

  /**
   * SchoolYear findFirst
   */
  export interface SchoolYearFindFirstArgs extends SchoolYearFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SchoolYear findFirstOrThrow
   */
  export type SchoolYearFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SchoolYear
     */
    select?: SchoolYearSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolYearInclude | null
    /**
     * Filter, which SchoolYear to fetch.
     */
    where?: SchoolYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolYears to fetch.
     */
    orderBy?: Enumerable<SchoolYearOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolYears.
     */
    cursor?: SchoolYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolYears.
     */
    distinct?: Enumerable<SchoolYearScalarFieldEnum>
  }


  /**
   * SchoolYear findMany
   */
  export type SchoolYearFindManyArgs = {
    /**
     * Select specific fields to fetch from the SchoolYear
     */
    select?: SchoolYearSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolYearInclude | null
    /**
     * Filter, which SchoolYears to fetch.
     */
    where?: SchoolYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolYears to fetch.
     */
    orderBy?: Enumerable<SchoolYearOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolYears.
     */
    cursor?: SchoolYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolYears.
     */
    skip?: number
    distinct?: Enumerable<SchoolYearScalarFieldEnum>
  }


  /**
   * SchoolYear create
   */
  export type SchoolYearCreateArgs = {
    /**
     * Select specific fields to fetch from the SchoolYear
     */
    select?: SchoolYearSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolYearInclude | null
    /**
     * The data needed to create a SchoolYear.
     */
    data: XOR<SchoolYearCreateInput, SchoolYearUncheckedCreateInput>
  }


  /**
   * SchoolYear createMany
   */
  export type SchoolYearCreateManyArgs = {
    /**
     * The data used to create many SchoolYears.
     */
    data: Enumerable<SchoolYearCreateManyInput>
  }


  /**
   * SchoolYear update
   */
  export type SchoolYearUpdateArgs = {
    /**
     * Select specific fields to fetch from the SchoolYear
     */
    select?: SchoolYearSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolYearInclude | null
    /**
     * The data needed to update a SchoolYear.
     */
    data: XOR<SchoolYearUpdateInput, SchoolYearUncheckedUpdateInput>
    /**
     * Choose, which SchoolYear to update.
     */
    where: SchoolYearWhereUniqueInput
  }


  /**
   * SchoolYear updateMany
   */
  export type SchoolYearUpdateManyArgs = {
    /**
     * The data used to update SchoolYears.
     */
    data: XOR<SchoolYearUpdateManyMutationInput, SchoolYearUncheckedUpdateManyInput>
    /**
     * Filter which SchoolYears to update
     */
    where?: SchoolYearWhereInput
  }


  /**
   * SchoolYear upsert
   */
  export type SchoolYearUpsertArgs = {
    /**
     * Select specific fields to fetch from the SchoolYear
     */
    select?: SchoolYearSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolYearInclude | null
    /**
     * The filter to search for the SchoolYear to update in case it exists.
     */
    where: SchoolYearWhereUniqueInput
    /**
     * In case the SchoolYear found by the `where` argument doesn't exist, create a new SchoolYear with this data.
     */
    create: XOR<SchoolYearCreateInput, SchoolYearUncheckedCreateInput>
    /**
     * In case the SchoolYear was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolYearUpdateInput, SchoolYearUncheckedUpdateInput>
  }


  /**
   * SchoolYear delete
   */
  export type SchoolYearDeleteArgs = {
    /**
     * Select specific fields to fetch from the SchoolYear
     */
    select?: SchoolYearSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolYearInclude | null
    /**
     * Filter which SchoolYear to delete.
     */
    where: SchoolYearWhereUniqueInput
  }


  /**
   * SchoolYear deleteMany
   */
  export type SchoolYearDeleteManyArgs = {
    /**
     * Filter which SchoolYears to delete
     */
    where?: SchoolYearWhereInput
  }


  /**
   * SchoolYear findRaw
   */
  export type SchoolYearFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * SchoolYear aggregateRaw
   */
  export type SchoolYearAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * SchoolYear.classRoom
   */
  export type SchoolYear$classRoomArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    where?: ClassRoomWhereInput
    orderBy?: Enumerable<ClassRoomOrderByWithRelationInput>
    cursor?: ClassRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ClassRoomScalarFieldEnum>
  }


  /**
   * SchoolYear.students
   */
  export type SchoolYear$studentsArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    where?: StudentWhereInput
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * SchoolYear.calendar
   */
  export type SchoolYear$calendarArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    where?: CalendarWhereInput
    orderBy?: Enumerable<CalendarOrderByWithRelationInput>
    cursor?: CalendarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CalendarScalarFieldEnum>
  }


  /**
   * SchoolYear.schedule
   */
  export type SchoolYear$scheduleArgs = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScheduleInclude | null
    where?: ScheduleWhereInput
    orderBy?: Enumerable<ScheduleOrderByWithRelationInput>
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ScheduleScalarFieldEnum>
  }


  /**
   * SchoolYear.objective
   */
  export type SchoolYear$objectiveArgs = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectiveInclude | null
    where?: ObjectiveWhereInput
    orderBy?: Enumerable<ObjectiveOrderByWithRelationInput>
    cursor?: ObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ObjectiveScalarFieldEnum>
  }


  /**
   * SchoolYear.tracker
   */
  export type SchoolYear$trackerArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    where?: TrackerWhereInput
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    cursor?: TrackerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TrackerScalarFieldEnum>
  }


  /**
   * SchoolYear.TDevice
   */
  export type SchoolYear$TDeviceArgs = {
    /**
     * Select specific fields to fetch from the TDevice
     */
    select?: TDeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceInclude | null
    where?: TDeviceWhereInput
    orderBy?: Enumerable<TDeviceOrderByWithRelationInput>
    cursor?: TDeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TDeviceScalarFieldEnum>
  }


  /**
   * SchoolYear without action
   */
  export type SchoolYearArgs = {
    /**
     * Select specific fields to fetch from the SchoolYear
     */
    select?: SchoolYearSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolYearInclude | null
  }



  /**
   * Model Teacher
   */


  export type AggregateTeacher = {
    _count: TeacherCountAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  export type TeacherMinAggregateOutputType = {
    id: string | null
    personalId: string | null
    instansiId: string | null
    nip: string | null
    nrg: string | null
    noKarpeg: string | null
    tmtTugas: Date | null
    tmtGol: Date | null
    position: string | null
    rank: string | null
    period: string | null
    certificate: string | null
    disable: boolean | null
  }

  export type TeacherMaxAggregateOutputType = {
    id: string | null
    personalId: string | null
    instansiId: string | null
    nip: string | null
    nrg: string | null
    noKarpeg: string | null
    tmtTugas: Date | null
    tmtGol: Date | null
    position: string | null
    rank: string | null
    period: string | null
    certificate: string | null
    disable: boolean | null
  }

  export type TeacherCountAggregateOutputType = {
    id: number
    personalId: number
    instansiId: number
    eventIds: number
    nip: number
    nrg: number
    noKarpeg: number
    tmtTugas: number
    tmtGol: number
    position: number
    rank: number
    period: number
    certificate: number
    disable: number
    _all: number
  }


  export type TeacherMinAggregateInputType = {
    id?: true
    personalId?: true
    instansiId?: true
    nip?: true
    nrg?: true
    noKarpeg?: true
    tmtTugas?: true
    tmtGol?: true
    position?: true
    rank?: true
    period?: true
    certificate?: true
    disable?: true
  }

  export type TeacherMaxAggregateInputType = {
    id?: true
    personalId?: true
    instansiId?: true
    nip?: true
    nrg?: true
    noKarpeg?: true
    tmtTugas?: true
    tmtGol?: true
    position?: true
    rank?: true
    period?: true
    certificate?: true
    disable?: true
  }

  export type TeacherCountAggregateInputType = {
    id?: true
    personalId?: true
    instansiId?: true
    eventIds?: true
    nip?: true
    nrg?: true
    noKarpeg?: true
    tmtTugas?: true
    tmtGol?: true
    position?: true
    rank?: true
    period?: true
    certificate?: true
    disable?: true
    _all?: true
  }

  export type TeacherAggregateArgs = {
    /**
     * Filter which Teacher to aggregate.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: Enumerable<TeacherOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teachers
    **/
    _count?: true | TeacherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherMaxAggregateInputType
  }

  export type GetTeacherAggregateType<T extends TeacherAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacher[P]>
      : GetScalarType<T[P], AggregateTeacher[P]>
  }




  export type TeacherGroupByArgs = {
    where?: TeacherWhereInput
    orderBy?: Enumerable<TeacherOrderByWithAggregationInput>
    by: TeacherScalarFieldEnum[]
    having?: TeacherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherCountAggregateInputType | true
    _min?: TeacherMinAggregateInputType
    _max?: TeacherMaxAggregateInputType
  }


  export type TeacherGroupByOutputType = {
    id: string
    personalId: string
    instansiId: string
    eventIds: string[]
    nip: string | null
    nrg: string | null
    noKarpeg: string | null
    tmtTugas: Date | null
    tmtGol: Date | null
    position: string | null
    rank: string | null
    period: string | null
    certificate: string | null
    disable: boolean
    _count: TeacherCountAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  type GetTeacherGroupByPayload<T extends TeacherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TeacherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherGroupByOutputType[P]>
        }
      >
    >


  export type TeacherSelect = {
    id?: boolean
    personalId?: boolean
    instansiId?: boolean
    eventIds?: boolean
    nip?: boolean
    nrg?: boolean
    noKarpeg?: boolean
    tmtTugas?: boolean
    tmtGol?: boolean
    position?: boolean
    rank?: boolean
    period?: boolean
    certificate?: boolean
    disable?: boolean
    personal?: boolean | PersonalArgs
    classRoom?: boolean | Teacher$classRoomArgs
    instansi?: boolean | InstansiArgs
    event?: boolean | Teacher$eventArgs
    tracker?: boolean | Teacher$trackerArgs
    teaching?: boolean | Teacher$teachingArgs
    _count?: boolean | TeacherCountOutputTypeArgs
  }


  export type TeacherInclude = {
    personal?: boolean | PersonalArgs
    classRoom?: boolean | Teacher$classRoomArgs
    instansi?: boolean | InstansiArgs
    event?: boolean | Teacher$eventArgs
    tracker?: boolean | Teacher$trackerArgs
    teaching?: boolean | Teacher$teachingArgs
    _count?: boolean | TeacherCountOutputTypeArgs
  }

  export type TeacherGetPayload<S extends boolean | null | undefined | TeacherArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Teacher :
    S extends undefined ? never :
    S extends { include: any } & (TeacherArgs | TeacherFindManyArgs)
    ? Teacher  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'personal' ? PersonalGetPayload<S['include'][P]> :
        P extends 'classRoom' ? Array < ClassRoomGetPayload<S['include'][P]>>  :
        P extends 'instansi' ? InstansiGetPayload<S['include'][P]> :
        P extends 'event' ? Array < CalendarGetPayload<S['include'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['include'][P]>>  :
        P extends 'teaching' ? Array < TeachingGetPayload<S['include'][P]>>  :
        P extends '_count' ? TeacherCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TeacherArgs | TeacherFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'personal' ? PersonalGetPayload<S['select'][P]> :
        P extends 'classRoom' ? Array < ClassRoomGetPayload<S['select'][P]>>  :
        P extends 'instansi' ? InstansiGetPayload<S['select'][P]> :
        P extends 'event' ? Array < CalendarGetPayload<S['select'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['select'][P]>>  :
        P extends 'teaching' ? Array < TeachingGetPayload<S['select'][P]>>  :
        P extends '_count' ? TeacherCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Teacher ? Teacher[P] : never
  } 
      : Teacher


  type TeacherCountArgs = 
    Omit<TeacherFindManyArgs, 'select' | 'include'> & {
      select?: TeacherCountAggregateInputType | true
    }

  export interface TeacherDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Teacher that matches the filter.
     * @param {TeacherFindUniqueArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeacherFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TeacherFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Teacher'> extends True ? Prisma__TeacherClient<TeacherGetPayload<T>> : Prisma__TeacherClient<TeacherGetPayload<T> | null, null>

    /**
     * Find one Teacher that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TeacherFindUniqueOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TeacherFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TeacherFindUniqueOrThrowArgs>
    ): Prisma__TeacherClient<TeacherGetPayload<T>>

    /**
     * Find the first Teacher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeacherFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TeacherFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Teacher'> extends True ? Prisma__TeacherClient<TeacherGetPayload<T>> : Prisma__TeacherClient<TeacherGetPayload<T> | null, null>

    /**
     * Find the first Teacher that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TeacherFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TeacherFindFirstOrThrowArgs>
    ): Prisma__TeacherClient<TeacherGetPayload<T>>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teacher.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teacher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherWithIdOnly = await prisma.teacher.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeacherFindManyArgs>(
      args?: SelectSubset<T, TeacherFindManyArgs>
    ): Prisma.PrismaPromise<Array<TeacherGetPayload<T>>>

    /**
     * Create a Teacher.
     * @param {TeacherCreateArgs} args - Arguments to create a Teacher.
     * @example
     * // Create one Teacher
     * const Teacher = await prisma.teacher.create({
     *   data: {
     *     // ... data to create a Teacher
     *   }
     * })
     * 
    **/
    create<T extends TeacherCreateArgs>(
      args: SelectSubset<T, TeacherCreateArgs>
    ): Prisma__TeacherClient<TeacherGetPayload<T>>

    /**
     * Create many Teachers.
     *     @param {TeacherCreateManyArgs} args - Arguments to create many Teachers.
     *     @example
     *     // Create many Teachers
     *     const teacher = await prisma.teacher.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeacherCreateManyArgs>(
      args?: SelectSubset<T, TeacherCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Teacher.
     * @param {TeacherDeleteArgs} args - Arguments to delete one Teacher.
     * @example
     * // Delete one Teacher
     * const Teacher = await prisma.teacher.delete({
     *   where: {
     *     // ... filter to delete one Teacher
     *   }
     * })
     * 
    **/
    delete<T extends TeacherDeleteArgs>(
      args: SelectSubset<T, TeacherDeleteArgs>
    ): Prisma__TeacherClient<TeacherGetPayload<T>>

    /**
     * Update one Teacher.
     * @param {TeacherUpdateArgs} args - Arguments to update one Teacher.
     * @example
     * // Update one Teacher
     * const teacher = await prisma.teacher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeacherUpdateArgs>(
      args: SelectSubset<T, TeacherUpdateArgs>
    ): Prisma__TeacherClient<TeacherGetPayload<T>>

    /**
     * Delete zero or more Teachers.
     * @param {TeacherDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teacher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeacherDeleteManyArgs>(
      args?: SelectSubset<T, TeacherDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeacherUpdateManyArgs>(
      args: SelectSubset<T, TeacherUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Teacher.
     * @param {TeacherUpsertArgs} args - Arguments to update or create a Teacher.
     * @example
     * // Update or create a Teacher
     * const teacher = await prisma.teacher.upsert({
     *   create: {
     *     // ... data to create a Teacher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teacher we want to update
     *   }
     * })
    **/
    upsert<T extends TeacherUpsertArgs>(
      args: SelectSubset<T, TeacherUpsertArgs>
    ): Prisma__TeacherClient<TeacherGetPayload<T>>

    /**
     * Find zero or more Teachers that matches the filter.
     * @param {TeacherFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const teacher = await prisma.teacher.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: TeacherFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Teacher.
     * @param {TeacherAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const teacher = await prisma.teacher.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: TeacherAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teacher.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends TeacherCountArgs>(
      args?: Subset<T, TeacherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherAggregateArgs>(args: Subset<T, TeacherAggregateArgs>): Prisma.PrismaPromise<GetTeacherAggregateType<T>>

    /**
     * Group by Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherGroupByArgs['orderBy'] }
        : { orderBy?: TeacherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Teacher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TeacherClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    personal<T extends PersonalArgs= {}>(args?: Subset<T, PersonalArgs>): Prisma__PersonalClient<PersonalGetPayload<T> | Null>;

    classRoom<T extends Teacher$classRoomArgs= {}>(args?: Subset<T, Teacher$classRoomArgs>): Prisma.PrismaPromise<Array<ClassRoomGetPayload<T>>| Null>;

    instansi<T extends InstansiArgs= {}>(args?: Subset<T, InstansiArgs>): Prisma__InstansiClient<InstansiGetPayload<T> | Null>;

    event<T extends Teacher$eventArgs= {}>(args?: Subset<T, Teacher$eventArgs>): Prisma.PrismaPromise<Array<CalendarGetPayload<T>>| Null>;

    tracker<T extends Teacher$trackerArgs= {}>(args?: Subset<T, Teacher$trackerArgs>): Prisma.PrismaPromise<Array<TrackerGetPayload<T>>| Null>;

    teaching<T extends Teacher$teachingArgs= {}>(args?: Subset<T, Teacher$teachingArgs>): Prisma.PrismaPromise<Array<TeachingGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Teacher base type for findUnique actions
   */
  export type TeacherFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findUnique
   */
  export interface TeacherFindUniqueArgs extends TeacherFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Teacher findUniqueOrThrow
   */
  export type TeacherFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }


  /**
   * Teacher base type for findFirst actions
   */
  export type TeacherFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: Enumerable<TeacherOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: Enumerable<TeacherScalarFieldEnum>
  }

  /**
   * Teacher findFirst
   */
  export interface TeacherFindFirstArgs extends TeacherFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Teacher findFirstOrThrow
   */
  export type TeacherFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: Enumerable<TeacherOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: Enumerable<TeacherScalarFieldEnum>
  }


  /**
   * Teacher findMany
   */
  export type TeacherFindManyArgs = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: Enumerable<TeacherOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    distinct?: Enumerable<TeacherScalarFieldEnum>
  }


  /**
   * Teacher create
   */
  export type TeacherCreateArgs = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
    /**
     * The data needed to create a Teacher.
     */
    data: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
  }


  /**
   * Teacher createMany
   */
  export type TeacherCreateManyArgs = {
    /**
     * The data used to create many Teachers.
     */
    data: Enumerable<TeacherCreateManyInput>
  }


  /**
   * Teacher update
   */
  export type TeacherUpdateArgs = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
    /**
     * The data needed to update a Teacher.
     */
    data: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
    /**
     * Choose, which Teacher to update.
     */
    where: TeacherWhereUniqueInput
  }


  /**
   * Teacher updateMany
   */
  export type TeacherUpdateManyArgs = {
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeacherWhereInput
  }


  /**
   * Teacher upsert
   */
  export type TeacherUpsertArgs = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
    /**
     * The filter to search for the Teacher to update in case it exists.
     */
    where: TeacherWhereUniqueInput
    /**
     * In case the Teacher found by the `where` argument doesn't exist, create a new Teacher with this data.
     */
    create: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
    /**
     * In case the Teacher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
  }


  /**
   * Teacher delete
   */
  export type TeacherDeleteArgs = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
    /**
     * Filter which Teacher to delete.
     */
    where: TeacherWhereUniqueInput
  }


  /**
   * Teacher deleteMany
   */
  export type TeacherDeleteManyArgs = {
    /**
     * Filter which Teachers to delete
     */
    where?: TeacherWhereInput
  }


  /**
   * Teacher findRaw
   */
  export type TeacherFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Teacher aggregateRaw
   */
  export type TeacherAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Teacher.classRoom
   */
  export type Teacher$classRoomArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    where?: ClassRoomWhereInput
    orderBy?: Enumerable<ClassRoomOrderByWithRelationInput>
    cursor?: ClassRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ClassRoomScalarFieldEnum>
  }


  /**
   * Teacher.event
   */
  export type Teacher$eventArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    where?: CalendarWhereInput
    orderBy?: Enumerable<CalendarOrderByWithRelationInput>
    cursor?: CalendarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CalendarScalarFieldEnum>
  }


  /**
   * Teacher.tracker
   */
  export type Teacher$trackerArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    where?: TrackerWhereInput
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    cursor?: TrackerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TrackerScalarFieldEnum>
  }


  /**
   * Teacher.teaching
   */
  export type Teacher$teachingArgs = {
    /**
     * Select specific fields to fetch from the Teaching
     */
    select?: TeachingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachingInclude | null
    where?: TeachingWhereInput
    orderBy?: Enumerable<TeachingOrderByWithRelationInput>
    cursor?: TeachingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeachingScalarFieldEnum>
  }


  /**
   * Teacher without action
   */
  export type TeacherArgs = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
  }



  /**
   * Model ClassRoom
   */


  export type AggregateClassRoom = {
    _count: ClassRoomCountAggregateOutputType | null
    _avg: ClassRoomAvgAggregateOutputType | null
    _sum: ClassRoomSumAggregateOutputType | null
    _min: ClassRoomMinAggregateOutputType | null
    _max: ClassRoomMaxAggregateOutputType | null
  }

  export type ClassRoomAvgAggregateOutputType = {
    level: number | null
  }

  export type ClassRoomSumAggregateOutputType = {
    level: number | null
  }

  export type ClassRoomMinAggregateOutputType = {
    id: string | null
    name: string | null
    yearId: string | null
    waliId: string | null
    level: number | null
    majorId: string | null
    disable: boolean | null
  }

  export type ClassRoomMaxAggregateOutputType = {
    id: string | null
    name: string | null
    yearId: string | null
    waliId: string | null
    level: number | null
    majorId: string | null
    disable: boolean | null
  }

  export type ClassRoomCountAggregateOutputType = {
    id: number
    name: number
    yearId: number
    waliId: number
    level: number
    majorId: number
    studentIds: number
    eventIds: number
    disable: number
    teachingIds: number
    tDeviceIds: number
    _all: number
  }


  export type ClassRoomAvgAggregateInputType = {
    level?: true
  }

  export type ClassRoomSumAggregateInputType = {
    level?: true
  }

  export type ClassRoomMinAggregateInputType = {
    id?: true
    name?: true
    yearId?: true
    waliId?: true
    level?: true
    majorId?: true
    disable?: true
  }

  export type ClassRoomMaxAggregateInputType = {
    id?: true
    name?: true
    yearId?: true
    waliId?: true
    level?: true
    majorId?: true
    disable?: true
  }

  export type ClassRoomCountAggregateInputType = {
    id?: true
    name?: true
    yearId?: true
    waliId?: true
    level?: true
    majorId?: true
    studentIds?: true
    eventIds?: true
    disable?: true
    teachingIds?: true
    tDeviceIds?: true
    _all?: true
  }

  export type ClassRoomAggregateArgs = {
    /**
     * Filter which ClassRoom to aggregate.
     */
    where?: ClassRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassRooms to fetch.
     */
    orderBy?: Enumerable<ClassRoomOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassRooms
    **/
    _count?: true | ClassRoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassRoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassRoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassRoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassRoomMaxAggregateInputType
  }

  export type GetClassRoomAggregateType<T extends ClassRoomAggregateArgs> = {
        [P in keyof T & keyof AggregateClassRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassRoom[P]>
      : GetScalarType<T[P], AggregateClassRoom[P]>
  }




  export type ClassRoomGroupByArgs = {
    where?: ClassRoomWhereInput
    orderBy?: Enumerable<ClassRoomOrderByWithAggregationInput>
    by: ClassRoomScalarFieldEnum[]
    having?: ClassRoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassRoomCountAggregateInputType | true
    _avg?: ClassRoomAvgAggregateInputType
    _sum?: ClassRoomSumAggregateInputType
    _min?: ClassRoomMinAggregateInputType
    _max?: ClassRoomMaxAggregateInputType
  }


  export type ClassRoomGroupByOutputType = {
    id: string
    name: string
    yearId: string
    waliId: string
    level: number
    majorId: string | null
    studentIds: string[]
    eventIds: string[]
    disable: boolean
    teachingIds: string[]
    tDeviceIds: string[]
    _count: ClassRoomCountAggregateOutputType | null
    _avg: ClassRoomAvgAggregateOutputType | null
    _sum: ClassRoomSumAggregateOutputType | null
    _min: ClassRoomMinAggregateOutputType | null
    _max: ClassRoomMaxAggregateOutputType | null
  }

  type GetClassRoomGroupByPayload<T extends ClassRoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ClassRoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassRoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassRoomGroupByOutputType[P]>
            : GetScalarType<T[P], ClassRoomGroupByOutputType[P]>
        }
      >
    >


  export type ClassRoomSelect = {
    id?: boolean
    name?: boolean
    yearId?: boolean
    waliId?: boolean
    level?: boolean
    property?: boolean | RoomPropertyArgs
    majorId?: boolean
    studentIds?: boolean
    eventIds?: boolean
    disable?: boolean
    teachingIds?: boolean
    tDeviceIds?: boolean
    year?: boolean | SchoolYearArgs
    wali?: boolean | TeacherArgs
    major?: boolean | KonsentrasiKeahlianArgs
    students?: boolean | ClassRoom$studentsArgs
    event?: boolean | ClassRoom$eventArgs
    tracker?: boolean | ClassRoom$trackerArgs
    teaching?: boolean | ClassRoom$teachingArgs
    tDevice?: boolean | ClassRoom$tDeviceArgs
    _count?: boolean | ClassRoomCountOutputTypeArgs
  }


  export type ClassRoomInclude = {
    year?: boolean | SchoolYearArgs
    wali?: boolean | TeacherArgs
    major?: boolean | KonsentrasiKeahlianArgs
    students?: boolean | ClassRoom$studentsArgs
    event?: boolean | ClassRoom$eventArgs
    tracker?: boolean | ClassRoom$trackerArgs
    teaching?: boolean | ClassRoom$teachingArgs
    tDevice?: boolean | ClassRoom$tDeviceArgs
    _count?: boolean | ClassRoomCountOutputTypeArgs
  }

  export type ClassRoomGetPayload<S extends boolean | null | undefined | ClassRoomArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ClassRoom :
    S extends undefined ? never :
    S extends { include: any } & (ClassRoomArgs | ClassRoomFindManyArgs)
    ? ClassRoom  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'year' ? SchoolYearGetPayload<S['include'][P]> :
        P extends 'wali' ? TeacherGetPayload<S['include'][P]> :
        P extends 'major' ? KonsentrasiKeahlianGetPayload<S['include'][P]> | null :
        P extends 'students' ? Array < StudentGetPayload<S['include'][P]>>  :
        P extends 'event' ? Array < CalendarGetPayload<S['include'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['include'][P]>>  :
        P extends 'teaching' ? Array < TeachingGetPayload<S['include'][P]>>  :
        P extends 'tDevice' ? Array < TDeviceGetPayload<S['include'][P]>>  :
        P extends '_count' ? ClassRoomCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ClassRoomArgs | ClassRoomFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'property' ? RoomPropertyGetPayload<S['select'][P]> | null :
        P extends 'year' ? SchoolYearGetPayload<S['select'][P]> :
        P extends 'wali' ? TeacherGetPayload<S['select'][P]> :
        P extends 'major' ? KonsentrasiKeahlianGetPayload<S['select'][P]> | null :
        P extends 'students' ? Array < StudentGetPayload<S['select'][P]>>  :
        P extends 'event' ? Array < CalendarGetPayload<S['select'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['select'][P]>>  :
        P extends 'teaching' ? Array < TeachingGetPayload<S['select'][P]>>  :
        P extends 'tDevice' ? Array < TDeviceGetPayload<S['select'][P]>>  :
        P extends '_count' ? ClassRoomCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ClassRoom ? ClassRoom[P] : never
  } 
      : ClassRoom


  type ClassRoomCountArgs = 
    Omit<ClassRoomFindManyArgs, 'select' | 'include'> & {
      select?: ClassRoomCountAggregateInputType | true
    }

  export interface ClassRoomDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ClassRoom that matches the filter.
     * @param {ClassRoomFindUniqueArgs} args - Arguments to find a ClassRoom
     * @example
     * // Get one ClassRoom
     * const classRoom = await prisma.classRoom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClassRoomFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ClassRoomFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ClassRoom'> extends True ? Prisma__ClassRoomClient<ClassRoomGetPayload<T>> : Prisma__ClassRoomClient<ClassRoomGetPayload<T> | null, null>

    /**
     * Find one ClassRoom that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClassRoomFindUniqueOrThrowArgs} args - Arguments to find a ClassRoom
     * @example
     * // Get one ClassRoom
     * const classRoom = await prisma.classRoom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClassRoomFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ClassRoomFindUniqueOrThrowArgs>
    ): Prisma__ClassRoomClient<ClassRoomGetPayload<T>>

    /**
     * Find the first ClassRoom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassRoomFindFirstArgs} args - Arguments to find a ClassRoom
     * @example
     * // Get one ClassRoom
     * const classRoom = await prisma.classRoom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClassRoomFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ClassRoomFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ClassRoom'> extends True ? Prisma__ClassRoomClient<ClassRoomGetPayload<T>> : Prisma__ClassRoomClient<ClassRoomGetPayload<T> | null, null>

    /**
     * Find the first ClassRoom that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassRoomFindFirstOrThrowArgs} args - Arguments to find a ClassRoom
     * @example
     * // Get one ClassRoom
     * const classRoom = await prisma.classRoom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClassRoomFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ClassRoomFindFirstOrThrowArgs>
    ): Prisma__ClassRoomClient<ClassRoomGetPayload<T>>

    /**
     * Find zero or more ClassRooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassRoomFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassRooms
     * const classRooms = await prisma.classRoom.findMany()
     * 
     * // Get first 10 ClassRooms
     * const classRooms = await prisma.classRoom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classRoomWithIdOnly = await prisma.classRoom.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClassRoomFindManyArgs>(
      args?: SelectSubset<T, ClassRoomFindManyArgs>
    ): Prisma.PrismaPromise<Array<ClassRoomGetPayload<T>>>

    /**
     * Create a ClassRoom.
     * @param {ClassRoomCreateArgs} args - Arguments to create a ClassRoom.
     * @example
     * // Create one ClassRoom
     * const ClassRoom = await prisma.classRoom.create({
     *   data: {
     *     // ... data to create a ClassRoom
     *   }
     * })
     * 
    **/
    create<T extends ClassRoomCreateArgs>(
      args: SelectSubset<T, ClassRoomCreateArgs>
    ): Prisma__ClassRoomClient<ClassRoomGetPayload<T>>

    /**
     * Create many ClassRooms.
     *     @param {ClassRoomCreateManyArgs} args - Arguments to create many ClassRooms.
     *     @example
     *     // Create many ClassRooms
     *     const classRoom = await prisma.classRoom.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClassRoomCreateManyArgs>(
      args?: SelectSubset<T, ClassRoomCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClassRoom.
     * @param {ClassRoomDeleteArgs} args - Arguments to delete one ClassRoom.
     * @example
     * // Delete one ClassRoom
     * const ClassRoom = await prisma.classRoom.delete({
     *   where: {
     *     // ... filter to delete one ClassRoom
     *   }
     * })
     * 
    **/
    delete<T extends ClassRoomDeleteArgs>(
      args: SelectSubset<T, ClassRoomDeleteArgs>
    ): Prisma__ClassRoomClient<ClassRoomGetPayload<T>>

    /**
     * Update one ClassRoom.
     * @param {ClassRoomUpdateArgs} args - Arguments to update one ClassRoom.
     * @example
     * // Update one ClassRoom
     * const classRoom = await prisma.classRoom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClassRoomUpdateArgs>(
      args: SelectSubset<T, ClassRoomUpdateArgs>
    ): Prisma__ClassRoomClient<ClassRoomGetPayload<T>>

    /**
     * Delete zero or more ClassRooms.
     * @param {ClassRoomDeleteManyArgs} args - Arguments to filter ClassRooms to delete.
     * @example
     * // Delete a few ClassRooms
     * const { count } = await prisma.classRoom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClassRoomDeleteManyArgs>(
      args?: SelectSubset<T, ClassRoomDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassRoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassRooms
     * const classRoom = await prisma.classRoom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClassRoomUpdateManyArgs>(
      args: SelectSubset<T, ClassRoomUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassRoom.
     * @param {ClassRoomUpsertArgs} args - Arguments to update or create a ClassRoom.
     * @example
     * // Update or create a ClassRoom
     * const classRoom = await prisma.classRoom.upsert({
     *   create: {
     *     // ... data to create a ClassRoom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassRoom we want to update
     *   }
     * })
    **/
    upsert<T extends ClassRoomUpsertArgs>(
      args: SelectSubset<T, ClassRoomUpsertArgs>
    ): Prisma__ClassRoomClient<ClassRoomGetPayload<T>>

    /**
     * Find zero or more ClassRooms that matches the filter.
     * @param {ClassRoomFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const classRoom = await prisma.classRoom.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ClassRoomFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ClassRoom.
     * @param {ClassRoomAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const classRoom = await prisma.classRoom.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ClassRoomAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of ClassRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassRoomCountArgs} args - Arguments to filter ClassRooms to count.
     * @example
     * // Count the number of ClassRooms
     * const count = await prisma.classRoom.count({
     *   where: {
     *     // ... the filter for the ClassRooms we want to count
     *   }
     * })
    **/
    count<T extends ClassRoomCountArgs>(
      args?: Subset<T, ClassRoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassRoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassRoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassRoomAggregateArgs>(args: Subset<T, ClassRoomAggregateArgs>): Prisma.PrismaPromise<GetClassRoomAggregateType<T>>

    /**
     * Group by ClassRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassRoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassRoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassRoomGroupByArgs['orderBy'] }
        : { orderBy?: ClassRoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassRoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassRoom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ClassRoomClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    property<T extends RoomPropertyArgs= {}>(args?: Subset<T, RoomPropertyArgs>): Prisma__RoomPropertyClient<RoomPropertyGetPayload<T> | Null>;

    year<T extends SchoolYearArgs= {}>(args?: Subset<T, SchoolYearArgs>): Prisma__SchoolYearClient<SchoolYearGetPayload<T> | Null>;

    wali<T extends TeacherArgs= {}>(args?: Subset<T, TeacherArgs>): Prisma__TeacherClient<TeacherGetPayload<T> | Null>;

    major<T extends KonsentrasiKeahlianArgs= {}>(args?: Subset<T, KonsentrasiKeahlianArgs>): Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T> | Null>;

    students<T extends ClassRoom$studentsArgs= {}>(args?: Subset<T, ClassRoom$studentsArgs>): Prisma.PrismaPromise<Array<StudentGetPayload<T>>| Null>;

    event<T extends ClassRoom$eventArgs= {}>(args?: Subset<T, ClassRoom$eventArgs>): Prisma.PrismaPromise<Array<CalendarGetPayload<T>>| Null>;

    tracker<T extends ClassRoom$trackerArgs= {}>(args?: Subset<T, ClassRoom$trackerArgs>): Prisma.PrismaPromise<Array<TrackerGetPayload<T>>| Null>;

    teaching<T extends ClassRoom$teachingArgs= {}>(args?: Subset<T, ClassRoom$teachingArgs>): Prisma.PrismaPromise<Array<TeachingGetPayload<T>>| Null>;

    tDevice<T extends ClassRoom$tDeviceArgs= {}>(args?: Subset<T, ClassRoom$tDeviceArgs>): Prisma.PrismaPromise<Array<TDeviceGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ClassRoom base type for findUnique actions
   */
  export type ClassRoomFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    /**
     * Filter, which ClassRoom to fetch.
     */
    where: ClassRoomWhereUniqueInput
  }

  /**
   * ClassRoom findUnique
   */
  export interface ClassRoomFindUniqueArgs extends ClassRoomFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ClassRoom findUniqueOrThrow
   */
  export type ClassRoomFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    /**
     * Filter, which ClassRoom to fetch.
     */
    where: ClassRoomWhereUniqueInput
  }


  /**
   * ClassRoom base type for findFirst actions
   */
  export type ClassRoomFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    /**
     * Filter, which ClassRoom to fetch.
     */
    where?: ClassRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassRooms to fetch.
     */
    orderBy?: Enumerable<ClassRoomOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassRooms.
     */
    cursor?: ClassRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassRooms.
     */
    distinct?: Enumerable<ClassRoomScalarFieldEnum>
  }

  /**
   * ClassRoom findFirst
   */
  export interface ClassRoomFindFirstArgs extends ClassRoomFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ClassRoom findFirstOrThrow
   */
  export type ClassRoomFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    /**
     * Filter, which ClassRoom to fetch.
     */
    where?: ClassRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassRooms to fetch.
     */
    orderBy?: Enumerable<ClassRoomOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassRooms.
     */
    cursor?: ClassRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassRooms.
     */
    distinct?: Enumerable<ClassRoomScalarFieldEnum>
  }


  /**
   * ClassRoom findMany
   */
  export type ClassRoomFindManyArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    /**
     * Filter, which ClassRooms to fetch.
     */
    where?: ClassRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassRooms to fetch.
     */
    orderBy?: Enumerable<ClassRoomOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassRooms.
     */
    cursor?: ClassRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassRooms.
     */
    skip?: number
    distinct?: Enumerable<ClassRoomScalarFieldEnum>
  }


  /**
   * ClassRoom create
   */
  export type ClassRoomCreateArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    /**
     * The data needed to create a ClassRoom.
     */
    data: XOR<ClassRoomCreateInput, ClassRoomUncheckedCreateInput>
  }


  /**
   * ClassRoom createMany
   */
  export type ClassRoomCreateManyArgs = {
    /**
     * The data used to create many ClassRooms.
     */
    data: Enumerable<ClassRoomCreateManyInput>
  }


  /**
   * ClassRoom update
   */
  export type ClassRoomUpdateArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    /**
     * The data needed to update a ClassRoom.
     */
    data: XOR<ClassRoomUpdateInput, ClassRoomUncheckedUpdateInput>
    /**
     * Choose, which ClassRoom to update.
     */
    where: ClassRoomWhereUniqueInput
  }


  /**
   * ClassRoom updateMany
   */
  export type ClassRoomUpdateManyArgs = {
    /**
     * The data used to update ClassRooms.
     */
    data: XOR<ClassRoomUpdateManyMutationInput, ClassRoomUncheckedUpdateManyInput>
    /**
     * Filter which ClassRooms to update
     */
    where?: ClassRoomWhereInput
  }


  /**
   * ClassRoom upsert
   */
  export type ClassRoomUpsertArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    /**
     * The filter to search for the ClassRoom to update in case it exists.
     */
    where: ClassRoomWhereUniqueInput
    /**
     * In case the ClassRoom found by the `where` argument doesn't exist, create a new ClassRoom with this data.
     */
    create: XOR<ClassRoomCreateInput, ClassRoomUncheckedCreateInput>
    /**
     * In case the ClassRoom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassRoomUpdateInput, ClassRoomUncheckedUpdateInput>
  }


  /**
   * ClassRoom delete
   */
  export type ClassRoomDeleteArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    /**
     * Filter which ClassRoom to delete.
     */
    where: ClassRoomWhereUniqueInput
  }


  /**
   * ClassRoom deleteMany
   */
  export type ClassRoomDeleteManyArgs = {
    /**
     * Filter which ClassRooms to delete
     */
    where?: ClassRoomWhereInput
  }


  /**
   * ClassRoom findRaw
   */
  export type ClassRoomFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * ClassRoom aggregateRaw
   */
  export type ClassRoomAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * ClassRoom.students
   */
  export type ClassRoom$studentsArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    where?: StudentWhereInput
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * ClassRoom.event
   */
  export type ClassRoom$eventArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    where?: CalendarWhereInput
    orderBy?: Enumerable<CalendarOrderByWithRelationInput>
    cursor?: CalendarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CalendarScalarFieldEnum>
  }


  /**
   * ClassRoom.tracker
   */
  export type ClassRoom$trackerArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    where?: TrackerWhereInput
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    cursor?: TrackerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TrackerScalarFieldEnum>
  }


  /**
   * ClassRoom.teaching
   */
  export type ClassRoom$teachingArgs = {
    /**
     * Select specific fields to fetch from the Teaching
     */
    select?: TeachingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachingInclude | null
    where?: TeachingWhereInput
    orderBy?: Enumerable<TeachingOrderByWithRelationInput>
    cursor?: TeachingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeachingScalarFieldEnum>
  }


  /**
   * ClassRoom.tDevice
   */
  export type ClassRoom$tDeviceArgs = {
    /**
     * Select specific fields to fetch from the TDevice
     */
    select?: TDeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceInclude | null
    where?: TDeviceWhereInput
    orderBy?: Enumerable<TDeviceOrderByWithRelationInput>
    cursor?: TDeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TDeviceScalarFieldEnum>
  }


  /**
   * ClassRoom without action
   */
  export type ClassRoomArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
  }



  /**
   * Model Student
   */


  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    nis: string | null
    lastSchool: string | null
    personalId: string | null
    majorId: string | null
    startYearId: string | null
    instansiId: string | null
    disable: boolean | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    nis: string | null
    lastSchool: string | null
    personalId: string | null
    majorId: string | null
    startYearId: string | null
    instansiId: string | null
    disable: boolean | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    nis: number
    lastSchool: number
    personalId: number
    majorId: number
    classRoomIds: number
    startYearId: number
    instansiId: number
    eventIds: number
    disable: number
    _all: number
  }


  export type StudentMinAggregateInputType = {
    id?: true
    nis?: true
    lastSchool?: true
    personalId?: true
    majorId?: true
    startYearId?: true
    instansiId?: true
    disable?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    nis?: true
    lastSchool?: true
    personalId?: true
    majorId?: true
    startYearId?: true
    instansiId?: true
    disable?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    nis?: true
    lastSchool?: true
    personalId?: true
    majorId?: true
    classRoomIds?: true
    startYearId?: true
    instansiId?: true
    eventIds?: true
    disable?: true
    _all?: true
  }

  export type StudentAggregateArgs = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs = {
    where?: StudentWhereInput
    orderBy?: Enumerable<StudentOrderByWithAggregationInput>
    by: StudentScalarFieldEnum[]
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }


  export type StudentGroupByOutputType = {
    id: string
    nis: string
    lastSchool: string
    personalId: string
    majorId: string | null
    classRoomIds: string[]
    startYearId: string
    instansiId: string
    eventIds: string[]
    disable: boolean
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect = {
    id?: boolean
    nis?: boolean
    lastSchool?: boolean
    personalId?: boolean
    majorId?: boolean
    classRoomIds?: boolean
    startYearId?: boolean
    instansiId?: boolean
    eventIds?: boolean
    disable?: boolean
    personal?: boolean | PersonalArgs
    major?: boolean | KonsentrasiKeahlianArgs
    classRoom?: boolean | Student$classRoomArgs
    startYear?: boolean | SchoolYearArgs
    instansi?: boolean | InstansiArgs
    event?: boolean | Student$eventArgs
    tracker?: boolean | Student$trackerArgs
    _count?: boolean | StudentCountOutputTypeArgs
  }


  export type StudentInclude = {
    personal?: boolean | PersonalArgs
    major?: boolean | KonsentrasiKeahlianArgs
    classRoom?: boolean | Student$classRoomArgs
    startYear?: boolean | SchoolYearArgs
    instansi?: boolean | InstansiArgs
    event?: boolean | Student$eventArgs
    tracker?: boolean | Student$trackerArgs
    _count?: boolean | StudentCountOutputTypeArgs
  }

  export type StudentGetPayload<S extends boolean | null | undefined | StudentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Student :
    S extends undefined ? never :
    S extends { include: any } & (StudentArgs | StudentFindManyArgs)
    ? Student  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'personal' ? PersonalGetPayload<S['include'][P]> :
        P extends 'major' ? KonsentrasiKeahlianGetPayload<S['include'][P]> | null :
        P extends 'classRoom' ? Array < ClassRoomGetPayload<S['include'][P]>>  :
        P extends 'startYear' ? SchoolYearGetPayload<S['include'][P]> :
        P extends 'instansi' ? InstansiGetPayload<S['include'][P]> :
        P extends 'event' ? Array < CalendarGetPayload<S['include'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['include'][P]>>  :
        P extends '_count' ? StudentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (StudentArgs | StudentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'personal' ? PersonalGetPayload<S['select'][P]> :
        P extends 'major' ? KonsentrasiKeahlianGetPayload<S['select'][P]> | null :
        P extends 'classRoom' ? Array < ClassRoomGetPayload<S['select'][P]>>  :
        P extends 'startYear' ? SchoolYearGetPayload<S['select'][P]> :
        P extends 'instansi' ? InstansiGetPayload<S['select'][P]> :
        P extends 'event' ? Array < CalendarGetPayload<S['select'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['select'][P]>>  :
        P extends '_count' ? StudentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Student ? Student[P] : never
  } 
      : Student


  type StudentCountArgs = 
    Omit<StudentFindManyArgs, 'select' | 'include'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StudentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Student'> extends True ? Prisma__StudentClient<StudentGetPayload<T>> : Prisma__StudentClient<StudentGetPayload<T> | null, null>

    /**
     * Find one Student that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StudentFindUniqueOrThrowArgs>
    ): Prisma__StudentClient<StudentGetPayload<T>>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StudentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Student'> extends True ? Prisma__StudentClient<StudentGetPayload<T>> : Prisma__StudentClient<StudentGetPayload<T> | null, null>

    /**
     * Find the first Student that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StudentFindFirstOrThrowArgs>
    ): Prisma__StudentClient<StudentGetPayload<T>>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StudentFindManyArgs>(
      args?: SelectSubset<T, StudentFindManyArgs>
    ): Prisma.PrismaPromise<Array<StudentGetPayload<T>>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
    **/
    create<T extends StudentCreateArgs>(
      args: SelectSubset<T, StudentCreateArgs>
    ): Prisma__StudentClient<StudentGetPayload<T>>

    /**
     * Create many Students.
     *     @param {StudentCreateManyArgs} args - Arguments to create many Students.
     *     @example
     *     // Create many Students
     *     const student = await prisma.student.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentCreateManyArgs>(
      args?: SelectSubset<T, StudentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
    **/
    delete<T extends StudentDeleteArgs>(
      args: SelectSubset<T, StudentDeleteArgs>
    ): Prisma__StudentClient<StudentGetPayload<T>>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentUpdateArgs>(
      args: SelectSubset<T, StudentUpdateArgs>
    ): Prisma__StudentClient<StudentGetPayload<T>>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentDeleteManyArgs>(
      args?: SelectSubset<T, StudentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentUpdateManyArgs>(
      args: SelectSubset<T, StudentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
    **/
    upsert<T extends StudentUpsertArgs>(
      args: SelectSubset<T, StudentUpsertArgs>
    ): Prisma__StudentClient<StudentGetPayload<T>>

    /**
     * Find zero or more Students that matches the filter.
     * @param {StudentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const student = await prisma.student.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: StudentFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Student.
     * @param {StudentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const student = await prisma.student.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: StudentAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StudentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    personal<T extends PersonalArgs= {}>(args?: Subset<T, PersonalArgs>): Prisma__PersonalClient<PersonalGetPayload<T> | Null>;

    major<T extends KonsentrasiKeahlianArgs= {}>(args?: Subset<T, KonsentrasiKeahlianArgs>): Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T> | Null>;

    classRoom<T extends Student$classRoomArgs= {}>(args?: Subset<T, Student$classRoomArgs>): Prisma.PrismaPromise<Array<ClassRoomGetPayload<T>>| Null>;

    startYear<T extends SchoolYearArgs= {}>(args?: Subset<T, SchoolYearArgs>): Prisma__SchoolYearClient<SchoolYearGetPayload<T> | Null>;

    instansi<T extends InstansiArgs= {}>(args?: Subset<T, InstansiArgs>): Prisma__InstansiClient<InstansiGetPayload<T> | Null>;

    event<T extends Student$eventArgs= {}>(args?: Subset<T, Student$eventArgs>): Prisma.PrismaPromise<Array<CalendarGetPayload<T>>| Null>;

    tracker<T extends Student$trackerArgs= {}>(args?: Subset<T, Student$trackerArgs>): Prisma.PrismaPromise<Array<TrackerGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Student base type for findUnique actions
   */
  export type StudentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUnique
   */
  export interface StudentFindUniqueArgs extends StudentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }


  /**
   * Student base type for findFirst actions
   */
  export type StudentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: Enumerable<StudentScalarFieldEnum>
  }

  /**
   * Student findFirst
   */
  export interface StudentFindFirstArgs extends StudentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * Student findMany
   */
  export type StudentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * Student create
   */
  export type StudentCreateArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }


  /**
   * Student createMany
   */
  export type StudentCreateManyArgs = {
    /**
     * The data used to create many Students.
     */
    data: Enumerable<StudentCreateManyInput>
  }


  /**
   * Student update
   */
  export type StudentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }


  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
  }


  /**
   * Student upsert
   */
  export type StudentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }


  /**
   * Student delete
   */
  export type StudentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }


  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
  }


  /**
   * Student findRaw
   */
  export type StudentFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Student aggregateRaw
   */
  export type StudentAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Student.classRoom
   */
  export type Student$classRoomArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    where?: ClassRoomWhereInput
    orderBy?: Enumerable<ClassRoomOrderByWithRelationInput>
    cursor?: ClassRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ClassRoomScalarFieldEnum>
  }


  /**
   * Student.event
   */
  export type Student$eventArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    where?: CalendarWhereInput
    orderBy?: Enumerable<CalendarOrderByWithRelationInput>
    cursor?: CalendarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CalendarScalarFieldEnum>
  }


  /**
   * Student.tracker
   */
  export type Student$trackerArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    where?: TrackerWhereInput
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    cursor?: TrackerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TrackerScalarFieldEnum>
  }


  /**
   * Student without action
   */
  export type StudentArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
  }



  /**
   * Model Schedule
   */


  export type AggregateSchedule = {
    _count: ScheduleCountAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  export type ScheduleMinAggregateOutputType = {
    id: string | null
    yearId: string | null
    mapelId: string | null
    disable: boolean | null
  }

  export type ScheduleMaxAggregateOutputType = {
    id: string | null
    yearId: string | null
    mapelId: string | null
    disable: boolean | null
  }

  export type ScheduleCountAggregateOutputType = {
    id: number
    yearId: number
    mapelId: number
    disable: number
    _all: number
  }


  export type ScheduleMinAggregateInputType = {
    id?: true
    yearId?: true
    mapelId?: true
    disable?: true
  }

  export type ScheduleMaxAggregateInputType = {
    id?: true
    yearId?: true
    mapelId?: true
    disable?: true
  }

  export type ScheduleCountAggregateInputType = {
    id?: true
    yearId?: true
    mapelId?: true
    disable?: true
    _all?: true
  }

  export type ScheduleAggregateArgs = {
    /**
     * Filter which Schedule to aggregate.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: Enumerable<ScheduleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schedules
    **/
    _count?: true | ScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleMaxAggregateInputType
  }

  export type GetScheduleAggregateType<T extends ScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchedule[P]>
      : GetScalarType<T[P], AggregateSchedule[P]>
  }




  export type ScheduleGroupByArgs = {
    where?: ScheduleWhereInput
    orderBy?: Enumerable<ScheduleOrderByWithAggregationInput>
    by: ScheduleScalarFieldEnum[]
    having?: ScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleCountAggregateInputType | true
    _min?: ScheduleMinAggregateInputType
    _max?: ScheduleMaxAggregateInputType
  }


  export type ScheduleGroupByOutputType = {
    id: string
    yearId: string
    mapelId: string
    disable: boolean
    _count: ScheduleCountAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  type GetScheduleGroupByPayload<T extends ScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleSelect = {
    id?: boolean
    yearId?: boolean
    mapelId?: boolean
    disable?: boolean
    year?: boolean | SchoolYearArgs
    mapel?: boolean | MataPelajaranArgs
    tracker?: boolean | Schedule$trackerArgs
    teaching?: boolean | Schedule$teachingArgs
    _count?: boolean | ScheduleCountOutputTypeArgs
  }


  export type ScheduleInclude = {
    year?: boolean | SchoolYearArgs
    mapel?: boolean | MataPelajaranArgs
    tracker?: boolean | Schedule$trackerArgs
    teaching?: boolean | Schedule$teachingArgs
    _count?: boolean | ScheduleCountOutputTypeArgs
  }

  export type ScheduleGetPayload<S extends boolean | null | undefined | ScheduleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Schedule :
    S extends undefined ? never :
    S extends { include: any } & (ScheduleArgs | ScheduleFindManyArgs)
    ? Schedule  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'year' ? SchoolYearGetPayload<S['include'][P]> :
        P extends 'mapel' ? MataPelajaranGetPayload<S['include'][P]> :
        P extends 'tracker' ? Array < TrackerGetPayload<S['include'][P]>>  :
        P extends 'teaching' ? Array < TeachingGetPayload<S['include'][P]>>  :
        P extends '_count' ? ScheduleCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ScheduleArgs | ScheduleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'year' ? SchoolYearGetPayload<S['select'][P]> :
        P extends 'mapel' ? MataPelajaranGetPayload<S['select'][P]> :
        P extends 'tracker' ? Array < TrackerGetPayload<S['select'][P]>>  :
        P extends 'teaching' ? Array < TeachingGetPayload<S['select'][P]>>  :
        P extends '_count' ? ScheduleCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Schedule ? Schedule[P] : never
  } 
      : Schedule


  type ScheduleCountArgs = 
    Omit<ScheduleFindManyArgs, 'select' | 'include'> & {
      select?: ScheduleCountAggregateInputType | true
    }

  export interface ScheduleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Schedule that matches the filter.
     * @param {ScheduleFindUniqueArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ScheduleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ScheduleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Schedule'> extends True ? Prisma__ScheduleClient<ScheduleGetPayload<T>> : Prisma__ScheduleClient<ScheduleGetPayload<T> | null, null>

    /**
     * Find one Schedule that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ScheduleFindUniqueOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ScheduleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ScheduleFindUniqueOrThrowArgs>
    ): Prisma__ScheduleClient<ScheduleGetPayload<T>>

    /**
     * Find the first Schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ScheduleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ScheduleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Schedule'> extends True ? Prisma__ScheduleClient<ScheduleGetPayload<T>> : Prisma__ScheduleClient<ScheduleGetPayload<T> | null, null>

    /**
     * Find the first Schedule that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ScheduleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ScheduleFindFirstOrThrowArgs>
    ): Prisma__ScheduleClient<ScheduleGetPayload<T>>

    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedule.findMany()
     * 
     * // Get first 10 Schedules
     * const schedules = await prisma.schedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleWithIdOnly = await prisma.schedule.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ScheduleFindManyArgs>(
      args?: SelectSubset<T, ScheduleFindManyArgs>
    ): Prisma.PrismaPromise<Array<ScheduleGetPayload<T>>>

    /**
     * Create a Schedule.
     * @param {ScheduleCreateArgs} args - Arguments to create a Schedule.
     * @example
     * // Create one Schedule
     * const Schedule = await prisma.schedule.create({
     *   data: {
     *     // ... data to create a Schedule
     *   }
     * })
     * 
    **/
    create<T extends ScheduleCreateArgs>(
      args: SelectSubset<T, ScheduleCreateArgs>
    ): Prisma__ScheduleClient<ScheduleGetPayload<T>>

    /**
     * Create many Schedules.
     *     @param {ScheduleCreateManyArgs} args - Arguments to create many Schedules.
     *     @example
     *     // Create many Schedules
     *     const schedule = await prisma.schedule.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ScheduleCreateManyArgs>(
      args?: SelectSubset<T, ScheduleCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Schedule.
     * @param {ScheduleDeleteArgs} args - Arguments to delete one Schedule.
     * @example
     * // Delete one Schedule
     * const Schedule = await prisma.schedule.delete({
     *   where: {
     *     // ... filter to delete one Schedule
     *   }
     * })
     * 
    **/
    delete<T extends ScheduleDeleteArgs>(
      args: SelectSubset<T, ScheduleDeleteArgs>
    ): Prisma__ScheduleClient<ScheduleGetPayload<T>>

    /**
     * Update one Schedule.
     * @param {ScheduleUpdateArgs} args - Arguments to update one Schedule.
     * @example
     * // Update one Schedule
     * const schedule = await prisma.schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ScheduleUpdateArgs>(
      args: SelectSubset<T, ScheduleUpdateArgs>
    ): Prisma__ScheduleClient<ScheduleGetPayload<T>>

    /**
     * Delete zero or more Schedules.
     * @param {ScheduleDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ScheduleDeleteManyArgs>(
      args?: SelectSubset<T, ScheduleDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ScheduleUpdateManyArgs>(
      args: SelectSubset<T, ScheduleUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Schedule.
     * @param {ScheduleUpsertArgs} args - Arguments to update or create a Schedule.
     * @example
     * // Update or create a Schedule
     * const schedule = await prisma.schedule.upsert({
     *   create: {
     *     // ... data to create a Schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedule we want to update
     *   }
     * })
    **/
    upsert<T extends ScheduleUpsertArgs>(
      args: SelectSubset<T, ScheduleUpsertArgs>
    ): Prisma__ScheduleClient<ScheduleGetPayload<T>>

    /**
     * Find zero or more Schedules that matches the filter.
     * @param {ScheduleFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const schedule = await prisma.schedule.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ScheduleFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Schedule.
     * @param {ScheduleAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const schedule = await prisma.schedule.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ScheduleAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedule.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends ScheduleCountArgs>(
      args?: Subset<T, ScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAggregateArgs>(args: Subset<T, ScheduleAggregateArgs>): Prisma.PrismaPromise<GetScheduleAggregateType<T>>

    /**
     * Group by Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ScheduleClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    year<T extends SchoolYearArgs= {}>(args?: Subset<T, SchoolYearArgs>): Prisma__SchoolYearClient<SchoolYearGetPayload<T> | Null>;

    mapel<T extends MataPelajaranArgs= {}>(args?: Subset<T, MataPelajaranArgs>): Prisma__MataPelajaranClient<MataPelajaranGetPayload<T> | Null>;

    tracker<T extends Schedule$trackerArgs= {}>(args?: Subset<T, Schedule$trackerArgs>): Prisma.PrismaPromise<Array<TrackerGetPayload<T>>| Null>;

    teaching<T extends Schedule$teachingArgs= {}>(args?: Subset<T, Schedule$teachingArgs>): Prisma.PrismaPromise<Array<TeachingGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Schedule base type for findUnique actions
   */
  export type ScheduleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScheduleInclude | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findUnique
   */
  export interface ScheduleFindUniqueArgs extends ScheduleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Schedule findUniqueOrThrow
   */
  export type ScheduleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScheduleInclude | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }


  /**
   * Schedule base type for findFirst actions
   */
  export type ScheduleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScheduleInclude | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: Enumerable<ScheduleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: Enumerable<ScheduleScalarFieldEnum>
  }

  /**
   * Schedule findFirst
   */
  export interface ScheduleFindFirstArgs extends ScheduleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Schedule findFirstOrThrow
   */
  export type ScheduleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScheduleInclude | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: Enumerable<ScheduleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: Enumerable<ScheduleScalarFieldEnum>
  }


  /**
   * Schedule findMany
   */
  export type ScheduleFindManyArgs = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScheduleInclude | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: Enumerable<ScheduleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    distinct?: Enumerable<ScheduleScalarFieldEnum>
  }


  /**
   * Schedule create
   */
  export type ScheduleCreateArgs = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScheduleInclude | null
    /**
     * The data needed to create a Schedule.
     */
    data: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
  }


  /**
   * Schedule createMany
   */
  export type ScheduleCreateManyArgs = {
    /**
     * The data used to create many Schedules.
     */
    data: Enumerable<ScheduleCreateManyInput>
  }


  /**
   * Schedule update
   */
  export type ScheduleUpdateArgs = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScheduleInclude | null
    /**
     * The data needed to update a Schedule.
     */
    data: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
    /**
     * Choose, which Schedule to update.
     */
    where: ScheduleWhereUniqueInput
  }


  /**
   * Schedule updateMany
   */
  export type ScheduleUpdateManyArgs = {
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
  }


  /**
   * Schedule upsert
   */
  export type ScheduleUpsertArgs = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScheduleInclude | null
    /**
     * The filter to search for the Schedule to update in case it exists.
     */
    where: ScheduleWhereUniqueInput
    /**
     * In case the Schedule found by the `where` argument doesn't exist, create a new Schedule with this data.
     */
    create: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
    /**
     * In case the Schedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
  }


  /**
   * Schedule delete
   */
  export type ScheduleDeleteArgs = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScheduleInclude | null
    /**
     * Filter which Schedule to delete.
     */
    where: ScheduleWhereUniqueInput
  }


  /**
   * Schedule deleteMany
   */
  export type ScheduleDeleteManyArgs = {
    /**
     * Filter which Schedules to delete
     */
    where?: ScheduleWhereInput
  }


  /**
   * Schedule findRaw
   */
  export type ScheduleFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Schedule aggregateRaw
   */
  export type ScheduleAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Schedule.tracker
   */
  export type Schedule$trackerArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    where?: TrackerWhereInput
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    cursor?: TrackerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TrackerScalarFieldEnum>
  }


  /**
   * Schedule.teaching
   */
  export type Schedule$teachingArgs = {
    /**
     * Select specific fields to fetch from the Teaching
     */
    select?: TeachingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachingInclude | null
    where?: TeachingWhereInput
    orderBy?: Enumerable<TeachingOrderByWithRelationInput>
    cursor?: TeachingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeachingScalarFieldEnum>
  }


  /**
   * Schedule without action
   */
  export type ScheduleArgs = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScheduleInclude | null
  }



  /**
   * Model Teaching
   */


  export type AggregateTeaching = {
    _count: TeachingCountAggregateOutputType | null
    _avg: TeachingAvgAggregateOutputType | null
    _sum: TeachingSumAggregateOutputType | null
    _min: TeachingMinAggregateOutputType | null
    _max: TeachingMaxAggregateOutputType | null
  }

  export type TeachingAvgAggregateOutputType = {
    level: number | null
    hours: number | null
  }

  export type TeachingSumAggregateOutputType = {
    level: number | null
    hours: number | null
  }

  export type TeachingMinAggregateOutputType = {
    id: string | null
    refId: string | null
    level: number | null
    hours: number | null
    semester: Semester | null
    teacherId: string | null
    disable: boolean | null
  }

  export type TeachingMaxAggregateOutputType = {
    id: string | null
    refId: string | null
    level: number | null
    hours: number | null
    semester: Semester | null
    teacherId: string | null
    disable: boolean | null
  }

  export type TeachingCountAggregateOutputType = {
    id: number
    refId: number
    level: number
    hours: number
    semester: number
    teacherId: number
    classRoomIds: number
    elemenIds: number
    disable: number
    _all: number
  }


  export type TeachingAvgAggregateInputType = {
    level?: true
    hours?: true
  }

  export type TeachingSumAggregateInputType = {
    level?: true
    hours?: true
  }

  export type TeachingMinAggregateInputType = {
    id?: true
    refId?: true
    level?: true
    hours?: true
    semester?: true
    teacherId?: true
    disable?: true
  }

  export type TeachingMaxAggregateInputType = {
    id?: true
    refId?: true
    level?: true
    hours?: true
    semester?: true
    teacherId?: true
    disable?: true
  }

  export type TeachingCountAggregateInputType = {
    id?: true
    refId?: true
    level?: true
    hours?: true
    semester?: true
    teacherId?: true
    classRoomIds?: true
    elemenIds?: true
    disable?: true
    _all?: true
  }

  export type TeachingAggregateArgs = {
    /**
     * Filter which Teaching to aggregate.
     */
    where?: TeachingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachings to fetch.
     */
    orderBy?: Enumerable<TeachingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeachingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teachings
    **/
    _count?: true | TeachingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeachingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeachingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeachingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeachingMaxAggregateInputType
  }

  export type GetTeachingAggregateType<T extends TeachingAggregateArgs> = {
        [P in keyof T & keyof AggregateTeaching]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeaching[P]>
      : GetScalarType<T[P], AggregateTeaching[P]>
  }




  export type TeachingGroupByArgs = {
    where?: TeachingWhereInput
    orderBy?: Enumerable<TeachingOrderByWithAggregationInput>
    by: TeachingScalarFieldEnum[]
    having?: TeachingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeachingCountAggregateInputType | true
    _avg?: TeachingAvgAggregateInputType
    _sum?: TeachingSumAggregateInputType
    _min?: TeachingMinAggregateInputType
    _max?: TeachingMaxAggregateInputType
  }


  export type TeachingGroupByOutputType = {
    id: string
    refId: string
    level: number
    hours: number
    semester: Semester
    teacherId: string
    classRoomIds: string[]
    elemenIds: string[]
    disable: boolean
    _count: TeachingCountAggregateOutputType | null
    _avg: TeachingAvgAggregateOutputType | null
    _sum: TeachingSumAggregateOutputType | null
    _min: TeachingMinAggregateOutputType | null
    _max: TeachingMaxAggregateOutputType | null
  }

  type GetTeachingGroupByPayload<T extends TeachingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TeachingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeachingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeachingGroupByOutputType[P]>
            : GetScalarType<T[P], TeachingGroupByOutputType[P]>
        }
      >
    >


  export type TeachingSelect = {
    id?: boolean
    refId?: boolean
    level?: boolean
    hours?: boolean
    semester?: boolean
    teacherId?: boolean
    classRoomIds?: boolean
    elemenIds?: boolean
    disable?: boolean
    ref?: boolean | ScheduleArgs
    teacher?: boolean | TeacherArgs
    classRoom?: boolean | Teaching$classRoomArgs
    elemen?: boolean | Teaching$elemenArgs
    tracker?: boolean | Teaching$trackerArgs
    tDevice?: boolean | Teaching$tDeviceArgs
    _count?: boolean | TeachingCountOutputTypeArgs
  }


  export type TeachingInclude = {
    ref?: boolean | ScheduleArgs
    teacher?: boolean | TeacherArgs
    classRoom?: boolean | Teaching$classRoomArgs
    elemen?: boolean | Teaching$elemenArgs
    tracker?: boolean | Teaching$trackerArgs
    tDevice?: boolean | Teaching$tDeviceArgs
    _count?: boolean | TeachingCountOutputTypeArgs
  }

  export type TeachingGetPayload<S extends boolean | null | undefined | TeachingArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Teaching :
    S extends undefined ? never :
    S extends { include: any } & (TeachingArgs | TeachingFindManyArgs)
    ? Teaching  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ref' ? ScheduleGetPayload<S['include'][P]> :
        P extends 'teacher' ? TeacherGetPayload<S['include'][P]> :
        P extends 'classRoom' ? Array < ClassRoomGetPayload<S['include'][P]>>  :
        P extends 'elemen' ? Array < ElementGetPayload<S['include'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['include'][P]>>  :
        P extends 'tDevice' ? Array < TDeviceGetPayload<S['include'][P]>>  :
        P extends '_count' ? TeachingCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TeachingArgs | TeachingFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ref' ? ScheduleGetPayload<S['select'][P]> :
        P extends 'teacher' ? TeacherGetPayload<S['select'][P]> :
        P extends 'classRoom' ? Array < ClassRoomGetPayload<S['select'][P]>>  :
        P extends 'elemen' ? Array < ElementGetPayload<S['select'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['select'][P]>>  :
        P extends 'tDevice' ? Array < TDeviceGetPayload<S['select'][P]>>  :
        P extends '_count' ? TeachingCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Teaching ? Teaching[P] : never
  } 
      : Teaching


  type TeachingCountArgs = 
    Omit<TeachingFindManyArgs, 'select' | 'include'> & {
      select?: TeachingCountAggregateInputType | true
    }

  export interface TeachingDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Teaching that matches the filter.
     * @param {TeachingFindUniqueArgs} args - Arguments to find a Teaching
     * @example
     * // Get one Teaching
     * const teaching = await prisma.teaching.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeachingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TeachingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Teaching'> extends True ? Prisma__TeachingClient<TeachingGetPayload<T>> : Prisma__TeachingClient<TeachingGetPayload<T> | null, null>

    /**
     * Find one Teaching that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TeachingFindUniqueOrThrowArgs} args - Arguments to find a Teaching
     * @example
     * // Get one Teaching
     * const teaching = await prisma.teaching.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TeachingFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TeachingFindUniqueOrThrowArgs>
    ): Prisma__TeachingClient<TeachingGetPayload<T>>

    /**
     * Find the first Teaching that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingFindFirstArgs} args - Arguments to find a Teaching
     * @example
     * // Get one Teaching
     * const teaching = await prisma.teaching.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeachingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TeachingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Teaching'> extends True ? Prisma__TeachingClient<TeachingGetPayload<T>> : Prisma__TeachingClient<TeachingGetPayload<T> | null, null>

    /**
     * Find the first Teaching that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingFindFirstOrThrowArgs} args - Arguments to find a Teaching
     * @example
     * // Get one Teaching
     * const teaching = await prisma.teaching.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TeachingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TeachingFindFirstOrThrowArgs>
    ): Prisma__TeachingClient<TeachingGetPayload<T>>

    /**
     * Find zero or more Teachings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachings
     * const teachings = await prisma.teaching.findMany()
     * 
     * // Get first 10 Teachings
     * const teachings = await prisma.teaching.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teachingWithIdOnly = await prisma.teaching.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeachingFindManyArgs>(
      args?: SelectSubset<T, TeachingFindManyArgs>
    ): Prisma.PrismaPromise<Array<TeachingGetPayload<T>>>

    /**
     * Create a Teaching.
     * @param {TeachingCreateArgs} args - Arguments to create a Teaching.
     * @example
     * // Create one Teaching
     * const Teaching = await prisma.teaching.create({
     *   data: {
     *     // ... data to create a Teaching
     *   }
     * })
     * 
    **/
    create<T extends TeachingCreateArgs>(
      args: SelectSubset<T, TeachingCreateArgs>
    ): Prisma__TeachingClient<TeachingGetPayload<T>>

    /**
     * Create many Teachings.
     *     @param {TeachingCreateManyArgs} args - Arguments to create many Teachings.
     *     @example
     *     // Create many Teachings
     *     const teaching = await prisma.teaching.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeachingCreateManyArgs>(
      args?: SelectSubset<T, TeachingCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Teaching.
     * @param {TeachingDeleteArgs} args - Arguments to delete one Teaching.
     * @example
     * // Delete one Teaching
     * const Teaching = await prisma.teaching.delete({
     *   where: {
     *     // ... filter to delete one Teaching
     *   }
     * })
     * 
    **/
    delete<T extends TeachingDeleteArgs>(
      args: SelectSubset<T, TeachingDeleteArgs>
    ): Prisma__TeachingClient<TeachingGetPayload<T>>

    /**
     * Update one Teaching.
     * @param {TeachingUpdateArgs} args - Arguments to update one Teaching.
     * @example
     * // Update one Teaching
     * const teaching = await prisma.teaching.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeachingUpdateArgs>(
      args: SelectSubset<T, TeachingUpdateArgs>
    ): Prisma__TeachingClient<TeachingGetPayload<T>>

    /**
     * Delete zero or more Teachings.
     * @param {TeachingDeleteManyArgs} args - Arguments to filter Teachings to delete.
     * @example
     * // Delete a few Teachings
     * const { count } = await prisma.teaching.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeachingDeleteManyArgs>(
      args?: SelectSubset<T, TeachingDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachings
     * const teaching = await prisma.teaching.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeachingUpdateManyArgs>(
      args: SelectSubset<T, TeachingUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Teaching.
     * @param {TeachingUpsertArgs} args - Arguments to update or create a Teaching.
     * @example
     * // Update or create a Teaching
     * const teaching = await prisma.teaching.upsert({
     *   create: {
     *     // ... data to create a Teaching
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teaching we want to update
     *   }
     * })
    **/
    upsert<T extends TeachingUpsertArgs>(
      args: SelectSubset<T, TeachingUpsertArgs>
    ): Prisma__TeachingClient<TeachingGetPayload<T>>

    /**
     * Find zero or more Teachings that matches the filter.
     * @param {TeachingFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const teaching = await prisma.teaching.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: TeachingFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Teaching.
     * @param {TeachingAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const teaching = await prisma.teaching.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: TeachingAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Teachings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingCountArgs} args - Arguments to filter Teachings to count.
     * @example
     * // Count the number of Teachings
     * const count = await prisma.teaching.count({
     *   where: {
     *     // ... the filter for the Teachings we want to count
     *   }
     * })
    **/
    count<T extends TeachingCountArgs>(
      args?: Subset<T, TeachingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeachingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teaching.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeachingAggregateArgs>(args: Subset<T, TeachingAggregateArgs>): Prisma.PrismaPromise<GetTeachingAggregateType<T>>

    /**
     * Group by Teaching.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeachingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeachingGroupByArgs['orderBy'] }
        : { orderBy?: TeachingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeachingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeachingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Teaching.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TeachingClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ref<T extends ScheduleArgs= {}>(args?: Subset<T, ScheduleArgs>): Prisma__ScheduleClient<ScheduleGetPayload<T> | Null>;

    teacher<T extends TeacherArgs= {}>(args?: Subset<T, TeacherArgs>): Prisma__TeacherClient<TeacherGetPayload<T> | Null>;

    classRoom<T extends Teaching$classRoomArgs= {}>(args?: Subset<T, Teaching$classRoomArgs>): Prisma.PrismaPromise<Array<ClassRoomGetPayload<T>>| Null>;

    elemen<T extends Teaching$elemenArgs= {}>(args?: Subset<T, Teaching$elemenArgs>): Prisma.PrismaPromise<Array<ElementGetPayload<T>>| Null>;

    tracker<T extends Teaching$trackerArgs= {}>(args?: Subset<T, Teaching$trackerArgs>): Prisma.PrismaPromise<Array<TrackerGetPayload<T>>| Null>;

    tDevice<T extends Teaching$tDeviceArgs= {}>(args?: Subset<T, Teaching$tDeviceArgs>): Prisma.PrismaPromise<Array<TDeviceGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Teaching base type for findUnique actions
   */
  export type TeachingFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Teaching
     */
    select?: TeachingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachingInclude | null
    /**
     * Filter, which Teaching to fetch.
     */
    where: TeachingWhereUniqueInput
  }

  /**
   * Teaching findUnique
   */
  export interface TeachingFindUniqueArgs extends TeachingFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Teaching findUniqueOrThrow
   */
  export type TeachingFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Teaching
     */
    select?: TeachingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachingInclude | null
    /**
     * Filter, which Teaching to fetch.
     */
    where: TeachingWhereUniqueInput
  }


  /**
   * Teaching base type for findFirst actions
   */
  export type TeachingFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Teaching
     */
    select?: TeachingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachingInclude | null
    /**
     * Filter, which Teaching to fetch.
     */
    where?: TeachingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachings to fetch.
     */
    orderBy?: Enumerable<TeachingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachings.
     */
    cursor?: TeachingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachings.
     */
    distinct?: Enumerable<TeachingScalarFieldEnum>
  }

  /**
   * Teaching findFirst
   */
  export interface TeachingFindFirstArgs extends TeachingFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Teaching findFirstOrThrow
   */
  export type TeachingFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Teaching
     */
    select?: TeachingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachingInclude | null
    /**
     * Filter, which Teaching to fetch.
     */
    where?: TeachingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachings to fetch.
     */
    orderBy?: Enumerable<TeachingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachings.
     */
    cursor?: TeachingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachings.
     */
    distinct?: Enumerable<TeachingScalarFieldEnum>
  }


  /**
   * Teaching findMany
   */
  export type TeachingFindManyArgs = {
    /**
     * Select specific fields to fetch from the Teaching
     */
    select?: TeachingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachingInclude | null
    /**
     * Filter, which Teachings to fetch.
     */
    where?: TeachingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachings to fetch.
     */
    orderBy?: Enumerable<TeachingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teachings.
     */
    cursor?: TeachingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachings.
     */
    skip?: number
    distinct?: Enumerable<TeachingScalarFieldEnum>
  }


  /**
   * Teaching create
   */
  export type TeachingCreateArgs = {
    /**
     * Select specific fields to fetch from the Teaching
     */
    select?: TeachingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachingInclude | null
    /**
     * The data needed to create a Teaching.
     */
    data: XOR<TeachingCreateInput, TeachingUncheckedCreateInput>
  }


  /**
   * Teaching createMany
   */
  export type TeachingCreateManyArgs = {
    /**
     * The data used to create many Teachings.
     */
    data: Enumerable<TeachingCreateManyInput>
  }


  /**
   * Teaching update
   */
  export type TeachingUpdateArgs = {
    /**
     * Select specific fields to fetch from the Teaching
     */
    select?: TeachingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachingInclude | null
    /**
     * The data needed to update a Teaching.
     */
    data: XOR<TeachingUpdateInput, TeachingUncheckedUpdateInput>
    /**
     * Choose, which Teaching to update.
     */
    where: TeachingWhereUniqueInput
  }


  /**
   * Teaching updateMany
   */
  export type TeachingUpdateManyArgs = {
    /**
     * The data used to update Teachings.
     */
    data: XOR<TeachingUpdateManyMutationInput, TeachingUncheckedUpdateManyInput>
    /**
     * Filter which Teachings to update
     */
    where?: TeachingWhereInput
  }


  /**
   * Teaching upsert
   */
  export type TeachingUpsertArgs = {
    /**
     * Select specific fields to fetch from the Teaching
     */
    select?: TeachingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachingInclude | null
    /**
     * The filter to search for the Teaching to update in case it exists.
     */
    where: TeachingWhereUniqueInput
    /**
     * In case the Teaching found by the `where` argument doesn't exist, create a new Teaching with this data.
     */
    create: XOR<TeachingCreateInput, TeachingUncheckedCreateInput>
    /**
     * In case the Teaching was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeachingUpdateInput, TeachingUncheckedUpdateInput>
  }


  /**
   * Teaching delete
   */
  export type TeachingDeleteArgs = {
    /**
     * Select specific fields to fetch from the Teaching
     */
    select?: TeachingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachingInclude | null
    /**
     * Filter which Teaching to delete.
     */
    where: TeachingWhereUniqueInput
  }


  /**
   * Teaching deleteMany
   */
  export type TeachingDeleteManyArgs = {
    /**
     * Filter which Teachings to delete
     */
    where?: TeachingWhereInput
  }


  /**
   * Teaching findRaw
   */
  export type TeachingFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Teaching aggregateRaw
   */
  export type TeachingAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Teaching.classRoom
   */
  export type Teaching$classRoomArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    where?: ClassRoomWhereInput
    orderBy?: Enumerable<ClassRoomOrderByWithRelationInput>
    cursor?: ClassRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ClassRoomScalarFieldEnum>
  }


  /**
   * Teaching.elemen
   */
  export type Teaching$elemenArgs = {
    /**
     * Select specific fields to fetch from the Element
     */
    select?: ElementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ElementInclude | null
    where?: ElementWhereInput
    orderBy?: Enumerable<ElementOrderByWithRelationInput>
    cursor?: ElementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ElementScalarFieldEnum>
  }


  /**
   * Teaching.tracker
   */
  export type Teaching$trackerArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    where?: TrackerWhereInput
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    cursor?: TrackerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TrackerScalarFieldEnum>
  }


  /**
   * Teaching.tDevice
   */
  export type Teaching$tDeviceArgs = {
    /**
     * Select specific fields to fetch from the TDevice
     */
    select?: TDeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceInclude | null
    where?: TDeviceWhereInput
    orderBy?: Enumerable<TDeviceOrderByWithRelationInput>
    cursor?: TDeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TDeviceScalarFieldEnum>
  }


  /**
   * Teaching without action
   */
  export type TeachingArgs = {
    /**
     * Select specific fields to fetch from the Teaching
     */
    select?: TeachingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachingInclude | null
  }



  /**
   * Model Link
   */


  export type AggregateLink = {
    _count: LinkCountAggregateOutputType | null
    _avg: LinkAvgAggregateOutputType | null
    _sum: LinkSumAggregateOutputType | null
    _min: LinkMinAggregateOutputType | null
    _max: LinkMaxAggregateOutputType | null
  }

  export type LinkAvgAggregateOutputType = {
    width: number | null
    height: number | null
  }

  export type LinkSumAggregateOutputType = {
    width: number | null
    height: number | null
  }

  export type LinkMinAggregateOutputType = {
    id: string | null
    url: string | null
    title: string | null
    description: string | null
    image: string | null
    width: number | null
    height: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LinkMaxAggregateOutputType = {
    id: string | null
    url: string | null
    title: string | null
    description: string | null
    image: string | null
    width: number | null
    height: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LinkCountAggregateOutputType = {
    id: number
    url: number
    title: number
    description: number
    image: number
    width: number
    height: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LinkAvgAggregateInputType = {
    width?: true
    height?: true
  }

  export type LinkSumAggregateInputType = {
    width?: true
    height?: true
  }

  export type LinkMinAggregateInputType = {
    id?: true
    url?: true
    title?: true
    description?: true
    image?: true
    width?: true
    height?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LinkMaxAggregateInputType = {
    id?: true
    url?: true
    title?: true
    description?: true
    image?: true
    width?: true
    height?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LinkCountAggregateInputType = {
    id?: true
    url?: true
    title?: true
    description?: true
    image?: true
    width?: true
    height?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LinkAggregateArgs = {
    /**
     * Filter which Link to aggregate.
     */
    where?: LinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Links to fetch.
     */
    orderBy?: Enumerable<LinkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Links
    **/
    _count?: true | LinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LinkMaxAggregateInputType
  }

  export type GetLinkAggregateType<T extends LinkAggregateArgs> = {
        [P in keyof T & keyof AggregateLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLink[P]>
      : GetScalarType<T[P], AggregateLink[P]>
  }




  export type LinkGroupByArgs = {
    where?: LinkWhereInput
    orderBy?: Enumerable<LinkOrderByWithAggregationInput>
    by: LinkScalarFieldEnum[]
    having?: LinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LinkCountAggregateInputType | true
    _avg?: LinkAvgAggregateInputType
    _sum?: LinkSumAggregateInputType
    _min?: LinkMinAggregateInputType
    _max?: LinkMaxAggregateInputType
  }


  export type LinkGroupByOutputType = {
    id: string
    url: string | null
    title: string
    description: string | null
    image: string | null
    width: number | null
    height: number | null
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: LinkCountAggregateOutputType | null
    _avg: LinkAvgAggregateOutputType | null
    _sum: LinkSumAggregateOutputType | null
    _min: LinkMinAggregateOutputType | null
    _max: LinkMaxAggregateOutputType | null
  }

  type GetLinkGroupByPayload<T extends LinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LinkGroupByOutputType[P]>
            : GetScalarType<T[P], LinkGroupByOutputType[P]>
        }
      >
    >


  export type LinkSelect = {
    id?: boolean
    url?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    width?: boolean
    height?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
    objResource?: boolean | Link$objResourceArgs
    _count?: boolean | LinkCountOutputTypeArgs
  }


  export type LinkInclude = {
    user?: boolean | UserArgs
    objResource?: boolean | Link$objResourceArgs
    _count?: boolean | LinkCountOutputTypeArgs
  }

  export type LinkGetPayload<S extends boolean | null | undefined | LinkArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Link :
    S extends undefined ? never :
    S extends { include: any } & (LinkArgs | LinkFindManyArgs)
    ? Link  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'objResource' ? Array < OresourceGetPayload<S['include'][P]>>  :
        P extends '_count' ? LinkCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LinkArgs | LinkFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'objResource' ? Array < OresourceGetPayload<S['select'][P]>>  :
        P extends '_count' ? LinkCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Link ? Link[P] : never
  } 
      : Link


  type LinkCountArgs = 
    Omit<LinkFindManyArgs, 'select' | 'include'> & {
      select?: LinkCountAggregateInputType | true
    }

  export interface LinkDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Link that matches the filter.
     * @param {LinkFindUniqueArgs} args - Arguments to find a Link
     * @example
     * // Get one Link
     * const link = await prisma.link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LinkFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LinkFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Link'> extends True ? Prisma__LinkClient<LinkGetPayload<T>> : Prisma__LinkClient<LinkGetPayload<T> | null, null>

    /**
     * Find one Link that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LinkFindUniqueOrThrowArgs} args - Arguments to find a Link
     * @example
     * // Get one Link
     * const link = await prisma.link.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LinkFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LinkFindUniqueOrThrowArgs>
    ): Prisma__LinkClient<LinkGetPayload<T>>

    /**
     * Find the first Link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkFindFirstArgs} args - Arguments to find a Link
     * @example
     * // Get one Link
     * const link = await prisma.link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LinkFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LinkFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Link'> extends True ? Prisma__LinkClient<LinkGetPayload<T>> : Prisma__LinkClient<LinkGetPayload<T> | null, null>

    /**
     * Find the first Link that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkFindFirstOrThrowArgs} args - Arguments to find a Link
     * @example
     * // Get one Link
     * const link = await prisma.link.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LinkFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LinkFindFirstOrThrowArgs>
    ): Prisma__LinkClient<LinkGetPayload<T>>

    /**
     * Find zero or more Links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Links
     * const links = await prisma.link.findMany()
     * 
     * // Get first 10 Links
     * const links = await prisma.link.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const linkWithIdOnly = await prisma.link.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LinkFindManyArgs>(
      args?: SelectSubset<T, LinkFindManyArgs>
    ): Prisma.PrismaPromise<Array<LinkGetPayload<T>>>

    /**
     * Create a Link.
     * @param {LinkCreateArgs} args - Arguments to create a Link.
     * @example
     * // Create one Link
     * const Link = await prisma.link.create({
     *   data: {
     *     // ... data to create a Link
     *   }
     * })
     * 
    **/
    create<T extends LinkCreateArgs>(
      args: SelectSubset<T, LinkCreateArgs>
    ): Prisma__LinkClient<LinkGetPayload<T>>

    /**
     * Create many Links.
     *     @param {LinkCreateManyArgs} args - Arguments to create many Links.
     *     @example
     *     // Create many Links
     *     const link = await prisma.link.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LinkCreateManyArgs>(
      args?: SelectSubset<T, LinkCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Link.
     * @param {LinkDeleteArgs} args - Arguments to delete one Link.
     * @example
     * // Delete one Link
     * const Link = await prisma.link.delete({
     *   where: {
     *     // ... filter to delete one Link
     *   }
     * })
     * 
    **/
    delete<T extends LinkDeleteArgs>(
      args: SelectSubset<T, LinkDeleteArgs>
    ): Prisma__LinkClient<LinkGetPayload<T>>

    /**
     * Update one Link.
     * @param {LinkUpdateArgs} args - Arguments to update one Link.
     * @example
     * // Update one Link
     * const link = await prisma.link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LinkUpdateArgs>(
      args: SelectSubset<T, LinkUpdateArgs>
    ): Prisma__LinkClient<LinkGetPayload<T>>

    /**
     * Delete zero or more Links.
     * @param {LinkDeleteManyArgs} args - Arguments to filter Links to delete.
     * @example
     * // Delete a few Links
     * const { count } = await prisma.link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LinkDeleteManyArgs>(
      args?: SelectSubset<T, LinkDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Links
     * const link = await prisma.link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LinkUpdateManyArgs>(
      args: SelectSubset<T, LinkUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Link.
     * @param {LinkUpsertArgs} args - Arguments to update or create a Link.
     * @example
     * // Update or create a Link
     * const link = await prisma.link.upsert({
     *   create: {
     *     // ... data to create a Link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Link we want to update
     *   }
     * })
    **/
    upsert<T extends LinkUpsertArgs>(
      args: SelectSubset<T, LinkUpsertArgs>
    ): Prisma__LinkClient<LinkGetPayload<T>>

    /**
     * Find zero or more Links that matches the filter.
     * @param {LinkFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const link = await prisma.link.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: LinkFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Link.
     * @param {LinkAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const link = await prisma.link.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: LinkAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkCountArgs} args - Arguments to filter Links to count.
     * @example
     * // Count the number of Links
     * const count = await prisma.link.count({
     *   where: {
     *     // ... the filter for the Links we want to count
     *   }
     * })
    **/
    count<T extends LinkCountArgs>(
      args?: Subset<T, LinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LinkAggregateArgs>(args: Subset<T, LinkAggregateArgs>): Prisma.PrismaPromise<GetLinkAggregateType<T>>

    /**
     * Group by Link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LinkGroupByArgs['orderBy'] }
        : { orderBy?: LinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LinkClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    objResource<T extends Link$objResourceArgs= {}>(args?: Subset<T, Link$objResourceArgs>): Prisma.PrismaPromise<Array<OresourceGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Link base type for findUnique actions
   */
  export type LinkFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
    /**
     * Filter, which Link to fetch.
     */
    where: LinkWhereUniqueInput
  }

  /**
   * Link findUnique
   */
  export interface LinkFindUniqueArgs extends LinkFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Link findUniqueOrThrow
   */
  export type LinkFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
    /**
     * Filter, which Link to fetch.
     */
    where: LinkWhereUniqueInput
  }


  /**
   * Link base type for findFirst actions
   */
  export type LinkFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
    /**
     * Filter, which Link to fetch.
     */
    where?: LinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Links to fetch.
     */
    orderBy?: Enumerable<LinkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Links.
     */
    cursor?: LinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Links.
     */
    distinct?: Enumerable<LinkScalarFieldEnum>
  }

  /**
   * Link findFirst
   */
  export interface LinkFindFirstArgs extends LinkFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Link findFirstOrThrow
   */
  export type LinkFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
    /**
     * Filter, which Link to fetch.
     */
    where?: LinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Links to fetch.
     */
    orderBy?: Enumerable<LinkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Links.
     */
    cursor?: LinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Links.
     */
    distinct?: Enumerable<LinkScalarFieldEnum>
  }


  /**
   * Link findMany
   */
  export type LinkFindManyArgs = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
    /**
     * Filter, which Links to fetch.
     */
    where?: LinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Links to fetch.
     */
    orderBy?: Enumerable<LinkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Links.
     */
    cursor?: LinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Links.
     */
    skip?: number
    distinct?: Enumerable<LinkScalarFieldEnum>
  }


  /**
   * Link create
   */
  export type LinkCreateArgs = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
    /**
     * The data needed to create a Link.
     */
    data: XOR<LinkCreateInput, LinkUncheckedCreateInput>
  }


  /**
   * Link createMany
   */
  export type LinkCreateManyArgs = {
    /**
     * The data used to create many Links.
     */
    data: Enumerable<LinkCreateManyInput>
  }


  /**
   * Link update
   */
  export type LinkUpdateArgs = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
    /**
     * The data needed to update a Link.
     */
    data: XOR<LinkUpdateInput, LinkUncheckedUpdateInput>
    /**
     * Choose, which Link to update.
     */
    where: LinkWhereUniqueInput
  }


  /**
   * Link updateMany
   */
  export type LinkUpdateManyArgs = {
    /**
     * The data used to update Links.
     */
    data: XOR<LinkUpdateManyMutationInput, LinkUncheckedUpdateManyInput>
    /**
     * Filter which Links to update
     */
    where?: LinkWhereInput
  }


  /**
   * Link upsert
   */
  export type LinkUpsertArgs = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
    /**
     * The filter to search for the Link to update in case it exists.
     */
    where: LinkWhereUniqueInput
    /**
     * In case the Link found by the `where` argument doesn't exist, create a new Link with this data.
     */
    create: XOR<LinkCreateInput, LinkUncheckedCreateInput>
    /**
     * In case the Link was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LinkUpdateInput, LinkUncheckedUpdateInput>
  }


  /**
   * Link delete
   */
  export type LinkDeleteArgs = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
    /**
     * Filter which Link to delete.
     */
    where: LinkWhereUniqueInput
  }


  /**
   * Link deleteMany
   */
  export type LinkDeleteManyArgs = {
    /**
     * Filter which Links to delete
     */
    where?: LinkWhereInput
  }


  /**
   * Link findRaw
   */
  export type LinkFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Link aggregateRaw
   */
  export type LinkAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Link.objResource
   */
  export type Link$objResourceArgs = {
    /**
     * Select specific fields to fetch from the Oresource
     */
    select?: OresourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OresourceInclude | null
    where?: OresourceWhereInput
    orderBy?: Enumerable<OresourceOrderByWithRelationInput>
    cursor?: OresourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OresourceScalarFieldEnum>
  }


  /**
   * Link without action
   */
  export type LinkArgs = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude | null
  }



  /**
   * Model OAssessment
   */


  export type AggregateOAssessment = {
    _count: OAssessmentCountAggregateOutputType | null
    _min: OAssessmentMinAggregateOutputType | null
    _max: OAssessmentMaxAggregateOutputType | null
  }

  export type OAssessmentMinAggregateOutputType = {
    id: string | null
    refId: string | null
    type: string | null
  }

  export type OAssessmentMaxAggregateOutputType = {
    id: string | null
    refId: string | null
    type: string | null
  }

  export type OAssessmentCountAggregateOutputType = {
    id: number
    refId: number
    type: number
    techs: number
    _all: number
  }


  export type OAssessmentMinAggregateInputType = {
    id?: true
    refId?: true
    type?: true
  }

  export type OAssessmentMaxAggregateInputType = {
    id?: true
    refId?: true
    type?: true
  }

  export type OAssessmentCountAggregateInputType = {
    id?: true
    refId?: true
    type?: true
    techs?: true
    _all?: true
  }

  export type OAssessmentAggregateArgs = {
    /**
     * Filter which OAssessment to aggregate.
     */
    where?: OAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAssessments to fetch.
     */
    orderBy?: Enumerable<OAssessmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OAssessments
    **/
    _count?: true | OAssessmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OAssessmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OAssessmentMaxAggregateInputType
  }

  export type GetOAssessmentAggregateType<T extends OAssessmentAggregateArgs> = {
        [P in keyof T & keyof AggregateOAssessment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOAssessment[P]>
      : GetScalarType<T[P], AggregateOAssessment[P]>
  }




  export type OAssessmentGroupByArgs = {
    where?: OAssessmentWhereInput
    orderBy?: Enumerable<OAssessmentOrderByWithAggregationInput>
    by: OAssessmentScalarFieldEnum[]
    having?: OAssessmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OAssessmentCountAggregateInputType | true
    _min?: OAssessmentMinAggregateInputType
    _max?: OAssessmentMaxAggregateInputType
  }


  export type OAssessmentGroupByOutputType = {
    id: string
    refId: string
    type: string
    techs: string[]
    _count: OAssessmentCountAggregateOutputType | null
    _min: OAssessmentMinAggregateOutputType | null
    _max: OAssessmentMaxAggregateOutputType | null
  }

  type GetOAssessmentGroupByPayload<T extends OAssessmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OAssessmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OAssessmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OAssessmentGroupByOutputType[P]>
            : GetScalarType<T[P], OAssessmentGroupByOutputType[P]>
        }
      >
    >


  export type OAssessmentSelect = {
    id?: boolean
    refId?: boolean
    type?: boolean
    techs?: boolean
    ref?: boolean | ObjectiveArgs
  }


  export type OAssessmentInclude = {
    ref?: boolean | ObjectiveArgs
  }

  export type OAssessmentGetPayload<S extends boolean | null | undefined | OAssessmentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OAssessment :
    S extends undefined ? never :
    S extends { include: any } & (OAssessmentArgs | OAssessmentFindManyArgs)
    ? OAssessment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ref' ? ObjectiveGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (OAssessmentArgs | OAssessmentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ref' ? ObjectiveGetPayload<S['select'][P]> :  P extends keyof OAssessment ? OAssessment[P] : never
  } 
      : OAssessment


  type OAssessmentCountArgs = 
    Omit<OAssessmentFindManyArgs, 'select' | 'include'> & {
      select?: OAssessmentCountAggregateInputType | true
    }

  export interface OAssessmentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one OAssessment that matches the filter.
     * @param {OAssessmentFindUniqueArgs} args - Arguments to find a OAssessment
     * @example
     * // Get one OAssessment
     * const oAssessment = await prisma.oAssessment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OAssessmentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OAssessmentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OAssessment'> extends True ? Prisma__OAssessmentClient<OAssessmentGetPayload<T>> : Prisma__OAssessmentClient<OAssessmentGetPayload<T> | null, null>

    /**
     * Find one OAssessment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OAssessmentFindUniqueOrThrowArgs} args - Arguments to find a OAssessment
     * @example
     * // Get one OAssessment
     * const oAssessment = await prisma.oAssessment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OAssessmentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OAssessmentFindUniqueOrThrowArgs>
    ): Prisma__OAssessmentClient<OAssessmentGetPayload<T>>

    /**
     * Find the first OAssessment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAssessmentFindFirstArgs} args - Arguments to find a OAssessment
     * @example
     * // Get one OAssessment
     * const oAssessment = await prisma.oAssessment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OAssessmentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OAssessmentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OAssessment'> extends True ? Prisma__OAssessmentClient<OAssessmentGetPayload<T>> : Prisma__OAssessmentClient<OAssessmentGetPayload<T> | null, null>

    /**
     * Find the first OAssessment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAssessmentFindFirstOrThrowArgs} args - Arguments to find a OAssessment
     * @example
     * // Get one OAssessment
     * const oAssessment = await prisma.oAssessment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OAssessmentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OAssessmentFindFirstOrThrowArgs>
    ): Prisma__OAssessmentClient<OAssessmentGetPayload<T>>

    /**
     * Find zero or more OAssessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAssessmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OAssessments
     * const oAssessments = await prisma.oAssessment.findMany()
     * 
     * // Get first 10 OAssessments
     * const oAssessments = await prisma.oAssessment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oAssessmentWithIdOnly = await prisma.oAssessment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OAssessmentFindManyArgs>(
      args?: SelectSubset<T, OAssessmentFindManyArgs>
    ): Prisma.PrismaPromise<Array<OAssessmentGetPayload<T>>>

    /**
     * Create a OAssessment.
     * @param {OAssessmentCreateArgs} args - Arguments to create a OAssessment.
     * @example
     * // Create one OAssessment
     * const OAssessment = await prisma.oAssessment.create({
     *   data: {
     *     // ... data to create a OAssessment
     *   }
     * })
     * 
    **/
    create<T extends OAssessmentCreateArgs>(
      args: SelectSubset<T, OAssessmentCreateArgs>
    ): Prisma__OAssessmentClient<OAssessmentGetPayload<T>>

    /**
     * Create many OAssessments.
     *     @param {OAssessmentCreateManyArgs} args - Arguments to create many OAssessments.
     *     @example
     *     // Create many OAssessments
     *     const oAssessment = await prisma.oAssessment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OAssessmentCreateManyArgs>(
      args?: SelectSubset<T, OAssessmentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OAssessment.
     * @param {OAssessmentDeleteArgs} args - Arguments to delete one OAssessment.
     * @example
     * // Delete one OAssessment
     * const OAssessment = await prisma.oAssessment.delete({
     *   where: {
     *     // ... filter to delete one OAssessment
     *   }
     * })
     * 
    **/
    delete<T extends OAssessmentDeleteArgs>(
      args: SelectSubset<T, OAssessmentDeleteArgs>
    ): Prisma__OAssessmentClient<OAssessmentGetPayload<T>>

    /**
     * Update one OAssessment.
     * @param {OAssessmentUpdateArgs} args - Arguments to update one OAssessment.
     * @example
     * // Update one OAssessment
     * const oAssessment = await prisma.oAssessment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OAssessmentUpdateArgs>(
      args: SelectSubset<T, OAssessmentUpdateArgs>
    ): Prisma__OAssessmentClient<OAssessmentGetPayload<T>>

    /**
     * Delete zero or more OAssessments.
     * @param {OAssessmentDeleteManyArgs} args - Arguments to filter OAssessments to delete.
     * @example
     * // Delete a few OAssessments
     * const { count } = await prisma.oAssessment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OAssessmentDeleteManyArgs>(
      args?: SelectSubset<T, OAssessmentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAssessmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OAssessments
     * const oAssessment = await prisma.oAssessment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OAssessmentUpdateManyArgs>(
      args: SelectSubset<T, OAssessmentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OAssessment.
     * @param {OAssessmentUpsertArgs} args - Arguments to update or create a OAssessment.
     * @example
     * // Update or create a OAssessment
     * const oAssessment = await prisma.oAssessment.upsert({
     *   create: {
     *     // ... data to create a OAssessment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OAssessment we want to update
     *   }
     * })
    **/
    upsert<T extends OAssessmentUpsertArgs>(
      args: SelectSubset<T, OAssessmentUpsertArgs>
    ): Prisma__OAssessmentClient<OAssessmentGetPayload<T>>

    /**
     * Find zero or more OAssessments that matches the filter.
     * @param {OAssessmentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const oAssessment = await prisma.oAssessment.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: OAssessmentFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a OAssessment.
     * @param {OAssessmentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const oAssessment = await prisma.oAssessment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: OAssessmentAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of OAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAssessmentCountArgs} args - Arguments to filter OAssessments to count.
     * @example
     * // Count the number of OAssessments
     * const count = await prisma.oAssessment.count({
     *   where: {
     *     // ... the filter for the OAssessments we want to count
     *   }
     * })
    **/
    count<T extends OAssessmentCountArgs>(
      args?: Subset<T, OAssessmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OAssessmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAssessmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OAssessmentAggregateArgs>(args: Subset<T, OAssessmentAggregateArgs>): Prisma.PrismaPromise<GetOAssessmentAggregateType<T>>

    /**
     * Group by OAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAssessmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OAssessmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OAssessmentGroupByArgs['orderBy'] }
        : { orderBy?: OAssessmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OAssessmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOAssessmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OAssessment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OAssessmentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ref<T extends ObjectiveArgs= {}>(args?: Subset<T, ObjectiveArgs>): Prisma__ObjectiveClient<ObjectiveGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OAssessment base type for findUnique actions
   */
  export type OAssessmentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OAssessment
     */
    select?: OAssessmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAssessmentInclude | null
    /**
     * Filter, which OAssessment to fetch.
     */
    where: OAssessmentWhereUniqueInput
  }

  /**
   * OAssessment findUnique
   */
  export interface OAssessmentFindUniqueArgs extends OAssessmentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OAssessment findUniqueOrThrow
   */
  export type OAssessmentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OAssessment
     */
    select?: OAssessmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAssessmentInclude | null
    /**
     * Filter, which OAssessment to fetch.
     */
    where: OAssessmentWhereUniqueInput
  }


  /**
   * OAssessment base type for findFirst actions
   */
  export type OAssessmentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OAssessment
     */
    select?: OAssessmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAssessmentInclude | null
    /**
     * Filter, which OAssessment to fetch.
     */
    where?: OAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAssessments to fetch.
     */
    orderBy?: Enumerable<OAssessmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAssessments.
     */
    cursor?: OAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAssessments.
     */
    distinct?: Enumerable<OAssessmentScalarFieldEnum>
  }

  /**
   * OAssessment findFirst
   */
  export interface OAssessmentFindFirstArgs extends OAssessmentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OAssessment findFirstOrThrow
   */
  export type OAssessmentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OAssessment
     */
    select?: OAssessmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAssessmentInclude | null
    /**
     * Filter, which OAssessment to fetch.
     */
    where?: OAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAssessments to fetch.
     */
    orderBy?: Enumerable<OAssessmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAssessments.
     */
    cursor?: OAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAssessments.
     */
    distinct?: Enumerable<OAssessmentScalarFieldEnum>
  }


  /**
   * OAssessment findMany
   */
  export type OAssessmentFindManyArgs = {
    /**
     * Select specific fields to fetch from the OAssessment
     */
    select?: OAssessmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAssessmentInclude | null
    /**
     * Filter, which OAssessments to fetch.
     */
    where?: OAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAssessments to fetch.
     */
    orderBy?: Enumerable<OAssessmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OAssessments.
     */
    cursor?: OAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAssessments.
     */
    skip?: number
    distinct?: Enumerable<OAssessmentScalarFieldEnum>
  }


  /**
   * OAssessment create
   */
  export type OAssessmentCreateArgs = {
    /**
     * Select specific fields to fetch from the OAssessment
     */
    select?: OAssessmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAssessmentInclude | null
    /**
     * The data needed to create a OAssessment.
     */
    data: XOR<OAssessmentCreateInput, OAssessmentUncheckedCreateInput>
  }


  /**
   * OAssessment createMany
   */
  export type OAssessmentCreateManyArgs = {
    /**
     * The data used to create many OAssessments.
     */
    data: Enumerable<OAssessmentCreateManyInput>
  }


  /**
   * OAssessment update
   */
  export type OAssessmentUpdateArgs = {
    /**
     * Select specific fields to fetch from the OAssessment
     */
    select?: OAssessmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAssessmentInclude | null
    /**
     * The data needed to update a OAssessment.
     */
    data: XOR<OAssessmentUpdateInput, OAssessmentUncheckedUpdateInput>
    /**
     * Choose, which OAssessment to update.
     */
    where: OAssessmentWhereUniqueInput
  }


  /**
   * OAssessment updateMany
   */
  export type OAssessmentUpdateManyArgs = {
    /**
     * The data used to update OAssessments.
     */
    data: XOR<OAssessmentUpdateManyMutationInput, OAssessmentUncheckedUpdateManyInput>
    /**
     * Filter which OAssessments to update
     */
    where?: OAssessmentWhereInput
  }


  /**
   * OAssessment upsert
   */
  export type OAssessmentUpsertArgs = {
    /**
     * Select specific fields to fetch from the OAssessment
     */
    select?: OAssessmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAssessmentInclude | null
    /**
     * The filter to search for the OAssessment to update in case it exists.
     */
    where: OAssessmentWhereUniqueInput
    /**
     * In case the OAssessment found by the `where` argument doesn't exist, create a new OAssessment with this data.
     */
    create: XOR<OAssessmentCreateInput, OAssessmentUncheckedCreateInput>
    /**
     * In case the OAssessment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OAssessmentUpdateInput, OAssessmentUncheckedUpdateInput>
  }


  /**
   * OAssessment delete
   */
  export type OAssessmentDeleteArgs = {
    /**
     * Select specific fields to fetch from the OAssessment
     */
    select?: OAssessmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAssessmentInclude | null
    /**
     * Filter which OAssessment to delete.
     */
    where: OAssessmentWhereUniqueInput
  }


  /**
   * OAssessment deleteMany
   */
  export type OAssessmentDeleteManyArgs = {
    /**
     * Filter which OAssessments to delete
     */
    where?: OAssessmentWhereInput
  }


  /**
   * OAssessment findRaw
   */
  export type OAssessmentFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * OAssessment aggregateRaw
   */
  export type OAssessmentAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * OAssessment without action
   */
  export type OAssessmentArgs = {
    /**
     * Select specific fields to fetch from the OAssessment
     */
    select?: OAssessmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAssessmentInclude | null
  }



  /**
   * Model Objective
   */


  export type AggregateObjective = {
    _count: ObjectiveCountAggregateOutputType | null
    _avg: ObjectiveAvgAggregateOutputType | null
    _sum: ObjectiveSumAggregateOutputType | null
    _min: ObjectiveMinAggregateOutputType | null
    _max: ObjectiveMaxAggregateOutputType | null
  }

  export type ObjectiveAvgAggregateOutputType = {
    level: number | null
    kkm: number | null
    steps: number | null
  }

  export type ObjectiveSumAggregateOutputType = {
    level: number | null
    kkm: number | null
    steps: number | null
  }

  export type ObjectiveMinAggregateOutputType = {
    id: string | null
    level: number | null
    fase: Fase | null
    userId: string | null
    instansiId: string | null
    yearId: string | null
    mapelId: string | null
    elementId: string | null
    achievementId: string | null
    code: string | null
    kkm: number | null
    steps: number | null
    subjectMatter: string | null
    disable: boolean | null
  }

  export type ObjectiveMaxAggregateOutputType = {
    id: string | null
    level: number | null
    fase: Fase | null
    userId: string | null
    instansiId: string | null
    yearId: string | null
    mapelId: string | null
    elementId: string | null
    achievementId: string | null
    code: string | null
    kkm: number | null
    steps: number | null
    subjectMatter: string | null
    disable: boolean | null
  }

  export type ObjectiveCountAggregateOutputType = {
    id: number
    level: number
    fase: number
    userId: number
    instansiId: number
    yearId: number
    mapelId: number
    elementId: number
    achievementId: number
    code: number
    kkm: number
    steps: number
    subjectMatter: number
    competencie: number
    firstSkill: number
    triggerQuest: number
    disable: number
    toolIds: number
    mateIds: number
    methIds: number
    mediaIds: number
    _all: number
  }


  export type ObjectiveAvgAggregateInputType = {
    level?: true
    kkm?: true
    steps?: true
  }

  export type ObjectiveSumAggregateInputType = {
    level?: true
    kkm?: true
    steps?: true
  }

  export type ObjectiveMinAggregateInputType = {
    id?: true
    level?: true
    fase?: true
    userId?: true
    instansiId?: true
    yearId?: true
    mapelId?: true
    elementId?: true
    achievementId?: true
    code?: true
    kkm?: true
    steps?: true
    subjectMatter?: true
    disable?: true
  }

  export type ObjectiveMaxAggregateInputType = {
    id?: true
    level?: true
    fase?: true
    userId?: true
    instansiId?: true
    yearId?: true
    mapelId?: true
    elementId?: true
    achievementId?: true
    code?: true
    kkm?: true
    steps?: true
    subjectMatter?: true
    disable?: true
  }

  export type ObjectiveCountAggregateInputType = {
    id?: true
    level?: true
    fase?: true
    userId?: true
    instansiId?: true
    yearId?: true
    mapelId?: true
    elementId?: true
    achievementId?: true
    code?: true
    kkm?: true
    steps?: true
    subjectMatter?: true
    competencie?: true
    firstSkill?: true
    triggerQuest?: true
    disable?: true
    toolIds?: true
    mateIds?: true
    methIds?: true
    mediaIds?: true
    _all?: true
  }

  export type ObjectiveAggregateArgs = {
    /**
     * Filter which Objective to aggregate.
     */
    where?: ObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objectives to fetch.
     */
    orderBy?: Enumerable<ObjectiveOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Objectives
    **/
    _count?: true | ObjectiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObjectiveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObjectiveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObjectiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObjectiveMaxAggregateInputType
  }

  export type GetObjectiveAggregateType<T extends ObjectiveAggregateArgs> = {
        [P in keyof T & keyof AggregateObjective]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObjective[P]>
      : GetScalarType<T[P], AggregateObjective[P]>
  }




  export type ObjectiveGroupByArgs = {
    where?: ObjectiveWhereInput
    orderBy?: Enumerable<ObjectiveOrderByWithAggregationInput>
    by: ObjectiveScalarFieldEnum[]
    having?: ObjectiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObjectiveCountAggregateInputType | true
    _avg?: ObjectiveAvgAggregateInputType
    _sum?: ObjectiveSumAggregateInputType
    _min?: ObjectiveMinAggregateInputType
    _max?: ObjectiveMaxAggregateInputType
  }


  export type ObjectiveGroupByOutputType = {
    id: string
    level: number
    fase: Fase
    userId: string
    instansiId: string
    yearId: string
    mapelId: string
    elementId: string
    achievementId: string
    code: string
    kkm: number
    steps: number
    subjectMatter: string
    competencie: string[]
    firstSkill: string[]
    triggerQuest: string[]
    disable: boolean
    toolIds: string[]
    mateIds: string[]
    methIds: string[]
    mediaIds: string[]
    _count: ObjectiveCountAggregateOutputType | null
    _avg: ObjectiveAvgAggregateOutputType | null
    _sum: ObjectiveSumAggregateOutputType | null
    _min: ObjectiveMinAggregateOutputType | null
    _max: ObjectiveMaxAggregateOutputType | null
  }

  type GetObjectiveGroupByPayload<T extends ObjectiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ObjectiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObjectiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObjectiveGroupByOutputType[P]>
            : GetScalarType<T[P], ObjectiveGroupByOutputType[P]>
        }
      >
    >


  export type ObjectiveSelect = {
    id?: boolean
    level?: boolean
    fase?: boolean
    userId?: boolean
    instansiId?: boolean
    yearId?: boolean
    mapelId?: boolean
    elementId?: boolean
    achievementId?: boolean
    code?: boolean
    kkm?: boolean
    steps?: boolean
    subjectMatter?: boolean
    competencie?: boolean
    firstSkill?: boolean
    triggerQuest?: boolean
    disable?: boolean
    toolIds?: boolean
    mateIds?: boolean
    methIds?: boolean
    mediaIds?: boolean
    user?: boolean | UserArgs
    instansi?: boolean | InstansiArgs
    year?: boolean | SchoolYearArgs
    mapel?: boolean | MataPelajaranArgs
    elemen?: boolean | ElementArgs
    achievement?: boolean | AchievementArgs
    material?: boolean | Objective$materialArgs
    tracker?: boolean | Objective$trackerArgs
    resourse?: boolean | Objective$resourseArgs
    ppp?: boolean | Objective$pppArgs
    tool?: boolean | Objective$toolArgs
    mate?: boolean | Objective$mateArgs
    meth?: boolean | Objective$methArgs
    media?: boolean | Objective$mediaArgs
    assessments?: boolean | Objective$assessmentsArgs
    devices?: boolean | Objective$devicesArgs
    _count?: boolean | ObjectiveCountOutputTypeArgs
  }


  export type ObjectiveInclude = {
    user?: boolean | UserArgs
    instansi?: boolean | InstansiArgs
    year?: boolean | SchoolYearArgs
    mapel?: boolean | MataPelajaranArgs
    elemen?: boolean | ElementArgs
    achievement?: boolean | AchievementArgs
    material?: boolean | Objective$materialArgs
    tracker?: boolean | Objective$trackerArgs
    resourse?: boolean | Objective$resourseArgs
    ppp?: boolean | Objective$pppArgs
    tool?: boolean | Objective$toolArgs
    mate?: boolean | Objective$mateArgs
    meth?: boolean | Objective$methArgs
    media?: boolean | Objective$mediaArgs
    assessments?: boolean | Objective$assessmentsArgs
    devices?: boolean | Objective$devicesArgs
    _count?: boolean | ObjectiveCountOutputTypeArgs
  }

  export type ObjectiveGetPayload<S extends boolean | null | undefined | ObjectiveArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Objective :
    S extends undefined ? never :
    S extends { include: any } & (ObjectiveArgs | ObjectiveFindManyArgs)
    ? Objective  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'instansi' ? InstansiGetPayload<S['include'][P]> :
        P extends 'year' ? SchoolYearGetPayload<S['include'][P]> :
        P extends 'mapel' ? MataPelajaranGetPayload<S['include'][P]> :
        P extends 'elemen' ? ElementGetPayload<S['include'][P]> :
        P extends 'achievement' ? AchievementGetPayload<S['include'][P]> :
        P extends 'material' ? Array < OMaterialGetPayload<S['include'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['include'][P]>>  :
        P extends 'resourse' ? Array < OresourceGetPayload<S['include'][P]>>  :
        P extends 'ppp' ? Array < OpppGetPayload<S['include'][P]>>  :
        P extends 'tool' ? Array < OhelperGetPayload<S['include'][P]>>  :
        P extends 'mate' ? Array < OhelperGetPayload<S['include'][P]>>  :
        P extends 'meth' ? Array < OhelperGetPayload<S['include'][P]>>  :
        P extends 'media' ? Array < OhelperGetPayload<S['include'][P]>>  :
        P extends 'assessments' ? Array < OAssessmentGetPayload<S['include'][P]>>  :
        P extends 'devices' ? Array < TDeviceDataGetPayload<S['include'][P]>>  :
        P extends '_count' ? ObjectiveCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ObjectiveArgs | ObjectiveFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'instansi' ? InstansiGetPayload<S['select'][P]> :
        P extends 'year' ? SchoolYearGetPayload<S['select'][P]> :
        P extends 'mapel' ? MataPelajaranGetPayload<S['select'][P]> :
        P extends 'elemen' ? ElementGetPayload<S['select'][P]> :
        P extends 'achievement' ? AchievementGetPayload<S['select'][P]> :
        P extends 'material' ? Array < OMaterialGetPayload<S['select'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['select'][P]>>  :
        P extends 'resourse' ? Array < OresourceGetPayload<S['select'][P]>>  :
        P extends 'ppp' ? Array < OpppGetPayload<S['select'][P]>>  :
        P extends 'tool' ? Array < OhelperGetPayload<S['select'][P]>>  :
        P extends 'mate' ? Array < OhelperGetPayload<S['select'][P]>>  :
        P extends 'meth' ? Array < OhelperGetPayload<S['select'][P]>>  :
        P extends 'media' ? Array < OhelperGetPayload<S['select'][P]>>  :
        P extends 'assessments' ? Array < OAssessmentGetPayload<S['select'][P]>>  :
        P extends 'devices' ? Array < TDeviceDataGetPayload<S['select'][P]>>  :
        P extends '_count' ? ObjectiveCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Objective ? Objective[P] : never
  } 
      : Objective


  type ObjectiveCountArgs = 
    Omit<ObjectiveFindManyArgs, 'select' | 'include'> & {
      select?: ObjectiveCountAggregateInputType | true
    }

  export interface ObjectiveDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Objective that matches the filter.
     * @param {ObjectiveFindUniqueArgs} args - Arguments to find a Objective
     * @example
     * // Get one Objective
     * const objective = await prisma.objective.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ObjectiveFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ObjectiveFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Objective'> extends True ? Prisma__ObjectiveClient<ObjectiveGetPayload<T>> : Prisma__ObjectiveClient<ObjectiveGetPayload<T> | null, null>

    /**
     * Find one Objective that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ObjectiveFindUniqueOrThrowArgs} args - Arguments to find a Objective
     * @example
     * // Get one Objective
     * const objective = await prisma.objective.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ObjectiveFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ObjectiveFindUniqueOrThrowArgs>
    ): Prisma__ObjectiveClient<ObjectiveGetPayload<T>>

    /**
     * Find the first Objective that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveFindFirstArgs} args - Arguments to find a Objective
     * @example
     * // Get one Objective
     * const objective = await prisma.objective.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ObjectiveFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ObjectiveFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Objective'> extends True ? Prisma__ObjectiveClient<ObjectiveGetPayload<T>> : Prisma__ObjectiveClient<ObjectiveGetPayload<T> | null, null>

    /**
     * Find the first Objective that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveFindFirstOrThrowArgs} args - Arguments to find a Objective
     * @example
     * // Get one Objective
     * const objective = await prisma.objective.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ObjectiveFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ObjectiveFindFirstOrThrowArgs>
    ): Prisma__ObjectiveClient<ObjectiveGetPayload<T>>

    /**
     * Find zero or more Objectives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Objectives
     * const objectives = await prisma.objective.findMany()
     * 
     * // Get first 10 Objectives
     * const objectives = await prisma.objective.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const objectiveWithIdOnly = await prisma.objective.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ObjectiveFindManyArgs>(
      args?: SelectSubset<T, ObjectiveFindManyArgs>
    ): Prisma.PrismaPromise<Array<ObjectiveGetPayload<T>>>

    /**
     * Create a Objective.
     * @param {ObjectiveCreateArgs} args - Arguments to create a Objective.
     * @example
     * // Create one Objective
     * const Objective = await prisma.objective.create({
     *   data: {
     *     // ... data to create a Objective
     *   }
     * })
     * 
    **/
    create<T extends ObjectiveCreateArgs>(
      args: SelectSubset<T, ObjectiveCreateArgs>
    ): Prisma__ObjectiveClient<ObjectiveGetPayload<T>>

    /**
     * Create many Objectives.
     *     @param {ObjectiveCreateManyArgs} args - Arguments to create many Objectives.
     *     @example
     *     // Create many Objectives
     *     const objective = await prisma.objective.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ObjectiveCreateManyArgs>(
      args?: SelectSubset<T, ObjectiveCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Objective.
     * @param {ObjectiveDeleteArgs} args - Arguments to delete one Objective.
     * @example
     * // Delete one Objective
     * const Objective = await prisma.objective.delete({
     *   where: {
     *     // ... filter to delete one Objective
     *   }
     * })
     * 
    **/
    delete<T extends ObjectiveDeleteArgs>(
      args: SelectSubset<T, ObjectiveDeleteArgs>
    ): Prisma__ObjectiveClient<ObjectiveGetPayload<T>>

    /**
     * Update one Objective.
     * @param {ObjectiveUpdateArgs} args - Arguments to update one Objective.
     * @example
     * // Update one Objective
     * const objective = await prisma.objective.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ObjectiveUpdateArgs>(
      args: SelectSubset<T, ObjectiveUpdateArgs>
    ): Prisma__ObjectiveClient<ObjectiveGetPayload<T>>

    /**
     * Delete zero or more Objectives.
     * @param {ObjectiveDeleteManyArgs} args - Arguments to filter Objectives to delete.
     * @example
     * // Delete a few Objectives
     * const { count } = await prisma.objective.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ObjectiveDeleteManyArgs>(
      args?: SelectSubset<T, ObjectiveDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Objectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Objectives
     * const objective = await prisma.objective.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ObjectiveUpdateManyArgs>(
      args: SelectSubset<T, ObjectiveUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Objective.
     * @param {ObjectiveUpsertArgs} args - Arguments to update or create a Objective.
     * @example
     * // Update or create a Objective
     * const objective = await prisma.objective.upsert({
     *   create: {
     *     // ... data to create a Objective
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Objective we want to update
     *   }
     * })
    **/
    upsert<T extends ObjectiveUpsertArgs>(
      args: SelectSubset<T, ObjectiveUpsertArgs>
    ): Prisma__ObjectiveClient<ObjectiveGetPayload<T>>

    /**
     * Find zero or more Objectives that matches the filter.
     * @param {ObjectiveFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const objective = await prisma.objective.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ObjectiveFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Objective.
     * @param {ObjectiveAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const objective = await prisma.objective.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ObjectiveAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Objectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveCountArgs} args - Arguments to filter Objectives to count.
     * @example
     * // Count the number of Objectives
     * const count = await prisma.objective.count({
     *   where: {
     *     // ... the filter for the Objectives we want to count
     *   }
     * })
    **/
    count<T extends ObjectiveCountArgs>(
      args?: Subset<T, ObjectiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObjectiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Objective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObjectiveAggregateArgs>(args: Subset<T, ObjectiveAggregateArgs>): Prisma.PrismaPromise<GetObjectiveAggregateType<T>>

    /**
     * Group by Objective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObjectiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObjectiveGroupByArgs['orderBy'] }
        : { orderBy?: ObjectiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObjectiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObjectiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Objective.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ObjectiveClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    instansi<T extends InstansiArgs= {}>(args?: Subset<T, InstansiArgs>): Prisma__InstansiClient<InstansiGetPayload<T> | Null>;

    year<T extends SchoolYearArgs= {}>(args?: Subset<T, SchoolYearArgs>): Prisma__SchoolYearClient<SchoolYearGetPayload<T> | Null>;

    mapel<T extends MataPelajaranArgs= {}>(args?: Subset<T, MataPelajaranArgs>): Prisma__MataPelajaranClient<MataPelajaranGetPayload<T> | Null>;

    elemen<T extends ElementArgs= {}>(args?: Subset<T, ElementArgs>): Prisma__ElementClient<ElementGetPayload<T> | Null>;

    achievement<T extends AchievementArgs= {}>(args?: Subset<T, AchievementArgs>): Prisma__AchievementClient<AchievementGetPayload<T> | Null>;

    material<T extends Objective$materialArgs= {}>(args?: Subset<T, Objective$materialArgs>): Prisma.PrismaPromise<Array<OMaterialGetPayload<T>>| Null>;

    tracker<T extends Objective$trackerArgs= {}>(args?: Subset<T, Objective$trackerArgs>): Prisma.PrismaPromise<Array<TrackerGetPayload<T>>| Null>;

    resourse<T extends Objective$resourseArgs= {}>(args?: Subset<T, Objective$resourseArgs>): Prisma.PrismaPromise<Array<OresourceGetPayload<T>>| Null>;

    ppp<T extends Objective$pppArgs= {}>(args?: Subset<T, Objective$pppArgs>): Prisma.PrismaPromise<Array<OpppGetPayload<T>>| Null>;

    tool<T extends Objective$toolArgs= {}>(args?: Subset<T, Objective$toolArgs>): Prisma.PrismaPromise<Array<OhelperGetPayload<T>>| Null>;

    mate<T extends Objective$mateArgs= {}>(args?: Subset<T, Objective$mateArgs>): Prisma.PrismaPromise<Array<OhelperGetPayload<T>>| Null>;

    meth<T extends Objective$methArgs= {}>(args?: Subset<T, Objective$methArgs>): Prisma.PrismaPromise<Array<OhelperGetPayload<T>>| Null>;

    media<T extends Objective$mediaArgs= {}>(args?: Subset<T, Objective$mediaArgs>): Prisma.PrismaPromise<Array<OhelperGetPayload<T>>| Null>;

    assessments<T extends Objective$assessmentsArgs= {}>(args?: Subset<T, Objective$assessmentsArgs>): Prisma.PrismaPromise<Array<OAssessmentGetPayload<T>>| Null>;

    devices<T extends Objective$devicesArgs= {}>(args?: Subset<T, Objective$devicesArgs>): Prisma.PrismaPromise<Array<TDeviceDataGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Objective base type for findUnique actions
   */
  export type ObjectiveFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectiveInclude | null
    /**
     * Filter, which Objective to fetch.
     */
    where: ObjectiveWhereUniqueInput
  }

  /**
   * Objective findUnique
   */
  export interface ObjectiveFindUniqueArgs extends ObjectiveFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Objective findUniqueOrThrow
   */
  export type ObjectiveFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectiveInclude | null
    /**
     * Filter, which Objective to fetch.
     */
    where: ObjectiveWhereUniqueInput
  }


  /**
   * Objective base type for findFirst actions
   */
  export type ObjectiveFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectiveInclude | null
    /**
     * Filter, which Objective to fetch.
     */
    where?: ObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objectives to fetch.
     */
    orderBy?: Enumerable<ObjectiveOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Objectives.
     */
    cursor?: ObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Objectives.
     */
    distinct?: Enumerable<ObjectiveScalarFieldEnum>
  }

  /**
   * Objective findFirst
   */
  export interface ObjectiveFindFirstArgs extends ObjectiveFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Objective findFirstOrThrow
   */
  export type ObjectiveFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectiveInclude | null
    /**
     * Filter, which Objective to fetch.
     */
    where?: ObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objectives to fetch.
     */
    orderBy?: Enumerable<ObjectiveOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Objectives.
     */
    cursor?: ObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Objectives.
     */
    distinct?: Enumerable<ObjectiveScalarFieldEnum>
  }


  /**
   * Objective findMany
   */
  export type ObjectiveFindManyArgs = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectiveInclude | null
    /**
     * Filter, which Objectives to fetch.
     */
    where?: ObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Objectives to fetch.
     */
    orderBy?: Enumerable<ObjectiveOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Objectives.
     */
    cursor?: ObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Objectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Objectives.
     */
    skip?: number
    distinct?: Enumerable<ObjectiveScalarFieldEnum>
  }


  /**
   * Objective create
   */
  export type ObjectiveCreateArgs = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectiveInclude | null
    /**
     * The data needed to create a Objective.
     */
    data: XOR<ObjectiveCreateInput, ObjectiveUncheckedCreateInput>
  }


  /**
   * Objective createMany
   */
  export type ObjectiveCreateManyArgs = {
    /**
     * The data used to create many Objectives.
     */
    data: Enumerable<ObjectiveCreateManyInput>
  }


  /**
   * Objective update
   */
  export type ObjectiveUpdateArgs = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectiveInclude | null
    /**
     * The data needed to update a Objective.
     */
    data: XOR<ObjectiveUpdateInput, ObjectiveUncheckedUpdateInput>
    /**
     * Choose, which Objective to update.
     */
    where: ObjectiveWhereUniqueInput
  }


  /**
   * Objective updateMany
   */
  export type ObjectiveUpdateManyArgs = {
    /**
     * The data used to update Objectives.
     */
    data: XOR<ObjectiveUpdateManyMutationInput, ObjectiveUncheckedUpdateManyInput>
    /**
     * Filter which Objectives to update
     */
    where?: ObjectiveWhereInput
  }


  /**
   * Objective upsert
   */
  export type ObjectiveUpsertArgs = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectiveInclude | null
    /**
     * The filter to search for the Objective to update in case it exists.
     */
    where: ObjectiveWhereUniqueInput
    /**
     * In case the Objective found by the `where` argument doesn't exist, create a new Objective with this data.
     */
    create: XOR<ObjectiveCreateInput, ObjectiveUncheckedCreateInput>
    /**
     * In case the Objective was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObjectiveUpdateInput, ObjectiveUncheckedUpdateInput>
  }


  /**
   * Objective delete
   */
  export type ObjectiveDeleteArgs = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectiveInclude | null
    /**
     * Filter which Objective to delete.
     */
    where: ObjectiveWhereUniqueInput
  }


  /**
   * Objective deleteMany
   */
  export type ObjectiveDeleteManyArgs = {
    /**
     * Filter which Objectives to delete
     */
    where?: ObjectiveWhereInput
  }


  /**
   * Objective findRaw
   */
  export type ObjectiveFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Objective aggregateRaw
   */
  export type ObjectiveAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Objective.material
   */
  export type Objective$materialArgs = {
    /**
     * Select specific fields to fetch from the OMaterial
     */
    select?: OMaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OMaterialInclude | null
    where?: OMaterialWhereInput
    orderBy?: Enumerable<OMaterialOrderByWithRelationInput>
    cursor?: OMaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OMaterialScalarFieldEnum>
  }


  /**
   * Objective.tracker
   */
  export type Objective$trackerArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    where?: TrackerWhereInput
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    cursor?: TrackerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TrackerScalarFieldEnum>
  }


  /**
   * Objective.resourse
   */
  export type Objective$resourseArgs = {
    /**
     * Select specific fields to fetch from the Oresource
     */
    select?: OresourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OresourceInclude | null
    where?: OresourceWhereInput
    orderBy?: Enumerable<OresourceOrderByWithRelationInput>
    cursor?: OresourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OresourceScalarFieldEnum>
  }


  /**
   * Objective.ppp
   */
  export type Objective$pppArgs = {
    /**
     * Select specific fields to fetch from the Oppp
     */
    select?: OpppSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OpppInclude | null
    where?: OpppWhereInput
    orderBy?: Enumerable<OpppOrderByWithRelationInput>
    cursor?: OpppWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OpppScalarFieldEnum>
  }


  /**
   * Objective.tool
   */
  export type Objective$toolArgs = {
    /**
     * Select specific fields to fetch from the Ohelper
     */
    select?: OhelperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OhelperInclude | null
    where?: OhelperWhereInput
    orderBy?: Enumerable<OhelperOrderByWithRelationInput>
    cursor?: OhelperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OhelperScalarFieldEnum>
  }


  /**
   * Objective.mate
   */
  export type Objective$mateArgs = {
    /**
     * Select specific fields to fetch from the Ohelper
     */
    select?: OhelperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OhelperInclude | null
    where?: OhelperWhereInput
    orderBy?: Enumerable<OhelperOrderByWithRelationInput>
    cursor?: OhelperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OhelperScalarFieldEnum>
  }


  /**
   * Objective.meth
   */
  export type Objective$methArgs = {
    /**
     * Select specific fields to fetch from the Ohelper
     */
    select?: OhelperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OhelperInclude | null
    where?: OhelperWhereInput
    orderBy?: Enumerable<OhelperOrderByWithRelationInput>
    cursor?: OhelperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OhelperScalarFieldEnum>
  }


  /**
   * Objective.media
   */
  export type Objective$mediaArgs = {
    /**
     * Select specific fields to fetch from the Ohelper
     */
    select?: OhelperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OhelperInclude | null
    where?: OhelperWhereInput
    orderBy?: Enumerable<OhelperOrderByWithRelationInput>
    cursor?: OhelperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OhelperScalarFieldEnum>
  }


  /**
   * Objective.assessments
   */
  export type Objective$assessmentsArgs = {
    /**
     * Select specific fields to fetch from the OAssessment
     */
    select?: OAssessmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAssessmentInclude | null
    where?: OAssessmentWhereInput
    orderBy?: Enumerable<OAssessmentOrderByWithRelationInput>
    cursor?: OAssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OAssessmentScalarFieldEnum>
  }


  /**
   * Objective.devices
   */
  export type Objective$devicesArgs = {
    /**
     * Select specific fields to fetch from the TDeviceData
     */
    select?: TDeviceDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceDataInclude | null
    where?: TDeviceDataWhereInput
    orderBy?: Enumerable<TDeviceDataOrderByWithRelationInput>
    cursor?: TDeviceDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TDeviceDataScalarFieldEnum>
  }


  /**
   * Objective without action
   */
  export type ObjectiveArgs = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectiveInclude | null
  }



  /**
   * Model OMaterial
   */


  export type AggregateOMaterial = {
    _count: OMaterialCountAggregateOutputType | null
    _avg: OMaterialAvgAggregateOutputType | null
    _sum: OMaterialSumAggregateOutputType | null
    _min: OMaterialMinAggregateOutputType | null
    _max: OMaterialMaxAggregateOutputType | null
  }

  export type OMaterialAvgAggregateOutputType = {
    no: number | null
  }

  export type OMaterialSumAggregateOutputType = {
    no: number | null
  }

  export type OMaterialMinAggregateOutputType = {
    id: string | null
    refId: string | null
    no: number | null
    content: string | null
    model: OMaterialModel | null
  }

  export type OMaterialMaxAggregateOutputType = {
    id: string | null
    refId: string | null
    no: number | null
    content: string | null
    model: OMaterialModel | null
  }

  export type OMaterialCountAggregateOutputType = {
    id: number
    refId: number
    no: number
    content: number
    model: number
    _all: number
  }


  export type OMaterialAvgAggregateInputType = {
    no?: true
  }

  export type OMaterialSumAggregateInputType = {
    no?: true
  }

  export type OMaterialMinAggregateInputType = {
    id?: true
    refId?: true
    no?: true
    content?: true
    model?: true
  }

  export type OMaterialMaxAggregateInputType = {
    id?: true
    refId?: true
    no?: true
    content?: true
    model?: true
  }

  export type OMaterialCountAggregateInputType = {
    id?: true
    refId?: true
    no?: true
    content?: true
    model?: true
    _all?: true
  }

  export type OMaterialAggregateArgs = {
    /**
     * Filter which OMaterial to aggregate.
     */
    where?: OMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OMaterials to fetch.
     */
    orderBy?: Enumerable<OMaterialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OMaterials
    **/
    _count?: true | OMaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OMaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OMaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OMaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OMaterialMaxAggregateInputType
  }

  export type GetOMaterialAggregateType<T extends OMaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateOMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOMaterial[P]>
      : GetScalarType<T[P], AggregateOMaterial[P]>
  }




  export type OMaterialGroupByArgs = {
    where?: OMaterialWhereInput
    orderBy?: Enumerable<OMaterialOrderByWithAggregationInput>
    by: OMaterialScalarFieldEnum[]
    having?: OMaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OMaterialCountAggregateInputType | true
    _avg?: OMaterialAvgAggregateInputType
    _sum?: OMaterialSumAggregateInputType
    _min?: OMaterialMinAggregateInputType
    _max?: OMaterialMaxAggregateInputType
  }


  export type OMaterialGroupByOutputType = {
    id: string
    refId: string
    no: number
    content: string
    model: OMaterialModel
    _count: OMaterialCountAggregateOutputType | null
    _avg: OMaterialAvgAggregateOutputType | null
    _sum: OMaterialSumAggregateOutputType | null
    _min: OMaterialMinAggregateOutputType | null
    _max: OMaterialMaxAggregateOutputType | null
  }

  type GetOMaterialGroupByPayload<T extends OMaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OMaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OMaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OMaterialGroupByOutputType[P]>
            : GetScalarType<T[P], OMaterialGroupByOutputType[P]>
        }
      >
    >


  export type OMaterialSelect = {
    id?: boolean
    refId?: boolean
    no?: boolean
    content?: boolean
    model?: boolean
    ref?: boolean | ObjectiveArgs
    learning?: boolean | OMaterial$learningArgs
    _count?: boolean | OMaterialCountOutputTypeArgs
  }


  export type OMaterialInclude = {
    ref?: boolean | ObjectiveArgs
    learning?: boolean | OMaterial$learningArgs
    _count?: boolean | OMaterialCountOutputTypeArgs
  }

  export type OMaterialGetPayload<S extends boolean | null | undefined | OMaterialArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OMaterial :
    S extends undefined ? never :
    S extends { include: any } & (OMaterialArgs | OMaterialFindManyArgs)
    ? OMaterial  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ref' ? ObjectiveGetPayload<S['include'][P]> :
        P extends 'learning' ? Array < OLearningGetPayload<S['include'][P]>>  :
        P extends '_count' ? OMaterialCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (OMaterialArgs | OMaterialFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ref' ? ObjectiveGetPayload<S['select'][P]> :
        P extends 'learning' ? Array < OLearningGetPayload<S['select'][P]>>  :
        P extends '_count' ? OMaterialCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof OMaterial ? OMaterial[P] : never
  } 
      : OMaterial


  type OMaterialCountArgs = 
    Omit<OMaterialFindManyArgs, 'select' | 'include'> & {
      select?: OMaterialCountAggregateInputType | true
    }

  export interface OMaterialDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one OMaterial that matches the filter.
     * @param {OMaterialFindUniqueArgs} args - Arguments to find a OMaterial
     * @example
     * // Get one OMaterial
     * const oMaterial = await prisma.oMaterial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OMaterialFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OMaterialFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OMaterial'> extends True ? Prisma__OMaterialClient<OMaterialGetPayload<T>> : Prisma__OMaterialClient<OMaterialGetPayload<T> | null, null>

    /**
     * Find one OMaterial that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OMaterialFindUniqueOrThrowArgs} args - Arguments to find a OMaterial
     * @example
     * // Get one OMaterial
     * const oMaterial = await prisma.oMaterial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OMaterialFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OMaterialFindUniqueOrThrowArgs>
    ): Prisma__OMaterialClient<OMaterialGetPayload<T>>

    /**
     * Find the first OMaterial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OMaterialFindFirstArgs} args - Arguments to find a OMaterial
     * @example
     * // Get one OMaterial
     * const oMaterial = await prisma.oMaterial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OMaterialFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OMaterialFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OMaterial'> extends True ? Prisma__OMaterialClient<OMaterialGetPayload<T>> : Prisma__OMaterialClient<OMaterialGetPayload<T> | null, null>

    /**
     * Find the first OMaterial that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OMaterialFindFirstOrThrowArgs} args - Arguments to find a OMaterial
     * @example
     * // Get one OMaterial
     * const oMaterial = await prisma.oMaterial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OMaterialFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OMaterialFindFirstOrThrowArgs>
    ): Prisma__OMaterialClient<OMaterialGetPayload<T>>

    /**
     * Find zero or more OMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OMaterialFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OMaterials
     * const oMaterials = await prisma.oMaterial.findMany()
     * 
     * // Get first 10 OMaterials
     * const oMaterials = await prisma.oMaterial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oMaterialWithIdOnly = await prisma.oMaterial.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OMaterialFindManyArgs>(
      args?: SelectSubset<T, OMaterialFindManyArgs>
    ): Prisma.PrismaPromise<Array<OMaterialGetPayload<T>>>

    /**
     * Create a OMaterial.
     * @param {OMaterialCreateArgs} args - Arguments to create a OMaterial.
     * @example
     * // Create one OMaterial
     * const OMaterial = await prisma.oMaterial.create({
     *   data: {
     *     // ... data to create a OMaterial
     *   }
     * })
     * 
    **/
    create<T extends OMaterialCreateArgs>(
      args: SelectSubset<T, OMaterialCreateArgs>
    ): Prisma__OMaterialClient<OMaterialGetPayload<T>>

    /**
     * Create many OMaterials.
     *     @param {OMaterialCreateManyArgs} args - Arguments to create many OMaterials.
     *     @example
     *     // Create many OMaterials
     *     const oMaterial = await prisma.oMaterial.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OMaterialCreateManyArgs>(
      args?: SelectSubset<T, OMaterialCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OMaterial.
     * @param {OMaterialDeleteArgs} args - Arguments to delete one OMaterial.
     * @example
     * // Delete one OMaterial
     * const OMaterial = await prisma.oMaterial.delete({
     *   where: {
     *     // ... filter to delete one OMaterial
     *   }
     * })
     * 
    **/
    delete<T extends OMaterialDeleteArgs>(
      args: SelectSubset<T, OMaterialDeleteArgs>
    ): Prisma__OMaterialClient<OMaterialGetPayload<T>>

    /**
     * Update one OMaterial.
     * @param {OMaterialUpdateArgs} args - Arguments to update one OMaterial.
     * @example
     * // Update one OMaterial
     * const oMaterial = await prisma.oMaterial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OMaterialUpdateArgs>(
      args: SelectSubset<T, OMaterialUpdateArgs>
    ): Prisma__OMaterialClient<OMaterialGetPayload<T>>

    /**
     * Delete zero or more OMaterials.
     * @param {OMaterialDeleteManyArgs} args - Arguments to filter OMaterials to delete.
     * @example
     * // Delete a few OMaterials
     * const { count } = await prisma.oMaterial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OMaterialDeleteManyArgs>(
      args?: SelectSubset<T, OMaterialDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OMaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OMaterials
     * const oMaterial = await prisma.oMaterial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OMaterialUpdateManyArgs>(
      args: SelectSubset<T, OMaterialUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OMaterial.
     * @param {OMaterialUpsertArgs} args - Arguments to update or create a OMaterial.
     * @example
     * // Update or create a OMaterial
     * const oMaterial = await prisma.oMaterial.upsert({
     *   create: {
     *     // ... data to create a OMaterial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OMaterial we want to update
     *   }
     * })
    **/
    upsert<T extends OMaterialUpsertArgs>(
      args: SelectSubset<T, OMaterialUpsertArgs>
    ): Prisma__OMaterialClient<OMaterialGetPayload<T>>

    /**
     * Find zero or more OMaterials that matches the filter.
     * @param {OMaterialFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const oMaterial = await prisma.oMaterial.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: OMaterialFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a OMaterial.
     * @param {OMaterialAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const oMaterial = await prisma.oMaterial.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: OMaterialAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of OMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OMaterialCountArgs} args - Arguments to filter OMaterials to count.
     * @example
     * // Count the number of OMaterials
     * const count = await prisma.oMaterial.count({
     *   where: {
     *     // ... the filter for the OMaterials we want to count
     *   }
     * })
    **/
    count<T extends OMaterialCountArgs>(
      args?: Subset<T, OMaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OMaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OMaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OMaterialAggregateArgs>(args: Subset<T, OMaterialAggregateArgs>): Prisma.PrismaPromise<GetOMaterialAggregateType<T>>

    /**
     * Group by OMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OMaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OMaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OMaterialGroupByArgs['orderBy'] }
        : { orderBy?: OMaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OMaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OMaterial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OMaterialClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ref<T extends ObjectiveArgs= {}>(args?: Subset<T, ObjectiveArgs>): Prisma__ObjectiveClient<ObjectiveGetPayload<T> | Null>;

    learning<T extends OMaterial$learningArgs= {}>(args?: Subset<T, OMaterial$learningArgs>): Prisma.PrismaPromise<Array<OLearningGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OMaterial base type for findUnique actions
   */
  export type OMaterialFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OMaterial
     */
    select?: OMaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OMaterialInclude | null
    /**
     * Filter, which OMaterial to fetch.
     */
    where: OMaterialWhereUniqueInput
  }

  /**
   * OMaterial findUnique
   */
  export interface OMaterialFindUniqueArgs extends OMaterialFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OMaterial findUniqueOrThrow
   */
  export type OMaterialFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OMaterial
     */
    select?: OMaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OMaterialInclude | null
    /**
     * Filter, which OMaterial to fetch.
     */
    where: OMaterialWhereUniqueInput
  }


  /**
   * OMaterial base type for findFirst actions
   */
  export type OMaterialFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OMaterial
     */
    select?: OMaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OMaterialInclude | null
    /**
     * Filter, which OMaterial to fetch.
     */
    where?: OMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OMaterials to fetch.
     */
    orderBy?: Enumerable<OMaterialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OMaterials.
     */
    cursor?: OMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OMaterials.
     */
    distinct?: Enumerable<OMaterialScalarFieldEnum>
  }

  /**
   * OMaterial findFirst
   */
  export interface OMaterialFindFirstArgs extends OMaterialFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OMaterial findFirstOrThrow
   */
  export type OMaterialFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OMaterial
     */
    select?: OMaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OMaterialInclude | null
    /**
     * Filter, which OMaterial to fetch.
     */
    where?: OMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OMaterials to fetch.
     */
    orderBy?: Enumerable<OMaterialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OMaterials.
     */
    cursor?: OMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OMaterials.
     */
    distinct?: Enumerable<OMaterialScalarFieldEnum>
  }


  /**
   * OMaterial findMany
   */
  export type OMaterialFindManyArgs = {
    /**
     * Select specific fields to fetch from the OMaterial
     */
    select?: OMaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OMaterialInclude | null
    /**
     * Filter, which OMaterials to fetch.
     */
    where?: OMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OMaterials to fetch.
     */
    orderBy?: Enumerable<OMaterialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OMaterials.
     */
    cursor?: OMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OMaterials.
     */
    skip?: number
    distinct?: Enumerable<OMaterialScalarFieldEnum>
  }


  /**
   * OMaterial create
   */
  export type OMaterialCreateArgs = {
    /**
     * Select specific fields to fetch from the OMaterial
     */
    select?: OMaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OMaterialInclude | null
    /**
     * The data needed to create a OMaterial.
     */
    data: XOR<OMaterialCreateInput, OMaterialUncheckedCreateInput>
  }


  /**
   * OMaterial createMany
   */
  export type OMaterialCreateManyArgs = {
    /**
     * The data used to create many OMaterials.
     */
    data: Enumerable<OMaterialCreateManyInput>
  }


  /**
   * OMaterial update
   */
  export type OMaterialUpdateArgs = {
    /**
     * Select specific fields to fetch from the OMaterial
     */
    select?: OMaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OMaterialInclude | null
    /**
     * The data needed to update a OMaterial.
     */
    data: XOR<OMaterialUpdateInput, OMaterialUncheckedUpdateInput>
    /**
     * Choose, which OMaterial to update.
     */
    where: OMaterialWhereUniqueInput
  }


  /**
   * OMaterial updateMany
   */
  export type OMaterialUpdateManyArgs = {
    /**
     * The data used to update OMaterials.
     */
    data: XOR<OMaterialUpdateManyMutationInput, OMaterialUncheckedUpdateManyInput>
    /**
     * Filter which OMaterials to update
     */
    where?: OMaterialWhereInput
  }


  /**
   * OMaterial upsert
   */
  export type OMaterialUpsertArgs = {
    /**
     * Select specific fields to fetch from the OMaterial
     */
    select?: OMaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OMaterialInclude | null
    /**
     * The filter to search for the OMaterial to update in case it exists.
     */
    where: OMaterialWhereUniqueInput
    /**
     * In case the OMaterial found by the `where` argument doesn't exist, create a new OMaterial with this data.
     */
    create: XOR<OMaterialCreateInput, OMaterialUncheckedCreateInput>
    /**
     * In case the OMaterial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OMaterialUpdateInput, OMaterialUncheckedUpdateInput>
  }


  /**
   * OMaterial delete
   */
  export type OMaterialDeleteArgs = {
    /**
     * Select specific fields to fetch from the OMaterial
     */
    select?: OMaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OMaterialInclude | null
    /**
     * Filter which OMaterial to delete.
     */
    where: OMaterialWhereUniqueInput
  }


  /**
   * OMaterial deleteMany
   */
  export type OMaterialDeleteManyArgs = {
    /**
     * Filter which OMaterials to delete
     */
    where?: OMaterialWhereInput
  }


  /**
   * OMaterial findRaw
   */
  export type OMaterialFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * OMaterial aggregateRaw
   */
  export type OMaterialAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * OMaterial.learning
   */
  export type OMaterial$learningArgs = {
    /**
     * Select specific fields to fetch from the OLearning
     */
    select?: OLearningSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OLearningInclude | null
    where?: OLearningWhereInput
    orderBy?: Enumerable<OLearningOrderByWithRelationInput>
    cursor?: OLearningWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OLearningScalarFieldEnum>
  }


  /**
   * OMaterial without action
   */
  export type OMaterialArgs = {
    /**
     * Select specific fields to fetch from the OMaterial
     */
    select?: OMaterialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OMaterialInclude | null
  }



  /**
   * Model OLearning
   */


  export type AggregateOLearning = {
    _count: OLearningCountAggregateOutputType | null
    _avg: OLearningAvgAggregateOutputType | null
    _sum: OLearningSumAggregateOutputType | null
    _min: OLearningMinAggregateOutputType | null
    _max: OLearningMaxAggregateOutputType | null
  }

  export type OLearningAvgAggregateOutputType = {
    no: number | null
  }

  export type OLearningSumAggregateOutputType = {
    no: number | null
  }

  export type OLearningMinAggregateOutputType = {
    id: string | null
    refId: string | null
    no: number | null
    content: string | null
    taksonomi: Taksonomi | null
    sentence: string | null
  }

  export type OLearningMaxAggregateOutputType = {
    id: string | null
    refId: string | null
    no: number | null
    content: string | null
    taksonomi: Taksonomi | null
    sentence: string | null
  }

  export type OLearningCountAggregateOutputType = {
    id: number
    refId: number
    no: number
    content: number
    taksonomi: number
    sentence: number
    _all: number
  }


  export type OLearningAvgAggregateInputType = {
    no?: true
  }

  export type OLearningSumAggregateInputType = {
    no?: true
  }

  export type OLearningMinAggregateInputType = {
    id?: true
    refId?: true
    no?: true
    content?: true
    taksonomi?: true
    sentence?: true
  }

  export type OLearningMaxAggregateInputType = {
    id?: true
    refId?: true
    no?: true
    content?: true
    taksonomi?: true
    sentence?: true
  }

  export type OLearningCountAggregateInputType = {
    id?: true
    refId?: true
    no?: true
    content?: true
    taksonomi?: true
    sentence?: true
    _all?: true
  }

  export type OLearningAggregateArgs = {
    /**
     * Filter which OLearning to aggregate.
     */
    where?: OLearningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OLearnings to fetch.
     */
    orderBy?: Enumerable<OLearningOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OLearningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OLearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OLearnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OLearnings
    **/
    _count?: true | OLearningCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OLearningAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OLearningSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OLearningMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OLearningMaxAggregateInputType
  }

  export type GetOLearningAggregateType<T extends OLearningAggregateArgs> = {
        [P in keyof T & keyof AggregateOLearning]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOLearning[P]>
      : GetScalarType<T[P], AggregateOLearning[P]>
  }




  export type OLearningGroupByArgs = {
    where?: OLearningWhereInput
    orderBy?: Enumerable<OLearningOrderByWithAggregationInput>
    by: OLearningScalarFieldEnum[]
    having?: OLearningScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OLearningCountAggregateInputType | true
    _avg?: OLearningAvgAggregateInputType
    _sum?: OLearningSumAggregateInputType
    _min?: OLearningMinAggregateInputType
    _max?: OLearningMaxAggregateInputType
  }


  export type OLearningGroupByOutputType = {
    id: string
    refId: string
    no: number
    content: string
    taksonomi: Taksonomi
    sentence: string
    _count: OLearningCountAggregateOutputType | null
    _avg: OLearningAvgAggregateOutputType | null
    _sum: OLearningSumAggregateOutputType | null
    _min: OLearningMinAggregateOutputType | null
    _max: OLearningMaxAggregateOutputType | null
  }

  type GetOLearningGroupByPayload<T extends OLearningGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OLearningGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OLearningGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OLearningGroupByOutputType[P]>
            : GetScalarType<T[P], OLearningGroupByOutputType[P]>
        }
      >
    >


  export type OLearningSelect = {
    id?: boolean
    refId?: boolean
    no?: boolean
    content?: boolean
    taksonomi?: boolean
    sentence?: boolean
    ref?: boolean | OMaterialArgs
  }


  export type OLearningInclude = {
    ref?: boolean | OMaterialArgs
  }

  export type OLearningGetPayload<S extends boolean | null | undefined | OLearningArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OLearning :
    S extends undefined ? never :
    S extends { include: any } & (OLearningArgs | OLearningFindManyArgs)
    ? OLearning  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ref' ? OMaterialGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (OLearningArgs | OLearningFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ref' ? OMaterialGetPayload<S['select'][P]> :  P extends keyof OLearning ? OLearning[P] : never
  } 
      : OLearning


  type OLearningCountArgs = 
    Omit<OLearningFindManyArgs, 'select' | 'include'> & {
      select?: OLearningCountAggregateInputType | true
    }

  export interface OLearningDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one OLearning that matches the filter.
     * @param {OLearningFindUniqueArgs} args - Arguments to find a OLearning
     * @example
     * // Get one OLearning
     * const oLearning = await prisma.oLearning.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OLearningFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OLearningFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OLearning'> extends True ? Prisma__OLearningClient<OLearningGetPayload<T>> : Prisma__OLearningClient<OLearningGetPayload<T> | null, null>

    /**
     * Find one OLearning that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OLearningFindUniqueOrThrowArgs} args - Arguments to find a OLearning
     * @example
     * // Get one OLearning
     * const oLearning = await prisma.oLearning.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OLearningFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OLearningFindUniqueOrThrowArgs>
    ): Prisma__OLearningClient<OLearningGetPayload<T>>

    /**
     * Find the first OLearning that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OLearningFindFirstArgs} args - Arguments to find a OLearning
     * @example
     * // Get one OLearning
     * const oLearning = await prisma.oLearning.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OLearningFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OLearningFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OLearning'> extends True ? Prisma__OLearningClient<OLearningGetPayload<T>> : Prisma__OLearningClient<OLearningGetPayload<T> | null, null>

    /**
     * Find the first OLearning that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OLearningFindFirstOrThrowArgs} args - Arguments to find a OLearning
     * @example
     * // Get one OLearning
     * const oLearning = await prisma.oLearning.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OLearningFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OLearningFindFirstOrThrowArgs>
    ): Prisma__OLearningClient<OLearningGetPayload<T>>

    /**
     * Find zero or more OLearnings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OLearningFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OLearnings
     * const oLearnings = await prisma.oLearning.findMany()
     * 
     * // Get first 10 OLearnings
     * const oLearnings = await prisma.oLearning.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oLearningWithIdOnly = await prisma.oLearning.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OLearningFindManyArgs>(
      args?: SelectSubset<T, OLearningFindManyArgs>
    ): Prisma.PrismaPromise<Array<OLearningGetPayload<T>>>

    /**
     * Create a OLearning.
     * @param {OLearningCreateArgs} args - Arguments to create a OLearning.
     * @example
     * // Create one OLearning
     * const OLearning = await prisma.oLearning.create({
     *   data: {
     *     // ... data to create a OLearning
     *   }
     * })
     * 
    **/
    create<T extends OLearningCreateArgs>(
      args: SelectSubset<T, OLearningCreateArgs>
    ): Prisma__OLearningClient<OLearningGetPayload<T>>

    /**
     * Create many OLearnings.
     *     @param {OLearningCreateManyArgs} args - Arguments to create many OLearnings.
     *     @example
     *     // Create many OLearnings
     *     const oLearning = await prisma.oLearning.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OLearningCreateManyArgs>(
      args?: SelectSubset<T, OLearningCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OLearning.
     * @param {OLearningDeleteArgs} args - Arguments to delete one OLearning.
     * @example
     * // Delete one OLearning
     * const OLearning = await prisma.oLearning.delete({
     *   where: {
     *     // ... filter to delete one OLearning
     *   }
     * })
     * 
    **/
    delete<T extends OLearningDeleteArgs>(
      args: SelectSubset<T, OLearningDeleteArgs>
    ): Prisma__OLearningClient<OLearningGetPayload<T>>

    /**
     * Update one OLearning.
     * @param {OLearningUpdateArgs} args - Arguments to update one OLearning.
     * @example
     * // Update one OLearning
     * const oLearning = await prisma.oLearning.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OLearningUpdateArgs>(
      args: SelectSubset<T, OLearningUpdateArgs>
    ): Prisma__OLearningClient<OLearningGetPayload<T>>

    /**
     * Delete zero or more OLearnings.
     * @param {OLearningDeleteManyArgs} args - Arguments to filter OLearnings to delete.
     * @example
     * // Delete a few OLearnings
     * const { count } = await prisma.oLearning.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OLearningDeleteManyArgs>(
      args?: SelectSubset<T, OLearningDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OLearnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OLearningUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OLearnings
     * const oLearning = await prisma.oLearning.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OLearningUpdateManyArgs>(
      args: SelectSubset<T, OLearningUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OLearning.
     * @param {OLearningUpsertArgs} args - Arguments to update or create a OLearning.
     * @example
     * // Update or create a OLearning
     * const oLearning = await prisma.oLearning.upsert({
     *   create: {
     *     // ... data to create a OLearning
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OLearning we want to update
     *   }
     * })
    **/
    upsert<T extends OLearningUpsertArgs>(
      args: SelectSubset<T, OLearningUpsertArgs>
    ): Prisma__OLearningClient<OLearningGetPayload<T>>

    /**
     * Find zero or more OLearnings that matches the filter.
     * @param {OLearningFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const oLearning = await prisma.oLearning.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: OLearningFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a OLearning.
     * @param {OLearningAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const oLearning = await prisma.oLearning.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: OLearningAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of OLearnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OLearningCountArgs} args - Arguments to filter OLearnings to count.
     * @example
     * // Count the number of OLearnings
     * const count = await prisma.oLearning.count({
     *   where: {
     *     // ... the filter for the OLearnings we want to count
     *   }
     * })
    **/
    count<T extends OLearningCountArgs>(
      args?: Subset<T, OLearningCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OLearningCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OLearning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OLearningAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OLearningAggregateArgs>(args: Subset<T, OLearningAggregateArgs>): Prisma.PrismaPromise<GetOLearningAggregateType<T>>

    /**
     * Group by OLearning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OLearningGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OLearningGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OLearningGroupByArgs['orderBy'] }
        : { orderBy?: OLearningGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OLearningGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOLearningGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OLearning.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OLearningClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ref<T extends OMaterialArgs= {}>(args?: Subset<T, OMaterialArgs>): Prisma__OMaterialClient<OMaterialGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OLearning base type for findUnique actions
   */
  export type OLearningFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OLearning
     */
    select?: OLearningSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OLearningInclude | null
    /**
     * Filter, which OLearning to fetch.
     */
    where: OLearningWhereUniqueInput
  }

  /**
   * OLearning findUnique
   */
  export interface OLearningFindUniqueArgs extends OLearningFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OLearning findUniqueOrThrow
   */
  export type OLearningFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OLearning
     */
    select?: OLearningSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OLearningInclude | null
    /**
     * Filter, which OLearning to fetch.
     */
    where: OLearningWhereUniqueInput
  }


  /**
   * OLearning base type for findFirst actions
   */
  export type OLearningFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OLearning
     */
    select?: OLearningSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OLearningInclude | null
    /**
     * Filter, which OLearning to fetch.
     */
    where?: OLearningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OLearnings to fetch.
     */
    orderBy?: Enumerable<OLearningOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OLearnings.
     */
    cursor?: OLearningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OLearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OLearnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OLearnings.
     */
    distinct?: Enumerable<OLearningScalarFieldEnum>
  }

  /**
   * OLearning findFirst
   */
  export interface OLearningFindFirstArgs extends OLearningFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OLearning findFirstOrThrow
   */
  export type OLearningFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OLearning
     */
    select?: OLearningSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OLearningInclude | null
    /**
     * Filter, which OLearning to fetch.
     */
    where?: OLearningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OLearnings to fetch.
     */
    orderBy?: Enumerable<OLearningOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OLearnings.
     */
    cursor?: OLearningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OLearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OLearnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OLearnings.
     */
    distinct?: Enumerable<OLearningScalarFieldEnum>
  }


  /**
   * OLearning findMany
   */
  export type OLearningFindManyArgs = {
    /**
     * Select specific fields to fetch from the OLearning
     */
    select?: OLearningSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OLearningInclude | null
    /**
     * Filter, which OLearnings to fetch.
     */
    where?: OLearningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OLearnings to fetch.
     */
    orderBy?: Enumerable<OLearningOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OLearnings.
     */
    cursor?: OLearningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OLearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OLearnings.
     */
    skip?: number
    distinct?: Enumerable<OLearningScalarFieldEnum>
  }


  /**
   * OLearning create
   */
  export type OLearningCreateArgs = {
    /**
     * Select specific fields to fetch from the OLearning
     */
    select?: OLearningSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OLearningInclude | null
    /**
     * The data needed to create a OLearning.
     */
    data: XOR<OLearningCreateInput, OLearningUncheckedCreateInput>
  }


  /**
   * OLearning createMany
   */
  export type OLearningCreateManyArgs = {
    /**
     * The data used to create many OLearnings.
     */
    data: Enumerable<OLearningCreateManyInput>
  }


  /**
   * OLearning update
   */
  export type OLearningUpdateArgs = {
    /**
     * Select specific fields to fetch from the OLearning
     */
    select?: OLearningSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OLearningInclude | null
    /**
     * The data needed to update a OLearning.
     */
    data: XOR<OLearningUpdateInput, OLearningUncheckedUpdateInput>
    /**
     * Choose, which OLearning to update.
     */
    where: OLearningWhereUniqueInput
  }


  /**
   * OLearning updateMany
   */
  export type OLearningUpdateManyArgs = {
    /**
     * The data used to update OLearnings.
     */
    data: XOR<OLearningUpdateManyMutationInput, OLearningUncheckedUpdateManyInput>
    /**
     * Filter which OLearnings to update
     */
    where?: OLearningWhereInput
  }


  /**
   * OLearning upsert
   */
  export type OLearningUpsertArgs = {
    /**
     * Select specific fields to fetch from the OLearning
     */
    select?: OLearningSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OLearningInclude | null
    /**
     * The filter to search for the OLearning to update in case it exists.
     */
    where: OLearningWhereUniqueInput
    /**
     * In case the OLearning found by the `where` argument doesn't exist, create a new OLearning with this data.
     */
    create: XOR<OLearningCreateInput, OLearningUncheckedCreateInput>
    /**
     * In case the OLearning was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OLearningUpdateInput, OLearningUncheckedUpdateInput>
  }


  /**
   * OLearning delete
   */
  export type OLearningDeleteArgs = {
    /**
     * Select specific fields to fetch from the OLearning
     */
    select?: OLearningSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OLearningInclude | null
    /**
     * Filter which OLearning to delete.
     */
    where: OLearningWhereUniqueInput
  }


  /**
   * OLearning deleteMany
   */
  export type OLearningDeleteManyArgs = {
    /**
     * Filter which OLearnings to delete
     */
    where?: OLearningWhereInput
  }


  /**
   * OLearning findRaw
   */
  export type OLearningFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * OLearning aggregateRaw
   */
  export type OLearningAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * OLearning without action
   */
  export type OLearningArgs = {
    /**
     * Select specific fields to fetch from the OLearning
     */
    select?: OLearningSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OLearningInclude | null
  }



  /**
   * Model Ohelper
   */


  export type AggregateOhelper = {
    _count: OhelperCountAggregateOutputType | null
    _min: OhelperMinAggregateOutputType | null
    _max: OhelperMaxAggregateOutputType | null
  }

  export type OhelperMinAggregateOutputType = {
    id: string | null
    type: OhelperType | null
    name: string | null
  }

  export type OhelperMaxAggregateOutputType = {
    id: string | null
    type: OhelperType | null
    name: string | null
  }

  export type OhelperCountAggregateOutputType = {
    id: number
    type: number
    name: number
    toolIds: number
    mateIds: number
    methIds: number
    mediaIds: number
    _all: number
  }


  export type OhelperMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
  }

  export type OhelperMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
  }

  export type OhelperCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    toolIds?: true
    mateIds?: true
    methIds?: true
    mediaIds?: true
    _all?: true
  }

  export type OhelperAggregateArgs = {
    /**
     * Filter which Ohelper to aggregate.
     */
    where?: OhelperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ohelpers to fetch.
     */
    orderBy?: Enumerable<OhelperOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OhelperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ohelpers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ohelpers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ohelpers
    **/
    _count?: true | OhelperCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OhelperMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OhelperMaxAggregateInputType
  }

  export type GetOhelperAggregateType<T extends OhelperAggregateArgs> = {
        [P in keyof T & keyof AggregateOhelper]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOhelper[P]>
      : GetScalarType<T[P], AggregateOhelper[P]>
  }




  export type OhelperGroupByArgs = {
    where?: OhelperWhereInput
    orderBy?: Enumerable<OhelperOrderByWithAggregationInput>
    by: OhelperScalarFieldEnum[]
    having?: OhelperScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OhelperCountAggregateInputType | true
    _min?: OhelperMinAggregateInputType
    _max?: OhelperMaxAggregateInputType
  }


  export type OhelperGroupByOutputType = {
    id: string
    type: OhelperType
    name: string
    toolIds: string[]
    mateIds: string[]
    methIds: string[]
    mediaIds: string[]
    _count: OhelperCountAggregateOutputType | null
    _min: OhelperMinAggregateOutputType | null
    _max: OhelperMaxAggregateOutputType | null
  }

  type GetOhelperGroupByPayload<T extends OhelperGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OhelperGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OhelperGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OhelperGroupByOutputType[P]>
            : GetScalarType<T[P], OhelperGroupByOutputType[P]>
        }
      >
    >


  export type OhelperSelect = {
    id?: boolean
    type?: boolean
    name?: boolean
    toolIds?: boolean
    mateIds?: boolean
    methIds?: boolean
    mediaIds?: boolean
    tool?: boolean | Ohelper$toolArgs
    mate?: boolean | Ohelper$mateArgs
    meth?: boolean | Ohelper$methArgs
    media?: boolean | Ohelper$mediaArgs
    _count?: boolean | OhelperCountOutputTypeArgs
  }


  export type OhelperInclude = {
    tool?: boolean | Ohelper$toolArgs
    mate?: boolean | Ohelper$mateArgs
    meth?: boolean | Ohelper$methArgs
    media?: boolean | Ohelper$mediaArgs
    _count?: boolean | OhelperCountOutputTypeArgs
  }

  export type OhelperGetPayload<S extends boolean | null | undefined | OhelperArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Ohelper :
    S extends undefined ? never :
    S extends { include: any } & (OhelperArgs | OhelperFindManyArgs)
    ? Ohelper  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'tool' ? Array < ObjectiveGetPayload<S['include'][P]>>  :
        P extends 'mate' ? Array < ObjectiveGetPayload<S['include'][P]>>  :
        P extends 'meth' ? Array < ObjectiveGetPayload<S['include'][P]>>  :
        P extends 'media' ? Array < ObjectiveGetPayload<S['include'][P]>>  :
        P extends '_count' ? OhelperCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (OhelperArgs | OhelperFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'tool' ? Array < ObjectiveGetPayload<S['select'][P]>>  :
        P extends 'mate' ? Array < ObjectiveGetPayload<S['select'][P]>>  :
        P extends 'meth' ? Array < ObjectiveGetPayload<S['select'][P]>>  :
        P extends 'media' ? Array < ObjectiveGetPayload<S['select'][P]>>  :
        P extends '_count' ? OhelperCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Ohelper ? Ohelper[P] : never
  } 
      : Ohelper


  type OhelperCountArgs = 
    Omit<OhelperFindManyArgs, 'select' | 'include'> & {
      select?: OhelperCountAggregateInputType | true
    }

  export interface OhelperDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Ohelper that matches the filter.
     * @param {OhelperFindUniqueArgs} args - Arguments to find a Ohelper
     * @example
     * // Get one Ohelper
     * const ohelper = await prisma.ohelper.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OhelperFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OhelperFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Ohelper'> extends True ? Prisma__OhelperClient<OhelperGetPayload<T>> : Prisma__OhelperClient<OhelperGetPayload<T> | null, null>

    /**
     * Find one Ohelper that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OhelperFindUniqueOrThrowArgs} args - Arguments to find a Ohelper
     * @example
     * // Get one Ohelper
     * const ohelper = await prisma.ohelper.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OhelperFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OhelperFindUniqueOrThrowArgs>
    ): Prisma__OhelperClient<OhelperGetPayload<T>>

    /**
     * Find the first Ohelper that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OhelperFindFirstArgs} args - Arguments to find a Ohelper
     * @example
     * // Get one Ohelper
     * const ohelper = await prisma.ohelper.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OhelperFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OhelperFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Ohelper'> extends True ? Prisma__OhelperClient<OhelperGetPayload<T>> : Prisma__OhelperClient<OhelperGetPayload<T> | null, null>

    /**
     * Find the first Ohelper that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OhelperFindFirstOrThrowArgs} args - Arguments to find a Ohelper
     * @example
     * // Get one Ohelper
     * const ohelper = await prisma.ohelper.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OhelperFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OhelperFindFirstOrThrowArgs>
    ): Prisma__OhelperClient<OhelperGetPayload<T>>

    /**
     * Find zero or more Ohelpers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OhelperFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ohelpers
     * const ohelpers = await prisma.ohelper.findMany()
     * 
     * // Get first 10 Ohelpers
     * const ohelpers = await prisma.ohelper.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ohelperWithIdOnly = await prisma.ohelper.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OhelperFindManyArgs>(
      args?: SelectSubset<T, OhelperFindManyArgs>
    ): Prisma.PrismaPromise<Array<OhelperGetPayload<T>>>

    /**
     * Create a Ohelper.
     * @param {OhelperCreateArgs} args - Arguments to create a Ohelper.
     * @example
     * // Create one Ohelper
     * const Ohelper = await prisma.ohelper.create({
     *   data: {
     *     // ... data to create a Ohelper
     *   }
     * })
     * 
    **/
    create<T extends OhelperCreateArgs>(
      args: SelectSubset<T, OhelperCreateArgs>
    ): Prisma__OhelperClient<OhelperGetPayload<T>>

    /**
     * Create many Ohelpers.
     *     @param {OhelperCreateManyArgs} args - Arguments to create many Ohelpers.
     *     @example
     *     // Create many Ohelpers
     *     const ohelper = await prisma.ohelper.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OhelperCreateManyArgs>(
      args?: SelectSubset<T, OhelperCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ohelper.
     * @param {OhelperDeleteArgs} args - Arguments to delete one Ohelper.
     * @example
     * // Delete one Ohelper
     * const Ohelper = await prisma.ohelper.delete({
     *   where: {
     *     // ... filter to delete one Ohelper
     *   }
     * })
     * 
    **/
    delete<T extends OhelperDeleteArgs>(
      args: SelectSubset<T, OhelperDeleteArgs>
    ): Prisma__OhelperClient<OhelperGetPayload<T>>

    /**
     * Update one Ohelper.
     * @param {OhelperUpdateArgs} args - Arguments to update one Ohelper.
     * @example
     * // Update one Ohelper
     * const ohelper = await prisma.ohelper.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OhelperUpdateArgs>(
      args: SelectSubset<T, OhelperUpdateArgs>
    ): Prisma__OhelperClient<OhelperGetPayload<T>>

    /**
     * Delete zero or more Ohelpers.
     * @param {OhelperDeleteManyArgs} args - Arguments to filter Ohelpers to delete.
     * @example
     * // Delete a few Ohelpers
     * const { count } = await prisma.ohelper.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OhelperDeleteManyArgs>(
      args?: SelectSubset<T, OhelperDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ohelpers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OhelperUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ohelpers
     * const ohelper = await prisma.ohelper.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OhelperUpdateManyArgs>(
      args: SelectSubset<T, OhelperUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ohelper.
     * @param {OhelperUpsertArgs} args - Arguments to update or create a Ohelper.
     * @example
     * // Update or create a Ohelper
     * const ohelper = await prisma.ohelper.upsert({
     *   create: {
     *     // ... data to create a Ohelper
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ohelper we want to update
     *   }
     * })
    **/
    upsert<T extends OhelperUpsertArgs>(
      args: SelectSubset<T, OhelperUpsertArgs>
    ): Prisma__OhelperClient<OhelperGetPayload<T>>

    /**
     * Find zero or more Ohelpers that matches the filter.
     * @param {OhelperFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const ohelper = await prisma.ohelper.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: OhelperFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Ohelper.
     * @param {OhelperAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const ohelper = await prisma.ohelper.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: OhelperAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Ohelpers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OhelperCountArgs} args - Arguments to filter Ohelpers to count.
     * @example
     * // Count the number of Ohelpers
     * const count = await prisma.ohelper.count({
     *   where: {
     *     // ... the filter for the Ohelpers we want to count
     *   }
     * })
    **/
    count<T extends OhelperCountArgs>(
      args?: Subset<T, OhelperCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OhelperCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ohelper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OhelperAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OhelperAggregateArgs>(args: Subset<T, OhelperAggregateArgs>): Prisma.PrismaPromise<GetOhelperAggregateType<T>>

    /**
     * Group by Ohelper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OhelperGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OhelperGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OhelperGroupByArgs['orderBy'] }
        : { orderBy?: OhelperGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OhelperGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOhelperGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Ohelper.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OhelperClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    tool<T extends Ohelper$toolArgs= {}>(args?: Subset<T, Ohelper$toolArgs>): Prisma.PrismaPromise<Array<ObjectiveGetPayload<T>>| Null>;

    mate<T extends Ohelper$mateArgs= {}>(args?: Subset<T, Ohelper$mateArgs>): Prisma.PrismaPromise<Array<ObjectiveGetPayload<T>>| Null>;

    meth<T extends Ohelper$methArgs= {}>(args?: Subset<T, Ohelper$methArgs>): Prisma.PrismaPromise<Array<ObjectiveGetPayload<T>>| Null>;

    media<T extends Ohelper$mediaArgs= {}>(args?: Subset<T, Ohelper$mediaArgs>): Prisma.PrismaPromise<Array<ObjectiveGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Ohelper base type for findUnique actions
   */
  export type OhelperFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Ohelper
     */
    select?: OhelperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OhelperInclude | null
    /**
     * Filter, which Ohelper to fetch.
     */
    where: OhelperWhereUniqueInput
  }

  /**
   * Ohelper findUnique
   */
  export interface OhelperFindUniqueArgs extends OhelperFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Ohelper findUniqueOrThrow
   */
  export type OhelperFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Ohelper
     */
    select?: OhelperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OhelperInclude | null
    /**
     * Filter, which Ohelper to fetch.
     */
    where: OhelperWhereUniqueInput
  }


  /**
   * Ohelper base type for findFirst actions
   */
  export type OhelperFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Ohelper
     */
    select?: OhelperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OhelperInclude | null
    /**
     * Filter, which Ohelper to fetch.
     */
    where?: OhelperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ohelpers to fetch.
     */
    orderBy?: Enumerable<OhelperOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ohelpers.
     */
    cursor?: OhelperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ohelpers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ohelpers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ohelpers.
     */
    distinct?: Enumerable<OhelperScalarFieldEnum>
  }

  /**
   * Ohelper findFirst
   */
  export interface OhelperFindFirstArgs extends OhelperFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Ohelper findFirstOrThrow
   */
  export type OhelperFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Ohelper
     */
    select?: OhelperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OhelperInclude | null
    /**
     * Filter, which Ohelper to fetch.
     */
    where?: OhelperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ohelpers to fetch.
     */
    orderBy?: Enumerable<OhelperOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ohelpers.
     */
    cursor?: OhelperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ohelpers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ohelpers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ohelpers.
     */
    distinct?: Enumerable<OhelperScalarFieldEnum>
  }


  /**
   * Ohelper findMany
   */
  export type OhelperFindManyArgs = {
    /**
     * Select specific fields to fetch from the Ohelper
     */
    select?: OhelperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OhelperInclude | null
    /**
     * Filter, which Ohelpers to fetch.
     */
    where?: OhelperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ohelpers to fetch.
     */
    orderBy?: Enumerable<OhelperOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ohelpers.
     */
    cursor?: OhelperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ohelpers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ohelpers.
     */
    skip?: number
    distinct?: Enumerable<OhelperScalarFieldEnum>
  }


  /**
   * Ohelper create
   */
  export type OhelperCreateArgs = {
    /**
     * Select specific fields to fetch from the Ohelper
     */
    select?: OhelperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OhelperInclude | null
    /**
     * The data needed to create a Ohelper.
     */
    data: XOR<OhelperCreateInput, OhelperUncheckedCreateInput>
  }


  /**
   * Ohelper createMany
   */
  export type OhelperCreateManyArgs = {
    /**
     * The data used to create many Ohelpers.
     */
    data: Enumerable<OhelperCreateManyInput>
  }


  /**
   * Ohelper update
   */
  export type OhelperUpdateArgs = {
    /**
     * Select specific fields to fetch from the Ohelper
     */
    select?: OhelperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OhelperInclude | null
    /**
     * The data needed to update a Ohelper.
     */
    data: XOR<OhelperUpdateInput, OhelperUncheckedUpdateInput>
    /**
     * Choose, which Ohelper to update.
     */
    where: OhelperWhereUniqueInput
  }


  /**
   * Ohelper updateMany
   */
  export type OhelperUpdateManyArgs = {
    /**
     * The data used to update Ohelpers.
     */
    data: XOR<OhelperUpdateManyMutationInput, OhelperUncheckedUpdateManyInput>
    /**
     * Filter which Ohelpers to update
     */
    where?: OhelperWhereInput
  }


  /**
   * Ohelper upsert
   */
  export type OhelperUpsertArgs = {
    /**
     * Select specific fields to fetch from the Ohelper
     */
    select?: OhelperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OhelperInclude | null
    /**
     * The filter to search for the Ohelper to update in case it exists.
     */
    where: OhelperWhereUniqueInput
    /**
     * In case the Ohelper found by the `where` argument doesn't exist, create a new Ohelper with this data.
     */
    create: XOR<OhelperCreateInput, OhelperUncheckedCreateInput>
    /**
     * In case the Ohelper was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OhelperUpdateInput, OhelperUncheckedUpdateInput>
  }


  /**
   * Ohelper delete
   */
  export type OhelperDeleteArgs = {
    /**
     * Select specific fields to fetch from the Ohelper
     */
    select?: OhelperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OhelperInclude | null
    /**
     * Filter which Ohelper to delete.
     */
    where: OhelperWhereUniqueInput
  }


  /**
   * Ohelper deleteMany
   */
  export type OhelperDeleteManyArgs = {
    /**
     * Filter which Ohelpers to delete
     */
    where?: OhelperWhereInput
  }


  /**
   * Ohelper findRaw
   */
  export type OhelperFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Ohelper aggregateRaw
   */
  export type OhelperAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Ohelper.tool
   */
  export type Ohelper$toolArgs = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectiveInclude | null
    where?: ObjectiveWhereInput
    orderBy?: Enumerable<ObjectiveOrderByWithRelationInput>
    cursor?: ObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ObjectiveScalarFieldEnum>
  }


  /**
   * Ohelper.mate
   */
  export type Ohelper$mateArgs = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectiveInclude | null
    where?: ObjectiveWhereInput
    orderBy?: Enumerable<ObjectiveOrderByWithRelationInput>
    cursor?: ObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ObjectiveScalarFieldEnum>
  }


  /**
   * Ohelper.meth
   */
  export type Ohelper$methArgs = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectiveInclude | null
    where?: ObjectiveWhereInput
    orderBy?: Enumerable<ObjectiveOrderByWithRelationInput>
    cursor?: ObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ObjectiveScalarFieldEnum>
  }


  /**
   * Ohelper.media
   */
  export type Ohelper$mediaArgs = {
    /**
     * Select specific fields to fetch from the Objective
     */
    select?: ObjectiveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObjectiveInclude | null
    where?: ObjectiveWhereInput
    orderBy?: Enumerable<ObjectiveOrderByWithRelationInput>
    cursor?: ObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ObjectiveScalarFieldEnum>
  }


  /**
   * Ohelper without action
   */
  export type OhelperArgs = {
    /**
     * Select specific fields to fetch from the Ohelper
     */
    select?: OhelperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OhelperInclude | null
  }



  /**
   * Model Oppp
   */


  export type AggregateOppp = {
    _count: OpppCountAggregateOutputType | null
    _min: OpppMinAggregateOutputType | null
    _max: OpppMaxAggregateOutputType | null
  }

  export type OpppMinAggregateOutputType = {
    id: string | null
    refId: string | null
    name: string | null
    description: string | null
  }

  export type OpppMaxAggregateOutputType = {
    id: string | null
    refId: string | null
    name: string | null
    description: string | null
  }

  export type OpppCountAggregateOutputType = {
    id: number
    refId: number
    name: number
    description: number
    _all: number
  }


  export type OpppMinAggregateInputType = {
    id?: true
    refId?: true
    name?: true
    description?: true
  }

  export type OpppMaxAggregateInputType = {
    id?: true
    refId?: true
    name?: true
    description?: true
  }

  export type OpppCountAggregateInputType = {
    id?: true
    refId?: true
    name?: true
    description?: true
    _all?: true
  }

  export type OpppAggregateArgs = {
    /**
     * Filter which Oppp to aggregate.
     */
    where?: OpppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Oppps to fetch.
     */
    orderBy?: Enumerable<OpppOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Oppps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Oppps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Oppps
    **/
    _count?: true | OpppCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpppMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpppMaxAggregateInputType
  }

  export type GetOpppAggregateType<T extends OpppAggregateArgs> = {
        [P in keyof T & keyof AggregateOppp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOppp[P]>
      : GetScalarType<T[P], AggregateOppp[P]>
  }




  export type OpppGroupByArgs = {
    where?: OpppWhereInput
    orderBy?: Enumerable<OpppOrderByWithAggregationInput>
    by: OpppScalarFieldEnum[]
    having?: OpppScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpppCountAggregateInputType | true
    _min?: OpppMinAggregateInputType
    _max?: OpppMaxAggregateInputType
  }


  export type OpppGroupByOutputType = {
    id: string
    refId: string
    name: string
    description: string | null
    _count: OpppCountAggregateOutputType | null
    _min: OpppMinAggregateOutputType | null
    _max: OpppMaxAggregateOutputType | null
  }

  type GetOpppGroupByPayload<T extends OpppGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OpppGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpppGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpppGroupByOutputType[P]>
            : GetScalarType<T[P], OpppGroupByOutputType[P]>
        }
      >
    >


  export type OpppSelect = {
    id?: boolean
    refId?: boolean
    name?: boolean
    description?: boolean
    ref?: boolean | ObjectiveArgs
  }


  export type OpppInclude = {
    ref?: boolean | ObjectiveArgs
  }

  export type OpppGetPayload<S extends boolean | null | undefined | OpppArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Oppp :
    S extends undefined ? never :
    S extends { include: any } & (OpppArgs | OpppFindManyArgs)
    ? Oppp  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ref' ? ObjectiveGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (OpppArgs | OpppFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ref' ? ObjectiveGetPayload<S['select'][P]> :  P extends keyof Oppp ? Oppp[P] : never
  } 
      : Oppp


  type OpppCountArgs = 
    Omit<OpppFindManyArgs, 'select' | 'include'> & {
      select?: OpppCountAggregateInputType | true
    }

  export interface OpppDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Oppp that matches the filter.
     * @param {OpppFindUniqueArgs} args - Arguments to find a Oppp
     * @example
     * // Get one Oppp
     * const oppp = await prisma.oppp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OpppFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OpppFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Oppp'> extends True ? Prisma__OpppClient<OpppGetPayload<T>> : Prisma__OpppClient<OpppGetPayload<T> | null, null>

    /**
     * Find one Oppp that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OpppFindUniqueOrThrowArgs} args - Arguments to find a Oppp
     * @example
     * // Get one Oppp
     * const oppp = await prisma.oppp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OpppFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OpppFindUniqueOrThrowArgs>
    ): Prisma__OpppClient<OpppGetPayload<T>>

    /**
     * Find the first Oppp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpppFindFirstArgs} args - Arguments to find a Oppp
     * @example
     * // Get one Oppp
     * const oppp = await prisma.oppp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OpppFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OpppFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Oppp'> extends True ? Prisma__OpppClient<OpppGetPayload<T>> : Prisma__OpppClient<OpppGetPayload<T> | null, null>

    /**
     * Find the first Oppp that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpppFindFirstOrThrowArgs} args - Arguments to find a Oppp
     * @example
     * // Get one Oppp
     * const oppp = await prisma.oppp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OpppFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OpppFindFirstOrThrowArgs>
    ): Prisma__OpppClient<OpppGetPayload<T>>

    /**
     * Find zero or more Oppps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpppFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Oppps
     * const oppps = await prisma.oppp.findMany()
     * 
     * // Get first 10 Oppps
     * const oppps = await prisma.oppp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const opppWithIdOnly = await prisma.oppp.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OpppFindManyArgs>(
      args?: SelectSubset<T, OpppFindManyArgs>
    ): Prisma.PrismaPromise<Array<OpppGetPayload<T>>>

    /**
     * Create a Oppp.
     * @param {OpppCreateArgs} args - Arguments to create a Oppp.
     * @example
     * // Create one Oppp
     * const Oppp = await prisma.oppp.create({
     *   data: {
     *     // ... data to create a Oppp
     *   }
     * })
     * 
    **/
    create<T extends OpppCreateArgs>(
      args: SelectSubset<T, OpppCreateArgs>
    ): Prisma__OpppClient<OpppGetPayload<T>>

    /**
     * Create many Oppps.
     *     @param {OpppCreateManyArgs} args - Arguments to create many Oppps.
     *     @example
     *     // Create many Oppps
     *     const oppp = await prisma.oppp.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OpppCreateManyArgs>(
      args?: SelectSubset<T, OpppCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Oppp.
     * @param {OpppDeleteArgs} args - Arguments to delete one Oppp.
     * @example
     * // Delete one Oppp
     * const Oppp = await prisma.oppp.delete({
     *   where: {
     *     // ... filter to delete one Oppp
     *   }
     * })
     * 
    **/
    delete<T extends OpppDeleteArgs>(
      args: SelectSubset<T, OpppDeleteArgs>
    ): Prisma__OpppClient<OpppGetPayload<T>>

    /**
     * Update one Oppp.
     * @param {OpppUpdateArgs} args - Arguments to update one Oppp.
     * @example
     * // Update one Oppp
     * const oppp = await prisma.oppp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OpppUpdateArgs>(
      args: SelectSubset<T, OpppUpdateArgs>
    ): Prisma__OpppClient<OpppGetPayload<T>>

    /**
     * Delete zero or more Oppps.
     * @param {OpppDeleteManyArgs} args - Arguments to filter Oppps to delete.
     * @example
     * // Delete a few Oppps
     * const { count } = await prisma.oppp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OpppDeleteManyArgs>(
      args?: SelectSubset<T, OpppDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Oppps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpppUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Oppps
     * const oppp = await prisma.oppp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OpppUpdateManyArgs>(
      args: SelectSubset<T, OpppUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Oppp.
     * @param {OpppUpsertArgs} args - Arguments to update or create a Oppp.
     * @example
     * // Update or create a Oppp
     * const oppp = await prisma.oppp.upsert({
     *   create: {
     *     // ... data to create a Oppp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Oppp we want to update
     *   }
     * })
    **/
    upsert<T extends OpppUpsertArgs>(
      args: SelectSubset<T, OpppUpsertArgs>
    ): Prisma__OpppClient<OpppGetPayload<T>>

    /**
     * Find zero or more Oppps that matches the filter.
     * @param {OpppFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const oppp = await prisma.oppp.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: OpppFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Oppp.
     * @param {OpppAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const oppp = await prisma.oppp.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: OpppAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Oppps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpppCountArgs} args - Arguments to filter Oppps to count.
     * @example
     * // Count the number of Oppps
     * const count = await prisma.oppp.count({
     *   where: {
     *     // ... the filter for the Oppps we want to count
     *   }
     * })
    **/
    count<T extends OpppCountArgs>(
      args?: Subset<T, OpppCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpppCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Oppp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpppAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpppAggregateArgs>(args: Subset<T, OpppAggregateArgs>): Prisma.PrismaPromise<GetOpppAggregateType<T>>

    /**
     * Group by Oppp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpppGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpppGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpppGroupByArgs['orderBy'] }
        : { orderBy?: OpppGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpppGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpppGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Oppp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OpppClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ref<T extends ObjectiveArgs= {}>(args?: Subset<T, ObjectiveArgs>): Prisma__ObjectiveClient<ObjectiveGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Oppp base type for findUnique actions
   */
  export type OpppFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Oppp
     */
    select?: OpppSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OpppInclude | null
    /**
     * Filter, which Oppp to fetch.
     */
    where: OpppWhereUniqueInput
  }

  /**
   * Oppp findUnique
   */
  export interface OpppFindUniqueArgs extends OpppFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Oppp findUniqueOrThrow
   */
  export type OpppFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Oppp
     */
    select?: OpppSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OpppInclude | null
    /**
     * Filter, which Oppp to fetch.
     */
    where: OpppWhereUniqueInput
  }


  /**
   * Oppp base type for findFirst actions
   */
  export type OpppFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Oppp
     */
    select?: OpppSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OpppInclude | null
    /**
     * Filter, which Oppp to fetch.
     */
    where?: OpppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Oppps to fetch.
     */
    orderBy?: Enumerable<OpppOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Oppps.
     */
    cursor?: OpppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Oppps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Oppps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Oppps.
     */
    distinct?: Enumerable<OpppScalarFieldEnum>
  }

  /**
   * Oppp findFirst
   */
  export interface OpppFindFirstArgs extends OpppFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Oppp findFirstOrThrow
   */
  export type OpppFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Oppp
     */
    select?: OpppSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OpppInclude | null
    /**
     * Filter, which Oppp to fetch.
     */
    where?: OpppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Oppps to fetch.
     */
    orderBy?: Enumerable<OpppOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Oppps.
     */
    cursor?: OpppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Oppps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Oppps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Oppps.
     */
    distinct?: Enumerable<OpppScalarFieldEnum>
  }


  /**
   * Oppp findMany
   */
  export type OpppFindManyArgs = {
    /**
     * Select specific fields to fetch from the Oppp
     */
    select?: OpppSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OpppInclude | null
    /**
     * Filter, which Oppps to fetch.
     */
    where?: OpppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Oppps to fetch.
     */
    orderBy?: Enumerable<OpppOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Oppps.
     */
    cursor?: OpppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Oppps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Oppps.
     */
    skip?: number
    distinct?: Enumerable<OpppScalarFieldEnum>
  }


  /**
   * Oppp create
   */
  export type OpppCreateArgs = {
    /**
     * Select specific fields to fetch from the Oppp
     */
    select?: OpppSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OpppInclude | null
    /**
     * The data needed to create a Oppp.
     */
    data: XOR<OpppCreateInput, OpppUncheckedCreateInput>
  }


  /**
   * Oppp createMany
   */
  export type OpppCreateManyArgs = {
    /**
     * The data used to create many Oppps.
     */
    data: Enumerable<OpppCreateManyInput>
  }


  /**
   * Oppp update
   */
  export type OpppUpdateArgs = {
    /**
     * Select specific fields to fetch from the Oppp
     */
    select?: OpppSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OpppInclude | null
    /**
     * The data needed to update a Oppp.
     */
    data: XOR<OpppUpdateInput, OpppUncheckedUpdateInput>
    /**
     * Choose, which Oppp to update.
     */
    where: OpppWhereUniqueInput
  }


  /**
   * Oppp updateMany
   */
  export type OpppUpdateManyArgs = {
    /**
     * The data used to update Oppps.
     */
    data: XOR<OpppUpdateManyMutationInput, OpppUncheckedUpdateManyInput>
    /**
     * Filter which Oppps to update
     */
    where?: OpppWhereInput
  }


  /**
   * Oppp upsert
   */
  export type OpppUpsertArgs = {
    /**
     * Select specific fields to fetch from the Oppp
     */
    select?: OpppSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OpppInclude | null
    /**
     * The filter to search for the Oppp to update in case it exists.
     */
    where: OpppWhereUniqueInput
    /**
     * In case the Oppp found by the `where` argument doesn't exist, create a new Oppp with this data.
     */
    create: XOR<OpppCreateInput, OpppUncheckedCreateInput>
    /**
     * In case the Oppp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpppUpdateInput, OpppUncheckedUpdateInput>
  }


  /**
   * Oppp delete
   */
  export type OpppDeleteArgs = {
    /**
     * Select specific fields to fetch from the Oppp
     */
    select?: OpppSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OpppInclude | null
    /**
     * Filter which Oppp to delete.
     */
    where: OpppWhereUniqueInput
  }


  /**
   * Oppp deleteMany
   */
  export type OpppDeleteManyArgs = {
    /**
     * Filter which Oppps to delete
     */
    where?: OpppWhereInput
  }


  /**
   * Oppp findRaw
   */
  export type OpppFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Oppp aggregateRaw
   */
  export type OpppAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Oppp without action
   */
  export type OpppArgs = {
    /**
     * Select specific fields to fetch from the Oppp
     */
    select?: OpppSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OpppInclude | null
  }



  /**
   * Model Oresource
   */


  export type AggregateOresource = {
    _count: OresourceCountAggregateOutputType | null
    _min: OresourceMinAggregateOutputType | null
    _max: OresourceMaxAggregateOutputType | null
  }

  export type OresourceMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: OresourceType | null
    refId: string | null
    linkId: string | null
  }

  export type OresourceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: OresourceType | null
    refId: string | null
    linkId: string | null
  }

  export type OresourceCountAggregateOutputType = {
    id: number
    name: number
    type: number
    refId: number
    linkId: number
    _all: number
  }


  export type OresourceMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    refId?: true
    linkId?: true
  }

  export type OresourceMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    refId?: true
    linkId?: true
  }

  export type OresourceCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    refId?: true
    linkId?: true
    _all?: true
  }

  export type OresourceAggregateArgs = {
    /**
     * Filter which Oresource to aggregate.
     */
    where?: OresourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Oresources to fetch.
     */
    orderBy?: Enumerable<OresourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OresourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Oresources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Oresources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Oresources
    **/
    _count?: true | OresourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OresourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OresourceMaxAggregateInputType
  }

  export type GetOresourceAggregateType<T extends OresourceAggregateArgs> = {
        [P in keyof T & keyof AggregateOresource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOresource[P]>
      : GetScalarType<T[P], AggregateOresource[P]>
  }




  export type OresourceGroupByArgs = {
    where?: OresourceWhereInput
    orderBy?: Enumerable<OresourceOrderByWithAggregationInput>
    by: OresourceScalarFieldEnum[]
    having?: OresourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OresourceCountAggregateInputType | true
    _min?: OresourceMinAggregateInputType
    _max?: OresourceMaxAggregateInputType
  }


  export type OresourceGroupByOutputType = {
    id: string
    name: string
    type: OresourceType
    refId: string
    linkId: string | null
    _count: OresourceCountAggregateOutputType | null
    _min: OresourceMinAggregateOutputType | null
    _max: OresourceMaxAggregateOutputType | null
  }

  type GetOresourceGroupByPayload<T extends OresourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OresourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OresourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OresourceGroupByOutputType[P]>
            : GetScalarType<T[P], OresourceGroupByOutputType[P]>
        }
      >
    >


  export type OresourceSelect = {
    id?: boolean
    name?: boolean
    type?: boolean
    refId?: boolean
    linkId?: boolean
    ref?: boolean | ObjectiveArgs
    link?: boolean | LinkArgs
  }


  export type OresourceInclude = {
    ref?: boolean | ObjectiveArgs
    link?: boolean | LinkArgs
  }

  export type OresourceGetPayload<S extends boolean | null | undefined | OresourceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Oresource :
    S extends undefined ? never :
    S extends { include: any } & (OresourceArgs | OresourceFindManyArgs)
    ? Oresource  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ref' ? ObjectiveGetPayload<S['include'][P]> :
        P extends 'link' ? LinkGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (OresourceArgs | OresourceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ref' ? ObjectiveGetPayload<S['select'][P]> :
        P extends 'link' ? LinkGetPayload<S['select'][P]> | null :  P extends keyof Oresource ? Oresource[P] : never
  } 
      : Oresource


  type OresourceCountArgs = 
    Omit<OresourceFindManyArgs, 'select' | 'include'> & {
      select?: OresourceCountAggregateInputType | true
    }

  export interface OresourceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Oresource that matches the filter.
     * @param {OresourceFindUniqueArgs} args - Arguments to find a Oresource
     * @example
     * // Get one Oresource
     * const oresource = await prisma.oresource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OresourceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OresourceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Oresource'> extends True ? Prisma__OresourceClient<OresourceGetPayload<T>> : Prisma__OresourceClient<OresourceGetPayload<T> | null, null>

    /**
     * Find one Oresource that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OresourceFindUniqueOrThrowArgs} args - Arguments to find a Oresource
     * @example
     * // Get one Oresource
     * const oresource = await prisma.oresource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OresourceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OresourceFindUniqueOrThrowArgs>
    ): Prisma__OresourceClient<OresourceGetPayload<T>>

    /**
     * Find the first Oresource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OresourceFindFirstArgs} args - Arguments to find a Oresource
     * @example
     * // Get one Oresource
     * const oresource = await prisma.oresource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OresourceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OresourceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Oresource'> extends True ? Prisma__OresourceClient<OresourceGetPayload<T>> : Prisma__OresourceClient<OresourceGetPayload<T> | null, null>

    /**
     * Find the first Oresource that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OresourceFindFirstOrThrowArgs} args - Arguments to find a Oresource
     * @example
     * // Get one Oresource
     * const oresource = await prisma.oresource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OresourceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OresourceFindFirstOrThrowArgs>
    ): Prisma__OresourceClient<OresourceGetPayload<T>>

    /**
     * Find zero or more Oresources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OresourceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Oresources
     * const oresources = await prisma.oresource.findMany()
     * 
     * // Get first 10 Oresources
     * const oresources = await prisma.oresource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oresourceWithIdOnly = await prisma.oresource.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OresourceFindManyArgs>(
      args?: SelectSubset<T, OresourceFindManyArgs>
    ): Prisma.PrismaPromise<Array<OresourceGetPayload<T>>>

    /**
     * Create a Oresource.
     * @param {OresourceCreateArgs} args - Arguments to create a Oresource.
     * @example
     * // Create one Oresource
     * const Oresource = await prisma.oresource.create({
     *   data: {
     *     // ... data to create a Oresource
     *   }
     * })
     * 
    **/
    create<T extends OresourceCreateArgs>(
      args: SelectSubset<T, OresourceCreateArgs>
    ): Prisma__OresourceClient<OresourceGetPayload<T>>

    /**
     * Create many Oresources.
     *     @param {OresourceCreateManyArgs} args - Arguments to create many Oresources.
     *     @example
     *     // Create many Oresources
     *     const oresource = await prisma.oresource.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OresourceCreateManyArgs>(
      args?: SelectSubset<T, OresourceCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Oresource.
     * @param {OresourceDeleteArgs} args - Arguments to delete one Oresource.
     * @example
     * // Delete one Oresource
     * const Oresource = await prisma.oresource.delete({
     *   where: {
     *     // ... filter to delete one Oresource
     *   }
     * })
     * 
    **/
    delete<T extends OresourceDeleteArgs>(
      args: SelectSubset<T, OresourceDeleteArgs>
    ): Prisma__OresourceClient<OresourceGetPayload<T>>

    /**
     * Update one Oresource.
     * @param {OresourceUpdateArgs} args - Arguments to update one Oresource.
     * @example
     * // Update one Oresource
     * const oresource = await prisma.oresource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OresourceUpdateArgs>(
      args: SelectSubset<T, OresourceUpdateArgs>
    ): Prisma__OresourceClient<OresourceGetPayload<T>>

    /**
     * Delete zero or more Oresources.
     * @param {OresourceDeleteManyArgs} args - Arguments to filter Oresources to delete.
     * @example
     * // Delete a few Oresources
     * const { count } = await prisma.oresource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OresourceDeleteManyArgs>(
      args?: SelectSubset<T, OresourceDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Oresources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OresourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Oresources
     * const oresource = await prisma.oresource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OresourceUpdateManyArgs>(
      args: SelectSubset<T, OresourceUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Oresource.
     * @param {OresourceUpsertArgs} args - Arguments to update or create a Oresource.
     * @example
     * // Update or create a Oresource
     * const oresource = await prisma.oresource.upsert({
     *   create: {
     *     // ... data to create a Oresource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Oresource we want to update
     *   }
     * })
    **/
    upsert<T extends OresourceUpsertArgs>(
      args: SelectSubset<T, OresourceUpsertArgs>
    ): Prisma__OresourceClient<OresourceGetPayload<T>>

    /**
     * Find zero or more Oresources that matches the filter.
     * @param {OresourceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const oresource = await prisma.oresource.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: OresourceFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Oresource.
     * @param {OresourceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const oresource = await prisma.oresource.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: OresourceAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Oresources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OresourceCountArgs} args - Arguments to filter Oresources to count.
     * @example
     * // Count the number of Oresources
     * const count = await prisma.oresource.count({
     *   where: {
     *     // ... the filter for the Oresources we want to count
     *   }
     * })
    **/
    count<T extends OresourceCountArgs>(
      args?: Subset<T, OresourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OresourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Oresource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OresourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OresourceAggregateArgs>(args: Subset<T, OresourceAggregateArgs>): Prisma.PrismaPromise<GetOresourceAggregateType<T>>

    /**
     * Group by Oresource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OresourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OresourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OresourceGroupByArgs['orderBy'] }
        : { orderBy?: OresourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OresourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOresourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Oresource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OresourceClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ref<T extends ObjectiveArgs= {}>(args?: Subset<T, ObjectiveArgs>): Prisma__ObjectiveClient<ObjectiveGetPayload<T> | Null>;

    link<T extends LinkArgs= {}>(args?: Subset<T, LinkArgs>): Prisma__LinkClient<LinkGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Oresource base type for findUnique actions
   */
  export type OresourceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Oresource
     */
    select?: OresourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OresourceInclude | null
    /**
     * Filter, which Oresource to fetch.
     */
    where: OresourceWhereUniqueInput
  }

  /**
   * Oresource findUnique
   */
  export interface OresourceFindUniqueArgs extends OresourceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Oresource findUniqueOrThrow
   */
  export type OresourceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Oresource
     */
    select?: OresourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OresourceInclude | null
    /**
     * Filter, which Oresource to fetch.
     */
    where: OresourceWhereUniqueInput
  }


  /**
   * Oresource base type for findFirst actions
   */
  export type OresourceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Oresource
     */
    select?: OresourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OresourceInclude | null
    /**
     * Filter, which Oresource to fetch.
     */
    where?: OresourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Oresources to fetch.
     */
    orderBy?: Enumerable<OresourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Oresources.
     */
    cursor?: OresourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Oresources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Oresources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Oresources.
     */
    distinct?: Enumerable<OresourceScalarFieldEnum>
  }

  /**
   * Oresource findFirst
   */
  export interface OresourceFindFirstArgs extends OresourceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Oresource findFirstOrThrow
   */
  export type OresourceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Oresource
     */
    select?: OresourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OresourceInclude | null
    /**
     * Filter, which Oresource to fetch.
     */
    where?: OresourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Oresources to fetch.
     */
    orderBy?: Enumerable<OresourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Oresources.
     */
    cursor?: OresourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Oresources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Oresources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Oresources.
     */
    distinct?: Enumerable<OresourceScalarFieldEnum>
  }


  /**
   * Oresource findMany
   */
  export type OresourceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Oresource
     */
    select?: OresourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OresourceInclude | null
    /**
     * Filter, which Oresources to fetch.
     */
    where?: OresourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Oresources to fetch.
     */
    orderBy?: Enumerable<OresourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Oresources.
     */
    cursor?: OresourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Oresources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Oresources.
     */
    skip?: number
    distinct?: Enumerable<OresourceScalarFieldEnum>
  }


  /**
   * Oresource create
   */
  export type OresourceCreateArgs = {
    /**
     * Select specific fields to fetch from the Oresource
     */
    select?: OresourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OresourceInclude | null
    /**
     * The data needed to create a Oresource.
     */
    data: XOR<OresourceCreateInput, OresourceUncheckedCreateInput>
  }


  /**
   * Oresource createMany
   */
  export type OresourceCreateManyArgs = {
    /**
     * The data used to create many Oresources.
     */
    data: Enumerable<OresourceCreateManyInput>
  }


  /**
   * Oresource update
   */
  export type OresourceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Oresource
     */
    select?: OresourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OresourceInclude | null
    /**
     * The data needed to update a Oresource.
     */
    data: XOR<OresourceUpdateInput, OresourceUncheckedUpdateInput>
    /**
     * Choose, which Oresource to update.
     */
    where: OresourceWhereUniqueInput
  }


  /**
   * Oresource updateMany
   */
  export type OresourceUpdateManyArgs = {
    /**
     * The data used to update Oresources.
     */
    data: XOR<OresourceUpdateManyMutationInput, OresourceUncheckedUpdateManyInput>
    /**
     * Filter which Oresources to update
     */
    where?: OresourceWhereInput
  }


  /**
   * Oresource upsert
   */
  export type OresourceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Oresource
     */
    select?: OresourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OresourceInclude | null
    /**
     * The filter to search for the Oresource to update in case it exists.
     */
    where: OresourceWhereUniqueInput
    /**
     * In case the Oresource found by the `where` argument doesn't exist, create a new Oresource with this data.
     */
    create: XOR<OresourceCreateInput, OresourceUncheckedCreateInput>
    /**
     * In case the Oresource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OresourceUpdateInput, OresourceUncheckedUpdateInput>
  }


  /**
   * Oresource delete
   */
  export type OresourceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Oresource
     */
    select?: OresourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OresourceInclude | null
    /**
     * Filter which Oresource to delete.
     */
    where: OresourceWhereUniqueInput
  }


  /**
   * Oresource deleteMany
   */
  export type OresourceDeleteManyArgs = {
    /**
     * Filter which Oresources to delete
     */
    where?: OresourceWhereInput
  }


  /**
   * Oresource findRaw
   */
  export type OresourceFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Oresource aggregateRaw
   */
  export type OresourceAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Oresource without action
   */
  export type OresourceArgs = {
    /**
     * Select specific fields to fetch from the Oresource
     */
    select?: OresourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OresourceInclude | null
  }



  /**
   * Model Book
   */


  export type AggregateBook = {
    _count: BookCountAggregateOutputType | null
    _min: BookMinAggregateOutputType | null
    _max: BookMaxAggregateOutputType | null
  }

  export type BookMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    author: string | null
  }

  export type BookMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    author: string | null
  }

  export type BookCountAggregateOutputType = {
    id: number
    name: number
    description: number
    author: number
    _all: number
  }


  export type BookMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    author?: true
  }

  export type BookMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    author?: true
  }

  export type BookCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    author?: true
    _all?: true
  }

  export type BookAggregateArgs = {
    /**
     * Filter which Book to aggregate.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: Enumerable<BookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Books
    **/
    _count?: true | BookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookMaxAggregateInputType
  }

  export type GetBookAggregateType<T extends BookAggregateArgs> = {
        [P in keyof T & keyof AggregateBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook[P]>
      : GetScalarType<T[P], AggregateBook[P]>
  }




  export type BookGroupByArgs = {
    where?: BookWhereInput
    orderBy?: Enumerable<BookOrderByWithAggregationInput>
    by: BookScalarFieldEnum[]
    having?: BookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookCountAggregateInputType | true
    _min?: BookMinAggregateInputType
    _max?: BookMaxAggregateInputType
  }


  export type BookGroupByOutputType = {
    id: string
    name: string
    description: string | null
    author: string | null
    _count: BookCountAggregateOutputType | null
    _min: BookMinAggregateOutputType | null
    _max: BookMaxAggregateOutputType | null
  }

  type GetBookGroupByPayload<T extends BookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookGroupByOutputType[P]>
            : GetScalarType<T[P], BookGroupByOutputType[P]>
        }
      >
    >


  export type BookSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    author?: boolean
  }


  export type BookGetPayload<S extends boolean | null | undefined | BookArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Book :
    S extends undefined ? never :
    S extends { include: any } & (BookArgs | BookFindManyArgs)
    ? Book 
    : S extends { select: any } & (BookArgs | BookFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Book ? Book[P] : never
  } 
      : Book


  type BookCountArgs = 
    Omit<BookFindManyArgs, 'select' | 'include'> & {
      select?: BookCountAggregateInputType | true
    }

  export interface BookDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Book that matches the filter.
     * @param {BookFindUniqueArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BookFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BookFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Book'> extends True ? Prisma__BookClient<BookGetPayload<T>> : Prisma__BookClient<BookGetPayload<T> | null, null>

    /**
     * Find one Book that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BookFindUniqueOrThrowArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BookFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BookFindUniqueOrThrowArgs>
    ): Prisma__BookClient<BookGetPayload<T>>

    /**
     * Find the first Book that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindFirstArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BookFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BookFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Book'> extends True ? Prisma__BookClient<BookGetPayload<T>> : Prisma__BookClient<BookGetPayload<T> | null, null>

    /**
     * Find the first Book that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindFirstOrThrowArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BookFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BookFindFirstOrThrowArgs>
    ): Prisma__BookClient<BookGetPayload<T>>

    /**
     * Find zero or more Books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Books
     * const books = await prisma.book.findMany()
     * 
     * // Get first 10 Books
     * const books = await prisma.book.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookWithIdOnly = await prisma.book.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BookFindManyArgs>(
      args?: SelectSubset<T, BookFindManyArgs>
    ): Prisma.PrismaPromise<Array<BookGetPayload<T>>>

    /**
     * Create a Book.
     * @param {BookCreateArgs} args - Arguments to create a Book.
     * @example
     * // Create one Book
     * const Book = await prisma.book.create({
     *   data: {
     *     // ... data to create a Book
     *   }
     * })
     * 
    **/
    create<T extends BookCreateArgs>(
      args: SelectSubset<T, BookCreateArgs>
    ): Prisma__BookClient<BookGetPayload<T>>

    /**
     * Create many Books.
     *     @param {BookCreateManyArgs} args - Arguments to create many Books.
     *     @example
     *     // Create many Books
     *     const book = await prisma.book.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BookCreateManyArgs>(
      args?: SelectSubset<T, BookCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Book.
     * @param {BookDeleteArgs} args - Arguments to delete one Book.
     * @example
     * // Delete one Book
     * const Book = await prisma.book.delete({
     *   where: {
     *     // ... filter to delete one Book
     *   }
     * })
     * 
    **/
    delete<T extends BookDeleteArgs>(
      args: SelectSubset<T, BookDeleteArgs>
    ): Prisma__BookClient<BookGetPayload<T>>

    /**
     * Update one Book.
     * @param {BookUpdateArgs} args - Arguments to update one Book.
     * @example
     * // Update one Book
     * const book = await prisma.book.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BookUpdateArgs>(
      args: SelectSubset<T, BookUpdateArgs>
    ): Prisma__BookClient<BookGetPayload<T>>

    /**
     * Delete zero or more Books.
     * @param {BookDeleteManyArgs} args - Arguments to filter Books to delete.
     * @example
     * // Delete a few Books
     * const { count } = await prisma.book.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BookDeleteManyArgs>(
      args?: SelectSubset<T, BookDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Books
     * const book = await prisma.book.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BookUpdateManyArgs>(
      args: SelectSubset<T, BookUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Book.
     * @param {BookUpsertArgs} args - Arguments to update or create a Book.
     * @example
     * // Update or create a Book
     * const book = await prisma.book.upsert({
     *   create: {
     *     // ... data to create a Book
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book we want to update
     *   }
     * })
    **/
    upsert<T extends BookUpsertArgs>(
      args: SelectSubset<T, BookUpsertArgs>
    ): Prisma__BookClient<BookGetPayload<T>>

    /**
     * Find zero or more Books that matches the filter.
     * @param {BookFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const book = await prisma.book.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: BookFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Book.
     * @param {BookAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const book = await prisma.book.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: BookAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCountArgs} args - Arguments to filter Books to count.
     * @example
     * // Count the number of Books
     * const count = await prisma.book.count({
     *   where: {
     *     // ... the filter for the Books we want to count
     *   }
     * })
    **/
    count<T extends BookCountArgs>(
      args?: Subset<T, BookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookAggregateArgs>(args: Subset<T, BookAggregateArgs>): Prisma.PrismaPromise<GetBookAggregateType<T>>

    /**
     * Group by Book.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookGroupByArgs['orderBy'] }
        : { orderBy?: BookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Book.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BookClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Book base type for findUnique actions
   */
  export type BookFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect | null
    /**
     * Filter, which Book to fetch.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book findUnique
   */
  export interface BookFindUniqueArgs extends BookFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Book findUniqueOrThrow
   */
  export type BookFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect | null
    /**
     * Filter, which Book to fetch.
     */
    where: BookWhereUniqueInput
  }


  /**
   * Book base type for findFirst actions
   */
  export type BookFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect | null
    /**
     * Filter, which Book to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: Enumerable<BookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Books.
     */
    distinct?: Enumerable<BookScalarFieldEnum>
  }

  /**
   * Book findFirst
   */
  export interface BookFindFirstArgs extends BookFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Book findFirstOrThrow
   */
  export type BookFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect | null
    /**
     * Filter, which Book to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: Enumerable<BookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Books.
     */
    distinct?: Enumerable<BookScalarFieldEnum>
  }


  /**
   * Book findMany
   */
  export type BookFindManyArgs = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect | null
    /**
     * Filter, which Books to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: Enumerable<BookOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    distinct?: Enumerable<BookScalarFieldEnum>
  }


  /**
   * Book create
   */
  export type BookCreateArgs = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect | null
    /**
     * The data needed to create a Book.
     */
    data: XOR<BookCreateInput, BookUncheckedCreateInput>
  }


  /**
   * Book createMany
   */
  export type BookCreateManyArgs = {
    /**
     * The data used to create many Books.
     */
    data: Enumerable<BookCreateManyInput>
  }


  /**
   * Book update
   */
  export type BookUpdateArgs = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect | null
    /**
     * The data needed to update a Book.
     */
    data: XOR<BookUpdateInput, BookUncheckedUpdateInput>
    /**
     * Choose, which Book to update.
     */
    where: BookWhereUniqueInput
  }


  /**
   * Book updateMany
   */
  export type BookUpdateManyArgs = {
    /**
     * The data used to update Books.
     */
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyInput>
    /**
     * Filter which Books to update
     */
    where?: BookWhereInput
  }


  /**
   * Book upsert
   */
  export type BookUpsertArgs = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect | null
    /**
     * The filter to search for the Book to update in case it exists.
     */
    where: BookWhereUniqueInput
    /**
     * In case the Book found by the `where` argument doesn't exist, create a new Book with this data.
     */
    create: XOR<BookCreateInput, BookUncheckedCreateInput>
    /**
     * In case the Book was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookUpdateInput, BookUncheckedUpdateInput>
  }


  /**
   * Book delete
   */
  export type BookDeleteArgs = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect | null
    /**
     * Filter which Book to delete.
     */
    where: BookWhereUniqueInput
  }


  /**
   * Book deleteMany
   */
  export type BookDeleteManyArgs = {
    /**
     * Filter which Books to delete
     */
    where?: BookWhereInput
  }


  /**
   * Book findRaw
   */
  export type BookFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Book aggregateRaw
   */
  export type BookAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Book without action
   */
  export type BookArgs = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect | null
  }



  /**
   * Model TDevice
   */


  export type AggregateTDevice = {
    _count: TDeviceCountAggregateOutputType | null
    _avg: TDeviceAvgAggregateOutputType | null
    _sum: TDeviceSumAggregateOutputType | null
    _min: TDeviceMinAggregateOutputType | null
    _max: TDeviceMaxAggregateOutputType | null
  }

  export type TDeviceAvgAggregateOutputType = {
    level: number | null
  }

  export type TDeviceSumAggregateOutputType = {
    level: number | null
  }

  export type TDeviceMinAggregateOutputType = {
    id: string | null
    name: string | null
    level: number | null
    fase: Fase | null
    teachingId: string | null
    yearId: string | null
    userId: string | null
    instansiId: string | null
    mapelId: string | null
    disable: boolean | null
    parentId: string | null
  }

  export type TDeviceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    level: number | null
    fase: Fase | null
    teachingId: string | null
    yearId: string | null
    userId: string | null
    instansiId: string | null
    mapelId: string | null
    disable: boolean | null
    parentId: string | null
  }

  export type TDeviceCountAggregateOutputType = {
    id: number
    name: number
    level: number
    fase: number
    teachingId: number
    yearId: number
    userId: number
    instansiId: number
    mapelId: number
    classRoomIds: number
    elemen: number
    disable: number
    parentId: number
    _all: number
  }


  export type TDeviceAvgAggregateInputType = {
    level?: true
  }

  export type TDeviceSumAggregateInputType = {
    level?: true
  }

  export type TDeviceMinAggregateInputType = {
    id?: true
    name?: true
    level?: true
    fase?: true
    teachingId?: true
    yearId?: true
    userId?: true
    instansiId?: true
    mapelId?: true
    disable?: true
    parentId?: true
  }

  export type TDeviceMaxAggregateInputType = {
    id?: true
    name?: true
    level?: true
    fase?: true
    teachingId?: true
    yearId?: true
    userId?: true
    instansiId?: true
    mapelId?: true
    disable?: true
    parentId?: true
  }

  export type TDeviceCountAggregateInputType = {
    id?: true
    name?: true
    level?: true
    fase?: true
    teachingId?: true
    yearId?: true
    userId?: true
    instansiId?: true
    mapelId?: true
    classRoomIds?: true
    elemen?: true
    disable?: true
    parentId?: true
    _all?: true
  }

  export type TDeviceAggregateArgs = {
    /**
     * Filter which TDevice to aggregate.
     */
    where?: TDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TDevices to fetch.
     */
    orderBy?: Enumerable<TDeviceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TDevices
    **/
    _count?: true | TDeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TDeviceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TDeviceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TDeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TDeviceMaxAggregateInputType
  }

  export type GetTDeviceAggregateType<T extends TDeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateTDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTDevice[P]>
      : GetScalarType<T[P], AggregateTDevice[P]>
  }




  export type TDeviceGroupByArgs = {
    where?: TDeviceWhereInput
    orderBy?: Enumerable<TDeviceOrderByWithAggregationInput>
    by: TDeviceScalarFieldEnum[]
    having?: TDeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TDeviceCountAggregateInputType | true
    _avg?: TDeviceAvgAggregateInputType
    _sum?: TDeviceSumAggregateInputType
    _min?: TDeviceMinAggregateInputType
    _max?: TDeviceMaxAggregateInputType
  }


  export type TDeviceGroupByOutputType = {
    id: string
    name: string
    level: number
    fase: Fase
    teachingId: string
    yearId: string
    userId: string
    instansiId: string
    mapelId: string
    classRoomIds: string[]
    elemen: string[]
    disable: boolean
    parentId: string | null
    _count: TDeviceCountAggregateOutputType | null
    _avg: TDeviceAvgAggregateOutputType | null
    _sum: TDeviceSumAggregateOutputType | null
    _min: TDeviceMinAggregateOutputType | null
    _max: TDeviceMaxAggregateOutputType | null
  }

  type GetTDeviceGroupByPayload<T extends TDeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TDeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TDeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TDeviceGroupByOutputType[P]>
            : GetScalarType<T[P], TDeviceGroupByOutputType[P]>
        }
      >
    >


  export type TDeviceSelect = {
    id?: boolean
    name?: boolean
    level?: boolean
    fase?: boolean
    teachingId?: boolean
    property?: boolean | TDevicePropsArgs
    yearId?: boolean
    userId?: boolean
    instansiId?: boolean
    mapelId?: boolean
    classRoomIds?: boolean
    elemen?: boolean
    disable?: boolean
    parentId?: boolean
    positions?: boolean | TDevicePosArgs
    teaching?: boolean | TeachingArgs
    year?: boolean | SchoolYearArgs
    user?: boolean | UserArgs
    instansi?: boolean | InstansiArgs
    mapel?: boolean | MataPelajaranArgs
    classRoom?: boolean | TDevice$classRoomArgs
    tracker?: boolean | TDevice$trackerArgs
    data?: boolean | TDevice$dataArgs
    children?: boolean | TDevice$childrenArgs
    parent?: boolean | TDeviceArgs
    _count?: boolean | TDeviceCountOutputTypeArgs
  }


  export type TDeviceInclude = {
    teaching?: boolean | TeachingArgs
    year?: boolean | SchoolYearArgs
    user?: boolean | UserArgs
    instansi?: boolean | InstansiArgs
    mapel?: boolean | MataPelajaranArgs
    classRoom?: boolean | TDevice$classRoomArgs
    tracker?: boolean | TDevice$trackerArgs
    data?: boolean | TDevice$dataArgs
    children?: boolean | TDevice$childrenArgs
    parent?: boolean | TDeviceArgs
    _count?: boolean | TDeviceCountOutputTypeArgs
  }

  export type TDeviceGetPayload<S extends boolean | null | undefined | TDeviceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TDevice :
    S extends undefined ? never :
    S extends { include: any } & (TDeviceArgs | TDeviceFindManyArgs)
    ? TDevice  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'teaching' ? TeachingGetPayload<S['include'][P]> :
        P extends 'year' ? SchoolYearGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'instansi' ? InstansiGetPayload<S['include'][P]> :
        P extends 'mapel' ? MataPelajaranGetPayload<S['include'][P]> :
        P extends 'classRoom' ? Array < ClassRoomGetPayload<S['include'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['include'][P]>>  :
        P extends 'data' ? Array < TDeviceDataGetPayload<S['include'][P]>>  :
        P extends 'children' ? Array < TDeviceGetPayload<S['include'][P]>>  :
        P extends 'parent' ? TDeviceGetPayload<S['include'][P]> | null :
        P extends '_count' ? TDeviceCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TDeviceArgs | TDeviceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'property' ? TDevicePropsGetPayload<S['select'][P]> :
        P extends 'positions' ? Array < TDevicePosGetPayload<S['select'][P]>>  :
        P extends 'teaching' ? TeachingGetPayload<S['select'][P]> :
        P extends 'year' ? SchoolYearGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'instansi' ? InstansiGetPayload<S['select'][P]> :
        P extends 'mapel' ? MataPelajaranGetPayload<S['select'][P]> :
        P extends 'classRoom' ? Array < ClassRoomGetPayload<S['select'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['select'][P]>>  :
        P extends 'data' ? Array < TDeviceDataGetPayload<S['select'][P]>>  :
        P extends 'children' ? Array < TDeviceGetPayload<S['select'][P]>>  :
        P extends 'parent' ? TDeviceGetPayload<S['select'][P]> | null :
        P extends '_count' ? TDeviceCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TDevice ? TDevice[P] : never
  } 
      : TDevice


  type TDeviceCountArgs = 
    Omit<TDeviceFindManyArgs, 'select' | 'include'> & {
      select?: TDeviceCountAggregateInputType | true
    }

  export interface TDeviceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TDevice that matches the filter.
     * @param {TDeviceFindUniqueArgs} args - Arguments to find a TDevice
     * @example
     * // Get one TDevice
     * const tDevice = await prisma.tDevice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TDeviceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TDeviceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TDevice'> extends True ? Prisma__TDeviceClient<TDeviceGetPayload<T>> : Prisma__TDeviceClient<TDeviceGetPayload<T> | null, null>

    /**
     * Find one TDevice that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TDeviceFindUniqueOrThrowArgs} args - Arguments to find a TDevice
     * @example
     * // Get one TDevice
     * const tDevice = await prisma.tDevice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TDeviceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TDeviceFindUniqueOrThrowArgs>
    ): Prisma__TDeviceClient<TDeviceGetPayload<T>>

    /**
     * Find the first TDevice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TDeviceFindFirstArgs} args - Arguments to find a TDevice
     * @example
     * // Get one TDevice
     * const tDevice = await prisma.tDevice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TDeviceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TDeviceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TDevice'> extends True ? Prisma__TDeviceClient<TDeviceGetPayload<T>> : Prisma__TDeviceClient<TDeviceGetPayload<T> | null, null>

    /**
     * Find the first TDevice that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TDeviceFindFirstOrThrowArgs} args - Arguments to find a TDevice
     * @example
     * // Get one TDevice
     * const tDevice = await prisma.tDevice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TDeviceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TDeviceFindFirstOrThrowArgs>
    ): Prisma__TDeviceClient<TDeviceGetPayload<T>>

    /**
     * Find zero or more TDevices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TDeviceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TDevices
     * const tDevices = await prisma.tDevice.findMany()
     * 
     * // Get first 10 TDevices
     * const tDevices = await prisma.tDevice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tDeviceWithIdOnly = await prisma.tDevice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TDeviceFindManyArgs>(
      args?: SelectSubset<T, TDeviceFindManyArgs>
    ): Prisma.PrismaPromise<Array<TDeviceGetPayload<T>>>

    /**
     * Create a TDevice.
     * @param {TDeviceCreateArgs} args - Arguments to create a TDevice.
     * @example
     * // Create one TDevice
     * const TDevice = await prisma.tDevice.create({
     *   data: {
     *     // ... data to create a TDevice
     *   }
     * })
     * 
    **/
    create<T extends TDeviceCreateArgs>(
      args: SelectSubset<T, TDeviceCreateArgs>
    ): Prisma__TDeviceClient<TDeviceGetPayload<T>>

    /**
     * Create many TDevices.
     *     @param {TDeviceCreateManyArgs} args - Arguments to create many TDevices.
     *     @example
     *     // Create many TDevices
     *     const tDevice = await prisma.tDevice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TDeviceCreateManyArgs>(
      args?: SelectSubset<T, TDeviceCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TDevice.
     * @param {TDeviceDeleteArgs} args - Arguments to delete one TDevice.
     * @example
     * // Delete one TDevice
     * const TDevice = await prisma.tDevice.delete({
     *   where: {
     *     // ... filter to delete one TDevice
     *   }
     * })
     * 
    **/
    delete<T extends TDeviceDeleteArgs>(
      args: SelectSubset<T, TDeviceDeleteArgs>
    ): Prisma__TDeviceClient<TDeviceGetPayload<T>>

    /**
     * Update one TDevice.
     * @param {TDeviceUpdateArgs} args - Arguments to update one TDevice.
     * @example
     * // Update one TDevice
     * const tDevice = await prisma.tDevice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TDeviceUpdateArgs>(
      args: SelectSubset<T, TDeviceUpdateArgs>
    ): Prisma__TDeviceClient<TDeviceGetPayload<T>>

    /**
     * Delete zero or more TDevices.
     * @param {TDeviceDeleteManyArgs} args - Arguments to filter TDevices to delete.
     * @example
     * // Delete a few TDevices
     * const { count } = await prisma.tDevice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TDeviceDeleteManyArgs>(
      args?: SelectSubset<T, TDeviceDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TDevices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TDeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TDevices
     * const tDevice = await prisma.tDevice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TDeviceUpdateManyArgs>(
      args: SelectSubset<T, TDeviceUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TDevice.
     * @param {TDeviceUpsertArgs} args - Arguments to update or create a TDevice.
     * @example
     * // Update or create a TDevice
     * const tDevice = await prisma.tDevice.upsert({
     *   create: {
     *     // ... data to create a TDevice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TDevice we want to update
     *   }
     * })
    **/
    upsert<T extends TDeviceUpsertArgs>(
      args: SelectSubset<T, TDeviceUpsertArgs>
    ): Prisma__TDeviceClient<TDeviceGetPayload<T>>

    /**
     * Find zero or more TDevices that matches the filter.
     * @param {TDeviceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tDevice = await prisma.tDevice.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: TDeviceFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TDevice.
     * @param {TDeviceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tDevice = await prisma.tDevice.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: TDeviceAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of TDevices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TDeviceCountArgs} args - Arguments to filter TDevices to count.
     * @example
     * // Count the number of TDevices
     * const count = await prisma.tDevice.count({
     *   where: {
     *     // ... the filter for the TDevices we want to count
     *   }
     * })
    **/
    count<T extends TDeviceCountArgs>(
      args?: Subset<T, TDeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TDeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TDevice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TDeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TDeviceAggregateArgs>(args: Subset<T, TDeviceAggregateArgs>): Prisma.PrismaPromise<GetTDeviceAggregateType<T>>

    /**
     * Group by TDevice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TDeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TDeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TDeviceGroupByArgs['orderBy'] }
        : { orderBy?: TDeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TDeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TDevice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TDeviceClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    property<T extends TDevicePropsArgs= {}>(args?: Subset<T, TDevicePropsArgs>): Prisma__TDevicePropsClient<TDevicePropsGetPayload<T> | Null>;

    positions<T extends TDevicePosArgs= {}>(args?: Subset<T, TDevicePosArgs>): Prisma.PrismaPromise<Array<TDevicePosGetPayload<T>>| Null>;

    teaching<T extends TeachingArgs= {}>(args?: Subset<T, TeachingArgs>): Prisma__TeachingClient<TeachingGetPayload<T> | Null>;

    year<T extends SchoolYearArgs= {}>(args?: Subset<T, SchoolYearArgs>): Prisma__SchoolYearClient<SchoolYearGetPayload<T> | Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    instansi<T extends InstansiArgs= {}>(args?: Subset<T, InstansiArgs>): Prisma__InstansiClient<InstansiGetPayload<T> | Null>;

    mapel<T extends MataPelajaranArgs= {}>(args?: Subset<T, MataPelajaranArgs>): Prisma__MataPelajaranClient<MataPelajaranGetPayload<T> | Null>;

    classRoom<T extends TDevice$classRoomArgs= {}>(args?: Subset<T, TDevice$classRoomArgs>): Prisma.PrismaPromise<Array<ClassRoomGetPayload<T>>| Null>;

    tracker<T extends TDevice$trackerArgs= {}>(args?: Subset<T, TDevice$trackerArgs>): Prisma.PrismaPromise<Array<TrackerGetPayload<T>>| Null>;

    data<T extends TDevice$dataArgs= {}>(args?: Subset<T, TDevice$dataArgs>): Prisma.PrismaPromise<Array<TDeviceDataGetPayload<T>>| Null>;

    children<T extends TDevice$childrenArgs= {}>(args?: Subset<T, TDevice$childrenArgs>): Prisma.PrismaPromise<Array<TDeviceGetPayload<T>>| Null>;

    parent<T extends TDeviceArgs= {}>(args?: Subset<T, TDeviceArgs>): Prisma__TDeviceClient<TDeviceGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TDevice base type for findUnique actions
   */
  export type TDeviceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TDevice
     */
    select?: TDeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceInclude | null
    /**
     * Filter, which TDevice to fetch.
     */
    where: TDeviceWhereUniqueInput
  }

  /**
   * TDevice findUnique
   */
  export interface TDeviceFindUniqueArgs extends TDeviceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TDevice findUniqueOrThrow
   */
  export type TDeviceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TDevice
     */
    select?: TDeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceInclude | null
    /**
     * Filter, which TDevice to fetch.
     */
    where: TDeviceWhereUniqueInput
  }


  /**
   * TDevice base type for findFirst actions
   */
  export type TDeviceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TDevice
     */
    select?: TDeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceInclude | null
    /**
     * Filter, which TDevice to fetch.
     */
    where?: TDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TDevices to fetch.
     */
    orderBy?: Enumerable<TDeviceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TDevices.
     */
    cursor?: TDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TDevices.
     */
    distinct?: Enumerable<TDeviceScalarFieldEnum>
  }

  /**
   * TDevice findFirst
   */
  export interface TDeviceFindFirstArgs extends TDeviceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TDevice findFirstOrThrow
   */
  export type TDeviceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TDevice
     */
    select?: TDeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceInclude | null
    /**
     * Filter, which TDevice to fetch.
     */
    where?: TDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TDevices to fetch.
     */
    orderBy?: Enumerable<TDeviceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TDevices.
     */
    cursor?: TDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TDevices.
     */
    distinct?: Enumerable<TDeviceScalarFieldEnum>
  }


  /**
   * TDevice findMany
   */
  export type TDeviceFindManyArgs = {
    /**
     * Select specific fields to fetch from the TDevice
     */
    select?: TDeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceInclude | null
    /**
     * Filter, which TDevices to fetch.
     */
    where?: TDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TDevices to fetch.
     */
    orderBy?: Enumerable<TDeviceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TDevices.
     */
    cursor?: TDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TDevices.
     */
    skip?: number
    distinct?: Enumerable<TDeviceScalarFieldEnum>
  }


  /**
   * TDevice create
   */
  export type TDeviceCreateArgs = {
    /**
     * Select specific fields to fetch from the TDevice
     */
    select?: TDeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceInclude | null
    /**
     * The data needed to create a TDevice.
     */
    data: XOR<TDeviceCreateInput, TDeviceUncheckedCreateInput>
  }


  /**
   * TDevice createMany
   */
  export type TDeviceCreateManyArgs = {
    /**
     * The data used to create many TDevices.
     */
    data: Enumerable<TDeviceCreateManyInput>
  }


  /**
   * TDevice update
   */
  export type TDeviceUpdateArgs = {
    /**
     * Select specific fields to fetch from the TDevice
     */
    select?: TDeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceInclude | null
    /**
     * The data needed to update a TDevice.
     */
    data: XOR<TDeviceUpdateInput, TDeviceUncheckedUpdateInput>
    /**
     * Choose, which TDevice to update.
     */
    where: TDeviceWhereUniqueInput
  }


  /**
   * TDevice updateMany
   */
  export type TDeviceUpdateManyArgs = {
    /**
     * The data used to update TDevices.
     */
    data: XOR<TDeviceUpdateManyMutationInput, TDeviceUncheckedUpdateManyInput>
    /**
     * Filter which TDevices to update
     */
    where?: TDeviceWhereInput
  }


  /**
   * TDevice upsert
   */
  export type TDeviceUpsertArgs = {
    /**
     * Select specific fields to fetch from the TDevice
     */
    select?: TDeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceInclude | null
    /**
     * The filter to search for the TDevice to update in case it exists.
     */
    where: TDeviceWhereUniqueInput
    /**
     * In case the TDevice found by the `where` argument doesn't exist, create a new TDevice with this data.
     */
    create: XOR<TDeviceCreateInput, TDeviceUncheckedCreateInput>
    /**
     * In case the TDevice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TDeviceUpdateInput, TDeviceUncheckedUpdateInput>
  }


  /**
   * TDevice delete
   */
  export type TDeviceDeleteArgs = {
    /**
     * Select specific fields to fetch from the TDevice
     */
    select?: TDeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceInclude | null
    /**
     * Filter which TDevice to delete.
     */
    where: TDeviceWhereUniqueInput
  }


  /**
   * TDevice deleteMany
   */
  export type TDeviceDeleteManyArgs = {
    /**
     * Filter which TDevices to delete
     */
    where?: TDeviceWhereInput
  }


  /**
   * TDevice findRaw
   */
  export type TDeviceFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * TDevice aggregateRaw
   */
  export type TDeviceAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * TDevice.classRoom
   */
  export type TDevice$classRoomArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    where?: ClassRoomWhereInput
    orderBy?: Enumerable<ClassRoomOrderByWithRelationInput>
    cursor?: ClassRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ClassRoomScalarFieldEnum>
  }


  /**
   * TDevice.tracker
   */
  export type TDevice$trackerArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    where?: TrackerWhereInput
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    cursor?: TrackerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TrackerScalarFieldEnum>
  }


  /**
   * TDevice.data
   */
  export type TDevice$dataArgs = {
    /**
     * Select specific fields to fetch from the TDeviceData
     */
    select?: TDeviceDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceDataInclude | null
    where?: TDeviceDataWhereInput
    orderBy?: Enumerable<TDeviceDataOrderByWithRelationInput>
    cursor?: TDeviceDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TDeviceDataScalarFieldEnum>
  }


  /**
   * TDevice.children
   */
  export type TDevice$childrenArgs = {
    /**
     * Select specific fields to fetch from the TDevice
     */
    select?: TDeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceInclude | null
    where?: TDeviceWhereInput
    orderBy?: Enumerable<TDeviceOrderByWithRelationInput>
    cursor?: TDeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TDeviceScalarFieldEnum>
  }


  /**
   * TDevice without action
   */
  export type TDeviceArgs = {
    /**
     * Select specific fields to fetch from the TDevice
     */
    select?: TDeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceInclude | null
  }



  /**
   * Model TDeviceData
   */


  export type AggregateTDeviceData = {
    _count: TDeviceDataCountAggregateOutputType | null
    _min: TDeviceDataMinAggregateOutputType | null
    _max: TDeviceDataMaxAggregateOutputType | null
  }

  export type TDeviceDataMinAggregateOutputType = {
    id: string | null
    refId: string | null
    objectiveId: string | null
  }

  export type TDeviceDataMaxAggregateOutputType = {
    id: string | null
    refId: string | null
    objectiveId: string | null
  }

  export type TDeviceDataCountAggregateOutputType = {
    id: number
    refId: number
    objectiveId: number
    _all: number
  }


  export type TDeviceDataMinAggregateInputType = {
    id?: true
    refId?: true
    objectiveId?: true
  }

  export type TDeviceDataMaxAggregateInputType = {
    id?: true
    refId?: true
    objectiveId?: true
  }

  export type TDeviceDataCountAggregateInputType = {
    id?: true
    refId?: true
    objectiveId?: true
    _all?: true
  }

  export type TDeviceDataAggregateArgs = {
    /**
     * Filter which TDeviceData to aggregate.
     */
    where?: TDeviceDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TDeviceData to fetch.
     */
    orderBy?: Enumerable<TDeviceDataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TDeviceDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TDeviceData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TDeviceData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TDeviceData
    **/
    _count?: true | TDeviceDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TDeviceDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TDeviceDataMaxAggregateInputType
  }

  export type GetTDeviceDataAggregateType<T extends TDeviceDataAggregateArgs> = {
        [P in keyof T & keyof AggregateTDeviceData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTDeviceData[P]>
      : GetScalarType<T[P], AggregateTDeviceData[P]>
  }




  export type TDeviceDataGroupByArgs = {
    where?: TDeviceDataWhereInput
    orderBy?: Enumerable<TDeviceDataOrderByWithAggregationInput>
    by: TDeviceDataScalarFieldEnum[]
    having?: TDeviceDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TDeviceDataCountAggregateInputType | true
    _min?: TDeviceDataMinAggregateInputType
    _max?: TDeviceDataMaxAggregateInputType
  }


  export type TDeviceDataGroupByOutputType = {
    id: string
    refId: string
    objectiveId: string
    _count: TDeviceDataCountAggregateOutputType | null
    _min: TDeviceDataMinAggregateOutputType | null
    _max: TDeviceDataMaxAggregateOutputType | null
  }

  type GetTDeviceDataGroupByPayload<T extends TDeviceDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TDeviceDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TDeviceDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TDeviceDataGroupByOutputType[P]>
            : GetScalarType<T[P], TDeviceDataGroupByOutputType[P]>
        }
      >
    >


  export type TDeviceDataSelect = {
    id?: boolean
    refId?: boolean
    objectiveId?: boolean
    positions?: boolean | TDevicePosArgs
    ref?: boolean | TDeviceArgs
    objective?: boolean | ObjectiveArgs
  }


  export type TDeviceDataInclude = {
    ref?: boolean | TDeviceArgs
    objective?: boolean | ObjectiveArgs
  }

  export type TDeviceDataGetPayload<S extends boolean | null | undefined | TDeviceDataArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TDeviceData :
    S extends undefined ? never :
    S extends { include: any } & (TDeviceDataArgs | TDeviceDataFindManyArgs)
    ? TDeviceData  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ref' ? TDeviceGetPayload<S['include'][P]> :
        P extends 'objective' ? ObjectiveGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TDeviceDataArgs | TDeviceDataFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'positions' ? Array < TDevicePosGetPayload<S['select'][P]>>  :
        P extends 'ref' ? TDeviceGetPayload<S['select'][P]> :
        P extends 'objective' ? ObjectiveGetPayload<S['select'][P]> :  P extends keyof TDeviceData ? TDeviceData[P] : never
  } 
      : TDeviceData


  type TDeviceDataCountArgs = 
    Omit<TDeviceDataFindManyArgs, 'select' | 'include'> & {
      select?: TDeviceDataCountAggregateInputType | true
    }

  export interface TDeviceDataDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TDeviceData that matches the filter.
     * @param {TDeviceDataFindUniqueArgs} args - Arguments to find a TDeviceData
     * @example
     * // Get one TDeviceData
     * const tDeviceData = await prisma.tDeviceData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TDeviceDataFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TDeviceDataFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TDeviceData'> extends True ? Prisma__TDeviceDataClient<TDeviceDataGetPayload<T>> : Prisma__TDeviceDataClient<TDeviceDataGetPayload<T> | null, null>

    /**
     * Find one TDeviceData that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TDeviceDataFindUniqueOrThrowArgs} args - Arguments to find a TDeviceData
     * @example
     * // Get one TDeviceData
     * const tDeviceData = await prisma.tDeviceData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TDeviceDataFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TDeviceDataFindUniqueOrThrowArgs>
    ): Prisma__TDeviceDataClient<TDeviceDataGetPayload<T>>

    /**
     * Find the first TDeviceData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TDeviceDataFindFirstArgs} args - Arguments to find a TDeviceData
     * @example
     * // Get one TDeviceData
     * const tDeviceData = await prisma.tDeviceData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TDeviceDataFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TDeviceDataFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TDeviceData'> extends True ? Prisma__TDeviceDataClient<TDeviceDataGetPayload<T>> : Prisma__TDeviceDataClient<TDeviceDataGetPayload<T> | null, null>

    /**
     * Find the first TDeviceData that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TDeviceDataFindFirstOrThrowArgs} args - Arguments to find a TDeviceData
     * @example
     * // Get one TDeviceData
     * const tDeviceData = await prisma.tDeviceData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TDeviceDataFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TDeviceDataFindFirstOrThrowArgs>
    ): Prisma__TDeviceDataClient<TDeviceDataGetPayload<T>>

    /**
     * Find zero or more TDeviceData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TDeviceDataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TDeviceData
     * const tDeviceData = await prisma.tDeviceData.findMany()
     * 
     * // Get first 10 TDeviceData
     * const tDeviceData = await prisma.tDeviceData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tDeviceDataWithIdOnly = await prisma.tDeviceData.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TDeviceDataFindManyArgs>(
      args?: SelectSubset<T, TDeviceDataFindManyArgs>
    ): Prisma.PrismaPromise<Array<TDeviceDataGetPayload<T>>>

    /**
     * Create a TDeviceData.
     * @param {TDeviceDataCreateArgs} args - Arguments to create a TDeviceData.
     * @example
     * // Create one TDeviceData
     * const TDeviceData = await prisma.tDeviceData.create({
     *   data: {
     *     // ... data to create a TDeviceData
     *   }
     * })
     * 
    **/
    create<T extends TDeviceDataCreateArgs>(
      args: SelectSubset<T, TDeviceDataCreateArgs>
    ): Prisma__TDeviceDataClient<TDeviceDataGetPayload<T>>

    /**
     * Create many TDeviceData.
     *     @param {TDeviceDataCreateManyArgs} args - Arguments to create many TDeviceData.
     *     @example
     *     // Create many TDeviceData
     *     const tDeviceData = await prisma.tDeviceData.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TDeviceDataCreateManyArgs>(
      args?: SelectSubset<T, TDeviceDataCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TDeviceData.
     * @param {TDeviceDataDeleteArgs} args - Arguments to delete one TDeviceData.
     * @example
     * // Delete one TDeviceData
     * const TDeviceData = await prisma.tDeviceData.delete({
     *   where: {
     *     // ... filter to delete one TDeviceData
     *   }
     * })
     * 
    **/
    delete<T extends TDeviceDataDeleteArgs>(
      args: SelectSubset<T, TDeviceDataDeleteArgs>
    ): Prisma__TDeviceDataClient<TDeviceDataGetPayload<T>>

    /**
     * Update one TDeviceData.
     * @param {TDeviceDataUpdateArgs} args - Arguments to update one TDeviceData.
     * @example
     * // Update one TDeviceData
     * const tDeviceData = await prisma.tDeviceData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TDeviceDataUpdateArgs>(
      args: SelectSubset<T, TDeviceDataUpdateArgs>
    ): Prisma__TDeviceDataClient<TDeviceDataGetPayload<T>>

    /**
     * Delete zero or more TDeviceData.
     * @param {TDeviceDataDeleteManyArgs} args - Arguments to filter TDeviceData to delete.
     * @example
     * // Delete a few TDeviceData
     * const { count } = await prisma.tDeviceData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TDeviceDataDeleteManyArgs>(
      args?: SelectSubset<T, TDeviceDataDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TDeviceData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TDeviceDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TDeviceData
     * const tDeviceData = await prisma.tDeviceData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TDeviceDataUpdateManyArgs>(
      args: SelectSubset<T, TDeviceDataUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TDeviceData.
     * @param {TDeviceDataUpsertArgs} args - Arguments to update or create a TDeviceData.
     * @example
     * // Update or create a TDeviceData
     * const tDeviceData = await prisma.tDeviceData.upsert({
     *   create: {
     *     // ... data to create a TDeviceData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TDeviceData we want to update
     *   }
     * })
    **/
    upsert<T extends TDeviceDataUpsertArgs>(
      args: SelectSubset<T, TDeviceDataUpsertArgs>
    ): Prisma__TDeviceDataClient<TDeviceDataGetPayload<T>>

    /**
     * Find zero or more TDeviceData that matches the filter.
     * @param {TDeviceDataFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tDeviceData = await prisma.tDeviceData.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: TDeviceDataFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TDeviceData.
     * @param {TDeviceDataAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tDeviceData = await prisma.tDeviceData.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: TDeviceDataAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of TDeviceData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TDeviceDataCountArgs} args - Arguments to filter TDeviceData to count.
     * @example
     * // Count the number of TDeviceData
     * const count = await prisma.tDeviceData.count({
     *   where: {
     *     // ... the filter for the TDeviceData we want to count
     *   }
     * })
    **/
    count<T extends TDeviceDataCountArgs>(
      args?: Subset<T, TDeviceDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TDeviceDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TDeviceData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TDeviceDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TDeviceDataAggregateArgs>(args: Subset<T, TDeviceDataAggregateArgs>): Prisma.PrismaPromise<GetTDeviceDataAggregateType<T>>

    /**
     * Group by TDeviceData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TDeviceDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TDeviceDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TDeviceDataGroupByArgs['orderBy'] }
        : { orderBy?: TDeviceDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TDeviceDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTDeviceDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TDeviceData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TDeviceDataClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    positions<T extends TDevicePosArgs= {}>(args?: Subset<T, TDevicePosArgs>): Prisma.PrismaPromise<Array<TDevicePosGetPayload<T>>| Null>;

    ref<T extends TDeviceArgs= {}>(args?: Subset<T, TDeviceArgs>): Prisma__TDeviceClient<TDeviceGetPayload<T> | Null>;

    objective<T extends ObjectiveArgs= {}>(args?: Subset<T, ObjectiveArgs>): Prisma__ObjectiveClient<ObjectiveGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TDeviceData base type for findUnique actions
   */
  export type TDeviceDataFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TDeviceData
     */
    select?: TDeviceDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceDataInclude | null
    /**
     * Filter, which TDeviceData to fetch.
     */
    where: TDeviceDataWhereUniqueInput
  }

  /**
   * TDeviceData findUnique
   */
  export interface TDeviceDataFindUniqueArgs extends TDeviceDataFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TDeviceData findUniqueOrThrow
   */
  export type TDeviceDataFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TDeviceData
     */
    select?: TDeviceDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceDataInclude | null
    /**
     * Filter, which TDeviceData to fetch.
     */
    where: TDeviceDataWhereUniqueInput
  }


  /**
   * TDeviceData base type for findFirst actions
   */
  export type TDeviceDataFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TDeviceData
     */
    select?: TDeviceDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceDataInclude | null
    /**
     * Filter, which TDeviceData to fetch.
     */
    where?: TDeviceDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TDeviceData to fetch.
     */
    orderBy?: Enumerable<TDeviceDataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TDeviceData.
     */
    cursor?: TDeviceDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TDeviceData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TDeviceData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TDeviceData.
     */
    distinct?: Enumerable<TDeviceDataScalarFieldEnum>
  }

  /**
   * TDeviceData findFirst
   */
  export interface TDeviceDataFindFirstArgs extends TDeviceDataFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TDeviceData findFirstOrThrow
   */
  export type TDeviceDataFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TDeviceData
     */
    select?: TDeviceDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceDataInclude | null
    /**
     * Filter, which TDeviceData to fetch.
     */
    where?: TDeviceDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TDeviceData to fetch.
     */
    orderBy?: Enumerable<TDeviceDataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TDeviceData.
     */
    cursor?: TDeviceDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TDeviceData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TDeviceData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TDeviceData.
     */
    distinct?: Enumerable<TDeviceDataScalarFieldEnum>
  }


  /**
   * TDeviceData findMany
   */
  export type TDeviceDataFindManyArgs = {
    /**
     * Select specific fields to fetch from the TDeviceData
     */
    select?: TDeviceDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceDataInclude | null
    /**
     * Filter, which TDeviceData to fetch.
     */
    where?: TDeviceDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TDeviceData to fetch.
     */
    orderBy?: Enumerable<TDeviceDataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TDeviceData.
     */
    cursor?: TDeviceDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TDeviceData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TDeviceData.
     */
    skip?: number
    distinct?: Enumerable<TDeviceDataScalarFieldEnum>
  }


  /**
   * TDeviceData create
   */
  export type TDeviceDataCreateArgs = {
    /**
     * Select specific fields to fetch from the TDeviceData
     */
    select?: TDeviceDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceDataInclude | null
    /**
     * The data needed to create a TDeviceData.
     */
    data: XOR<TDeviceDataCreateInput, TDeviceDataUncheckedCreateInput>
  }


  /**
   * TDeviceData createMany
   */
  export type TDeviceDataCreateManyArgs = {
    /**
     * The data used to create many TDeviceData.
     */
    data: Enumerable<TDeviceDataCreateManyInput>
  }


  /**
   * TDeviceData update
   */
  export type TDeviceDataUpdateArgs = {
    /**
     * Select specific fields to fetch from the TDeviceData
     */
    select?: TDeviceDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceDataInclude | null
    /**
     * The data needed to update a TDeviceData.
     */
    data: XOR<TDeviceDataUpdateInput, TDeviceDataUncheckedUpdateInput>
    /**
     * Choose, which TDeviceData to update.
     */
    where: TDeviceDataWhereUniqueInput
  }


  /**
   * TDeviceData updateMany
   */
  export type TDeviceDataUpdateManyArgs = {
    /**
     * The data used to update TDeviceData.
     */
    data: XOR<TDeviceDataUpdateManyMutationInput, TDeviceDataUncheckedUpdateManyInput>
    /**
     * Filter which TDeviceData to update
     */
    where?: TDeviceDataWhereInput
  }


  /**
   * TDeviceData upsert
   */
  export type TDeviceDataUpsertArgs = {
    /**
     * Select specific fields to fetch from the TDeviceData
     */
    select?: TDeviceDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceDataInclude | null
    /**
     * The filter to search for the TDeviceData to update in case it exists.
     */
    where: TDeviceDataWhereUniqueInput
    /**
     * In case the TDeviceData found by the `where` argument doesn't exist, create a new TDeviceData with this data.
     */
    create: XOR<TDeviceDataCreateInput, TDeviceDataUncheckedCreateInput>
    /**
     * In case the TDeviceData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TDeviceDataUpdateInput, TDeviceDataUncheckedUpdateInput>
  }


  /**
   * TDeviceData delete
   */
  export type TDeviceDataDeleteArgs = {
    /**
     * Select specific fields to fetch from the TDeviceData
     */
    select?: TDeviceDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceDataInclude | null
    /**
     * Filter which TDeviceData to delete.
     */
    where: TDeviceDataWhereUniqueInput
  }


  /**
   * TDeviceData deleteMany
   */
  export type TDeviceDataDeleteManyArgs = {
    /**
     * Filter which TDeviceData to delete
     */
    where?: TDeviceDataWhereInput
  }


  /**
   * TDeviceData findRaw
   */
  export type TDeviceDataFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * TDeviceData aggregateRaw
   */
  export type TDeviceDataAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * TDeviceData without action
   */
  export type TDeviceDataArgs = {
    /**
     * Select specific fields to fetch from the TDeviceData
     */
    select?: TDeviceDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TDeviceDataInclude | null
  }



  /**
   * Model Calendar
   */


  export type AggregateCalendar = {
    _count: CalendarCountAggregateOutputType | null
    _min: CalendarMinAggregateOutputType | null
    _max: CalendarMaxAggregateOutputType | null
  }

  export type CalendarMinAggregateOutputType = {
    id: string | null
    refId: string | null
    name: string | null
    description: string | null
    start: Date | null
    end: Date | null
    color: string | null
    disable: boolean | null
  }

  export type CalendarMaxAggregateOutputType = {
    id: string | null
    refId: string | null
    name: string | null
    description: string | null
    start: Date | null
    end: Date | null
    color: string | null
    disable: boolean | null
  }

  export type CalendarCountAggregateOutputType = {
    id: number
    refId: number
    name: number
    description: number
    start: number
    end: number
    color: number
    classRoomIds: number
    studentIds: number
    teacherIds: number
    disable: number
    _all: number
  }


  export type CalendarMinAggregateInputType = {
    id?: true
    refId?: true
    name?: true
    description?: true
    start?: true
    end?: true
    color?: true
    disable?: true
  }

  export type CalendarMaxAggregateInputType = {
    id?: true
    refId?: true
    name?: true
    description?: true
    start?: true
    end?: true
    color?: true
    disable?: true
  }

  export type CalendarCountAggregateInputType = {
    id?: true
    refId?: true
    name?: true
    description?: true
    start?: true
    end?: true
    color?: true
    classRoomIds?: true
    studentIds?: true
    teacherIds?: true
    disable?: true
    _all?: true
  }

  export type CalendarAggregateArgs = {
    /**
     * Filter which Calendar to aggregate.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: Enumerable<CalendarOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Calendars
    **/
    _count?: true | CalendarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarMaxAggregateInputType
  }

  export type GetCalendarAggregateType<T extends CalendarAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendar[P]>
      : GetScalarType<T[P], AggregateCalendar[P]>
  }




  export type CalendarGroupByArgs = {
    where?: CalendarWhereInput
    orderBy?: Enumerable<CalendarOrderByWithAggregationInput>
    by: CalendarScalarFieldEnum[]
    having?: CalendarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarCountAggregateInputType | true
    _min?: CalendarMinAggregateInputType
    _max?: CalendarMaxAggregateInputType
  }


  export type CalendarGroupByOutputType = {
    id: string
    refId: string
    name: string
    description: string | null
    start: Date
    end: Date | null
    color: string
    classRoomIds: string[]
    studentIds: string[]
    teacherIds: string[]
    disable: boolean
    _count: CalendarCountAggregateOutputType | null
    _min: CalendarMinAggregateOutputType | null
    _max: CalendarMaxAggregateOutputType | null
  }

  type GetCalendarGroupByPayload<T extends CalendarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CalendarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarGroupByOutputType[P]>
        }
      >
    >


  export type CalendarSelect = {
    id?: boolean
    refId?: boolean
    name?: boolean
    description?: boolean
    start?: boolean
    end?: boolean
    color?: boolean
    classRoomIds?: boolean
    studentIds?: boolean
    teacherIds?: boolean
    disable?: boolean
    ref?: boolean | SchoolYearArgs
    classRoom?: boolean | Calendar$classRoomArgs
    student?: boolean | Calendar$studentArgs
    teacher?: boolean | Calendar$teacherArgs
    tracker?: boolean | Calendar$trackerArgs
    _count?: boolean | CalendarCountOutputTypeArgs
  }


  export type CalendarInclude = {
    ref?: boolean | SchoolYearArgs
    classRoom?: boolean | Calendar$classRoomArgs
    student?: boolean | Calendar$studentArgs
    teacher?: boolean | Calendar$teacherArgs
    tracker?: boolean | Calendar$trackerArgs
    _count?: boolean | CalendarCountOutputTypeArgs
  }

  export type CalendarGetPayload<S extends boolean | null | undefined | CalendarArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Calendar :
    S extends undefined ? never :
    S extends { include: any } & (CalendarArgs | CalendarFindManyArgs)
    ? Calendar  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ref' ? SchoolYearGetPayload<S['include'][P]> :
        P extends 'classRoom' ? Array < ClassRoomGetPayload<S['include'][P]>>  :
        P extends 'student' ? Array < StudentGetPayload<S['include'][P]>>  :
        P extends 'teacher' ? Array < TeacherGetPayload<S['include'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['include'][P]>>  :
        P extends '_count' ? CalendarCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CalendarArgs | CalendarFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ref' ? SchoolYearGetPayload<S['select'][P]> :
        P extends 'classRoom' ? Array < ClassRoomGetPayload<S['select'][P]>>  :
        P extends 'student' ? Array < StudentGetPayload<S['select'][P]>>  :
        P extends 'teacher' ? Array < TeacherGetPayload<S['select'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['select'][P]>>  :
        P extends '_count' ? CalendarCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Calendar ? Calendar[P] : never
  } 
      : Calendar


  type CalendarCountArgs = 
    Omit<CalendarFindManyArgs, 'select' | 'include'> & {
      select?: CalendarCountAggregateInputType | true
    }

  export interface CalendarDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Calendar that matches the filter.
     * @param {CalendarFindUniqueArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CalendarFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CalendarFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Calendar'> extends True ? Prisma__CalendarClient<CalendarGetPayload<T>> : Prisma__CalendarClient<CalendarGetPayload<T> | null, null>

    /**
     * Find one Calendar that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CalendarFindUniqueOrThrowArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CalendarFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CalendarFindUniqueOrThrowArgs>
    ): Prisma__CalendarClient<CalendarGetPayload<T>>

    /**
     * Find the first Calendar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFindFirstArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CalendarFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CalendarFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Calendar'> extends True ? Prisma__CalendarClient<CalendarGetPayload<T>> : Prisma__CalendarClient<CalendarGetPayload<T> | null, null>

    /**
     * Find the first Calendar that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFindFirstOrThrowArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CalendarFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CalendarFindFirstOrThrowArgs>
    ): Prisma__CalendarClient<CalendarGetPayload<T>>

    /**
     * Find zero or more Calendars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Calendars
     * const calendars = await prisma.calendar.findMany()
     * 
     * // Get first 10 Calendars
     * const calendars = await prisma.calendar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarWithIdOnly = await prisma.calendar.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CalendarFindManyArgs>(
      args?: SelectSubset<T, CalendarFindManyArgs>
    ): Prisma.PrismaPromise<Array<CalendarGetPayload<T>>>

    /**
     * Create a Calendar.
     * @param {CalendarCreateArgs} args - Arguments to create a Calendar.
     * @example
     * // Create one Calendar
     * const Calendar = await prisma.calendar.create({
     *   data: {
     *     // ... data to create a Calendar
     *   }
     * })
     * 
    **/
    create<T extends CalendarCreateArgs>(
      args: SelectSubset<T, CalendarCreateArgs>
    ): Prisma__CalendarClient<CalendarGetPayload<T>>

    /**
     * Create many Calendars.
     *     @param {CalendarCreateManyArgs} args - Arguments to create many Calendars.
     *     @example
     *     // Create many Calendars
     *     const calendar = await prisma.calendar.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CalendarCreateManyArgs>(
      args?: SelectSubset<T, CalendarCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Calendar.
     * @param {CalendarDeleteArgs} args - Arguments to delete one Calendar.
     * @example
     * // Delete one Calendar
     * const Calendar = await prisma.calendar.delete({
     *   where: {
     *     // ... filter to delete one Calendar
     *   }
     * })
     * 
    **/
    delete<T extends CalendarDeleteArgs>(
      args: SelectSubset<T, CalendarDeleteArgs>
    ): Prisma__CalendarClient<CalendarGetPayload<T>>

    /**
     * Update one Calendar.
     * @param {CalendarUpdateArgs} args - Arguments to update one Calendar.
     * @example
     * // Update one Calendar
     * const calendar = await prisma.calendar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CalendarUpdateArgs>(
      args: SelectSubset<T, CalendarUpdateArgs>
    ): Prisma__CalendarClient<CalendarGetPayload<T>>

    /**
     * Delete zero or more Calendars.
     * @param {CalendarDeleteManyArgs} args - Arguments to filter Calendars to delete.
     * @example
     * // Delete a few Calendars
     * const { count } = await prisma.calendar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CalendarDeleteManyArgs>(
      args?: SelectSubset<T, CalendarDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Calendars
     * const calendar = await prisma.calendar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CalendarUpdateManyArgs>(
      args: SelectSubset<T, CalendarUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Calendar.
     * @param {CalendarUpsertArgs} args - Arguments to update or create a Calendar.
     * @example
     * // Update or create a Calendar
     * const calendar = await prisma.calendar.upsert({
     *   create: {
     *     // ... data to create a Calendar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Calendar we want to update
     *   }
     * })
    **/
    upsert<T extends CalendarUpsertArgs>(
      args: SelectSubset<T, CalendarUpsertArgs>
    ): Prisma__CalendarClient<CalendarGetPayload<T>>

    /**
     * Find zero or more Calendars that matches the filter.
     * @param {CalendarFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const calendar = await prisma.calendar.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: CalendarFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Calendar.
     * @param {CalendarAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const calendar = await prisma.calendar.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: CalendarAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Calendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarCountArgs} args - Arguments to filter Calendars to count.
     * @example
     * // Count the number of Calendars
     * const count = await prisma.calendar.count({
     *   where: {
     *     // ... the filter for the Calendars we want to count
     *   }
     * })
    **/
    count<T extends CalendarCountArgs>(
      args?: Subset<T, CalendarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Calendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarAggregateArgs>(args: Subset<T, CalendarAggregateArgs>): Prisma.PrismaPromise<GetCalendarAggregateType<T>>

    /**
     * Group by Calendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarGroupByArgs['orderBy'] }
        : { orderBy?: CalendarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Calendar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CalendarClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ref<T extends SchoolYearArgs= {}>(args?: Subset<T, SchoolYearArgs>): Prisma__SchoolYearClient<SchoolYearGetPayload<T> | Null>;

    classRoom<T extends Calendar$classRoomArgs= {}>(args?: Subset<T, Calendar$classRoomArgs>): Prisma.PrismaPromise<Array<ClassRoomGetPayload<T>>| Null>;

    student<T extends Calendar$studentArgs= {}>(args?: Subset<T, Calendar$studentArgs>): Prisma.PrismaPromise<Array<StudentGetPayload<T>>| Null>;

    teacher<T extends Calendar$teacherArgs= {}>(args?: Subset<T, Calendar$teacherArgs>): Prisma.PrismaPromise<Array<TeacherGetPayload<T>>| Null>;

    tracker<T extends Calendar$trackerArgs= {}>(args?: Subset<T, Calendar$trackerArgs>): Prisma.PrismaPromise<Array<TrackerGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Calendar base type for findUnique actions
   */
  export type CalendarFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    /**
     * Filter, which Calendar to fetch.
     */
    where: CalendarWhereUniqueInput
  }

  /**
   * Calendar findUnique
   */
  export interface CalendarFindUniqueArgs extends CalendarFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Calendar findUniqueOrThrow
   */
  export type CalendarFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    /**
     * Filter, which Calendar to fetch.
     */
    where: CalendarWhereUniqueInput
  }


  /**
   * Calendar base type for findFirst actions
   */
  export type CalendarFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    /**
     * Filter, which Calendar to fetch.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: Enumerable<CalendarOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Calendars.
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Calendars.
     */
    distinct?: Enumerable<CalendarScalarFieldEnum>
  }

  /**
   * Calendar findFirst
   */
  export interface CalendarFindFirstArgs extends CalendarFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Calendar findFirstOrThrow
   */
  export type CalendarFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    /**
     * Filter, which Calendar to fetch.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: Enumerable<CalendarOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Calendars.
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Calendars.
     */
    distinct?: Enumerable<CalendarScalarFieldEnum>
  }


  /**
   * Calendar findMany
   */
  export type CalendarFindManyArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    /**
     * Filter, which Calendars to fetch.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: Enumerable<CalendarOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Calendars.
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    distinct?: Enumerable<CalendarScalarFieldEnum>
  }


  /**
   * Calendar create
   */
  export type CalendarCreateArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    /**
     * The data needed to create a Calendar.
     */
    data: XOR<CalendarCreateInput, CalendarUncheckedCreateInput>
  }


  /**
   * Calendar createMany
   */
  export type CalendarCreateManyArgs = {
    /**
     * The data used to create many Calendars.
     */
    data: Enumerable<CalendarCreateManyInput>
  }


  /**
   * Calendar update
   */
  export type CalendarUpdateArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    /**
     * The data needed to update a Calendar.
     */
    data: XOR<CalendarUpdateInput, CalendarUncheckedUpdateInput>
    /**
     * Choose, which Calendar to update.
     */
    where: CalendarWhereUniqueInput
  }


  /**
   * Calendar updateMany
   */
  export type CalendarUpdateManyArgs = {
    /**
     * The data used to update Calendars.
     */
    data: XOR<CalendarUpdateManyMutationInput, CalendarUncheckedUpdateManyInput>
    /**
     * Filter which Calendars to update
     */
    where?: CalendarWhereInput
  }


  /**
   * Calendar upsert
   */
  export type CalendarUpsertArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    /**
     * The filter to search for the Calendar to update in case it exists.
     */
    where: CalendarWhereUniqueInput
    /**
     * In case the Calendar found by the `where` argument doesn't exist, create a new Calendar with this data.
     */
    create: XOR<CalendarCreateInput, CalendarUncheckedCreateInput>
    /**
     * In case the Calendar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarUpdateInput, CalendarUncheckedUpdateInput>
  }


  /**
   * Calendar delete
   */
  export type CalendarDeleteArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
    /**
     * Filter which Calendar to delete.
     */
    where: CalendarWhereUniqueInput
  }


  /**
   * Calendar deleteMany
   */
  export type CalendarDeleteManyArgs = {
    /**
     * Filter which Calendars to delete
     */
    where?: CalendarWhereInput
  }


  /**
   * Calendar findRaw
   */
  export type CalendarFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Calendar aggregateRaw
   */
  export type CalendarAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Calendar.classRoom
   */
  export type Calendar$classRoomArgs = {
    /**
     * Select specific fields to fetch from the ClassRoom
     */
    select?: ClassRoomSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClassRoomInclude | null
    where?: ClassRoomWhereInput
    orderBy?: Enumerable<ClassRoomOrderByWithRelationInput>
    cursor?: ClassRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ClassRoomScalarFieldEnum>
  }


  /**
   * Calendar.student
   */
  export type Calendar$studentArgs = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude | null
    where?: StudentWhereInput
    orderBy?: Enumerable<StudentOrderByWithRelationInput>
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StudentScalarFieldEnum>
  }


  /**
   * Calendar.teacher
   */
  export type Calendar$teacherArgs = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherInclude | null
    where?: TeacherWhereInput
    orderBy?: Enumerable<TeacherOrderByWithRelationInput>
    cursor?: TeacherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeacherScalarFieldEnum>
  }


  /**
   * Calendar.tracker
   */
  export type Calendar$trackerArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    where?: TrackerWhereInput
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    cursor?: TrackerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TrackerScalarFieldEnum>
  }


  /**
   * Calendar without action
   */
  export type CalendarArgs = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CalendarInclude | null
  }



  /**
   * Model Dudi
   */


  export type AggregateDudi = {
    _count: DudiCountAggregateOutputType | null
    _min: DudiMinAggregateOutputType | null
    _max: DudiMaxAggregateOutputType | null
  }

  export type DudiMinAggregateOutputType = {
    id: string | null
    name: string | null
    street: string | null
    instansiId: string | null
    majorId: string | null
    disable: boolean | null
    kkniId: string | null
  }

  export type DudiMaxAggregateOutputType = {
    id: string | null
    name: string | null
    street: string | null
    instansiId: string | null
    majorId: string | null
    disable: boolean | null
    kkniId: string | null
  }

  export type DudiCountAggregateOutputType = {
    id: number
    name: number
    street: number
    instansiId: number
    majorId: number
    collabs: number
    disable: number
    kkniId: number
    _all: number
  }


  export type DudiMinAggregateInputType = {
    id?: true
    name?: true
    street?: true
    instansiId?: true
    majorId?: true
    disable?: true
    kkniId?: true
  }

  export type DudiMaxAggregateInputType = {
    id?: true
    name?: true
    street?: true
    instansiId?: true
    majorId?: true
    disable?: true
    kkniId?: true
  }

  export type DudiCountAggregateInputType = {
    id?: true
    name?: true
    street?: true
    instansiId?: true
    majorId?: true
    collabs?: true
    disable?: true
    kkniId?: true
    _all?: true
  }

  export type DudiAggregateArgs = {
    /**
     * Filter which Dudi to aggregate.
     */
    where?: DudiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dudis to fetch.
     */
    orderBy?: Enumerable<DudiOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DudiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dudis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dudis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dudis
    **/
    _count?: true | DudiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DudiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DudiMaxAggregateInputType
  }

  export type GetDudiAggregateType<T extends DudiAggregateArgs> = {
        [P in keyof T & keyof AggregateDudi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDudi[P]>
      : GetScalarType<T[P], AggregateDudi[P]>
  }




  export type DudiGroupByArgs = {
    where?: DudiWhereInput
    orderBy?: Enumerable<DudiOrderByWithAggregationInput>
    by: DudiScalarFieldEnum[]
    having?: DudiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DudiCountAggregateInputType | true
    _min?: DudiMinAggregateInputType
    _max?: DudiMaxAggregateInputType
  }


  export type DudiGroupByOutputType = {
    id: string
    name: string
    street: string
    instansiId: string
    majorId: string
    collabs: string[]
    disable: boolean
    kkniId: string | null
    _count: DudiCountAggregateOutputType | null
    _min: DudiMinAggregateOutputType | null
    _max: DudiMaxAggregateOutputType | null
  }

  type GetDudiGroupByPayload<T extends DudiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DudiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DudiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DudiGroupByOutputType[P]>
            : GetScalarType<T[P], DudiGroupByOutputType[P]>
        }
      >
    >


  export type DudiSelect = {
    id?: boolean
    name?: boolean
    street?: boolean
    address?: boolean | AddressArgs
    instansiId?: boolean
    majorId?: boolean
    contact?: boolean | ContactDudiArgs
    collabs?: boolean
    timework?: boolean | DudiTimeWorkArgs
    disable?: boolean
    kkniId?: boolean
    instansi?: boolean | InstansiArgs
    major?: boolean | KonsentrasiKeahlianArgs
    learning?: boolean | Dudi$learningArgs
    tracker?: boolean | Dudi$trackerArgs
    kkni?: boolean | KkniArgs
    _count?: boolean | DudiCountOutputTypeArgs
  }


  export type DudiInclude = {
    instansi?: boolean | InstansiArgs
    major?: boolean | KonsentrasiKeahlianArgs
    learning?: boolean | Dudi$learningArgs
    tracker?: boolean | Dudi$trackerArgs
    kkni?: boolean | KkniArgs
    _count?: boolean | DudiCountOutputTypeArgs
  }

  export type DudiGetPayload<S extends boolean | null | undefined | DudiArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Dudi :
    S extends undefined ? never :
    S extends { include: any } & (DudiArgs | DudiFindManyArgs)
    ? Dudi  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'instansi' ? InstansiGetPayload<S['include'][P]> :
        P extends 'major' ? KonsentrasiKeahlianGetPayload<S['include'][P]> :
        P extends 'learning' ? Array < DudiLearningGetPayload<S['include'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['include'][P]>>  :
        P extends 'kkni' ? KkniGetPayload<S['include'][P]> | null :
        P extends '_count' ? DudiCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DudiArgs | DudiFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'address' ? AddressGetPayload<S['select'][P]> :
        P extends 'contact' ? ContactDudiGetPayload<S['select'][P]> :
        P extends 'timework' ? DudiTimeWorkGetPayload<S['select'][P]> :
        P extends 'instansi' ? InstansiGetPayload<S['select'][P]> :
        P extends 'major' ? KonsentrasiKeahlianGetPayload<S['select'][P]> :
        P extends 'learning' ? Array < DudiLearningGetPayload<S['select'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['select'][P]>>  :
        P extends 'kkni' ? KkniGetPayload<S['select'][P]> | null :
        P extends '_count' ? DudiCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Dudi ? Dudi[P] : never
  } 
      : Dudi


  type DudiCountArgs = 
    Omit<DudiFindManyArgs, 'select' | 'include'> & {
      select?: DudiCountAggregateInputType | true
    }

  export interface DudiDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Dudi that matches the filter.
     * @param {DudiFindUniqueArgs} args - Arguments to find a Dudi
     * @example
     * // Get one Dudi
     * const dudi = await prisma.dudi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DudiFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DudiFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Dudi'> extends True ? Prisma__DudiClient<DudiGetPayload<T>> : Prisma__DudiClient<DudiGetPayload<T> | null, null>

    /**
     * Find one Dudi that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DudiFindUniqueOrThrowArgs} args - Arguments to find a Dudi
     * @example
     * // Get one Dudi
     * const dudi = await prisma.dudi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DudiFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DudiFindUniqueOrThrowArgs>
    ): Prisma__DudiClient<DudiGetPayload<T>>

    /**
     * Find the first Dudi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DudiFindFirstArgs} args - Arguments to find a Dudi
     * @example
     * // Get one Dudi
     * const dudi = await prisma.dudi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DudiFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DudiFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Dudi'> extends True ? Prisma__DudiClient<DudiGetPayload<T>> : Prisma__DudiClient<DudiGetPayload<T> | null, null>

    /**
     * Find the first Dudi that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DudiFindFirstOrThrowArgs} args - Arguments to find a Dudi
     * @example
     * // Get one Dudi
     * const dudi = await prisma.dudi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DudiFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DudiFindFirstOrThrowArgs>
    ): Prisma__DudiClient<DudiGetPayload<T>>

    /**
     * Find zero or more Dudis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DudiFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dudis
     * const dudis = await prisma.dudi.findMany()
     * 
     * // Get first 10 Dudis
     * const dudis = await prisma.dudi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dudiWithIdOnly = await prisma.dudi.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DudiFindManyArgs>(
      args?: SelectSubset<T, DudiFindManyArgs>
    ): Prisma.PrismaPromise<Array<DudiGetPayload<T>>>

    /**
     * Create a Dudi.
     * @param {DudiCreateArgs} args - Arguments to create a Dudi.
     * @example
     * // Create one Dudi
     * const Dudi = await prisma.dudi.create({
     *   data: {
     *     // ... data to create a Dudi
     *   }
     * })
     * 
    **/
    create<T extends DudiCreateArgs>(
      args: SelectSubset<T, DudiCreateArgs>
    ): Prisma__DudiClient<DudiGetPayload<T>>

    /**
     * Create many Dudis.
     *     @param {DudiCreateManyArgs} args - Arguments to create many Dudis.
     *     @example
     *     // Create many Dudis
     *     const dudi = await prisma.dudi.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DudiCreateManyArgs>(
      args?: SelectSubset<T, DudiCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Dudi.
     * @param {DudiDeleteArgs} args - Arguments to delete one Dudi.
     * @example
     * // Delete one Dudi
     * const Dudi = await prisma.dudi.delete({
     *   where: {
     *     // ... filter to delete one Dudi
     *   }
     * })
     * 
    **/
    delete<T extends DudiDeleteArgs>(
      args: SelectSubset<T, DudiDeleteArgs>
    ): Prisma__DudiClient<DudiGetPayload<T>>

    /**
     * Update one Dudi.
     * @param {DudiUpdateArgs} args - Arguments to update one Dudi.
     * @example
     * // Update one Dudi
     * const dudi = await prisma.dudi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DudiUpdateArgs>(
      args: SelectSubset<T, DudiUpdateArgs>
    ): Prisma__DudiClient<DudiGetPayload<T>>

    /**
     * Delete zero or more Dudis.
     * @param {DudiDeleteManyArgs} args - Arguments to filter Dudis to delete.
     * @example
     * // Delete a few Dudis
     * const { count } = await prisma.dudi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DudiDeleteManyArgs>(
      args?: SelectSubset<T, DudiDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dudis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DudiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dudis
     * const dudi = await prisma.dudi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DudiUpdateManyArgs>(
      args: SelectSubset<T, DudiUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dudi.
     * @param {DudiUpsertArgs} args - Arguments to update or create a Dudi.
     * @example
     * // Update or create a Dudi
     * const dudi = await prisma.dudi.upsert({
     *   create: {
     *     // ... data to create a Dudi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dudi we want to update
     *   }
     * })
    **/
    upsert<T extends DudiUpsertArgs>(
      args: SelectSubset<T, DudiUpsertArgs>
    ): Prisma__DudiClient<DudiGetPayload<T>>

    /**
     * Find zero or more Dudis that matches the filter.
     * @param {DudiFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dudi = await prisma.dudi.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: DudiFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Dudi.
     * @param {DudiAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dudi = await prisma.dudi.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: DudiAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Dudis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DudiCountArgs} args - Arguments to filter Dudis to count.
     * @example
     * // Count the number of Dudis
     * const count = await prisma.dudi.count({
     *   where: {
     *     // ... the filter for the Dudis we want to count
     *   }
     * })
    **/
    count<T extends DudiCountArgs>(
      args?: Subset<T, DudiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DudiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dudi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DudiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DudiAggregateArgs>(args: Subset<T, DudiAggregateArgs>): Prisma.PrismaPromise<GetDudiAggregateType<T>>

    /**
     * Group by Dudi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DudiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DudiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DudiGroupByArgs['orderBy'] }
        : { orderBy?: DudiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DudiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDudiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Dudi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DudiClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    address<T extends AddressArgs= {}>(args?: Subset<T, AddressArgs>): Prisma__AddressClient<AddressGetPayload<T> | Null>;

    contact<T extends ContactDudiArgs= {}>(args?: Subset<T, ContactDudiArgs>): Prisma__ContactDudiClient<ContactDudiGetPayload<T> | Null>;

    timework<T extends DudiTimeWorkArgs= {}>(args?: Subset<T, DudiTimeWorkArgs>): Prisma__DudiTimeWorkClient<DudiTimeWorkGetPayload<T> | Null>;

    instansi<T extends InstansiArgs= {}>(args?: Subset<T, InstansiArgs>): Prisma__InstansiClient<InstansiGetPayload<T> | Null>;

    major<T extends KonsentrasiKeahlianArgs= {}>(args?: Subset<T, KonsentrasiKeahlianArgs>): Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T> | Null>;

    learning<T extends Dudi$learningArgs= {}>(args?: Subset<T, Dudi$learningArgs>): Prisma.PrismaPromise<Array<DudiLearningGetPayload<T>>| Null>;

    tracker<T extends Dudi$trackerArgs= {}>(args?: Subset<T, Dudi$trackerArgs>): Prisma.PrismaPromise<Array<TrackerGetPayload<T>>| Null>;

    kkni<T extends KkniArgs= {}>(args?: Subset<T, KkniArgs>): Prisma__KkniClient<KkniGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Dudi base type for findUnique actions
   */
  export type DudiFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Dudi
     */
    select?: DudiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiInclude | null
    /**
     * Filter, which Dudi to fetch.
     */
    where: DudiWhereUniqueInput
  }

  /**
   * Dudi findUnique
   */
  export interface DudiFindUniqueArgs extends DudiFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Dudi findUniqueOrThrow
   */
  export type DudiFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Dudi
     */
    select?: DudiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiInclude | null
    /**
     * Filter, which Dudi to fetch.
     */
    where: DudiWhereUniqueInput
  }


  /**
   * Dudi base type for findFirst actions
   */
  export type DudiFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Dudi
     */
    select?: DudiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiInclude | null
    /**
     * Filter, which Dudi to fetch.
     */
    where?: DudiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dudis to fetch.
     */
    orderBy?: Enumerable<DudiOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dudis.
     */
    cursor?: DudiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dudis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dudis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dudis.
     */
    distinct?: Enumerable<DudiScalarFieldEnum>
  }

  /**
   * Dudi findFirst
   */
  export interface DudiFindFirstArgs extends DudiFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Dudi findFirstOrThrow
   */
  export type DudiFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Dudi
     */
    select?: DudiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiInclude | null
    /**
     * Filter, which Dudi to fetch.
     */
    where?: DudiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dudis to fetch.
     */
    orderBy?: Enumerable<DudiOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dudis.
     */
    cursor?: DudiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dudis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dudis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dudis.
     */
    distinct?: Enumerable<DudiScalarFieldEnum>
  }


  /**
   * Dudi findMany
   */
  export type DudiFindManyArgs = {
    /**
     * Select specific fields to fetch from the Dudi
     */
    select?: DudiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiInclude | null
    /**
     * Filter, which Dudis to fetch.
     */
    where?: DudiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dudis to fetch.
     */
    orderBy?: Enumerable<DudiOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dudis.
     */
    cursor?: DudiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dudis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dudis.
     */
    skip?: number
    distinct?: Enumerable<DudiScalarFieldEnum>
  }


  /**
   * Dudi create
   */
  export type DudiCreateArgs = {
    /**
     * Select specific fields to fetch from the Dudi
     */
    select?: DudiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiInclude | null
    /**
     * The data needed to create a Dudi.
     */
    data: XOR<DudiCreateInput, DudiUncheckedCreateInput>
  }


  /**
   * Dudi createMany
   */
  export type DudiCreateManyArgs = {
    /**
     * The data used to create many Dudis.
     */
    data: Enumerable<DudiCreateManyInput>
  }


  /**
   * Dudi update
   */
  export type DudiUpdateArgs = {
    /**
     * Select specific fields to fetch from the Dudi
     */
    select?: DudiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiInclude | null
    /**
     * The data needed to update a Dudi.
     */
    data: XOR<DudiUpdateInput, DudiUncheckedUpdateInput>
    /**
     * Choose, which Dudi to update.
     */
    where: DudiWhereUniqueInput
  }


  /**
   * Dudi updateMany
   */
  export type DudiUpdateManyArgs = {
    /**
     * The data used to update Dudis.
     */
    data: XOR<DudiUpdateManyMutationInput, DudiUncheckedUpdateManyInput>
    /**
     * Filter which Dudis to update
     */
    where?: DudiWhereInput
  }


  /**
   * Dudi upsert
   */
  export type DudiUpsertArgs = {
    /**
     * Select specific fields to fetch from the Dudi
     */
    select?: DudiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiInclude | null
    /**
     * The filter to search for the Dudi to update in case it exists.
     */
    where: DudiWhereUniqueInput
    /**
     * In case the Dudi found by the `where` argument doesn't exist, create a new Dudi with this data.
     */
    create: XOR<DudiCreateInput, DudiUncheckedCreateInput>
    /**
     * In case the Dudi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DudiUpdateInput, DudiUncheckedUpdateInput>
  }


  /**
   * Dudi delete
   */
  export type DudiDeleteArgs = {
    /**
     * Select specific fields to fetch from the Dudi
     */
    select?: DudiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiInclude | null
    /**
     * Filter which Dudi to delete.
     */
    where: DudiWhereUniqueInput
  }


  /**
   * Dudi deleteMany
   */
  export type DudiDeleteManyArgs = {
    /**
     * Filter which Dudis to delete
     */
    where?: DudiWhereInput
  }


  /**
   * Dudi findRaw
   */
  export type DudiFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Dudi aggregateRaw
   */
  export type DudiAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Dudi.learning
   */
  export type Dudi$learningArgs = {
    /**
     * Select specific fields to fetch from the DudiLearning
     */
    select?: DudiLearningSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiLearningInclude | null
    where?: DudiLearningWhereInput
    orderBy?: Enumerable<DudiLearningOrderByWithRelationInput>
    cursor?: DudiLearningWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DudiLearningScalarFieldEnum>
  }


  /**
   * Dudi.tracker
   */
  export type Dudi$trackerArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    where?: TrackerWhereInput
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    cursor?: TrackerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TrackerScalarFieldEnum>
  }


  /**
   * Dudi without action
   */
  export type DudiArgs = {
    /**
     * Select specific fields to fetch from the Dudi
     */
    select?: DudiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiInclude | null
  }



  /**
   * Model DudiLearning
   */


  export type AggregateDudiLearning = {
    _count: DudiLearningCountAggregateOutputType | null
    _avg: DudiLearningAvgAggregateOutputType | null
    _sum: DudiLearningSumAggregateOutputType | null
    _min: DudiLearningMinAggregateOutputType | null
    _max: DudiLearningMaxAggregateOutputType | null
  }

  export type DudiLearningAvgAggregateOutputType = {
    no: number | null
  }

  export type DudiLearningSumAggregateOutputType = {
    no: number | null
  }

  export type DudiLearningMinAggregateOutputType = {
    id: string | null
    no: number | null
    refId: string | null
    code: string | null
    name: string | null
  }

  export type DudiLearningMaxAggregateOutputType = {
    id: string | null
    no: number | null
    refId: string | null
    code: string | null
    name: string | null
  }

  export type DudiLearningCountAggregateOutputType = {
    id: number
    no: number
    refId: number
    code: number
    name: number
    _all: number
  }


  export type DudiLearningAvgAggregateInputType = {
    no?: true
  }

  export type DudiLearningSumAggregateInputType = {
    no?: true
  }

  export type DudiLearningMinAggregateInputType = {
    id?: true
    no?: true
    refId?: true
    code?: true
    name?: true
  }

  export type DudiLearningMaxAggregateInputType = {
    id?: true
    no?: true
    refId?: true
    code?: true
    name?: true
  }

  export type DudiLearningCountAggregateInputType = {
    id?: true
    no?: true
    refId?: true
    code?: true
    name?: true
    _all?: true
  }

  export type DudiLearningAggregateArgs = {
    /**
     * Filter which DudiLearning to aggregate.
     */
    where?: DudiLearningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DudiLearnings to fetch.
     */
    orderBy?: Enumerable<DudiLearningOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DudiLearningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DudiLearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DudiLearnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DudiLearnings
    **/
    _count?: true | DudiLearningCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DudiLearningAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DudiLearningSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DudiLearningMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DudiLearningMaxAggregateInputType
  }

  export type GetDudiLearningAggregateType<T extends DudiLearningAggregateArgs> = {
        [P in keyof T & keyof AggregateDudiLearning]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDudiLearning[P]>
      : GetScalarType<T[P], AggregateDudiLearning[P]>
  }




  export type DudiLearningGroupByArgs = {
    where?: DudiLearningWhereInput
    orderBy?: Enumerable<DudiLearningOrderByWithAggregationInput>
    by: DudiLearningScalarFieldEnum[]
    having?: DudiLearningScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DudiLearningCountAggregateInputType | true
    _avg?: DudiLearningAvgAggregateInputType
    _sum?: DudiLearningSumAggregateInputType
    _min?: DudiLearningMinAggregateInputType
    _max?: DudiLearningMaxAggregateInputType
  }


  export type DudiLearningGroupByOutputType = {
    id: string
    no: number
    refId: string
    code: string
    name: string
    _count: DudiLearningCountAggregateOutputType | null
    _avg: DudiLearningAvgAggregateOutputType | null
    _sum: DudiLearningSumAggregateOutputType | null
    _min: DudiLearningMinAggregateOutputType | null
    _max: DudiLearningMaxAggregateOutputType | null
  }

  type GetDudiLearningGroupByPayload<T extends DudiLearningGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DudiLearningGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DudiLearningGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DudiLearningGroupByOutputType[P]>
            : GetScalarType<T[P], DudiLearningGroupByOutputType[P]>
        }
      >
    >


  export type DudiLearningSelect = {
    id?: boolean
    no?: boolean
    refId?: boolean
    code?: boolean
    name?: boolean
    indicator?: boolean | DudiIndicatorArgs
    ref?: boolean | DudiArgs
  }


  export type DudiLearningInclude = {
    ref?: boolean | DudiArgs
  }

  export type DudiLearningGetPayload<S extends boolean | null | undefined | DudiLearningArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DudiLearning :
    S extends undefined ? never :
    S extends { include: any } & (DudiLearningArgs | DudiLearningFindManyArgs)
    ? DudiLearning  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ref' ? DudiGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DudiLearningArgs | DudiLearningFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'indicator' ? Array < DudiIndicatorGetPayload<S['select'][P]>>  :
        P extends 'ref' ? DudiGetPayload<S['select'][P]> :  P extends keyof DudiLearning ? DudiLearning[P] : never
  } 
      : DudiLearning


  type DudiLearningCountArgs = 
    Omit<DudiLearningFindManyArgs, 'select' | 'include'> & {
      select?: DudiLearningCountAggregateInputType | true
    }

  export interface DudiLearningDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one DudiLearning that matches the filter.
     * @param {DudiLearningFindUniqueArgs} args - Arguments to find a DudiLearning
     * @example
     * // Get one DudiLearning
     * const dudiLearning = await prisma.dudiLearning.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DudiLearningFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DudiLearningFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DudiLearning'> extends True ? Prisma__DudiLearningClient<DudiLearningGetPayload<T>> : Prisma__DudiLearningClient<DudiLearningGetPayload<T> | null, null>

    /**
     * Find one DudiLearning that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DudiLearningFindUniqueOrThrowArgs} args - Arguments to find a DudiLearning
     * @example
     * // Get one DudiLearning
     * const dudiLearning = await prisma.dudiLearning.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DudiLearningFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DudiLearningFindUniqueOrThrowArgs>
    ): Prisma__DudiLearningClient<DudiLearningGetPayload<T>>

    /**
     * Find the first DudiLearning that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DudiLearningFindFirstArgs} args - Arguments to find a DudiLearning
     * @example
     * // Get one DudiLearning
     * const dudiLearning = await prisma.dudiLearning.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DudiLearningFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DudiLearningFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DudiLearning'> extends True ? Prisma__DudiLearningClient<DudiLearningGetPayload<T>> : Prisma__DudiLearningClient<DudiLearningGetPayload<T> | null, null>

    /**
     * Find the first DudiLearning that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DudiLearningFindFirstOrThrowArgs} args - Arguments to find a DudiLearning
     * @example
     * // Get one DudiLearning
     * const dudiLearning = await prisma.dudiLearning.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DudiLearningFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DudiLearningFindFirstOrThrowArgs>
    ): Prisma__DudiLearningClient<DudiLearningGetPayload<T>>

    /**
     * Find zero or more DudiLearnings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DudiLearningFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DudiLearnings
     * const dudiLearnings = await prisma.dudiLearning.findMany()
     * 
     * // Get first 10 DudiLearnings
     * const dudiLearnings = await prisma.dudiLearning.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dudiLearningWithIdOnly = await prisma.dudiLearning.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DudiLearningFindManyArgs>(
      args?: SelectSubset<T, DudiLearningFindManyArgs>
    ): Prisma.PrismaPromise<Array<DudiLearningGetPayload<T>>>

    /**
     * Create a DudiLearning.
     * @param {DudiLearningCreateArgs} args - Arguments to create a DudiLearning.
     * @example
     * // Create one DudiLearning
     * const DudiLearning = await prisma.dudiLearning.create({
     *   data: {
     *     // ... data to create a DudiLearning
     *   }
     * })
     * 
    **/
    create<T extends DudiLearningCreateArgs>(
      args: SelectSubset<T, DudiLearningCreateArgs>
    ): Prisma__DudiLearningClient<DudiLearningGetPayload<T>>

    /**
     * Create many DudiLearnings.
     *     @param {DudiLearningCreateManyArgs} args - Arguments to create many DudiLearnings.
     *     @example
     *     // Create many DudiLearnings
     *     const dudiLearning = await prisma.dudiLearning.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DudiLearningCreateManyArgs>(
      args?: SelectSubset<T, DudiLearningCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DudiLearning.
     * @param {DudiLearningDeleteArgs} args - Arguments to delete one DudiLearning.
     * @example
     * // Delete one DudiLearning
     * const DudiLearning = await prisma.dudiLearning.delete({
     *   where: {
     *     // ... filter to delete one DudiLearning
     *   }
     * })
     * 
    **/
    delete<T extends DudiLearningDeleteArgs>(
      args: SelectSubset<T, DudiLearningDeleteArgs>
    ): Prisma__DudiLearningClient<DudiLearningGetPayload<T>>

    /**
     * Update one DudiLearning.
     * @param {DudiLearningUpdateArgs} args - Arguments to update one DudiLearning.
     * @example
     * // Update one DudiLearning
     * const dudiLearning = await prisma.dudiLearning.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DudiLearningUpdateArgs>(
      args: SelectSubset<T, DudiLearningUpdateArgs>
    ): Prisma__DudiLearningClient<DudiLearningGetPayload<T>>

    /**
     * Delete zero or more DudiLearnings.
     * @param {DudiLearningDeleteManyArgs} args - Arguments to filter DudiLearnings to delete.
     * @example
     * // Delete a few DudiLearnings
     * const { count } = await prisma.dudiLearning.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DudiLearningDeleteManyArgs>(
      args?: SelectSubset<T, DudiLearningDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DudiLearnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DudiLearningUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DudiLearnings
     * const dudiLearning = await prisma.dudiLearning.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DudiLearningUpdateManyArgs>(
      args: SelectSubset<T, DudiLearningUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DudiLearning.
     * @param {DudiLearningUpsertArgs} args - Arguments to update or create a DudiLearning.
     * @example
     * // Update or create a DudiLearning
     * const dudiLearning = await prisma.dudiLearning.upsert({
     *   create: {
     *     // ... data to create a DudiLearning
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DudiLearning we want to update
     *   }
     * })
    **/
    upsert<T extends DudiLearningUpsertArgs>(
      args: SelectSubset<T, DudiLearningUpsertArgs>
    ): Prisma__DudiLearningClient<DudiLearningGetPayload<T>>

    /**
     * Find zero or more DudiLearnings that matches the filter.
     * @param {DudiLearningFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dudiLearning = await prisma.dudiLearning.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: DudiLearningFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DudiLearning.
     * @param {DudiLearningAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dudiLearning = await prisma.dudiLearning.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: DudiLearningAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of DudiLearnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DudiLearningCountArgs} args - Arguments to filter DudiLearnings to count.
     * @example
     * // Count the number of DudiLearnings
     * const count = await prisma.dudiLearning.count({
     *   where: {
     *     // ... the filter for the DudiLearnings we want to count
     *   }
     * })
    **/
    count<T extends DudiLearningCountArgs>(
      args?: Subset<T, DudiLearningCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DudiLearningCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DudiLearning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DudiLearningAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DudiLearningAggregateArgs>(args: Subset<T, DudiLearningAggregateArgs>): Prisma.PrismaPromise<GetDudiLearningAggregateType<T>>

    /**
     * Group by DudiLearning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DudiLearningGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DudiLearningGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DudiLearningGroupByArgs['orderBy'] }
        : { orderBy?: DudiLearningGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DudiLearningGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDudiLearningGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DudiLearning.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DudiLearningClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    indicator<T extends DudiIndicatorArgs= {}>(args?: Subset<T, DudiIndicatorArgs>): Prisma.PrismaPromise<Array<DudiIndicatorGetPayload<T>>| Null>;

    ref<T extends DudiArgs= {}>(args?: Subset<T, DudiArgs>): Prisma__DudiClient<DudiGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DudiLearning base type for findUnique actions
   */
  export type DudiLearningFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DudiLearning
     */
    select?: DudiLearningSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiLearningInclude | null
    /**
     * Filter, which DudiLearning to fetch.
     */
    where: DudiLearningWhereUniqueInput
  }

  /**
   * DudiLearning findUnique
   */
  export interface DudiLearningFindUniqueArgs extends DudiLearningFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DudiLearning findUniqueOrThrow
   */
  export type DudiLearningFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DudiLearning
     */
    select?: DudiLearningSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiLearningInclude | null
    /**
     * Filter, which DudiLearning to fetch.
     */
    where: DudiLearningWhereUniqueInput
  }


  /**
   * DudiLearning base type for findFirst actions
   */
  export type DudiLearningFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DudiLearning
     */
    select?: DudiLearningSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiLearningInclude | null
    /**
     * Filter, which DudiLearning to fetch.
     */
    where?: DudiLearningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DudiLearnings to fetch.
     */
    orderBy?: Enumerable<DudiLearningOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DudiLearnings.
     */
    cursor?: DudiLearningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DudiLearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DudiLearnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DudiLearnings.
     */
    distinct?: Enumerable<DudiLearningScalarFieldEnum>
  }

  /**
   * DudiLearning findFirst
   */
  export interface DudiLearningFindFirstArgs extends DudiLearningFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DudiLearning findFirstOrThrow
   */
  export type DudiLearningFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DudiLearning
     */
    select?: DudiLearningSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiLearningInclude | null
    /**
     * Filter, which DudiLearning to fetch.
     */
    where?: DudiLearningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DudiLearnings to fetch.
     */
    orderBy?: Enumerable<DudiLearningOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DudiLearnings.
     */
    cursor?: DudiLearningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DudiLearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DudiLearnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DudiLearnings.
     */
    distinct?: Enumerable<DudiLearningScalarFieldEnum>
  }


  /**
   * DudiLearning findMany
   */
  export type DudiLearningFindManyArgs = {
    /**
     * Select specific fields to fetch from the DudiLearning
     */
    select?: DudiLearningSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiLearningInclude | null
    /**
     * Filter, which DudiLearnings to fetch.
     */
    where?: DudiLearningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DudiLearnings to fetch.
     */
    orderBy?: Enumerable<DudiLearningOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DudiLearnings.
     */
    cursor?: DudiLearningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DudiLearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DudiLearnings.
     */
    skip?: number
    distinct?: Enumerable<DudiLearningScalarFieldEnum>
  }


  /**
   * DudiLearning create
   */
  export type DudiLearningCreateArgs = {
    /**
     * Select specific fields to fetch from the DudiLearning
     */
    select?: DudiLearningSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiLearningInclude | null
    /**
     * The data needed to create a DudiLearning.
     */
    data: XOR<DudiLearningCreateInput, DudiLearningUncheckedCreateInput>
  }


  /**
   * DudiLearning createMany
   */
  export type DudiLearningCreateManyArgs = {
    /**
     * The data used to create many DudiLearnings.
     */
    data: Enumerable<DudiLearningCreateManyInput>
  }


  /**
   * DudiLearning update
   */
  export type DudiLearningUpdateArgs = {
    /**
     * Select specific fields to fetch from the DudiLearning
     */
    select?: DudiLearningSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiLearningInclude | null
    /**
     * The data needed to update a DudiLearning.
     */
    data: XOR<DudiLearningUpdateInput, DudiLearningUncheckedUpdateInput>
    /**
     * Choose, which DudiLearning to update.
     */
    where: DudiLearningWhereUniqueInput
  }


  /**
   * DudiLearning updateMany
   */
  export type DudiLearningUpdateManyArgs = {
    /**
     * The data used to update DudiLearnings.
     */
    data: XOR<DudiLearningUpdateManyMutationInput, DudiLearningUncheckedUpdateManyInput>
    /**
     * Filter which DudiLearnings to update
     */
    where?: DudiLearningWhereInput
  }


  /**
   * DudiLearning upsert
   */
  export type DudiLearningUpsertArgs = {
    /**
     * Select specific fields to fetch from the DudiLearning
     */
    select?: DudiLearningSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiLearningInclude | null
    /**
     * The filter to search for the DudiLearning to update in case it exists.
     */
    where: DudiLearningWhereUniqueInput
    /**
     * In case the DudiLearning found by the `where` argument doesn't exist, create a new DudiLearning with this data.
     */
    create: XOR<DudiLearningCreateInput, DudiLearningUncheckedCreateInput>
    /**
     * In case the DudiLearning was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DudiLearningUpdateInput, DudiLearningUncheckedUpdateInput>
  }


  /**
   * DudiLearning delete
   */
  export type DudiLearningDeleteArgs = {
    /**
     * Select specific fields to fetch from the DudiLearning
     */
    select?: DudiLearningSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiLearningInclude | null
    /**
     * Filter which DudiLearning to delete.
     */
    where: DudiLearningWhereUniqueInput
  }


  /**
   * DudiLearning deleteMany
   */
  export type DudiLearningDeleteManyArgs = {
    /**
     * Filter which DudiLearnings to delete
     */
    where?: DudiLearningWhereInput
  }


  /**
   * DudiLearning findRaw
   */
  export type DudiLearningFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * DudiLearning aggregateRaw
   */
  export type DudiLearningAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * DudiLearning without action
   */
  export type DudiLearningArgs = {
    /**
     * Select specific fields to fetch from the DudiLearning
     */
    select?: DudiLearningSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiLearningInclude | null
  }



  /**
   * Model Kkni
   */


  export type AggregateKkni = {
    _count: KkniCountAggregateOutputType | null
    _avg: KkniAvgAggregateOutputType | null
    _sum: KkniSumAggregateOutputType | null
    _min: KkniMinAggregateOutputType | null
    _max: KkniMaxAggregateOutputType | null
  }

  export type KkniAvgAggregateOutputType = {
    no: number | null
  }

  export type KkniSumAggregateOutputType = {
    no: number | null
  }

  export type KkniMinAggregateOutputType = {
    id: string | null
    konsentrasiId: string | null
    no: number | null
    code: string | null
    name: string | null
    description: string | null
    disable: boolean | null
  }

  export type KkniMaxAggregateOutputType = {
    id: string | null
    konsentrasiId: string | null
    no: number | null
    code: string | null
    name: string | null
    description: string | null
    disable: boolean | null
  }

  export type KkniCountAggregateOutputType = {
    id: number
    konsentrasiId: number
    no: number
    code: number
    name: number
    description: number
    disable: number
    _all: number
  }


  export type KkniAvgAggregateInputType = {
    no?: true
  }

  export type KkniSumAggregateInputType = {
    no?: true
  }

  export type KkniMinAggregateInputType = {
    id?: true
    konsentrasiId?: true
    no?: true
    code?: true
    name?: true
    description?: true
    disable?: true
  }

  export type KkniMaxAggregateInputType = {
    id?: true
    konsentrasiId?: true
    no?: true
    code?: true
    name?: true
    description?: true
    disable?: true
  }

  export type KkniCountAggregateInputType = {
    id?: true
    konsentrasiId?: true
    no?: true
    code?: true
    name?: true
    description?: true
    disable?: true
    _all?: true
  }

  export type KkniAggregateArgs = {
    /**
     * Filter which Kkni to aggregate.
     */
    where?: KkniWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kknis to fetch.
     */
    orderBy?: Enumerable<KkniOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KkniWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kknis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kknis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Kknis
    **/
    _count?: true | KkniCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KkniAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KkniSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KkniMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KkniMaxAggregateInputType
  }

  export type GetKkniAggregateType<T extends KkniAggregateArgs> = {
        [P in keyof T & keyof AggregateKkni]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKkni[P]>
      : GetScalarType<T[P], AggregateKkni[P]>
  }




  export type KkniGroupByArgs = {
    where?: KkniWhereInput
    orderBy?: Enumerable<KkniOrderByWithAggregationInput>
    by: KkniScalarFieldEnum[]
    having?: KkniScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KkniCountAggregateInputType | true
    _avg?: KkniAvgAggregateInputType
    _sum?: KkniSumAggregateInputType
    _min?: KkniMinAggregateInputType
    _max?: KkniMaxAggregateInputType
  }


  export type KkniGroupByOutputType = {
    id: string
    konsentrasiId: string
    no: number
    code: string
    name: string
    description: string | null
    disable: boolean
    _count: KkniCountAggregateOutputType | null
    _avg: KkniAvgAggregateOutputType | null
    _sum: KkniSumAggregateOutputType | null
    _min: KkniMinAggregateOutputType | null
    _max: KkniMaxAggregateOutputType | null
  }

  type GetKkniGroupByPayload<T extends KkniGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<KkniGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KkniGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KkniGroupByOutputType[P]>
            : GetScalarType<T[P], KkniGroupByOutputType[P]>
        }
      >
    >


  export type KkniSelect = {
    id?: boolean
    konsentrasiId?: boolean
    no?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    disable?: boolean
    konsentrasi?: boolean | KonsentrasiKeahlianArgs
    dudi?: boolean | Kkni$dudiArgs
    tracker?: boolean | Kkni$trackerArgs
    _count?: boolean | KkniCountOutputTypeArgs
  }


  export type KkniInclude = {
    konsentrasi?: boolean | KonsentrasiKeahlianArgs
    dudi?: boolean | Kkni$dudiArgs
    tracker?: boolean | Kkni$trackerArgs
    _count?: boolean | KkniCountOutputTypeArgs
  }

  export type KkniGetPayload<S extends boolean | null | undefined | KkniArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Kkni :
    S extends undefined ? never :
    S extends { include: any } & (KkniArgs | KkniFindManyArgs)
    ? Kkni  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'konsentrasi' ? KonsentrasiKeahlianGetPayload<S['include'][P]> :
        P extends 'dudi' ? Array < DudiGetPayload<S['include'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['include'][P]>>  :
        P extends '_count' ? KkniCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (KkniArgs | KkniFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'konsentrasi' ? KonsentrasiKeahlianGetPayload<S['select'][P]> :
        P extends 'dudi' ? Array < DudiGetPayload<S['select'][P]>>  :
        P extends 'tracker' ? Array < TrackerGetPayload<S['select'][P]>>  :
        P extends '_count' ? KkniCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Kkni ? Kkni[P] : never
  } 
      : Kkni


  type KkniCountArgs = 
    Omit<KkniFindManyArgs, 'select' | 'include'> & {
      select?: KkniCountAggregateInputType | true
    }

  export interface KkniDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Kkni that matches the filter.
     * @param {KkniFindUniqueArgs} args - Arguments to find a Kkni
     * @example
     * // Get one Kkni
     * const kkni = await prisma.kkni.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends KkniFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, KkniFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Kkni'> extends True ? Prisma__KkniClient<KkniGetPayload<T>> : Prisma__KkniClient<KkniGetPayload<T> | null, null>

    /**
     * Find one Kkni that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {KkniFindUniqueOrThrowArgs} args - Arguments to find a Kkni
     * @example
     * // Get one Kkni
     * const kkni = await prisma.kkni.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends KkniFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, KkniFindUniqueOrThrowArgs>
    ): Prisma__KkniClient<KkniGetPayload<T>>

    /**
     * Find the first Kkni that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KkniFindFirstArgs} args - Arguments to find a Kkni
     * @example
     * // Get one Kkni
     * const kkni = await prisma.kkni.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends KkniFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, KkniFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Kkni'> extends True ? Prisma__KkniClient<KkniGetPayload<T>> : Prisma__KkniClient<KkniGetPayload<T> | null, null>

    /**
     * Find the first Kkni that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KkniFindFirstOrThrowArgs} args - Arguments to find a Kkni
     * @example
     * // Get one Kkni
     * const kkni = await prisma.kkni.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends KkniFindFirstOrThrowArgs>(
      args?: SelectSubset<T, KkniFindFirstOrThrowArgs>
    ): Prisma__KkniClient<KkniGetPayload<T>>

    /**
     * Find zero or more Kknis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KkniFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kknis
     * const kknis = await prisma.kkni.findMany()
     * 
     * // Get first 10 Kknis
     * const kknis = await prisma.kkni.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kkniWithIdOnly = await prisma.kkni.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends KkniFindManyArgs>(
      args?: SelectSubset<T, KkniFindManyArgs>
    ): Prisma.PrismaPromise<Array<KkniGetPayload<T>>>

    /**
     * Create a Kkni.
     * @param {KkniCreateArgs} args - Arguments to create a Kkni.
     * @example
     * // Create one Kkni
     * const Kkni = await prisma.kkni.create({
     *   data: {
     *     // ... data to create a Kkni
     *   }
     * })
     * 
    **/
    create<T extends KkniCreateArgs>(
      args: SelectSubset<T, KkniCreateArgs>
    ): Prisma__KkniClient<KkniGetPayload<T>>

    /**
     * Create many Kknis.
     *     @param {KkniCreateManyArgs} args - Arguments to create many Kknis.
     *     @example
     *     // Create many Kknis
     *     const kkni = await prisma.kkni.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends KkniCreateManyArgs>(
      args?: SelectSubset<T, KkniCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Kkni.
     * @param {KkniDeleteArgs} args - Arguments to delete one Kkni.
     * @example
     * // Delete one Kkni
     * const Kkni = await prisma.kkni.delete({
     *   where: {
     *     // ... filter to delete one Kkni
     *   }
     * })
     * 
    **/
    delete<T extends KkniDeleteArgs>(
      args: SelectSubset<T, KkniDeleteArgs>
    ): Prisma__KkniClient<KkniGetPayload<T>>

    /**
     * Update one Kkni.
     * @param {KkniUpdateArgs} args - Arguments to update one Kkni.
     * @example
     * // Update one Kkni
     * const kkni = await prisma.kkni.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends KkniUpdateArgs>(
      args: SelectSubset<T, KkniUpdateArgs>
    ): Prisma__KkniClient<KkniGetPayload<T>>

    /**
     * Delete zero or more Kknis.
     * @param {KkniDeleteManyArgs} args - Arguments to filter Kknis to delete.
     * @example
     * // Delete a few Kknis
     * const { count } = await prisma.kkni.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends KkniDeleteManyArgs>(
      args?: SelectSubset<T, KkniDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kknis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KkniUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kknis
     * const kkni = await prisma.kkni.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends KkniUpdateManyArgs>(
      args: SelectSubset<T, KkniUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kkni.
     * @param {KkniUpsertArgs} args - Arguments to update or create a Kkni.
     * @example
     * // Update or create a Kkni
     * const kkni = await prisma.kkni.upsert({
     *   create: {
     *     // ... data to create a Kkni
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kkni we want to update
     *   }
     * })
    **/
    upsert<T extends KkniUpsertArgs>(
      args: SelectSubset<T, KkniUpsertArgs>
    ): Prisma__KkniClient<KkniGetPayload<T>>

    /**
     * Find zero or more Kknis that matches the filter.
     * @param {KkniFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const kkni = await prisma.kkni.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: KkniFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Kkni.
     * @param {KkniAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const kkni = await prisma.kkni.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: KkniAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Kknis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KkniCountArgs} args - Arguments to filter Kknis to count.
     * @example
     * // Count the number of Kknis
     * const count = await prisma.kkni.count({
     *   where: {
     *     // ... the filter for the Kknis we want to count
     *   }
     * })
    **/
    count<T extends KkniCountArgs>(
      args?: Subset<T, KkniCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KkniCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kkni.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KkniAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KkniAggregateArgs>(args: Subset<T, KkniAggregateArgs>): Prisma.PrismaPromise<GetKkniAggregateType<T>>

    /**
     * Group by Kkni.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KkniGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KkniGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KkniGroupByArgs['orderBy'] }
        : { orderBy?: KkniGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KkniGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKkniGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Kkni.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__KkniClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    konsentrasi<T extends KonsentrasiKeahlianArgs= {}>(args?: Subset<T, KonsentrasiKeahlianArgs>): Prisma__KonsentrasiKeahlianClient<KonsentrasiKeahlianGetPayload<T> | Null>;

    dudi<T extends Kkni$dudiArgs= {}>(args?: Subset<T, Kkni$dudiArgs>): Prisma.PrismaPromise<Array<DudiGetPayload<T>>| Null>;

    tracker<T extends Kkni$trackerArgs= {}>(args?: Subset<T, Kkni$trackerArgs>): Prisma.PrismaPromise<Array<TrackerGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Kkni base type for findUnique actions
   */
  export type KkniFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Kkni
     */
    select?: KkniSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KkniInclude | null
    /**
     * Filter, which Kkni to fetch.
     */
    where: KkniWhereUniqueInput
  }

  /**
   * Kkni findUnique
   */
  export interface KkniFindUniqueArgs extends KkniFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Kkni findUniqueOrThrow
   */
  export type KkniFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Kkni
     */
    select?: KkniSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KkniInclude | null
    /**
     * Filter, which Kkni to fetch.
     */
    where: KkniWhereUniqueInput
  }


  /**
   * Kkni base type for findFirst actions
   */
  export type KkniFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Kkni
     */
    select?: KkniSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KkniInclude | null
    /**
     * Filter, which Kkni to fetch.
     */
    where?: KkniWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kknis to fetch.
     */
    orderBy?: Enumerable<KkniOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kknis.
     */
    cursor?: KkniWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kknis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kknis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kknis.
     */
    distinct?: Enumerable<KkniScalarFieldEnum>
  }

  /**
   * Kkni findFirst
   */
  export interface KkniFindFirstArgs extends KkniFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Kkni findFirstOrThrow
   */
  export type KkniFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Kkni
     */
    select?: KkniSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KkniInclude | null
    /**
     * Filter, which Kkni to fetch.
     */
    where?: KkniWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kknis to fetch.
     */
    orderBy?: Enumerable<KkniOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kknis.
     */
    cursor?: KkniWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kknis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kknis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kknis.
     */
    distinct?: Enumerable<KkniScalarFieldEnum>
  }


  /**
   * Kkni findMany
   */
  export type KkniFindManyArgs = {
    /**
     * Select specific fields to fetch from the Kkni
     */
    select?: KkniSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KkniInclude | null
    /**
     * Filter, which Kknis to fetch.
     */
    where?: KkniWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kknis to fetch.
     */
    orderBy?: Enumerable<KkniOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Kknis.
     */
    cursor?: KkniWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kknis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kknis.
     */
    skip?: number
    distinct?: Enumerable<KkniScalarFieldEnum>
  }


  /**
   * Kkni create
   */
  export type KkniCreateArgs = {
    /**
     * Select specific fields to fetch from the Kkni
     */
    select?: KkniSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KkniInclude | null
    /**
     * The data needed to create a Kkni.
     */
    data: XOR<KkniCreateInput, KkniUncheckedCreateInput>
  }


  /**
   * Kkni createMany
   */
  export type KkniCreateManyArgs = {
    /**
     * The data used to create many Kknis.
     */
    data: Enumerable<KkniCreateManyInput>
  }


  /**
   * Kkni update
   */
  export type KkniUpdateArgs = {
    /**
     * Select specific fields to fetch from the Kkni
     */
    select?: KkniSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KkniInclude | null
    /**
     * The data needed to update a Kkni.
     */
    data: XOR<KkniUpdateInput, KkniUncheckedUpdateInput>
    /**
     * Choose, which Kkni to update.
     */
    where: KkniWhereUniqueInput
  }


  /**
   * Kkni updateMany
   */
  export type KkniUpdateManyArgs = {
    /**
     * The data used to update Kknis.
     */
    data: XOR<KkniUpdateManyMutationInput, KkniUncheckedUpdateManyInput>
    /**
     * Filter which Kknis to update
     */
    where?: KkniWhereInput
  }


  /**
   * Kkni upsert
   */
  export type KkniUpsertArgs = {
    /**
     * Select specific fields to fetch from the Kkni
     */
    select?: KkniSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KkniInclude | null
    /**
     * The filter to search for the Kkni to update in case it exists.
     */
    where: KkniWhereUniqueInput
    /**
     * In case the Kkni found by the `where` argument doesn't exist, create a new Kkni with this data.
     */
    create: XOR<KkniCreateInput, KkniUncheckedCreateInput>
    /**
     * In case the Kkni was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KkniUpdateInput, KkniUncheckedUpdateInput>
  }


  /**
   * Kkni delete
   */
  export type KkniDeleteArgs = {
    /**
     * Select specific fields to fetch from the Kkni
     */
    select?: KkniSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KkniInclude | null
    /**
     * Filter which Kkni to delete.
     */
    where: KkniWhereUniqueInput
  }


  /**
   * Kkni deleteMany
   */
  export type KkniDeleteManyArgs = {
    /**
     * Filter which Kknis to delete
     */
    where?: KkniWhereInput
  }


  /**
   * Kkni findRaw
   */
  export type KkniFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Kkni aggregateRaw
   */
  export type KkniAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Kkni.dudi
   */
  export type Kkni$dudiArgs = {
    /**
     * Select specific fields to fetch from the Dudi
     */
    select?: DudiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DudiInclude | null
    where?: DudiWhereInput
    orderBy?: Enumerable<DudiOrderByWithRelationInput>
    cursor?: DudiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DudiScalarFieldEnum>
  }


  /**
   * Kkni.tracker
   */
  export type Kkni$trackerArgs = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude | null
    where?: TrackerWhereInput
    orderBy?: Enumerable<TrackerOrderByWithRelationInput>
    cursor?: TrackerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TrackerScalarFieldEnum>
  }


  /**
   * Kkni without action
   */
  export type KkniArgs = {
    /**
     * Select specific fields to fetch from the Kkni
     */
    select?: KkniSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KkniInclude | null
  }



  /**
   * Enums
   */

  export const AchievementScalarFieldEnum: {
    id: 'id',
    no: 'no',
    fase: 'fase',
    description: 'description',
    elementId: 'elementId',
    disable: 'disable'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const AuthScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    personalId: 'personalId'
  };

  export type AuthScalarFieldEnum = (typeof AuthScalarFieldEnum)[keyof typeof AuthScalarFieldEnum]


  export const BidangKeahlianScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    disable: 'disable'
  };

  export type BidangKeahlianScalarFieldEnum = (typeof BidangKeahlianScalarFieldEnum)[keyof typeof BidangKeahlianScalarFieldEnum]


  export const BookScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    author: 'author'
  };

  export type BookScalarFieldEnum = (typeof BookScalarFieldEnum)[keyof typeof BookScalarFieldEnum]


  export const CalendarScalarFieldEnum: {
    id: 'id',
    refId: 'refId',
    name: 'name',
    description: 'description',
    start: 'start',
    end: 'end',
    color: 'color',
    classRoomIds: 'classRoomIds',
    studentIds: 'studentIds',
    teacherIds: 'teacherIds',
    disable: 'disable'
  };

  export type CalendarScalarFieldEnum = (typeof CalendarScalarFieldEnum)[keyof typeof CalendarScalarFieldEnum]


  export const ClassRoomScalarFieldEnum: {
    id: 'id',
    name: 'name',
    yearId: 'yearId',
    waliId: 'waliId',
    level: 'level',
    majorId: 'majorId',
    studentIds: 'studentIds',
    eventIds: 'eventIds',
    disable: 'disable',
    teachingIds: 'teachingIds',
    tDeviceIds: 'tDeviceIds'
  };

  export type ClassRoomScalarFieldEnum = (typeof ClassRoomScalarFieldEnum)[keyof typeof ClassRoomScalarFieldEnum]


  export const DudiLearningScalarFieldEnum: {
    id: 'id',
    no: 'no',
    refId: 'refId',
    code: 'code',
    name: 'name'
  };

  export type DudiLearningScalarFieldEnum = (typeof DudiLearningScalarFieldEnum)[keyof typeof DudiLearningScalarFieldEnum]


  export const DudiScalarFieldEnum: {
    id: 'id',
    name: 'name',
    street: 'street',
    instansiId: 'instansiId',
    majorId: 'majorId',
    collabs: 'collabs',
    disable: 'disable',
    kkniId: 'kkniId'
  };

  export type DudiScalarFieldEnum = (typeof DudiScalarFieldEnum)[keyof typeof DudiScalarFieldEnum]


  export const ElementScalarFieldEnum: {
    id: 'id',
    no: 'no',
    name: 'name',
    description: 'description',
    mapelId: 'mapelId',
    disable: 'disable',
    scheduleClassIds: 'scheduleClassIds'
  };

  export type ElementScalarFieldEnum = (typeof ElementScalarFieldEnum)[keyof typeof ElementScalarFieldEnum]


  export const FamilyTreeChildScalarFieldEnum: {
    id: 'id',
    no: 'no',
    type: 'type',
    kkId: 'kkId',
    personalId: 'personalId'
  };

  export type FamilyTreeChildScalarFieldEnum = (typeof FamilyTreeChildScalarFieldEnum)[keyof typeof FamilyTreeChildScalarFieldEnum]


  export const FamilyTreeScalarFieldEnum: {
    id: 'id',
    nokk: 'nokk',
    fatherId: 'fatherId',
    motherId: 'motherId',
    waliId: 'waliId',
    coupleId: 'coupleId'
  };

  export type FamilyTreeScalarFieldEnum = (typeof FamilyTreeScalarFieldEnum)[keyof typeof FamilyTreeScalarFieldEnum]


  export const InstansiScalarFieldEnum: {
    id: 'id',
    npsn: 'npsn',
    name: 'name',
    isPrivate: 'isPrivate',
    level: 'level',
    religion: 'religion',
    major: 'major',
    majorIds: 'majorIds',
    disable: 'disable'
  };

  export type InstansiScalarFieldEnum = (typeof InstansiScalarFieldEnum)[keyof typeof InstansiScalarFieldEnum]


  export const KkniScalarFieldEnum: {
    id: 'id',
    konsentrasiId: 'konsentrasiId',
    no: 'no',
    code: 'code',
    name: 'name',
    description: 'description',
    disable: 'disable'
  };

  export type KkniScalarFieldEnum = (typeof KkniScalarFieldEnum)[keyof typeof KkniScalarFieldEnum]


  export const KonsentrasiKeahlianScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    programId: 'programId',
    tahun: 'tahun',
    instansiIds: 'instansiIds',
    disable: 'disable'
  };

  export type KonsentrasiKeahlianScalarFieldEnum = (typeof KonsentrasiKeahlianScalarFieldEnum)[keyof typeof KonsentrasiKeahlianScalarFieldEnum]


  export const LinkScalarFieldEnum: {
    id: 'id',
    url: 'url',
    title: 'title',
    description: 'description',
    image: 'image',
    width: 'width',
    height: 'height',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LinkScalarFieldEnum = (typeof LinkScalarFieldEnum)[keyof typeof LinkScalarFieldEnum]


  export const MataPelajaranScalarFieldEnum: {
    id: 'id',
    level: 'level',
    type: 'type',
    no: 'no',
    code: 'code',
    name: 'name',
    religion: 'religion',
    programId: 'programId',
    keahlianid: 'keahlianid',
    instansiId: 'instansiId',
    disable: 'disable'
  };

  export type MataPelajaranScalarFieldEnum = (typeof MataPelajaranScalarFieldEnum)[keyof typeof MataPelajaranScalarFieldEnum]


  export const OAssessmentScalarFieldEnum: {
    id: 'id',
    refId: 'refId',
    type: 'type',
    techs: 'techs'
  };

  export type OAssessmentScalarFieldEnum = (typeof OAssessmentScalarFieldEnum)[keyof typeof OAssessmentScalarFieldEnum]


  export const OLearningScalarFieldEnum: {
    id: 'id',
    refId: 'refId',
    no: 'no',
    content: 'content',
    taksonomi: 'taksonomi',
    sentence: 'sentence'
  };

  export type OLearningScalarFieldEnum = (typeof OLearningScalarFieldEnum)[keyof typeof OLearningScalarFieldEnum]


  export const OMaterialScalarFieldEnum: {
    id: 'id',
    refId: 'refId',
    no: 'no',
    content: 'content',
    model: 'model'
  };

  export type OMaterialScalarFieldEnum = (typeof OMaterialScalarFieldEnum)[keyof typeof OMaterialScalarFieldEnum]


  export const ObjectiveScalarFieldEnum: {
    id: 'id',
    level: 'level',
    fase: 'fase',
    userId: 'userId',
    instansiId: 'instansiId',
    yearId: 'yearId',
    mapelId: 'mapelId',
    elementId: 'elementId',
    achievementId: 'achievementId',
    code: 'code',
    kkm: 'kkm',
    steps: 'steps',
    subjectMatter: 'subjectMatter',
    competencie: 'competencie',
    firstSkill: 'firstSkill',
    triggerQuest: 'triggerQuest',
    disable: 'disable',
    toolIds: 'toolIds',
    mateIds: 'mateIds',
    methIds: 'methIds',
    mediaIds: 'mediaIds'
  };

  export type ObjectiveScalarFieldEnum = (typeof ObjectiveScalarFieldEnum)[keyof typeof ObjectiveScalarFieldEnum]


  export const OhelperScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    toolIds: 'toolIds',
    mateIds: 'mateIds',
    methIds: 'methIds',
    mediaIds: 'mediaIds'
  };

  export type OhelperScalarFieldEnum = (typeof OhelperScalarFieldEnum)[keyof typeof OhelperScalarFieldEnum]


  export const OpppScalarFieldEnum: {
    id: 'id',
    refId: 'refId',
    name: 'name',
    description: 'description'
  };

  export type OpppScalarFieldEnum = (typeof OpppScalarFieldEnum)[keyof typeof OpppScalarFieldEnum]


  export const OresourceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    refId: 'refId',
    linkId: 'linkId'
  };

  export type OresourceScalarFieldEnum = (typeof OresourceScalarFieldEnum)[keyof typeof OresourceScalarFieldEnum]


  export const PersonalScalarFieldEnum: {
    id: 'id',
    nik: 'nik',
    nisn: 'nisn',
    type: 'type',
    fullname: 'fullname',
    gender: 'gender',
    foreign: 'foreign',
    country: 'country',
    religion: 'religion',
    email: 'email',
    belajarId: 'belajarId',
    nophone: 'nophone',
    isLife: 'isLife',
    disable: 'disable'
  };

  export type PersonalScalarFieldEnum = (typeof PersonalScalarFieldEnum)[keyof typeof PersonalScalarFieldEnum]


  export const ProgramKeahlianScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    bidangId: 'bidangId',
    disable: 'disable'
  };

  export type ProgramKeahlianScalarFieldEnum = (typeof ProgramKeahlianScalarFieldEnum)[keyof typeof ProgramKeahlianScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const RoleScalarFieldEnum: {
    id: 'id',
    key: 'key',
    instansiId: 'instansiId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const ScheduleScalarFieldEnum: {
    id: 'id',
    yearId: 'yearId',
    mapelId: 'mapelId',
    disable: 'disable'
  };

  export type ScheduleScalarFieldEnum = (typeof ScheduleScalarFieldEnum)[keyof typeof ScheduleScalarFieldEnum]


  export const SchoolYearScalarFieldEnum: {
    id: 'id',
    year: 'year',
    instansiId: 'instansiId',
    departments: 'departments',
    disable: 'disable'
  };

  export type SchoolYearScalarFieldEnum = (typeof SchoolYearScalarFieldEnum)[keyof typeof SchoolYearScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const StudentScalarFieldEnum: {
    id: 'id',
    nis: 'nis',
    lastSchool: 'lastSchool',
    personalId: 'personalId',
    majorId: 'majorId',
    classRoomIds: 'classRoomIds',
    startYearId: 'startYearId',
    instansiId: 'instansiId',
    eventIds: 'eventIds',
    disable: 'disable'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const TDeviceDataScalarFieldEnum: {
    id: 'id',
    refId: 'refId',
    objectiveId: 'objectiveId'
  };

  export type TDeviceDataScalarFieldEnum = (typeof TDeviceDataScalarFieldEnum)[keyof typeof TDeviceDataScalarFieldEnum]


  export const TDeviceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    level: 'level',
    fase: 'fase',
    teachingId: 'teachingId',
    yearId: 'yearId',
    userId: 'userId',
    instansiId: 'instansiId',
    mapelId: 'mapelId',
    classRoomIds: 'classRoomIds',
    elemen: 'elemen',
    disable: 'disable',
    parentId: 'parentId'
  };

  export type TDeviceScalarFieldEnum = (typeof TDeviceScalarFieldEnum)[keyof typeof TDeviceScalarFieldEnum]


  export const TeacherScalarFieldEnum: {
    id: 'id',
    personalId: 'personalId',
    instansiId: 'instansiId',
    eventIds: 'eventIds',
    nip: 'nip',
    nrg: 'nrg',
    noKarpeg: 'noKarpeg',
    tmtTugas: 'tmtTugas',
    tmtGol: 'tmtGol',
    position: 'position',
    rank: 'rank',
    period: 'period',
    certificate: 'certificate',
    disable: 'disable'
  };

  export type TeacherScalarFieldEnum = (typeof TeacherScalarFieldEnum)[keyof typeof TeacherScalarFieldEnum]


  export const TeachingScalarFieldEnum: {
    id: 'id',
    refId: 'refId',
    level: 'level',
    hours: 'hours',
    semester: 'semester',
    teacherId: 'teacherId',
    classRoomIds: 'classRoomIds',
    elemenIds: 'elemenIds',
    disable: 'disable'
  };

  export type TeachingScalarFieldEnum = (typeof TeachingScalarFieldEnum)[keyof typeof TeachingScalarFieldEnum]


  export const TrackerScalarFieldEnum: {
    id: 'id',
    point: 'point',
    type: 'type',
    userId: 'userId',
    refId: 'refId',
    instansiId: 'instansiId',
    createdAt: 'createdAt',
    mapelId: 'mapelId',
    elementId: 'elementId',
    cpId: 'cpId',
    bidangId: 'bidangId',
    programId: 'programId',
    konsentrasiId: 'konsentrasiId',
    tpId: 'tpId',
    teacherId: 'teacherId',
    kelasId: 'kelasId',
    muridId: 'muridId',
    jadwalId: 'jadwalId',
    mengajarId: 'mengajarId',
    tujuanId: 'tujuanId',
    perangkatId: 'perangkatId',
    kalenderId: 'kalenderId',
    dudiId: 'dudiId',
    kkniId: 'kkniId'
  };

  export type TrackerScalarFieldEnum = (typeof TrackerScalarFieldEnum)[keyof typeof TrackerScalarFieldEnum]


  export const UploadScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    url: 'url'
  };

  export type UploadScalarFieldEnum = (typeof UploadScalarFieldEnum)[keyof typeof UploadScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    picture: 'picture',
    username: 'username',
    active: 'active',
    verify: 'verify',
    password: 'password',
    passhash: 'passhash',
    roleId: 'roleId',
    disable: 'disable'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type TrackerWhereInput = {
    AND?: Enumerable<TrackerWhereInput>
    OR?: Enumerable<TrackerWhereInput>
    NOT?: Enumerable<TrackerWhereInput>
    id?: StringFilter | string
    point?: EnumPointTrackerFilter | PointTracker
    type?: EnumTypeTrackerFilter | TypeTracker
    userId?: StringFilter | string
    refId?: StringFilter | string
    instansiId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    mapelId?: StringNullableFilter | string | null
    elementId?: StringNullableFilter | string | null
    cpId?: StringNullableFilter | string | null
    bidangId?: StringNullableFilter | string | null
    programId?: StringNullableFilter | string | null
    konsentrasiId?: StringNullableFilter | string | null
    tpId?: StringNullableFilter | string | null
    teacherId?: StringNullableFilter | string | null
    kelasId?: StringNullableFilter | string | null
    muridId?: StringNullableFilter | string | null
    jadwalId?: StringNullableFilter | string | null
    mengajarId?: StringNullableFilter | string | null
    tujuanId?: StringNullableFilter | string | null
    perangkatId?: StringNullableFilter | string | null
    kalenderId?: StringNullableFilter | string | null
    dudiId?: StringNullableFilter | string | null
    kkniId?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    ref?: XOR<InstansiRelationFilter, InstansiWhereInput>
    instansi?: XOR<InstansiRelationFilter, InstansiWhereInput> | null
    mapel?: XOR<MataPelajaranRelationFilter, MataPelajaranWhereInput> | null
    elemen?: XOR<ElementRelationFilter, ElementWhereInput> | null
    cp?: XOR<AchievementRelationFilter, AchievementWhereInput> | null
    bidang?: XOR<BidangKeahlianRelationFilter, BidangKeahlianWhereInput> | null
    program?: XOR<ProgramKeahlianRelationFilter, ProgramKeahlianWhereInput> | null
    konsentrasi?: XOR<KonsentrasiKeahlianRelationFilter, KonsentrasiKeahlianWhereInput> | null
    tp?: XOR<SchoolYearRelationFilter, SchoolYearWhereInput> | null
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput> | null
    kelas?: XOR<ClassRoomRelationFilter, ClassRoomWhereInput> | null
    murid?: XOR<StudentRelationFilter, StudentWhereInput> | null
    jadwal?: XOR<ScheduleRelationFilter, ScheduleWhereInput> | null
    mengajar?: XOR<TeachingRelationFilter, TeachingWhereInput> | null
    tujuan?: XOR<ObjectiveRelationFilter, ObjectiveWhereInput> | null
    perangkat?: XOR<TDeviceRelationFilter, TDeviceWhereInput> | null
    kalender?: XOR<CalendarRelationFilter, CalendarWhereInput> | null
    dudi?: XOR<DudiRelationFilter, DudiWhereInput> | null
    kkni?: XOR<KkniRelationFilter, KkniWhereInput> | null
  }

  export type TrackerOrderByWithRelationInput = {
    id?: SortOrder
    point?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    refId?: SortOrder
    instansiId?: SortOrder
    createdAt?: SortOrder
    mapelId?: SortOrder
    elementId?: SortOrder
    cpId?: SortOrder
    bidangId?: SortOrder
    programId?: SortOrder
    konsentrasiId?: SortOrder
    tpId?: SortOrder
    teacherId?: SortOrder
    kelasId?: SortOrder
    muridId?: SortOrder
    jadwalId?: SortOrder
    mengajarId?: SortOrder
    tujuanId?: SortOrder
    perangkatId?: SortOrder
    kalenderId?: SortOrder
    dudiId?: SortOrder
    kkniId?: SortOrder
    user?: UserOrderByWithRelationInput
    ref?: InstansiOrderByWithRelationInput
    instansi?: InstansiOrderByWithRelationInput
    mapel?: MataPelajaranOrderByWithRelationInput
    elemen?: ElementOrderByWithRelationInput
    cp?: AchievementOrderByWithRelationInput
    bidang?: BidangKeahlianOrderByWithRelationInput
    program?: ProgramKeahlianOrderByWithRelationInput
    konsentrasi?: KonsentrasiKeahlianOrderByWithRelationInput
    tp?: SchoolYearOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
    kelas?: ClassRoomOrderByWithRelationInput
    murid?: StudentOrderByWithRelationInput
    jadwal?: ScheduleOrderByWithRelationInput
    mengajar?: TeachingOrderByWithRelationInput
    tujuan?: ObjectiveOrderByWithRelationInput
    perangkat?: TDeviceOrderByWithRelationInput
    kalender?: CalendarOrderByWithRelationInput
    dudi?: DudiOrderByWithRelationInput
    kkni?: KkniOrderByWithRelationInput
  }

  export type TrackerWhereUniqueInput = {
    id?: string
  }

  export type TrackerOrderByWithAggregationInput = {
    id?: SortOrder
    point?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    refId?: SortOrder
    instansiId?: SortOrder
    createdAt?: SortOrder
    mapelId?: SortOrder
    elementId?: SortOrder
    cpId?: SortOrder
    bidangId?: SortOrder
    programId?: SortOrder
    konsentrasiId?: SortOrder
    tpId?: SortOrder
    teacherId?: SortOrder
    kelasId?: SortOrder
    muridId?: SortOrder
    jadwalId?: SortOrder
    mengajarId?: SortOrder
    tujuanId?: SortOrder
    perangkatId?: SortOrder
    kalenderId?: SortOrder
    dudiId?: SortOrder
    kkniId?: SortOrder
    _count?: TrackerCountOrderByAggregateInput
    _max?: TrackerMaxOrderByAggregateInput
    _min?: TrackerMinOrderByAggregateInput
  }

  export type TrackerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TrackerScalarWhereWithAggregatesInput>
    OR?: Enumerable<TrackerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TrackerScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    point?: EnumPointTrackerWithAggregatesFilter | PointTracker
    type?: EnumTypeTrackerWithAggregatesFilter | TypeTracker
    userId?: StringWithAggregatesFilter | string
    refId?: StringWithAggregatesFilter | string
    instansiId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    mapelId?: StringNullableWithAggregatesFilter | string | null
    elementId?: StringNullableWithAggregatesFilter | string | null
    cpId?: StringNullableWithAggregatesFilter | string | null
    bidangId?: StringNullableWithAggregatesFilter | string | null
    programId?: StringNullableWithAggregatesFilter | string | null
    konsentrasiId?: StringNullableWithAggregatesFilter | string | null
    tpId?: StringNullableWithAggregatesFilter | string | null
    teacherId?: StringNullableWithAggregatesFilter | string | null
    kelasId?: StringNullableWithAggregatesFilter | string | null
    muridId?: StringNullableWithAggregatesFilter | string | null
    jadwalId?: StringNullableWithAggregatesFilter | string | null
    mengajarId?: StringNullableWithAggregatesFilter | string | null
    tujuanId?: StringNullableWithAggregatesFilter | string | null
    perangkatId?: StringNullableWithAggregatesFilter | string | null
    kalenderId?: StringNullableWithAggregatesFilter | string | null
    dudiId?: StringNullableWithAggregatesFilter | string | null
    kkniId?: StringNullableWithAggregatesFilter | string | null
  }

  export type InstansiWhereInput = {
    AND?: Enumerable<InstansiWhereInput>
    OR?: Enumerable<InstansiWhereInput>
    NOT?: Enumerable<InstansiWhereInput>
    id?: StringFilter | string
    npsn?: StringFilter | string
    name?: StringFilter | string
    isPrivate?: BoolFilter | boolean
    address?: XOR<AddressCompositeFilter, AddressObjectEqualityInput>
    level?: EnumLevelFilter | Level
    religion?: EnumReligionNullableFilter | Religion | null
    major?: BoolNullableFilter | boolean | null
    majorIds?: StringNullableListFilter
    disable?: BoolFilter | boolean
    majors?: KonsentrasiKeahlianListRelationFilter
    role?: RoleListRelationFilter
    schoolYear?: SchoolYearListRelationFilter
    teacher?: TeacherListRelationFilter
    student?: StudentListRelationFilter
    tracker?: TrackerListRelationFilter
    history?: TrackerListRelationFilter
    unikMapels?: MataPelajaranListRelationFilter
    tDevice?: TDeviceListRelationFilter
    objective?: ObjectiveListRelationFilter
    dudi?: DudiListRelationFilter
  }

  export type InstansiOrderByWithRelationInput = {
    id?: SortOrder
    npsn?: SortOrder
    name?: SortOrder
    isPrivate?: SortOrder
    address?: AddressOrderByInput
    level?: SortOrder
    religion?: SortOrder
    major?: SortOrder
    majorIds?: SortOrder
    disable?: SortOrder
    majors?: KonsentrasiKeahlianOrderByRelationAggregateInput
    role?: RoleOrderByRelationAggregateInput
    schoolYear?: SchoolYearOrderByRelationAggregateInput
    teacher?: TeacherOrderByRelationAggregateInput
    student?: StudentOrderByRelationAggregateInput
    tracker?: TrackerOrderByRelationAggregateInput
    history?: TrackerOrderByRelationAggregateInput
    unikMapels?: MataPelajaranOrderByRelationAggregateInput
    tDevice?: TDeviceOrderByRelationAggregateInput
    objective?: ObjectiveOrderByRelationAggregateInput
    dudi?: DudiOrderByRelationAggregateInput
  }

  export type InstansiWhereUniqueInput = {
    id?: string
    npsn?: string
  }

  export type InstansiOrderByWithAggregationInput = {
    id?: SortOrder
    npsn?: SortOrder
    name?: SortOrder
    isPrivate?: SortOrder
    level?: SortOrder
    religion?: SortOrder
    major?: SortOrder
    majorIds?: SortOrder
    disable?: SortOrder
    _count?: InstansiCountOrderByAggregateInput
    _max?: InstansiMaxOrderByAggregateInput
    _min?: InstansiMinOrderByAggregateInput
  }

  export type InstansiScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InstansiScalarWhereWithAggregatesInput>
    OR?: Enumerable<InstansiScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InstansiScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    npsn?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    isPrivate?: BoolWithAggregatesFilter | boolean
    level?: EnumLevelWithAggregatesFilter | Level
    religion?: EnumReligionNullableWithAggregatesFilter | Religion | null
    major?: BoolNullableWithAggregatesFilter | boolean | null
    majorIds?: StringNullableListFilter
    disable?: BoolWithAggregatesFilter | boolean
  }

  export type MataPelajaranWhereInput = {
    AND?: Enumerable<MataPelajaranWhereInput>
    OR?: Enumerable<MataPelajaranWhereInput>
    NOT?: Enumerable<MataPelajaranWhereInput>
    id?: StringFilter | string
    level?: EnumLevelNullableFilter | Level | null
    type?: EnumMataPelajaranTypeFilter | MataPelajaranType
    no?: StringFilter | string
    code?: StringFilter | string
    name?: StringFilter | string
    religion?: EnumReligionNullableFilter | Religion | null
    programId?: StringNullableFilter | string | null
    keahlianid?: StringNullableFilter | string | null
    instansiId?: StringNullableFilter | string | null
    disable?: BoolFilter | boolean
    program?: XOR<ProgramKeahlianRelationFilter, ProgramKeahlianWhereInput> | null
    keahlian?: XOR<KonsentrasiKeahlianRelationFilter, KonsentrasiKeahlianWhereInput> | null
    instansi?: XOR<InstansiRelationFilter, InstansiWhereInput> | null
    element?: ElementListRelationFilter
    schedule?: ScheduleListRelationFilter
    tracker?: TrackerListRelationFilter
    objective?: ObjectiveListRelationFilter
    device?: TDeviceListRelationFilter
  }

  export type MataPelajaranOrderByWithRelationInput = {
    id?: SortOrder
    level?: SortOrder
    type?: SortOrder
    no?: SortOrder
    code?: SortOrder
    name?: SortOrder
    religion?: SortOrder
    programId?: SortOrder
    keahlianid?: SortOrder
    instansiId?: SortOrder
    disable?: SortOrder
    program?: ProgramKeahlianOrderByWithRelationInput
    keahlian?: KonsentrasiKeahlianOrderByWithRelationInput
    instansi?: InstansiOrderByWithRelationInput
    element?: ElementOrderByRelationAggregateInput
    schedule?: ScheduleOrderByRelationAggregateInput
    tracker?: TrackerOrderByRelationAggregateInput
    objective?: ObjectiveOrderByRelationAggregateInput
    device?: TDeviceOrderByRelationAggregateInput
  }

  export type MataPelajaranWhereUniqueInput = {
    id?: string
    nameMapel?: MataPelajaranNameMapelCompoundUniqueInput
  }

  export type MataPelajaranOrderByWithAggregationInput = {
    id?: SortOrder
    level?: SortOrder
    type?: SortOrder
    no?: SortOrder
    code?: SortOrder
    name?: SortOrder
    religion?: SortOrder
    programId?: SortOrder
    keahlianid?: SortOrder
    instansiId?: SortOrder
    disable?: SortOrder
    _count?: MataPelajaranCountOrderByAggregateInput
    _max?: MataPelajaranMaxOrderByAggregateInput
    _min?: MataPelajaranMinOrderByAggregateInput
  }

  export type MataPelajaranScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MataPelajaranScalarWhereWithAggregatesInput>
    OR?: Enumerable<MataPelajaranScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MataPelajaranScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    level?: EnumLevelNullableWithAggregatesFilter | Level | null
    type?: EnumMataPelajaranTypeWithAggregatesFilter | MataPelajaranType
    no?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    religion?: EnumReligionNullableWithAggregatesFilter | Religion | null
    programId?: StringNullableWithAggregatesFilter | string | null
    keahlianid?: StringNullableWithAggregatesFilter | string | null
    instansiId?: StringNullableWithAggregatesFilter | string | null
    disable?: BoolWithAggregatesFilter | boolean
  }

  export type ElementWhereInput = {
    AND?: Enumerable<ElementWhereInput>
    OR?: Enumerable<ElementWhereInput>
    NOT?: Enumerable<ElementWhereInput>
    id?: StringFilter | string
    no?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    mapelId?: StringFilter | string
    disable?: BoolFilter | boolean
    scheduleClassIds?: StringNullableListFilter
    achievement?: AchievementListRelationFilter
    mapel?: XOR<MataPelajaranRelationFilter, MataPelajaranWhereInput>
    tracker?: TrackerListRelationFilter
    scheduleClass?: TeachingListRelationFilter
    objective?: ObjectiveListRelationFilter
  }

  export type ElementOrderByWithRelationInput = {
    id?: SortOrder
    no?: SortOrder
    name?: SortOrder
    description?: SortOrder
    mapelId?: SortOrder
    disable?: SortOrder
    scheduleClassIds?: SortOrder
    achievement?: AchievementOrderByRelationAggregateInput
    mapel?: MataPelajaranOrderByWithRelationInput
    tracker?: TrackerOrderByRelationAggregateInput
    scheduleClass?: TeachingOrderByRelationAggregateInput
    objective?: ObjectiveOrderByRelationAggregateInput
  }

  export type ElementWhereUniqueInput = {
    id?: string
    nameElement?: ElementNameElementCompoundUniqueInput
  }

  export type ElementOrderByWithAggregationInput = {
    id?: SortOrder
    no?: SortOrder
    name?: SortOrder
    description?: SortOrder
    mapelId?: SortOrder
    disable?: SortOrder
    scheduleClassIds?: SortOrder
    _count?: ElementCountOrderByAggregateInput
    _avg?: ElementAvgOrderByAggregateInput
    _max?: ElementMaxOrderByAggregateInput
    _min?: ElementMinOrderByAggregateInput
    _sum?: ElementSumOrderByAggregateInput
  }

  export type ElementScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ElementScalarWhereWithAggregatesInput>
    OR?: Enumerable<ElementScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ElementScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    no?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    mapelId?: StringWithAggregatesFilter | string
    disable?: BoolWithAggregatesFilter | boolean
    scheduleClassIds?: StringNullableListFilter
  }

  export type AchievementWhereInput = {
    AND?: Enumerable<AchievementWhereInput>
    OR?: Enumerable<AchievementWhereInput>
    NOT?: Enumerable<AchievementWhereInput>
    id?: StringFilter | string
    no?: IntFilter | number
    fase?: EnumFaseFilter | Fase
    description?: StringFilter | string
    elementId?: StringFilter | string
    disable?: BoolFilter | boolean
    element?: XOR<ElementRelationFilter, ElementWhereInput>
    objective?: ObjectiveListRelationFilter
    tracker?: TrackerListRelationFilter
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    no?: SortOrder
    fase?: SortOrder
    description?: SortOrder
    elementId?: SortOrder
    disable?: SortOrder
    element?: ElementOrderByWithRelationInput
    objective?: ObjectiveOrderByRelationAggregateInput
    tracker?: TrackerOrderByRelationAggregateInput
  }

  export type AchievementWhereUniqueInput = {
    id?: string
    nameCP?: AchievementNameCPCompoundUniqueInput
  }

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    no?: SortOrder
    fase?: SortOrder
    description?: SortOrder
    elementId?: SortOrder
    disable?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _avg?: AchievementAvgOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
    _sum?: AchievementSumOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AchievementScalarWhereWithAggregatesInput>
    OR?: Enumerable<AchievementScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AchievementScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    no?: IntWithAggregatesFilter | number
    fase?: EnumFaseWithAggregatesFilter | Fase
    description?: StringWithAggregatesFilter | string
    elementId?: StringWithAggregatesFilter | string
    disable?: BoolWithAggregatesFilter | boolean
  }

  export type BidangKeahlianWhereInput = {
    AND?: Enumerable<BidangKeahlianWhereInput>
    OR?: Enumerable<BidangKeahlianWhereInput>
    NOT?: Enumerable<BidangKeahlianWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    name?: StringFilter | string
    disable?: BoolFilter | boolean
    program?: ProgramKeahlianListRelationFilter
    tracker?: TrackerListRelationFilter
  }

  export type BidangKeahlianOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    disable?: SortOrder
    program?: ProgramKeahlianOrderByRelationAggregateInput
    tracker?: TrackerOrderByRelationAggregateInput
  }

  export type BidangKeahlianWhereUniqueInput = {
    id?: string
    nameBidang?: BidangKeahlianNameBidangCompoundUniqueInput
  }

  export type BidangKeahlianOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    disable?: SortOrder
    _count?: BidangKeahlianCountOrderByAggregateInput
    _max?: BidangKeahlianMaxOrderByAggregateInput
    _min?: BidangKeahlianMinOrderByAggregateInput
  }

  export type BidangKeahlianScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BidangKeahlianScalarWhereWithAggregatesInput>
    OR?: Enumerable<BidangKeahlianScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BidangKeahlianScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    disable?: BoolWithAggregatesFilter | boolean
  }

  export type ProgramKeahlianWhereInput = {
    AND?: Enumerable<ProgramKeahlianWhereInput>
    OR?: Enumerable<ProgramKeahlianWhereInput>
    NOT?: Enumerable<ProgramKeahlianWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    name?: StringFilter | string
    bidangId?: StringFilter | string
    disable?: BoolFilter | boolean
    bidang?: XOR<BidangKeahlianRelationFilter, BidangKeahlianWhereInput>
    konsentrasi?: KonsentrasiKeahlianListRelationFilter
    tracker?: TrackerListRelationFilter
    mapel?: MataPelajaranListRelationFilter
  }

  export type ProgramKeahlianOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    bidangId?: SortOrder
    disable?: SortOrder
    bidang?: BidangKeahlianOrderByWithRelationInput
    konsentrasi?: KonsentrasiKeahlianOrderByRelationAggregateInput
    tracker?: TrackerOrderByRelationAggregateInput
    mapel?: MataPelajaranOrderByRelationAggregateInput
  }

  export type ProgramKeahlianWhereUniqueInput = {
    id?: string
    nameProgram?: ProgramKeahlianNameProgramCompoundUniqueInput
  }

  export type ProgramKeahlianOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    bidangId?: SortOrder
    disable?: SortOrder
    _count?: ProgramKeahlianCountOrderByAggregateInput
    _max?: ProgramKeahlianMaxOrderByAggregateInput
    _min?: ProgramKeahlianMinOrderByAggregateInput
  }

  export type ProgramKeahlianScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProgramKeahlianScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProgramKeahlianScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProgramKeahlianScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    bidangId?: StringWithAggregatesFilter | string
    disable?: BoolWithAggregatesFilter | boolean
  }

  export type KonsentrasiKeahlianWhereInput = {
    AND?: Enumerable<KonsentrasiKeahlianWhereInput>
    OR?: Enumerable<KonsentrasiKeahlianWhereInput>
    NOT?: Enumerable<KonsentrasiKeahlianWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    name?: StringFilter | string
    programId?: StringFilter | string
    tahun?: IntFilter | number
    instansiIds?: StringNullableListFilter
    disable?: BoolFilter | boolean
    program?: XOR<ProgramKeahlianRelationFilter, ProgramKeahlianWhereInput>
    student?: StudentListRelationFilter
    instansi?: InstansiListRelationFilter
    classRoom?: ClassRoomListRelationFilter
    tracker?: TrackerListRelationFilter
    mapel?: MataPelajaranListRelationFilter
    dudi?: DudiListRelationFilter
    kkni?: KkniListRelationFilter
  }

  export type KonsentrasiKeahlianOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    programId?: SortOrder
    tahun?: SortOrder
    instansiIds?: SortOrder
    disable?: SortOrder
    program?: ProgramKeahlianOrderByWithRelationInput
    student?: StudentOrderByRelationAggregateInput
    instansi?: InstansiOrderByRelationAggregateInput
    classRoom?: ClassRoomOrderByRelationAggregateInput
    tracker?: TrackerOrderByRelationAggregateInput
    mapel?: MataPelajaranOrderByRelationAggregateInput
    dudi?: DudiOrderByRelationAggregateInput
    kkni?: KkniOrderByRelationAggregateInput
  }

  export type KonsentrasiKeahlianWhereUniqueInput = {
    id?: string
    nameKonsentrasi?: KonsentrasiKeahlianNameKonsentrasiCompoundUniqueInput
  }

  export type KonsentrasiKeahlianOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    programId?: SortOrder
    tahun?: SortOrder
    instansiIds?: SortOrder
    disable?: SortOrder
    _count?: KonsentrasiKeahlianCountOrderByAggregateInput
    _avg?: KonsentrasiKeahlianAvgOrderByAggregateInput
    _max?: KonsentrasiKeahlianMaxOrderByAggregateInput
    _min?: KonsentrasiKeahlianMinOrderByAggregateInput
    _sum?: KonsentrasiKeahlianSumOrderByAggregateInput
  }

  export type KonsentrasiKeahlianScalarWhereWithAggregatesInput = {
    AND?: Enumerable<KonsentrasiKeahlianScalarWhereWithAggregatesInput>
    OR?: Enumerable<KonsentrasiKeahlianScalarWhereWithAggregatesInput>
    NOT?: Enumerable<KonsentrasiKeahlianScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    programId?: StringWithAggregatesFilter | string
    tahun?: IntWithAggregatesFilter | number
    instansiIds?: StringNullableListFilter
    disable?: BoolWithAggregatesFilter | boolean
  }

  export type RoleWhereInput = {
    AND?: Enumerable<RoleWhereInput>
    OR?: Enumerable<RoleWhereInput>
    NOT?: Enumerable<RoleWhereInput>
    id?: StringFilter | string
    key?: EnumRolesFilter | Roles
    instansiId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    instansi?: XOR<InstansiRelationFilter, InstansiWhereInput>
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    instansiId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instansi?: InstansiOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = {
    id?: string
    nameRole?: RoleNameRoleCompoundUniqueInput
  }

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    instansiId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RoleScalarWhereWithAggregatesInput>
    OR?: Enumerable<RoleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RoleScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    key?: EnumRolesWithAggregatesFilter | Roles
    instansiId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    picture?: StringNullableFilter | string | null
    username?: StringFilter | string
    active?: BoolFilter | boolean
    verify?: BoolFilter | boolean
    password?: StringFilter | string
    passhash?: StringFilter | string
    roleId?: StringNullableFilter | string | null
    disable?: BoolFilter | boolean
    google?: XOR<GoogleNullableCompositeFilter, GoogleObjectEqualityInput> | null
    role?: XOR<RoleRelationFilter, RoleWhereInput> | null
    auth?: XOR<AuthRelationFilter, AuthWhereInput> | null
    tracker?: TrackerListRelationFilter
    objective?: ObjectiveListRelationFilter
    link?: LinkListRelationFilter
    tDevice?: TDeviceListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    picture?: SortOrder
    username?: SortOrder
    active?: SortOrder
    verify?: SortOrder
    password?: SortOrder
    passhash?: SortOrder
    roleId?: SortOrder
    disable?: SortOrder
    google?: GoogleOrderByInput
    role?: RoleOrderByWithRelationInput
    auth?: AuthOrderByWithRelationInput
    tracker?: TrackerOrderByRelationAggregateInput
    objective?: ObjectiveOrderByRelationAggregateInput
    link?: LinkOrderByRelationAggregateInput
    tDevice?: TDeviceOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    username?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    picture?: SortOrder
    username?: SortOrder
    active?: SortOrder
    verify?: SortOrder
    password?: SortOrder
    passhash?: SortOrder
    roleId?: SortOrder
    disable?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    picture?: StringNullableWithAggregatesFilter | string | null
    username?: StringWithAggregatesFilter | string
    active?: BoolWithAggregatesFilter | boolean
    verify?: BoolWithAggregatesFilter | boolean
    password?: StringWithAggregatesFilter | string
    passhash?: StringWithAggregatesFilter | string
    roleId?: StringNullableWithAggregatesFilter | string | null
    disable?: BoolWithAggregatesFilter | boolean
  }

  export type UploadWhereInput = {
    AND?: Enumerable<UploadWhereInput>
    OR?: Enumerable<UploadWhereInput>
    NOT?: Enumerable<UploadWhereInput>
    id?: StringFilter | string
    type?: EnumUploadTypeFilter | UploadType
    name?: StringFilter | string
    url?: StringFilter | string
  }

  export type UploadOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    url?: SortOrder
  }

  export type UploadWhereUniqueInput = {
    id?: string
  }

  export type UploadOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    url?: SortOrder
    _count?: UploadCountOrderByAggregateInput
    _max?: UploadMaxOrderByAggregateInput
    _min?: UploadMinOrderByAggregateInput
  }

  export type UploadScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UploadScalarWhereWithAggregatesInput>
    OR?: Enumerable<UploadScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UploadScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: EnumUploadTypeWithAggregatesFilter | UploadType
    name?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
  }

  export type PersonalWhereInput = {
    AND?: Enumerable<PersonalWhereInput>
    OR?: Enumerable<PersonalWhereInput>
    NOT?: Enumerable<PersonalWhereInput>
    id?: StringFilter | string
    nik?: StringNullableFilter | string | null
    nisn?: StringNullableFilter | string | null
    type?: EnumTypePersonalFilter | TypePersonal
    fullname?: StringFilter | string
    gender?: EnumGenderFilter | Gender
    foreign?: BoolNullableFilter | boolean | null
    country?: StringNullableFilter | string | null
    religion?: EnumReligionFilter | Religion
    born?: XOR<BornCompositeFilter, BornObjectEqualityInput>
    email?: StringNullableFilter | string | null
    belajarId?: StringNullableFilter | string | null
    nophone?: StringNullableFilter | string | null
    isLife?: BoolNullableFilter | boolean | null
    address?: XOR<AddressNullableCompositeFilter, AddressObjectEqualityInput> | null
    education?: XOR<EducationCompositeListFilter, Enumerable<EducationObjectEqualityInput>>
    training?: XOR<TrainingCompositeListFilter, Enumerable<TrainingObjectEqualityInput>>
    employment?: XOR<EmploymentCompositeListFilter, Enumerable<EmploymentObjectEqualityInput>>
    profession?: XOR<ProfessionCompositeListFilter, Enumerable<ProfessionObjectEqualityInput>>
    overseas?: XOR<OverseasCompositeListFilter, Enumerable<OverseasObjectEqualityInput>>
    scientific?: XOR<ScientificCompositeListFilter, Enumerable<ScientificObjectEqualityInput>>
    organization?: XOR<OrganizationCompositeListFilter, Enumerable<OrganizationObjectEqualityInput>>
    papers?: XOR<PapersCompositeListFilter, Enumerable<PapersObjectEqualityInput>>
    innovation?: XOR<InnovationCompositeListFilter, Enumerable<InnovationObjectEqualityInput>>
    award?: XOR<AwardCompositeListFilter, Enumerable<AwardObjectEqualityInput>>
    sourcePerson?: XOR<SourcePersonCompositeListFilter, Enumerable<SourcePersonObjectEqualityInput>>
    contest?: XOR<ContestCompositeListFilter, Enumerable<ContestObjectEqualityInput>>
    documents?: XOR<DocumentsCompositeListFilter, Enumerable<DocumentsObjectEqualityInput>>
    additional?: XOR<AdditionalCompositeListFilter, Enumerable<AdditionalObjectEqualityInput>>
    disable?: BoolFilter | boolean
    auth?: XOR<AuthRelationFilter, AuthWhereInput> | null
    father?: FamilyTreeListRelationFilter
    mother?: FamilyTreeListRelationFilter
    wali?: FamilyTreeListRelationFilter
    couple?: FamilyTreeListRelationFilter
    child?: XOR<FamilyTreeChildRelationFilter, FamilyTreeChildWhereInput> | null
    student?: StudentListRelationFilter
    teacher?: TeacherListRelationFilter
  }

  export type PersonalOrderByWithRelationInput = {
    id?: SortOrder
    nik?: SortOrder
    nisn?: SortOrder
    type?: SortOrder
    fullname?: SortOrder
    gender?: SortOrder
    foreign?: SortOrder
    country?: SortOrder
    religion?: SortOrder
    born?: BornOrderByInput
    email?: SortOrder
    belajarId?: SortOrder
    nophone?: SortOrder
    isLife?: SortOrder
    address?: AddressOrderByInput
    education?: EducationOrderByCompositeAggregateInput
    training?: TrainingOrderByCompositeAggregateInput
    employment?: EmploymentOrderByCompositeAggregateInput
    profession?: ProfessionOrderByCompositeAggregateInput
    overseas?: OverseasOrderByCompositeAggregateInput
    scientific?: ScientificOrderByCompositeAggregateInput
    organization?: OrganizationOrderByCompositeAggregateInput
    papers?: PapersOrderByCompositeAggregateInput
    innovation?: InnovationOrderByCompositeAggregateInput
    award?: AwardOrderByCompositeAggregateInput
    sourcePerson?: SourcePersonOrderByCompositeAggregateInput
    contest?: ContestOrderByCompositeAggregateInput
    documents?: DocumentsOrderByCompositeAggregateInput
    additional?: AdditionalOrderByCompositeAggregateInput
    disable?: SortOrder
    auth?: AuthOrderByWithRelationInput
    father?: FamilyTreeOrderByRelationAggregateInput
    mother?: FamilyTreeOrderByRelationAggregateInput
    wali?: FamilyTreeOrderByRelationAggregateInput
    couple?: FamilyTreeOrderByRelationAggregateInput
    child?: FamilyTreeChildOrderByWithRelationInput
    student?: StudentOrderByRelationAggregateInput
    teacher?: TeacherOrderByRelationAggregateInput
  }

  export type PersonalWhereUniqueInput = {
    id?: string
  }

  export type PersonalOrderByWithAggregationInput = {
    id?: SortOrder
    nik?: SortOrder
    nisn?: SortOrder
    type?: SortOrder
    fullname?: SortOrder
    gender?: SortOrder
    foreign?: SortOrder
    country?: SortOrder
    religion?: SortOrder
    email?: SortOrder
    belajarId?: SortOrder
    nophone?: SortOrder
    isLife?: SortOrder
    disable?: SortOrder
    _count?: PersonalCountOrderByAggregateInput
    _max?: PersonalMaxOrderByAggregateInput
    _min?: PersonalMinOrderByAggregateInput
  }

  export type PersonalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PersonalScalarWhereWithAggregatesInput>
    OR?: Enumerable<PersonalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PersonalScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    nik?: StringNullableWithAggregatesFilter | string | null
    nisn?: StringNullableWithAggregatesFilter | string | null
    type?: EnumTypePersonalWithAggregatesFilter | TypePersonal
    fullname?: StringWithAggregatesFilter | string
    gender?: EnumGenderWithAggregatesFilter | Gender
    foreign?: BoolNullableWithAggregatesFilter | boolean | null
    country?: StringNullableWithAggregatesFilter | string | null
    religion?: EnumReligionWithAggregatesFilter | Religion
    email?: StringNullableWithAggregatesFilter | string | null
    belajarId?: StringNullableWithAggregatesFilter | string | null
    nophone?: StringNullableWithAggregatesFilter | string | null
    isLife?: BoolNullableWithAggregatesFilter | boolean | null
    disable?: BoolWithAggregatesFilter | boolean
  }

  export type AuthWhereInput = {
    AND?: Enumerable<AuthWhereInput>
    OR?: Enumerable<AuthWhereInput>
    NOT?: Enumerable<AuthWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    personalId?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    personal?: XOR<PersonalRelationFilter, PersonalWhereInput>
  }

  export type AuthOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    personalId?: SortOrder
    user?: UserOrderByWithRelationInput
    personal?: PersonalOrderByWithRelationInput
  }

  export type AuthWhereUniqueInput = {
    id?: string
    userId?: string
    personalId?: string
    AuthUserPersonal?: AuthAuthUserPersonalCompoundUniqueInput
  }

  export type AuthOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    personalId?: SortOrder
    _count?: AuthCountOrderByAggregateInput
    _max?: AuthMaxOrderByAggregateInput
    _min?: AuthMinOrderByAggregateInput
  }

  export type AuthScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AuthScalarWhereWithAggregatesInput>
    OR?: Enumerable<AuthScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AuthScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    personalId?: StringWithAggregatesFilter | string
  }

  export type FamilyTreeWhereInput = {
    AND?: Enumerable<FamilyTreeWhereInput>
    OR?: Enumerable<FamilyTreeWhereInput>
    NOT?: Enumerable<FamilyTreeWhereInput>
    id?: StringFilter | string
    nokk?: StringFilter | string
    fatherId?: StringNullableFilter | string | null
    motherId?: StringNullableFilter | string | null
    waliId?: StringNullableFilter | string | null
    coupleId?: StringNullableFilter | string | null
    address?: XOR<AddressCompositeFilter, AddressObjectEqualityInput>
    father?: XOR<PersonalRelationFilter, PersonalWhereInput> | null
    mother?: XOR<PersonalRelationFilter, PersonalWhereInput> | null
    wali?: XOR<PersonalRelationFilter, PersonalWhereInput> | null
    couple?: XOR<PersonalRelationFilter, PersonalWhereInput> | null
    childs?: FamilyTreeChildListRelationFilter
  }

  export type FamilyTreeOrderByWithRelationInput = {
    id?: SortOrder
    nokk?: SortOrder
    fatherId?: SortOrder
    motherId?: SortOrder
    waliId?: SortOrder
    coupleId?: SortOrder
    address?: AddressOrderByInput
    father?: PersonalOrderByWithRelationInput
    mother?: PersonalOrderByWithRelationInput
    wali?: PersonalOrderByWithRelationInput
    couple?: PersonalOrderByWithRelationInput
    childs?: FamilyTreeChildOrderByRelationAggregateInput
  }

  export type FamilyTreeWhereUniqueInput = {
    id?: string
  }

  export type FamilyTreeOrderByWithAggregationInput = {
    id?: SortOrder
    nokk?: SortOrder
    fatherId?: SortOrder
    motherId?: SortOrder
    waliId?: SortOrder
    coupleId?: SortOrder
    _count?: FamilyTreeCountOrderByAggregateInput
    _max?: FamilyTreeMaxOrderByAggregateInput
    _min?: FamilyTreeMinOrderByAggregateInput
  }

  export type FamilyTreeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FamilyTreeScalarWhereWithAggregatesInput>
    OR?: Enumerable<FamilyTreeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FamilyTreeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    nokk?: StringWithAggregatesFilter | string
    fatherId?: StringNullableWithAggregatesFilter | string | null
    motherId?: StringNullableWithAggregatesFilter | string | null
    waliId?: StringNullableWithAggregatesFilter | string | null
    coupleId?: StringNullableWithAggregatesFilter | string | null
  }

  export type FamilyTreeChildWhereInput = {
    AND?: Enumerable<FamilyTreeChildWhereInput>
    OR?: Enumerable<FamilyTreeChildWhereInput>
    NOT?: Enumerable<FamilyTreeChildWhereInput>
    id?: StringFilter | string
    no?: IntFilter | number
    type?: EnumChildTypeFilter | ChildType
    kkId?: StringFilter | string
    personalId?: StringFilter | string
    kk?: XOR<FamilyTreeRelationFilter, FamilyTreeWhereInput>
    personal?: XOR<PersonalRelationFilter, PersonalWhereInput>
  }

  export type FamilyTreeChildOrderByWithRelationInput = {
    id?: SortOrder
    no?: SortOrder
    type?: SortOrder
    kkId?: SortOrder
    personalId?: SortOrder
    kk?: FamilyTreeOrderByWithRelationInput
    personal?: PersonalOrderByWithRelationInput
  }

  export type FamilyTreeChildWhereUniqueInput = {
    id?: string
    personalId?: string
  }

  export type FamilyTreeChildOrderByWithAggregationInput = {
    id?: SortOrder
    no?: SortOrder
    type?: SortOrder
    kkId?: SortOrder
    personalId?: SortOrder
    _count?: FamilyTreeChildCountOrderByAggregateInput
    _avg?: FamilyTreeChildAvgOrderByAggregateInput
    _max?: FamilyTreeChildMaxOrderByAggregateInput
    _min?: FamilyTreeChildMinOrderByAggregateInput
    _sum?: FamilyTreeChildSumOrderByAggregateInput
  }

  export type FamilyTreeChildScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FamilyTreeChildScalarWhereWithAggregatesInput>
    OR?: Enumerable<FamilyTreeChildScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FamilyTreeChildScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    no?: IntWithAggregatesFilter | number
    type?: EnumChildTypeWithAggregatesFilter | ChildType
    kkId?: StringWithAggregatesFilter | string
    personalId?: StringWithAggregatesFilter | string
  }

  export type SchoolYearWhereInput = {
    AND?: Enumerable<SchoolYearWhereInput>
    OR?: Enumerable<SchoolYearWhereInput>
    NOT?: Enumerable<SchoolYearWhereInput>
    id?: StringFilter | string
    year?: IntFilter | number
    instansiId?: StringFilter | string
    departments?: StringNullableListFilter
    organizational?: XOR<OrganizationalCompositeFilter, OrganizationalObjectEqualityInput>
    disable?: BoolFilter | boolean
    instansi?: XOR<InstansiRelationFilter, InstansiWhereInput>
    classRoom?: ClassRoomListRelationFilter
    students?: StudentListRelationFilter
    calendar?: CalendarListRelationFilter
    schedule?: ScheduleListRelationFilter
    objective?: ObjectiveListRelationFilter
    tracker?: TrackerListRelationFilter
    TDevice?: TDeviceListRelationFilter
  }

  export type SchoolYearOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrder
    instansiId?: SortOrder
    departments?: SortOrder
    organizational?: OrganizationalOrderByInput
    disable?: SortOrder
    instansi?: InstansiOrderByWithRelationInput
    classRoom?: ClassRoomOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    calendar?: CalendarOrderByRelationAggregateInput
    schedule?: ScheduleOrderByRelationAggregateInput
    objective?: ObjectiveOrderByRelationAggregateInput
    tracker?: TrackerOrderByRelationAggregateInput
    TDevice?: TDeviceOrderByRelationAggregateInput
  }

  export type SchoolYearWhereUniqueInput = {
    id?: string
    eSchoolYear?: SchoolYearESchoolYearCompoundUniqueInput
  }

  export type SchoolYearOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrder
    instansiId?: SortOrder
    departments?: SortOrder
    disable?: SortOrder
    _count?: SchoolYearCountOrderByAggregateInput
    _avg?: SchoolYearAvgOrderByAggregateInput
    _max?: SchoolYearMaxOrderByAggregateInput
    _min?: SchoolYearMinOrderByAggregateInput
    _sum?: SchoolYearSumOrderByAggregateInput
  }

  export type SchoolYearScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SchoolYearScalarWhereWithAggregatesInput>
    OR?: Enumerable<SchoolYearScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SchoolYearScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    year?: IntWithAggregatesFilter | number
    instansiId?: StringWithAggregatesFilter | string
    departments?: StringNullableListFilter
    disable?: BoolWithAggregatesFilter | boolean
  }

  export type TeacherWhereInput = {
    AND?: Enumerable<TeacherWhereInput>
    OR?: Enumerable<TeacherWhereInput>
    NOT?: Enumerable<TeacherWhereInput>
    id?: StringFilter | string
    personalId?: StringFilter | string
    instansiId?: StringFilter | string
    eventIds?: StringNullableListFilter
    nip?: StringNullableFilter | string | null
    nrg?: StringNullableFilter | string | null
    noKarpeg?: StringNullableFilter | string | null
    tmtTugas?: DateTimeNullableFilter | Date | string | null
    tmtGol?: DateTimeNullableFilter | Date | string | null
    position?: StringNullableFilter | string | null
    rank?: StringNullableFilter | string | null
    period?: StringNullableFilter | string | null
    certificate?: StringNullableFilter | string | null
    disable?: BoolFilter | boolean
    personal?: XOR<PersonalRelationFilter, PersonalWhereInput>
    classRoom?: ClassRoomListRelationFilter
    instansi?: XOR<InstansiRelationFilter, InstansiWhereInput>
    event?: CalendarListRelationFilter
    tracker?: TrackerListRelationFilter
    teaching?: TeachingListRelationFilter
  }

  export type TeacherOrderByWithRelationInput = {
    id?: SortOrder
    personalId?: SortOrder
    instansiId?: SortOrder
    eventIds?: SortOrder
    nip?: SortOrder
    nrg?: SortOrder
    noKarpeg?: SortOrder
    tmtTugas?: SortOrder
    tmtGol?: SortOrder
    position?: SortOrder
    rank?: SortOrder
    period?: SortOrder
    certificate?: SortOrder
    disable?: SortOrder
    personal?: PersonalOrderByWithRelationInput
    classRoom?: ClassRoomOrderByRelationAggregateInput
    instansi?: InstansiOrderByWithRelationInput
    event?: CalendarOrderByRelationAggregateInput
    tracker?: TrackerOrderByRelationAggregateInput
    teaching?: TeachingOrderByRelationAggregateInput
  }

  export type TeacherWhereUniqueInput = {
    id?: string
    teachIn?: TeacherTeachInCompoundUniqueInput
  }

  export type TeacherOrderByWithAggregationInput = {
    id?: SortOrder
    personalId?: SortOrder
    instansiId?: SortOrder
    eventIds?: SortOrder
    nip?: SortOrder
    nrg?: SortOrder
    noKarpeg?: SortOrder
    tmtTugas?: SortOrder
    tmtGol?: SortOrder
    position?: SortOrder
    rank?: SortOrder
    period?: SortOrder
    certificate?: SortOrder
    disable?: SortOrder
    _count?: TeacherCountOrderByAggregateInput
    _max?: TeacherMaxOrderByAggregateInput
    _min?: TeacherMinOrderByAggregateInput
  }

  export type TeacherScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TeacherScalarWhereWithAggregatesInput>
    OR?: Enumerable<TeacherScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TeacherScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    personalId?: StringWithAggregatesFilter | string
    instansiId?: StringWithAggregatesFilter | string
    eventIds?: StringNullableListFilter
    nip?: StringNullableWithAggregatesFilter | string | null
    nrg?: StringNullableWithAggregatesFilter | string | null
    noKarpeg?: StringNullableWithAggregatesFilter | string | null
    tmtTugas?: DateTimeNullableWithAggregatesFilter | Date | string | null
    tmtGol?: DateTimeNullableWithAggregatesFilter | Date | string | null
    position?: StringNullableWithAggregatesFilter | string | null
    rank?: StringNullableWithAggregatesFilter | string | null
    period?: StringNullableWithAggregatesFilter | string | null
    certificate?: StringNullableWithAggregatesFilter | string | null
    disable?: BoolWithAggregatesFilter | boolean
  }

  export type ClassRoomWhereInput = {
    AND?: Enumerable<ClassRoomWhereInput>
    OR?: Enumerable<ClassRoomWhereInput>
    NOT?: Enumerable<ClassRoomWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    yearId?: StringFilter | string
    waliId?: StringFilter | string
    level?: IntFilter | number
    property?: XOR<RoomPropertyNullableCompositeFilter, RoomPropertyObjectEqualityInput> | null
    majorId?: StringNullableFilter | string | null
    studentIds?: StringNullableListFilter
    eventIds?: StringNullableListFilter
    disable?: BoolFilter | boolean
    teachingIds?: StringNullableListFilter
    tDeviceIds?: StringNullableListFilter
    year?: XOR<SchoolYearRelationFilter, SchoolYearWhereInput>
    wali?: XOR<TeacherRelationFilter, TeacherWhereInput>
    major?: XOR<KonsentrasiKeahlianRelationFilter, KonsentrasiKeahlianWhereInput> | null
    students?: StudentListRelationFilter
    event?: CalendarListRelationFilter
    tracker?: TrackerListRelationFilter
    teaching?: TeachingListRelationFilter
    tDevice?: TDeviceListRelationFilter
  }

  export type ClassRoomOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    yearId?: SortOrder
    waliId?: SortOrder
    level?: SortOrder
    property?: RoomPropertyOrderByInput
    majorId?: SortOrder
    studentIds?: SortOrder
    eventIds?: SortOrder
    disable?: SortOrder
    teachingIds?: SortOrder
    tDeviceIds?: SortOrder
    year?: SchoolYearOrderByWithRelationInput
    wali?: TeacherOrderByWithRelationInput
    major?: KonsentrasiKeahlianOrderByWithRelationInput
    students?: StudentOrderByRelationAggregateInput
    event?: CalendarOrderByRelationAggregateInput
    tracker?: TrackerOrderByRelationAggregateInput
    teaching?: TeachingOrderByRelationAggregateInput
    tDevice?: TDeviceOrderByRelationAggregateInput
  }

  export type ClassRoomWhereUniqueInput = {
    id?: string
    nameClassRoom?: ClassRoomNameClassRoomCompoundUniqueInput
  }

  export type ClassRoomOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    yearId?: SortOrder
    waliId?: SortOrder
    level?: SortOrder
    majorId?: SortOrder
    studentIds?: SortOrder
    eventIds?: SortOrder
    disable?: SortOrder
    teachingIds?: SortOrder
    tDeviceIds?: SortOrder
    _count?: ClassRoomCountOrderByAggregateInput
    _avg?: ClassRoomAvgOrderByAggregateInput
    _max?: ClassRoomMaxOrderByAggregateInput
    _min?: ClassRoomMinOrderByAggregateInput
    _sum?: ClassRoomSumOrderByAggregateInput
  }

  export type ClassRoomScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ClassRoomScalarWhereWithAggregatesInput>
    OR?: Enumerable<ClassRoomScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ClassRoomScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    yearId?: StringWithAggregatesFilter | string
    waliId?: StringWithAggregatesFilter | string
    level?: IntWithAggregatesFilter | number
    majorId?: StringNullableWithAggregatesFilter | string | null
    studentIds?: StringNullableListFilter
    eventIds?: StringNullableListFilter
    disable?: BoolWithAggregatesFilter | boolean
    teachingIds?: StringNullableListFilter
    tDeviceIds?: StringNullableListFilter
  }

  export type StudentWhereInput = {
    AND?: Enumerable<StudentWhereInput>
    OR?: Enumerable<StudentWhereInput>
    NOT?: Enumerable<StudentWhereInput>
    id?: StringFilter | string
    nis?: StringFilter | string
    lastSchool?: StringFilter | string
    personalId?: StringFilter | string
    majorId?: StringNullableFilter | string | null
    classRoomIds?: StringNullableListFilter
    startYearId?: StringFilter | string
    instansiId?: StringFilter | string
    eventIds?: StringNullableListFilter
    disable?: BoolFilter | boolean
    personal?: XOR<PersonalRelationFilter, PersonalWhereInput>
    major?: XOR<KonsentrasiKeahlianRelationFilter, KonsentrasiKeahlianWhereInput> | null
    classRoom?: ClassRoomListRelationFilter
    startYear?: XOR<SchoolYearRelationFilter, SchoolYearWhereInput>
    instansi?: XOR<InstansiRelationFilter, InstansiWhereInput>
    event?: CalendarListRelationFilter
    tracker?: TrackerListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    nis?: SortOrder
    lastSchool?: SortOrder
    personalId?: SortOrder
    majorId?: SortOrder
    classRoomIds?: SortOrder
    startYearId?: SortOrder
    instansiId?: SortOrder
    eventIds?: SortOrder
    disable?: SortOrder
    personal?: PersonalOrderByWithRelationInput
    major?: KonsentrasiKeahlianOrderByWithRelationInput
    classRoom?: ClassRoomOrderByRelationAggregateInput
    startYear?: SchoolYearOrderByWithRelationInput
    instansi?: InstansiOrderByWithRelationInput
    event?: CalendarOrderByRelationAggregateInput
    tracker?: TrackerOrderByRelationAggregateInput
  }

  export type StudentWhereUniqueInput = {
    id?: string
    studyIn?: StudentStudyInCompoundUniqueInput
  }

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    nis?: SortOrder
    lastSchool?: SortOrder
    personalId?: SortOrder
    majorId?: SortOrder
    classRoomIds?: SortOrder
    startYearId?: SortOrder
    instansiId?: SortOrder
    eventIds?: SortOrder
    disable?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StudentScalarWhereWithAggregatesInput>
    OR?: Enumerable<StudentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StudentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    nis?: StringWithAggregatesFilter | string
    lastSchool?: StringWithAggregatesFilter | string
    personalId?: StringWithAggregatesFilter | string
    majorId?: StringNullableWithAggregatesFilter | string | null
    classRoomIds?: StringNullableListFilter
    startYearId?: StringWithAggregatesFilter | string
    instansiId?: StringWithAggregatesFilter | string
    eventIds?: StringNullableListFilter
    disable?: BoolWithAggregatesFilter | boolean
  }

  export type ScheduleWhereInput = {
    AND?: Enumerable<ScheduleWhereInput>
    OR?: Enumerable<ScheduleWhereInput>
    NOT?: Enumerable<ScheduleWhereInput>
    id?: StringFilter | string
    yearId?: StringFilter | string
    mapelId?: StringFilter | string
    disable?: BoolFilter | boolean
    year?: XOR<SchoolYearRelationFilter, SchoolYearWhereInput>
    mapel?: XOR<MataPelajaranRelationFilter, MataPelajaranWhereInput>
    tracker?: TrackerListRelationFilter
    teaching?: TeachingListRelationFilter
  }

  export type ScheduleOrderByWithRelationInput = {
    id?: SortOrder
    yearId?: SortOrder
    mapelId?: SortOrder
    disable?: SortOrder
    year?: SchoolYearOrderByWithRelationInput
    mapel?: MataPelajaranOrderByWithRelationInput
    tracker?: TrackerOrderByRelationAggregateInput
    teaching?: TeachingOrderByRelationAggregateInput
  }

  export type ScheduleWhereUniqueInput = {
    id?: string
    yearId_mapelId?: ScheduleYearIdMapelIdCompoundUniqueInput
  }

  export type ScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    yearId?: SortOrder
    mapelId?: SortOrder
    disable?: SortOrder
    _count?: ScheduleCountOrderByAggregateInput
    _max?: ScheduleMaxOrderByAggregateInput
    _min?: ScheduleMinOrderByAggregateInput
  }

  export type ScheduleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ScheduleScalarWhereWithAggregatesInput>
    OR?: Enumerable<ScheduleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ScheduleScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    yearId?: StringWithAggregatesFilter | string
    mapelId?: StringWithAggregatesFilter | string
    disable?: BoolWithAggregatesFilter | boolean
  }

  export type TeachingWhereInput = {
    AND?: Enumerable<TeachingWhereInput>
    OR?: Enumerable<TeachingWhereInput>
    NOT?: Enumerable<TeachingWhereInput>
    id?: StringFilter | string
    refId?: StringFilter | string
    level?: IntFilter | number
    hours?: IntFilter | number
    semester?: EnumSemesterFilter | Semester
    teacherId?: StringFilter | string
    classRoomIds?: StringNullableListFilter
    elemenIds?: StringNullableListFilter
    disable?: BoolFilter | boolean
    ref?: XOR<ScheduleRelationFilter, ScheduleWhereInput>
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
    classRoom?: ClassRoomListRelationFilter
    elemen?: ElementListRelationFilter
    tracker?: TrackerListRelationFilter
    tDevice?: TDeviceListRelationFilter
  }

  export type TeachingOrderByWithRelationInput = {
    id?: SortOrder
    refId?: SortOrder
    level?: SortOrder
    hours?: SortOrder
    semester?: SortOrder
    teacherId?: SortOrder
    classRoomIds?: SortOrder
    elemenIds?: SortOrder
    disable?: SortOrder
    ref?: ScheduleOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
    classRoom?: ClassRoomOrderByRelationAggregateInput
    elemen?: ElementOrderByRelationAggregateInput
    tracker?: TrackerOrderByRelationAggregateInput
    tDevice?: TDeviceOrderByRelationAggregateInput
  }

  export type TeachingWhereUniqueInput = {
    id?: string
    level_semester_refId_teacherId?: TeachingLevelSemesterRefIdTeacherIdCompoundUniqueInput
  }

  export type TeachingOrderByWithAggregationInput = {
    id?: SortOrder
    refId?: SortOrder
    level?: SortOrder
    hours?: SortOrder
    semester?: SortOrder
    teacherId?: SortOrder
    classRoomIds?: SortOrder
    elemenIds?: SortOrder
    disable?: SortOrder
    _count?: TeachingCountOrderByAggregateInput
    _avg?: TeachingAvgOrderByAggregateInput
    _max?: TeachingMaxOrderByAggregateInput
    _min?: TeachingMinOrderByAggregateInput
    _sum?: TeachingSumOrderByAggregateInput
  }

  export type TeachingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TeachingScalarWhereWithAggregatesInput>
    OR?: Enumerable<TeachingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TeachingScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    refId?: StringWithAggregatesFilter | string
    level?: IntWithAggregatesFilter | number
    hours?: IntWithAggregatesFilter | number
    semester?: EnumSemesterWithAggregatesFilter | Semester
    teacherId?: StringWithAggregatesFilter | string
    classRoomIds?: StringNullableListFilter
    elemenIds?: StringNullableListFilter
    disable?: BoolWithAggregatesFilter | boolean
  }

  export type LinkWhereInput = {
    AND?: Enumerable<LinkWhereInput>
    OR?: Enumerable<LinkWhereInput>
    NOT?: Enumerable<LinkWhereInput>
    id?: StringFilter | string
    url?: StringNullableFilter | string | null
    title?: StringFilter | string
    description?: StringNullableFilter | string | null
    image?: StringNullableFilter | string | null
    width?: IntNullableFilter | number | null
    height?: IntNullableFilter | number | null
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    objResource?: OresourceListRelationFilter
  }

  export type LinkOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    width?: SortOrder
    height?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    objResource?: OresourceOrderByRelationAggregateInput
  }

  export type LinkWhereUniqueInput = {
    id?: string
    url?: string
  }

  export type LinkOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    width?: SortOrder
    height?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LinkCountOrderByAggregateInput
    _avg?: LinkAvgOrderByAggregateInput
    _max?: LinkMaxOrderByAggregateInput
    _min?: LinkMinOrderByAggregateInput
    _sum?: LinkSumOrderByAggregateInput
  }

  export type LinkScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LinkScalarWhereWithAggregatesInput>
    OR?: Enumerable<LinkScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LinkScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    url?: StringNullableWithAggregatesFilter | string | null
    title?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    image?: StringNullableWithAggregatesFilter | string | null
    width?: IntNullableWithAggregatesFilter | number | null
    height?: IntNullableWithAggregatesFilter | number | null
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OAssessmentWhereInput = {
    AND?: Enumerable<OAssessmentWhereInput>
    OR?: Enumerable<OAssessmentWhereInput>
    NOT?: Enumerable<OAssessmentWhereInput>
    id?: StringFilter | string
    refId?: StringFilter | string
    type?: StringFilter | string
    techs?: StringNullableListFilter
    ref?: XOR<ObjectiveRelationFilter, ObjectiveWhereInput>
  }

  export type OAssessmentOrderByWithRelationInput = {
    id?: SortOrder
    refId?: SortOrder
    type?: SortOrder
    techs?: SortOrder
    ref?: ObjectiveOrderByWithRelationInput
  }

  export type OAssessmentWhereUniqueInput = {
    id?: string
  }

  export type OAssessmentOrderByWithAggregationInput = {
    id?: SortOrder
    refId?: SortOrder
    type?: SortOrder
    techs?: SortOrder
    _count?: OAssessmentCountOrderByAggregateInput
    _max?: OAssessmentMaxOrderByAggregateInput
    _min?: OAssessmentMinOrderByAggregateInput
  }

  export type OAssessmentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OAssessmentScalarWhereWithAggregatesInput>
    OR?: Enumerable<OAssessmentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OAssessmentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    refId?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    techs?: StringNullableListFilter
  }

  export type ObjectiveWhereInput = {
    AND?: Enumerable<ObjectiveWhereInput>
    OR?: Enumerable<ObjectiveWhereInput>
    NOT?: Enumerable<ObjectiveWhereInput>
    id?: StringFilter | string
    level?: IntFilter | number
    fase?: EnumFaseFilter | Fase
    userId?: StringFilter | string
    instansiId?: StringFilter | string
    yearId?: StringFilter | string
    mapelId?: StringFilter | string
    elementId?: StringFilter | string
    achievementId?: StringFilter | string
    code?: StringFilter | string
    kkm?: IntFilter | number
    steps?: IntFilter | number
    subjectMatter?: StringFilter | string
    competencie?: StringNullableListFilter
    firstSkill?: StringNullableListFilter
    triggerQuest?: StringNullableListFilter
    disable?: BoolFilter | boolean
    toolIds?: StringNullableListFilter
    mateIds?: StringNullableListFilter
    methIds?: StringNullableListFilter
    mediaIds?: StringNullableListFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
    instansi?: XOR<InstansiRelationFilter, InstansiWhereInput>
    year?: XOR<SchoolYearRelationFilter, SchoolYearWhereInput>
    mapel?: XOR<MataPelajaranRelationFilter, MataPelajaranWhereInput>
    elemen?: XOR<ElementRelationFilter, ElementWhereInput>
    achievement?: XOR<AchievementRelationFilter, AchievementWhereInput>
    material?: OMaterialListRelationFilter
    tracker?: TrackerListRelationFilter
    resourse?: OresourceListRelationFilter
    ppp?: OpppListRelationFilter
    tool?: OhelperListRelationFilter
    mate?: OhelperListRelationFilter
    meth?: OhelperListRelationFilter
    media?: OhelperListRelationFilter
    assessments?: OAssessmentListRelationFilter
    devices?: TDeviceDataListRelationFilter
  }

  export type ObjectiveOrderByWithRelationInput = {
    id?: SortOrder
    level?: SortOrder
    fase?: SortOrder
    userId?: SortOrder
    instansiId?: SortOrder
    yearId?: SortOrder
    mapelId?: SortOrder
    elementId?: SortOrder
    achievementId?: SortOrder
    code?: SortOrder
    kkm?: SortOrder
    steps?: SortOrder
    subjectMatter?: SortOrder
    competencie?: SortOrder
    firstSkill?: SortOrder
    triggerQuest?: SortOrder
    disable?: SortOrder
    toolIds?: SortOrder
    mateIds?: SortOrder
    methIds?: SortOrder
    mediaIds?: SortOrder
    user?: UserOrderByWithRelationInput
    instansi?: InstansiOrderByWithRelationInput
    year?: SchoolYearOrderByWithRelationInput
    mapel?: MataPelajaranOrderByWithRelationInput
    elemen?: ElementOrderByWithRelationInput
    achievement?: AchievementOrderByWithRelationInput
    material?: OMaterialOrderByRelationAggregateInput
    tracker?: TrackerOrderByRelationAggregateInput
    resourse?: OresourceOrderByRelationAggregateInput
    ppp?: OpppOrderByRelationAggregateInput
    tool?: OhelperOrderByRelationAggregateInput
    mate?: OhelperOrderByRelationAggregateInput
    meth?: OhelperOrderByRelationAggregateInput
    media?: OhelperOrderByRelationAggregateInput
    assessments?: OAssessmentOrderByRelationAggregateInput
    devices?: TDeviceDataOrderByRelationAggregateInput
  }

  export type ObjectiveWhereUniqueInput = {
    id?: string
  }

  export type ObjectiveOrderByWithAggregationInput = {
    id?: SortOrder
    level?: SortOrder
    fase?: SortOrder
    userId?: SortOrder
    instansiId?: SortOrder
    yearId?: SortOrder
    mapelId?: SortOrder
    elementId?: SortOrder
    achievementId?: SortOrder
    code?: SortOrder
    kkm?: SortOrder
    steps?: SortOrder
    subjectMatter?: SortOrder
    competencie?: SortOrder
    firstSkill?: SortOrder
    triggerQuest?: SortOrder
    disable?: SortOrder
    toolIds?: SortOrder
    mateIds?: SortOrder
    methIds?: SortOrder
    mediaIds?: SortOrder
    _count?: ObjectiveCountOrderByAggregateInput
    _avg?: ObjectiveAvgOrderByAggregateInput
    _max?: ObjectiveMaxOrderByAggregateInput
    _min?: ObjectiveMinOrderByAggregateInput
    _sum?: ObjectiveSumOrderByAggregateInput
  }

  export type ObjectiveScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ObjectiveScalarWhereWithAggregatesInput>
    OR?: Enumerable<ObjectiveScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ObjectiveScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    level?: IntWithAggregatesFilter | number
    fase?: EnumFaseWithAggregatesFilter | Fase
    userId?: StringWithAggregatesFilter | string
    instansiId?: StringWithAggregatesFilter | string
    yearId?: StringWithAggregatesFilter | string
    mapelId?: StringWithAggregatesFilter | string
    elementId?: StringWithAggregatesFilter | string
    achievementId?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    kkm?: IntWithAggregatesFilter | number
    steps?: IntWithAggregatesFilter | number
    subjectMatter?: StringWithAggregatesFilter | string
    competencie?: StringNullableListFilter
    firstSkill?: StringNullableListFilter
    triggerQuest?: StringNullableListFilter
    disable?: BoolWithAggregatesFilter | boolean
    toolIds?: StringNullableListFilter
    mateIds?: StringNullableListFilter
    methIds?: StringNullableListFilter
    mediaIds?: StringNullableListFilter
  }

  export type OMaterialWhereInput = {
    AND?: Enumerable<OMaterialWhereInput>
    OR?: Enumerable<OMaterialWhereInput>
    NOT?: Enumerable<OMaterialWhereInput>
    id?: StringFilter | string
    refId?: StringFilter | string
    no?: IntFilter | number
    content?: StringFilter | string
    model?: EnumOMaterialModelFilter | OMaterialModel
    ref?: XOR<ObjectiveRelationFilter, ObjectiveWhereInput>
    learning?: OLearningListRelationFilter
  }

  export type OMaterialOrderByWithRelationInput = {
    id?: SortOrder
    refId?: SortOrder
    no?: SortOrder
    content?: SortOrder
    model?: SortOrder
    ref?: ObjectiveOrderByWithRelationInput
    learning?: OLearningOrderByRelationAggregateInput
  }

  export type OMaterialWhereUniqueInput = {
    id?: string
    no_refId?: OMaterialNoRefIdCompoundUniqueInput
  }

  export type OMaterialOrderByWithAggregationInput = {
    id?: SortOrder
    refId?: SortOrder
    no?: SortOrder
    content?: SortOrder
    model?: SortOrder
    _count?: OMaterialCountOrderByAggregateInput
    _avg?: OMaterialAvgOrderByAggregateInput
    _max?: OMaterialMaxOrderByAggregateInput
    _min?: OMaterialMinOrderByAggregateInput
    _sum?: OMaterialSumOrderByAggregateInput
  }

  export type OMaterialScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OMaterialScalarWhereWithAggregatesInput>
    OR?: Enumerable<OMaterialScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OMaterialScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    refId?: StringWithAggregatesFilter | string
    no?: IntWithAggregatesFilter | number
    content?: StringWithAggregatesFilter | string
    model?: EnumOMaterialModelWithAggregatesFilter | OMaterialModel
  }

  export type OLearningWhereInput = {
    AND?: Enumerable<OLearningWhereInput>
    OR?: Enumerable<OLearningWhereInput>
    NOT?: Enumerable<OLearningWhereInput>
    id?: StringFilter | string
    refId?: StringFilter | string
    no?: IntFilter | number
    content?: StringFilter | string
    taksonomi?: EnumTaksonomiFilter | Taksonomi
    sentence?: StringFilter | string
    ref?: XOR<OMaterialRelationFilter, OMaterialWhereInput>
  }

  export type OLearningOrderByWithRelationInput = {
    id?: SortOrder
    refId?: SortOrder
    no?: SortOrder
    content?: SortOrder
    taksonomi?: SortOrder
    sentence?: SortOrder
    ref?: OMaterialOrderByWithRelationInput
  }

  export type OLearningWhereUniqueInput = {
    id?: string
    no_refId?: OLearningNoRefIdCompoundUniqueInput
  }

  export type OLearningOrderByWithAggregationInput = {
    id?: SortOrder
    refId?: SortOrder
    no?: SortOrder
    content?: SortOrder
    taksonomi?: SortOrder
    sentence?: SortOrder
    _count?: OLearningCountOrderByAggregateInput
    _avg?: OLearningAvgOrderByAggregateInput
    _max?: OLearningMaxOrderByAggregateInput
    _min?: OLearningMinOrderByAggregateInput
    _sum?: OLearningSumOrderByAggregateInput
  }

  export type OLearningScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OLearningScalarWhereWithAggregatesInput>
    OR?: Enumerable<OLearningScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OLearningScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    refId?: StringWithAggregatesFilter | string
    no?: IntWithAggregatesFilter | number
    content?: StringWithAggregatesFilter | string
    taksonomi?: EnumTaksonomiWithAggregatesFilter | Taksonomi
    sentence?: StringWithAggregatesFilter | string
  }

  export type OhelperWhereInput = {
    AND?: Enumerable<OhelperWhereInput>
    OR?: Enumerable<OhelperWhereInput>
    NOT?: Enumerable<OhelperWhereInput>
    id?: StringFilter | string
    type?: EnumOhelperTypeFilter | OhelperType
    name?: StringFilter | string
    toolIds?: StringNullableListFilter
    mateIds?: StringNullableListFilter
    methIds?: StringNullableListFilter
    mediaIds?: StringNullableListFilter
    tool?: ObjectiveListRelationFilter
    mate?: ObjectiveListRelationFilter
    meth?: ObjectiveListRelationFilter
    media?: ObjectiveListRelationFilter
  }

  export type OhelperOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    toolIds?: SortOrder
    mateIds?: SortOrder
    methIds?: SortOrder
    mediaIds?: SortOrder
    tool?: ObjectiveOrderByRelationAggregateInput
    mate?: ObjectiveOrderByRelationAggregateInput
    meth?: ObjectiveOrderByRelationAggregateInput
    media?: ObjectiveOrderByRelationAggregateInput
  }

  export type OhelperWhereUniqueInput = {
    id?: string
    type_name?: OhelperTypeNameCompoundUniqueInput
  }

  export type OhelperOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    toolIds?: SortOrder
    mateIds?: SortOrder
    methIds?: SortOrder
    mediaIds?: SortOrder
    _count?: OhelperCountOrderByAggregateInput
    _max?: OhelperMaxOrderByAggregateInput
    _min?: OhelperMinOrderByAggregateInput
  }

  export type OhelperScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OhelperScalarWhereWithAggregatesInput>
    OR?: Enumerable<OhelperScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OhelperScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: EnumOhelperTypeWithAggregatesFilter | OhelperType
    name?: StringWithAggregatesFilter | string
    toolIds?: StringNullableListFilter
    mateIds?: StringNullableListFilter
    methIds?: StringNullableListFilter
    mediaIds?: StringNullableListFilter
  }

  export type OpppWhereInput = {
    AND?: Enumerable<OpppWhereInput>
    OR?: Enumerable<OpppWhereInput>
    NOT?: Enumerable<OpppWhereInput>
    id?: StringFilter | string
    refId?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    ref?: XOR<ObjectiveRelationFilter, ObjectiveWhereInput>
  }

  export type OpppOrderByWithRelationInput = {
    id?: SortOrder
    refId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ref?: ObjectiveOrderByWithRelationInput
  }

  export type OpppWhereUniqueInput = {
    id?: string
    refId_name?: OpppRefIdNameCompoundUniqueInput
  }

  export type OpppOrderByWithAggregationInput = {
    id?: SortOrder
    refId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    _count?: OpppCountOrderByAggregateInput
    _max?: OpppMaxOrderByAggregateInput
    _min?: OpppMinOrderByAggregateInput
  }

  export type OpppScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OpppScalarWhereWithAggregatesInput>
    OR?: Enumerable<OpppScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OpppScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    refId?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type OresourceWhereInput = {
    AND?: Enumerable<OresourceWhereInput>
    OR?: Enumerable<OresourceWhereInput>
    NOT?: Enumerable<OresourceWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    type?: EnumOresourceTypeFilter | OresourceType
    refId?: StringFilter | string
    linkId?: StringNullableFilter | string | null
    ref?: XOR<ObjectiveRelationFilter, ObjectiveWhereInput>
    link?: XOR<LinkRelationFilter, LinkWhereInput> | null
  }

  export type OresourceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    refId?: SortOrder
    linkId?: SortOrder
    ref?: ObjectiveOrderByWithRelationInput
    link?: LinkOrderByWithRelationInput
  }

  export type OresourceWhereUniqueInput = {
    id?: string
    keys?: OresourceKeysCompoundUniqueInput
  }

  export type OresourceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    refId?: SortOrder
    linkId?: SortOrder
    _count?: OresourceCountOrderByAggregateInput
    _max?: OresourceMaxOrderByAggregateInput
    _min?: OresourceMinOrderByAggregateInput
  }

  export type OresourceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OresourceScalarWhereWithAggregatesInput>
    OR?: Enumerable<OresourceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OresourceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    type?: EnumOresourceTypeWithAggregatesFilter | OresourceType
    refId?: StringWithAggregatesFilter | string
    linkId?: StringNullableWithAggregatesFilter | string | null
  }

  export type BookWhereInput = {
    AND?: Enumerable<BookWhereInput>
    OR?: Enumerable<BookWhereInput>
    NOT?: Enumerable<BookWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    author?: StringNullableFilter | string | null
  }

  export type BookOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    author?: SortOrder
  }

  export type BookWhereUniqueInput = {
    id?: string
  }

  export type BookOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    author?: SortOrder
    _count?: BookCountOrderByAggregateInput
    _max?: BookMaxOrderByAggregateInput
    _min?: BookMinOrderByAggregateInput
  }

  export type BookScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BookScalarWhereWithAggregatesInput>
    OR?: Enumerable<BookScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BookScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    author?: StringNullableWithAggregatesFilter | string | null
  }

  export type TDeviceWhereInput = {
    AND?: Enumerable<TDeviceWhereInput>
    OR?: Enumerable<TDeviceWhereInput>
    NOT?: Enumerable<TDeviceWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    level?: IntFilter | number
    fase?: EnumFaseFilter | Fase
    teachingId?: StringFilter | string
    property?: XOR<TDevicePropsCompositeFilter, TDevicePropsObjectEqualityInput>
    yearId?: StringFilter | string
    userId?: StringFilter | string
    instansiId?: StringFilter | string
    mapelId?: StringFilter | string
    classRoomIds?: StringNullableListFilter
    elemen?: StringNullableListFilter
    disable?: BoolFilter | boolean
    parentId?: StringNullableFilter | string | null
    positions?: XOR<TDevicePosCompositeListFilter, Enumerable<TDevicePosObjectEqualityInput>>
    teaching?: XOR<TeachingRelationFilter, TeachingWhereInput>
    year?: XOR<SchoolYearRelationFilter, SchoolYearWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    instansi?: XOR<InstansiRelationFilter, InstansiWhereInput>
    mapel?: XOR<MataPelajaranRelationFilter, MataPelajaranWhereInput>
    classRoom?: ClassRoomListRelationFilter
    tracker?: TrackerListRelationFilter
    data?: TDeviceDataListRelationFilter
    children?: TDeviceListRelationFilter
    parent?: XOR<TDeviceRelationFilter, TDeviceWhereInput> | null
  }

  export type TDeviceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    fase?: SortOrder
    teachingId?: SortOrder
    property?: TDevicePropsOrderByInput
    yearId?: SortOrder
    userId?: SortOrder
    instansiId?: SortOrder
    mapelId?: SortOrder
    classRoomIds?: SortOrder
    elemen?: SortOrder
    disable?: SortOrder
    parentId?: SortOrder
    positions?: TDevicePosOrderByCompositeAggregateInput
    teaching?: TeachingOrderByWithRelationInput
    year?: SchoolYearOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    instansi?: InstansiOrderByWithRelationInput
    mapel?: MataPelajaranOrderByWithRelationInput
    classRoom?: ClassRoomOrderByRelationAggregateInput
    tracker?: TrackerOrderByRelationAggregateInput
    data?: TDeviceDataOrderByRelationAggregateInput
    children?: TDeviceOrderByRelationAggregateInput
    parent?: TDeviceOrderByWithRelationInput
  }

  export type TDeviceWhereUniqueInput = {
    id?: string
  }

  export type TDeviceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    fase?: SortOrder
    teachingId?: SortOrder
    yearId?: SortOrder
    userId?: SortOrder
    instansiId?: SortOrder
    mapelId?: SortOrder
    classRoomIds?: SortOrder
    elemen?: SortOrder
    disable?: SortOrder
    parentId?: SortOrder
    _count?: TDeviceCountOrderByAggregateInput
    _avg?: TDeviceAvgOrderByAggregateInput
    _max?: TDeviceMaxOrderByAggregateInput
    _min?: TDeviceMinOrderByAggregateInput
    _sum?: TDeviceSumOrderByAggregateInput
  }

  export type TDeviceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TDeviceScalarWhereWithAggregatesInput>
    OR?: Enumerable<TDeviceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TDeviceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    level?: IntWithAggregatesFilter | number
    fase?: EnumFaseWithAggregatesFilter | Fase
    teachingId?: StringWithAggregatesFilter | string
    yearId?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    instansiId?: StringWithAggregatesFilter | string
    mapelId?: StringWithAggregatesFilter | string
    classRoomIds?: StringNullableListFilter
    elemen?: StringNullableListFilter
    disable?: BoolWithAggregatesFilter | boolean
    parentId?: StringNullableWithAggregatesFilter | string | null
  }

  export type TDeviceDataWhereInput = {
    AND?: Enumerable<TDeviceDataWhereInput>
    OR?: Enumerable<TDeviceDataWhereInput>
    NOT?: Enumerable<TDeviceDataWhereInput>
    id?: StringFilter | string
    refId?: StringFilter | string
    objectiveId?: StringFilter | string
    positions?: XOR<TDevicePosCompositeListFilter, Enumerable<TDevicePosObjectEqualityInput>>
    ref?: XOR<TDeviceRelationFilter, TDeviceWhereInput>
    objective?: XOR<ObjectiveRelationFilter, ObjectiveWhereInput>
  }

  export type TDeviceDataOrderByWithRelationInput = {
    id?: SortOrder
    refId?: SortOrder
    objectiveId?: SortOrder
    positions?: TDevicePosOrderByCompositeAggregateInput
    ref?: TDeviceOrderByWithRelationInput
    objective?: ObjectiveOrderByWithRelationInput
  }

  export type TDeviceDataWhereUniqueInput = {
    id?: string
  }

  export type TDeviceDataOrderByWithAggregationInput = {
    id?: SortOrder
    refId?: SortOrder
    objectiveId?: SortOrder
    _count?: TDeviceDataCountOrderByAggregateInput
    _max?: TDeviceDataMaxOrderByAggregateInput
    _min?: TDeviceDataMinOrderByAggregateInput
  }

  export type TDeviceDataScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TDeviceDataScalarWhereWithAggregatesInput>
    OR?: Enumerable<TDeviceDataScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TDeviceDataScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    refId?: StringWithAggregatesFilter | string
    objectiveId?: StringWithAggregatesFilter | string
  }

  export type CalendarWhereInput = {
    AND?: Enumerable<CalendarWhereInput>
    OR?: Enumerable<CalendarWhereInput>
    NOT?: Enumerable<CalendarWhereInput>
    id?: StringFilter | string
    refId?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    start?: DateTimeFilter | Date | string
    end?: DateTimeNullableFilter | Date | string | null
    color?: StringFilter | string
    classRoomIds?: StringNullableListFilter
    studentIds?: StringNullableListFilter
    teacherIds?: StringNullableListFilter
    disable?: BoolFilter | boolean
    ref?: XOR<SchoolYearRelationFilter, SchoolYearWhereInput>
    classRoom?: ClassRoomListRelationFilter
    student?: StudentListRelationFilter
    teacher?: TeacherListRelationFilter
    tracker?: TrackerListRelationFilter
  }

  export type CalendarOrderByWithRelationInput = {
    id?: SortOrder
    refId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    start?: SortOrder
    end?: SortOrder
    color?: SortOrder
    classRoomIds?: SortOrder
    studentIds?: SortOrder
    teacherIds?: SortOrder
    disable?: SortOrder
    ref?: SchoolYearOrderByWithRelationInput
    classRoom?: ClassRoomOrderByRelationAggregateInput
    student?: StudentOrderByRelationAggregateInput
    teacher?: TeacherOrderByRelationAggregateInput
    tracker?: TrackerOrderByRelationAggregateInput
  }

  export type CalendarWhereUniqueInput = {
    id?: string
  }

  export type CalendarOrderByWithAggregationInput = {
    id?: SortOrder
    refId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    start?: SortOrder
    end?: SortOrder
    color?: SortOrder
    classRoomIds?: SortOrder
    studentIds?: SortOrder
    teacherIds?: SortOrder
    disable?: SortOrder
    _count?: CalendarCountOrderByAggregateInput
    _max?: CalendarMaxOrderByAggregateInput
    _min?: CalendarMinOrderByAggregateInput
  }

  export type CalendarScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CalendarScalarWhereWithAggregatesInput>
    OR?: Enumerable<CalendarScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CalendarScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    refId?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    start?: DateTimeWithAggregatesFilter | Date | string
    end?: DateTimeNullableWithAggregatesFilter | Date | string | null
    color?: StringWithAggregatesFilter | string
    classRoomIds?: StringNullableListFilter
    studentIds?: StringNullableListFilter
    teacherIds?: StringNullableListFilter
    disable?: BoolWithAggregatesFilter | boolean
  }

  export type DudiWhereInput = {
    AND?: Enumerable<DudiWhereInput>
    OR?: Enumerable<DudiWhereInput>
    NOT?: Enumerable<DudiWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    street?: StringFilter | string
    address?: XOR<AddressCompositeFilter, AddressObjectEqualityInput>
    instansiId?: StringFilter | string
    majorId?: StringFilter | string
    contact?: XOR<ContactDudiCompositeFilter, ContactDudiObjectEqualityInput>
    collabs?: StringNullableListFilter
    timework?: XOR<DudiTimeWorkCompositeFilter, DudiTimeWorkObjectEqualityInput>
    disable?: BoolFilter | boolean
    kkniId?: StringNullableFilter | string | null
    instansi?: XOR<InstansiRelationFilter, InstansiWhereInput>
    major?: XOR<KonsentrasiKeahlianRelationFilter, KonsentrasiKeahlianWhereInput>
    learning?: DudiLearningListRelationFilter
    tracker?: TrackerListRelationFilter
    kkni?: XOR<KkniRelationFilter, KkniWhereInput> | null
  }

  export type DudiOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    street?: SortOrder
    address?: AddressOrderByInput
    instansiId?: SortOrder
    majorId?: SortOrder
    contact?: ContactDudiOrderByInput
    collabs?: SortOrder
    timework?: DudiTimeWorkOrderByInput
    disable?: SortOrder
    kkniId?: SortOrder
    instansi?: InstansiOrderByWithRelationInput
    major?: KonsentrasiKeahlianOrderByWithRelationInput
    learning?: DudiLearningOrderByRelationAggregateInput
    tracker?: TrackerOrderByRelationAggregateInput
    kkni?: KkniOrderByWithRelationInput
  }

  export type DudiWhereUniqueInput = {
    id?: string
  }

  export type DudiOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    street?: SortOrder
    instansiId?: SortOrder
    majorId?: SortOrder
    collabs?: SortOrder
    disable?: SortOrder
    kkniId?: SortOrder
    _count?: DudiCountOrderByAggregateInput
    _max?: DudiMaxOrderByAggregateInput
    _min?: DudiMinOrderByAggregateInput
  }

  export type DudiScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DudiScalarWhereWithAggregatesInput>
    OR?: Enumerable<DudiScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DudiScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    street?: StringWithAggregatesFilter | string
    instansiId?: StringWithAggregatesFilter | string
    majorId?: StringWithAggregatesFilter | string
    collabs?: StringNullableListFilter
    disable?: BoolWithAggregatesFilter | boolean
    kkniId?: StringNullableWithAggregatesFilter | string | null
  }

  export type DudiLearningWhereInput = {
    AND?: Enumerable<DudiLearningWhereInput>
    OR?: Enumerable<DudiLearningWhereInput>
    NOT?: Enumerable<DudiLearningWhereInput>
    id?: StringFilter | string
    no?: IntFilter | number
    refId?: StringFilter | string
    code?: StringFilter | string
    name?: StringFilter | string
    indicator?: XOR<DudiIndicatorCompositeListFilter, Enumerable<DudiIndicatorObjectEqualityInput>>
    ref?: XOR<DudiRelationFilter, DudiWhereInput>
  }

  export type DudiLearningOrderByWithRelationInput = {
    id?: SortOrder
    no?: SortOrder
    refId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    indicator?: DudiIndicatorOrderByCompositeAggregateInput
    ref?: DudiOrderByWithRelationInput
  }

  export type DudiLearningWhereUniqueInput = {
    id?: string
  }

  export type DudiLearningOrderByWithAggregationInput = {
    id?: SortOrder
    no?: SortOrder
    refId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    _count?: DudiLearningCountOrderByAggregateInput
    _avg?: DudiLearningAvgOrderByAggregateInput
    _max?: DudiLearningMaxOrderByAggregateInput
    _min?: DudiLearningMinOrderByAggregateInput
    _sum?: DudiLearningSumOrderByAggregateInput
  }

  export type DudiLearningScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DudiLearningScalarWhereWithAggregatesInput>
    OR?: Enumerable<DudiLearningScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DudiLearningScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    no?: IntWithAggregatesFilter | number
    refId?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
  }

  export type KkniWhereInput = {
    AND?: Enumerable<KkniWhereInput>
    OR?: Enumerable<KkniWhereInput>
    NOT?: Enumerable<KkniWhereInput>
    id?: StringFilter | string
    konsentrasiId?: StringFilter | string
    no?: IntFilter | number
    code?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    disable?: BoolFilter | boolean
    konsentrasi?: XOR<KonsentrasiKeahlianRelationFilter, KonsentrasiKeahlianWhereInput>
    dudi?: DudiListRelationFilter
    tracker?: TrackerListRelationFilter
  }

  export type KkniOrderByWithRelationInput = {
    id?: SortOrder
    konsentrasiId?: SortOrder
    no?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    disable?: SortOrder
    konsentrasi?: KonsentrasiKeahlianOrderByWithRelationInput
    dudi?: DudiOrderByRelationAggregateInput
    tracker?: TrackerOrderByRelationAggregateInput
  }

  export type KkniWhereUniqueInput = {
    id?: string
  }

  export type KkniOrderByWithAggregationInput = {
    id?: SortOrder
    konsentrasiId?: SortOrder
    no?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    disable?: SortOrder
    _count?: KkniCountOrderByAggregateInput
    _avg?: KkniAvgOrderByAggregateInput
    _max?: KkniMaxOrderByAggregateInput
    _min?: KkniMinOrderByAggregateInput
    _sum?: KkniSumOrderByAggregateInput
  }

  export type KkniScalarWhereWithAggregatesInput = {
    AND?: Enumerable<KkniScalarWhereWithAggregatesInput>
    OR?: Enumerable<KkniScalarWhereWithAggregatesInput>
    NOT?: Enumerable<KkniScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    konsentrasiId?: StringWithAggregatesFilter | string
    no?: IntWithAggregatesFilter | number
    code?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    disable?: BoolWithAggregatesFilter | boolean
  }

  export type TrackerCreateInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrackerInput
    ref: InstansiCreateNestedOneWithoutHistoryInput
    instansi?: InstansiCreateNestedOneWithoutTrackerInput
    mapel?: MataPelajaranCreateNestedOneWithoutTrackerInput
    elemen?: ElementCreateNestedOneWithoutTrackerInput
    cp?: AchievementCreateNestedOneWithoutTrackerInput
    bidang?: BidangKeahlianCreateNestedOneWithoutTrackerInput
    program?: ProgramKeahlianCreateNestedOneWithoutTrackerInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedOneWithoutTrackerInput
    tp?: SchoolYearCreateNestedOneWithoutTrackerInput
    teacher?: TeacherCreateNestedOneWithoutTrackerInput
    kelas?: ClassRoomCreateNestedOneWithoutTrackerInput
    murid?: StudentCreateNestedOneWithoutTrackerInput
    jadwal?: ScheduleCreateNestedOneWithoutTrackerInput
    mengajar?: TeachingCreateNestedOneWithoutTrackerInput
    tujuan?: ObjectiveCreateNestedOneWithoutTrackerInput
    perangkat?: TDeviceCreateNestedOneWithoutTrackerInput
    kalender?: CalendarCreateNestedOneWithoutTrackerInput
    dudi?: DudiCreateNestedOneWithoutTrackerInput
    kkni?: KkniCreateNestedOneWithoutTrackerInput
  }

  export type TrackerUncheckedCreateInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TrackerUpdateInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrackerNestedInput
    ref?: InstansiUpdateOneRequiredWithoutHistoryNestedInput
    instansi?: InstansiUpdateOneWithoutTrackerNestedInput
    mapel?: MataPelajaranUpdateOneWithoutTrackerNestedInput
    elemen?: ElementUpdateOneWithoutTrackerNestedInput
    cp?: AchievementUpdateOneWithoutTrackerNestedInput
    bidang?: BidangKeahlianUpdateOneWithoutTrackerNestedInput
    program?: ProgramKeahlianUpdateOneWithoutTrackerNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateOneWithoutTrackerNestedInput
    tp?: SchoolYearUpdateOneWithoutTrackerNestedInput
    teacher?: TeacherUpdateOneWithoutTrackerNestedInput
    kelas?: ClassRoomUpdateOneWithoutTrackerNestedInput
    murid?: StudentUpdateOneWithoutTrackerNestedInput
    jadwal?: ScheduleUpdateOneWithoutTrackerNestedInput
    mengajar?: TeachingUpdateOneWithoutTrackerNestedInput
    tujuan?: ObjectiveUpdateOneWithoutTrackerNestedInput
    perangkat?: TDeviceUpdateOneWithoutTrackerNestedInput
    kalender?: CalendarUpdateOneWithoutTrackerNestedInput
    dudi?: DudiUpdateOneWithoutTrackerNestedInput
    kkni?: KkniUpdateOneWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    userId?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapelId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    cpId?: NullableStringFieldUpdateOperationsInput | string | null
    bidangId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    konsentrasiId?: NullableStringFieldUpdateOperationsInput | string | null
    tpId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    kelasId?: NullableStringFieldUpdateOperationsInput | string | null
    muridId?: NullableStringFieldUpdateOperationsInput | string | null
    jadwalId?: NullableStringFieldUpdateOperationsInput | string | null
    mengajarId?: NullableStringFieldUpdateOperationsInput | string | null
    tujuanId?: NullableStringFieldUpdateOperationsInput | string | null
    perangkatId?: NullableStringFieldUpdateOperationsInput | string | null
    kalenderId?: NullableStringFieldUpdateOperationsInput | string | null
    dudiId?: NullableStringFieldUpdateOperationsInput | string | null
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrackerCreateManyInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TrackerUpdateManyMutationInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackerUncheckedUpdateManyInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    userId?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapelId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    cpId?: NullableStringFieldUpdateOperationsInput | string | null
    bidangId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    konsentrasiId?: NullableStringFieldUpdateOperationsInput | string | null
    tpId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    kelasId?: NullableStringFieldUpdateOperationsInput | string | null
    muridId?: NullableStringFieldUpdateOperationsInput | string | null
    jadwalId?: NullableStringFieldUpdateOperationsInput | string | null
    mengajarId?: NullableStringFieldUpdateOperationsInput | string | null
    tujuanId?: NullableStringFieldUpdateOperationsInput | string | null
    perangkatId?: NullableStringFieldUpdateOperationsInput | string | null
    kalenderId?: NullableStringFieldUpdateOperationsInput | string | null
    dudiId?: NullableStringFieldUpdateOperationsInput | string | null
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InstansiCreateInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    disable?: boolean
    majors?: KonsentrasiKeahlianCreateNestedManyWithoutInstansiInput
    role?: RoleCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearCreateNestedManyWithoutInstansiInput
    teacher?: TeacherCreateNestedManyWithoutInstansiInput
    student?: StudentCreateNestedManyWithoutInstansiInput
    tracker?: TrackerCreateNestedManyWithoutInstansiInput
    history?: TrackerCreateNestedManyWithoutRefInput
    unikMapels?: MataPelajaranCreateNestedManyWithoutInstansiInput
    tDevice?: TDeviceCreateNestedManyWithoutInstansiInput
    objective?: ObjectiveCreateNestedManyWithoutInstansiInput
    dudi?: DudiCreateNestedManyWithoutInstansiInput
  }

  export type InstansiUncheckedCreateInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    majorIds?: InstansiCreatemajorIdsInput | Enumerable<string>
    disable?: boolean
    majors?: KonsentrasiKeahlianUncheckedCreateNestedManyWithoutInstansiInput
    role?: RoleUncheckedCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearUncheckedCreateNestedManyWithoutInstansiInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutInstansiInput
    student?: StudentUncheckedCreateNestedManyWithoutInstansiInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutInstansiInput
    history?: TrackerUncheckedCreateNestedManyWithoutRefInput
    unikMapels?: MataPelajaranUncheckedCreateNestedManyWithoutInstansiInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutInstansiInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutInstansiInput
    dudi?: DudiUncheckedCreateNestedManyWithoutInstansiInput
  }

  export type InstansiUpdateInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    majors?: KonsentrasiKeahlianUpdateManyWithoutInstansiNestedInput
    role?: RoleUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUpdateManyWithoutInstansiNestedInput
    student?: StudentUpdateManyWithoutInstansiNestedInput
    tracker?: TrackerUpdateManyWithoutInstansiNestedInput
    history?: TrackerUpdateManyWithoutRefNestedInput
    unikMapels?: MataPelajaranUpdateManyWithoutInstansiNestedInput
    tDevice?: TDeviceUpdateManyWithoutInstansiNestedInput
    objective?: ObjectiveUpdateManyWithoutInstansiNestedInput
    dudi?: DudiUpdateManyWithoutInstansiNestedInput
  }

  export type InstansiUncheckedUpdateInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    majorIds?: InstansiUpdatemajorIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    majors?: KonsentrasiKeahlianUncheckedUpdateManyWithoutInstansiNestedInput
    role?: RoleUncheckedUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUncheckedUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutInstansiNestedInput
    student?: StudentUncheckedUpdateManyWithoutInstansiNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutInstansiNestedInput
    history?: TrackerUncheckedUpdateManyWithoutRefNestedInput
    unikMapels?: MataPelajaranUncheckedUpdateManyWithoutInstansiNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutInstansiNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutInstansiNestedInput
    dudi?: DudiUncheckedUpdateManyWithoutInstansiNestedInput
  }

  export type InstansiCreateManyInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    majorIds?: InstansiCreatemajorIdsInput | Enumerable<string>
    disable?: boolean
  }

  export type InstansiUpdateManyMutationInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InstansiUncheckedUpdateManyInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    majorIds?: InstansiUpdatemajorIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MataPelajaranCreateInput = {
    id?: string
    level?: Level | null
    type?: MataPelajaranType
    no: string
    code: string
    name: string
    religion?: Religion | null
    disable?: boolean
    program?: ProgramKeahlianCreateNestedOneWithoutMapelInput
    keahlian?: KonsentrasiKeahlianCreateNestedOneWithoutMapelInput
    instansi?: InstansiCreateNestedOneWithoutUnikMapelsInput
    element?: ElementCreateNestedManyWithoutMapelInput
    schedule?: ScheduleCreateNestedManyWithoutMapelInput
    tracker?: TrackerCreateNestedManyWithoutMapelInput
    objective?: ObjectiveCreateNestedManyWithoutMapelInput
    device?: TDeviceCreateNestedManyWithoutMapelInput
  }

  export type MataPelajaranUncheckedCreateInput = {
    id?: string
    level?: Level | null
    type?: MataPelajaranType
    no: string
    code: string
    name: string
    religion?: Religion | null
    programId?: string | null
    keahlianid?: string | null
    instansiId?: string | null
    disable?: boolean
    element?: ElementUncheckedCreateNestedManyWithoutMapelInput
    schedule?: ScheduleUncheckedCreateNestedManyWithoutMapelInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutMapelInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutMapelInput
    device?: TDeviceUncheckedCreateNestedManyWithoutMapelInput
  }

  export type MataPelajaranUpdateInput = {
    level?: NullableEnumLevelFieldUpdateOperationsInput | Level | null
    type?: EnumMataPelajaranTypeFieldUpdateOperationsInput | MataPelajaranType
    no?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    program?: ProgramKeahlianUpdateOneWithoutMapelNestedInput
    keahlian?: KonsentrasiKeahlianUpdateOneWithoutMapelNestedInput
    instansi?: InstansiUpdateOneWithoutUnikMapelsNestedInput
    element?: ElementUpdateManyWithoutMapelNestedInput
    schedule?: ScheduleUpdateManyWithoutMapelNestedInput
    tracker?: TrackerUpdateManyWithoutMapelNestedInput
    objective?: ObjectiveUpdateManyWithoutMapelNestedInput
    device?: TDeviceUpdateManyWithoutMapelNestedInput
  }

  export type MataPelajaranUncheckedUpdateInput = {
    level?: NullableEnumLevelFieldUpdateOperationsInput | Level | null
    type?: EnumMataPelajaranTypeFieldUpdateOperationsInput | MataPelajaranType
    no?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    keahlianid?: NullableStringFieldUpdateOperationsInput | string | null
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    element?: ElementUncheckedUpdateManyWithoutMapelNestedInput
    schedule?: ScheduleUncheckedUpdateManyWithoutMapelNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutMapelNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutMapelNestedInput
    device?: TDeviceUncheckedUpdateManyWithoutMapelNestedInput
  }

  export type MataPelajaranCreateManyInput = {
    id?: string
    level?: Level | null
    type?: MataPelajaranType
    no: string
    code: string
    name: string
    religion?: Religion | null
    programId?: string | null
    keahlianid?: string | null
    instansiId?: string | null
    disable?: boolean
  }

  export type MataPelajaranUpdateManyMutationInput = {
    level?: NullableEnumLevelFieldUpdateOperationsInput | Level | null
    type?: EnumMataPelajaranTypeFieldUpdateOperationsInput | MataPelajaranType
    no?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MataPelajaranUncheckedUpdateManyInput = {
    level?: NullableEnumLevelFieldUpdateOperationsInput | Level | null
    type?: EnumMataPelajaranTypeFieldUpdateOperationsInput | MataPelajaranType
    no?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    keahlianid?: NullableStringFieldUpdateOperationsInput | string | null
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ElementCreateInput = {
    id?: string
    no: number
    name: string
    description: string
    disable?: boolean
    achievement?: AchievementCreateNestedManyWithoutElementInput
    mapel: MataPelajaranCreateNestedOneWithoutElementInput
    tracker?: TrackerCreateNestedManyWithoutElemenInput
    scheduleClass?: TeachingCreateNestedManyWithoutElemenInput
    objective?: ObjectiveCreateNestedManyWithoutElemenInput
  }

  export type ElementUncheckedCreateInput = {
    id?: string
    no: number
    name: string
    description: string
    mapelId: string
    disable?: boolean
    scheduleClassIds?: ElementCreatescheduleClassIdsInput | Enumerable<string>
    achievement?: AchievementUncheckedCreateNestedManyWithoutElementInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutElemenInput
    scheduleClass?: TeachingUncheckedCreateNestedManyWithoutElemenInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutElemenInput
  }

  export type ElementUpdateInput = {
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    achievement?: AchievementUpdateManyWithoutElementNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutElementNestedInput
    tracker?: TrackerUpdateManyWithoutElemenNestedInput
    scheduleClass?: TeachingUpdateManyWithoutElemenNestedInput
    objective?: ObjectiveUpdateManyWithoutElemenNestedInput
  }

  export type ElementUncheckedUpdateInput = {
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    scheduleClassIds?: ElementUpdatescheduleClassIdsInput | Enumerable<string>
    achievement?: AchievementUncheckedUpdateManyWithoutElementNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutElemenNestedInput
    scheduleClass?: TeachingUncheckedUpdateManyWithoutElemenNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutElemenNestedInput
  }

  export type ElementCreateManyInput = {
    id?: string
    no: number
    name: string
    description: string
    mapelId: string
    disable?: boolean
    scheduleClassIds?: ElementCreatescheduleClassIdsInput | Enumerable<string>
  }

  export type ElementUpdateManyMutationInput = {
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ElementUncheckedUpdateManyInput = {
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    scheduleClassIds?: ElementUpdatescheduleClassIdsInput | Enumerable<string>
  }

  export type AchievementCreateInput = {
    id?: string
    no: number
    fase?: Fase
    description: string
    disable?: boolean
    element: ElementCreateNestedOneWithoutAchievementInput
    objective?: ObjectiveCreateNestedManyWithoutAchievementInput
    tracker?: TrackerCreateNestedManyWithoutCpInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: string
    no: number
    fase?: Fase
    description: string
    elementId: string
    disable?: boolean
    objective?: ObjectiveUncheckedCreateNestedManyWithoutAchievementInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutCpInput
  }

  export type AchievementUpdateInput = {
    no?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    description?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    element?: ElementUpdateOneRequiredWithoutAchievementNestedInput
    objective?: ObjectiveUpdateManyWithoutAchievementNestedInput
    tracker?: TrackerUpdateManyWithoutCpNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    no?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    description?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    objective?: ObjectiveUncheckedUpdateManyWithoutAchievementNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutCpNestedInput
  }

  export type AchievementCreateManyInput = {
    id?: string
    no: number
    fase?: Fase
    description: string
    elementId: string
    disable?: boolean
  }

  export type AchievementUpdateManyMutationInput = {
    no?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    description?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AchievementUncheckedUpdateManyInput = {
    no?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    description?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BidangKeahlianCreateInput = {
    id?: string
    code: string
    name: string
    disable?: boolean
    program?: ProgramKeahlianCreateNestedManyWithoutBidangInput
    tracker?: TrackerCreateNestedManyWithoutBidangInput
  }

  export type BidangKeahlianUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    disable?: boolean
    program?: ProgramKeahlianUncheckedCreateNestedManyWithoutBidangInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutBidangInput
  }

  export type BidangKeahlianUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    program?: ProgramKeahlianUpdateManyWithoutBidangNestedInput
    tracker?: TrackerUpdateManyWithoutBidangNestedInput
  }

  export type BidangKeahlianUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    program?: ProgramKeahlianUncheckedUpdateManyWithoutBidangNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutBidangNestedInput
  }

  export type BidangKeahlianCreateManyInput = {
    id?: string
    code: string
    name: string
    disable?: boolean
  }

  export type BidangKeahlianUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BidangKeahlianUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProgramKeahlianCreateInput = {
    id?: string
    code: string
    name: string
    disable?: boolean
    bidang: BidangKeahlianCreateNestedOneWithoutProgramInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedManyWithoutProgramInput
    tracker?: TrackerCreateNestedManyWithoutProgramInput
    mapel?: MataPelajaranCreateNestedManyWithoutProgramInput
  }

  export type ProgramKeahlianUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    bidangId: string
    disable?: boolean
    konsentrasi?: KonsentrasiKeahlianUncheckedCreateNestedManyWithoutProgramInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutProgramInput
    mapel?: MataPelajaranUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramKeahlianUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    bidang?: BidangKeahlianUpdateOneRequiredWithoutProgramNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateManyWithoutProgramNestedInput
    tracker?: TrackerUpdateManyWithoutProgramNestedInput
    mapel?: MataPelajaranUpdateManyWithoutProgramNestedInput
  }

  export type ProgramKeahlianUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bidangId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    konsentrasi?: KonsentrasiKeahlianUncheckedUpdateManyWithoutProgramNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutProgramNestedInput
    mapel?: MataPelajaranUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramKeahlianCreateManyInput = {
    id?: string
    code: string
    name: string
    bidangId: string
    disable?: boolean
  }

  export type ProgramKeahlianUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProgramKeahlianUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bidangId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type KonsentrasiKeahlianCreateInput = {
    id?: string
    code: string
    name: string
    tahun: number
    disable?: boolean
    program: ProgramKeahlianCreateNestedOneWithoutKonsentrasiInput
    student?: StudentCreateNestedManyWithoutMajorInput
    instansi?: InstansiCreateNestedManyWithoutMajorsInput
    classRoom?: ClassRoomCreateNestedManyWithoutMajorInput
    tracker?: TrackerCreateNestedManyWithoutKonsentrasiInput
    mapel?: MataPelajaranCreateNestedManyWithoutKeahlianInput
    dudi?: DudiCreateNestedManyWithoutMajorInput
    kkni?: KkniCreateNestedManyWithoutKonsentrasiInput
  }

  export type KonsentrasiKeahlianUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    programId: string
    tahun: number
    instansiIds?: KonsentrasiKeahlianCreateinstansiIdsInput | Enumerable<string>
    disable?: boolean
    student?: StudentUncheckedCreateNestedManyWithoutMajorInput
    instansi?: InstansiUncheckedCreateNestedManyWithoutMajorsInput
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutMajorInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutKonsentrasiInput
    mapel?: MataPelajaranUncheckedCreateNestedManyWithoutKeahlianInput
    dudi?: DudiUncheckedCreateNestedManyWithoutMajorInput
    kkni?: KkniUncheckedCreateNestedManyWithoutKonsentrasiInput
  }

  export type KonsentrasiKeahlianUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    disable?: BoolFieldUpdateOperationsInput | boolean
    program?: ProgramKeahlianUpdateOneRequiredWithoutKonsentrasiNestedInput
    student?: StudentUpdateManyWithoutMajorNestedInput
    instansi?: InstansiUpdateManyWithoutMajorsNestedInput
    classRoom?: ClassRoomUpdateManyWithoutMajorNestedInput
    tracker?: TrackerUpdateManyWithoutKonsentrasiNestedInput
    mapel?: MataPelajaranUpdateManyWithoutKeahlianNestedInput
    dudi?: DudiUpdateManyWithoutMajorNestedInput
    kkni?: KkniUpdateManyWithoutKonsentrasiNestedInput
  }

  export type KonsentrasiKeahlianUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    instansiIds?: KonsentrasiKeahlianUpdateinstansiIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUncheckedUpdateManyWithoutMajorNestedInput
    instansi?: InstansiUncheckedUpdateManyWithoutMajorsNestedInput
    classRoom?: ClassRoomUncheckedUpdateManyWithoutMajorNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutKonsentrasiNestedInput
    mapel?: MataPelajaranUncheckedUpdateManyWithoutKeahlianNestedInput
    dudi?: DudiUncheckedUpdateManyWithoutMajorNestedInput
    kkni?: KkniUncheckedUpdateManyWithoutKonsentrasiNestedInput
  }

  export type KonsentrasiKeahlianCreateManyInput = {
    id?: string
    code: string
    name: string
    programId: string
    tahun: number
    instansiIds?: KonsentrasiKeahlianCreateinstansiIdsInput | Enumerable<string>
    disable?: boolean
  }

  export type KonsentrasiKeahlianUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type KonsentrasiKeahlianUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    instansiIds?: KonsentrasiKeahlianUpdateinstansiIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoleCreateInput = {
    id?: string
    key: Roles
    createdAt?: Date | string
    updatedAt?: Date | string
    instansi: InstansiCreateNestedOneWithoutRoleInput
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    key: Roles
    instansiId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    key?: EnumRolesFieldUpdateOperationsInput | Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instansi?: InstansiUpdateOneRequiredWithoutRoleNestedInput
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    key?: EnumRolesFieldUpdateOperationsInput | Roles
    instansiId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    key: Roles
    instansiId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    key?: EnumRolesFieldUpdateOperationsInput | Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    key?: EnumRolesFieldUpdateOperationsInput | Roles
    instansiId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    disable?: boolean
    google?: XOR<GoogleNullableCreateEnvelopeInput, GoogleCreateInput> | null
    role?: RoleCreateNestedOneWithoutUsersInput
    auth?: AuthCreateNestedOneWithoutUserInput
    tracker?: TrackerCreateNestedManyWithoutUserInput
    objective?: ObjectiveCreateNestedManyWithoutUserInput
    link?: LinkCreateNestedManyWithoutUserInput
    tDevice?: TDeviceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    roleId?: string | null
    disable?: boolean
    google?: XOR<GoogleNullableCreateEnvelopeInput, GoogleCreateInput> | null
    auth?: AuthUncheckedCreateNestedOneWithoutUserInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutUserInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutUserInput
    link?: LinkUncheckedCreateNestedManyWithoutUserInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    google?: XOR<GoogleNullableUpdateEnvelopeInput, GoogleCreateInput> | null
    role?: RoleUpdateOneWithoutUsersNestedInput
    auth?: AuthUpdateOneWithoutUserNestedInput
    tracker?: TrackerUpdateManyWithoutUserNestedInput
    objective?: ObjectiveUpdateManyWithoutUserNestedInput
    link?: LinkUpdateManyWithoutUserNestedInput
    tDevice?: TDeviceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    google?: XOR<GoogleNullableUpdateEnvelopeInput, GoogleCreateInput> | null
    auth?: AuthUncheckedUpdateOneWithoutUserNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutUserNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutUserNestedInput
    link?: LinkUncheckedUpdateManyWithoutUserNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    roleId?: string | null
    disable?: boolean
    google?: XOR<GoogleNullableCreateEnvelopeInput, GoogleCreateInput> | null
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    google?: XOR<GoogleNullableUpdateEnvelopeInput, GoogleCreateInput> | null
  }

  export type UserUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    google?: XOR<GoogleNullableUpdateEnvelopeInput, GoogleCreateInput> | null
  }

  export type UploadCreateInput = {
    id?: string
    type: UploadType
    name: string
    url: string
  }

  export type UploadUncheckedCreateInput = {
    id?: string
    type: UploadType
    name: string
    url: string
  }

  export type UploadUpdateInput = {
    type?: EnumUploadTypeFieldUpdateOperationsInput | UploadType
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type UploadUncheckedUpdateInput = {
    type?: EnumUploadTypeFieldUpdateOperationsInput | UploadType
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type UploadCreateManyInput = {
    id?: string
    type: UploadType
    name: string
    url: string
  }

  export type UploadUpdateManyMutationInput = {
    type?: EnumUploadTypeFieldUpdateOperationsInput | UploadType
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type UploadUncheckedUpdateManyInput = {
    type?: EnumUploadTypeFieldUpdateOperationsInput | UploadType
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type PersonalCreateInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign?: boolean | null
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email?: string | null
    belajarId?: string | null
    nophone?: string | null
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: boolean
    auth?: AuthCreateNestedOneWithoutPersonalInput
    father?: FamilyTreeCreateNestedManyWithoutFatherInput
    mother?: FamilyTreeCreateNestedManyWithoutMotherInput
    wali?: FamilyTreeCreateNestedManyWithoutWaliInput
    couple?: FamilyTreeCreateNestedManyWithoutCoupleInput
    child?: FamilyTreeChildCreateNestedOneWithoutPersonalInput
    student?: StudentCreateNestedManyWithoutPersonalInput
    teacher?: TeacherCreateNestedManyWithoutPersonalInput
  }

  export type PersonalUncheckedCreateInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign?: boolean | null
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email?: string | null
    belajarId?: string | null
    nophone?: string | null
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: boolean
    auth?: AuthUncheckedCreateNestedOneWithoutPersonalInput
    father?: FamilyTreeUncheckedCreateNestedManyWithoutFatherInput
    mother?: FamilyTreeUncheckedCreateNestedManyWithoutMotherInput
    wali?: FamilyTreeUncheckedCreateNestedManyWithoutWaliInput
    couple?: FamilyTreeUncheckedCreateNestedManyWithoutCoupleInput
    child?: FamilyTreeChildUncheckedCreateNestedOneWithoutPersonalInput
    student?: StudentUncheckedCreateNestedManyWithoutPersonalInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutPersonalInput
  }

  export type PersonalUpdateInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: NullableStringFieldUpdateOperationsInput | string | null
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: NullableStringFieldUpdateOperationsInput | string | null
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: BoolFieldUpdateOperationsInput | boolean
    auth?: AuthUpdateOneWithoutPersonalNestedInput
    father?: FamilyTreeUpdateManyWithoutFatherNestedInput
    mother?: FamilyTreeUpdateManyWithoutMotherNestedInput
    wali?: FamilyTreeUpdateManyWithoutWaliNestedInput
    couple?: FamilyTreeUpdateManyWithoutCoupleNestedInput
    child?: FamilyTreeChildUpdateOneWithoutPersonalNestedInput
    student?: StudentUpdateManyWithoutPersonalNestedInput
    teacher?: TeacherUpdateManyWithoutPersonalNestedInput
  }

  export type PersonalUncheckedUpdateInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: NullableStringFieldUpdateOperationsInput | string | null
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: NullableStringFieldUpdateOperationsInput | string | null
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: BoolFieldUpdateOperationsInput | boolean
    auth?: AuthUncheckedUpdateOneWithoutPersonalNestedInput
    father?: FamilyTreeUncheckedUpdateManyWithoutFatherNestedInput
    mother?: FamilyTreeUncheckedUpdateManyWithoutMotherNestedInput
    wali?: FamilyTreeUncheckedUpdateManyWithoutWaliNestedInput
    couple?: FamilyTreeUncheckedUpdateManyWithoutCoupleNestedInput
    child?: FamilyTreeChildUncheckedUpdateOneWithoutPersonalNestedInput
    student?: StudentUncheckedUpdateManyWithoutPersonalNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutPersonalNestedInput
  }

  export type PersonalCreateManyInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign?: boolean | null
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email?: string | null
    belajarId?: string | null
    nophone?: string | null
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: boolean
  }

  export type PersonalUpdateManyMutationInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: NullableStringFieldUpdateOperationsInput | string | null
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: NullableStringFieldUpdateOperationsInput | string | null
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PersonalUncheckedUpdateManyInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: NullableStringFieldUpdateOperationsInput | string | null
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: NullableStringFieldUpdateOperationsInput | string | null
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuthCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutAuthInput
    personal: PersonalCreateNestedOneWithoutAuthInput
  }

  export type AuthUncheckedCreateInput = {
    id?: string
    userId: string
    personalId: string
  }

  export type AuthUpdateInput = {
    user?: UserUpdateOneRequiredWithoutAuthNestedInput
    personal?: PersonalUpdateOneRequiredWithoutAuthNestedInput
  }

  export type AuthUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    personalId?: StringFieldUpdateOperationsInput | string
  }

  export type AuthCreateManyInput = {
    id?: string
    userId: string
    personalId: string
  }

  export type AuthUpdateManyMutationInput = {

  }

  export type AuthUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    personalId?: StringFieldUpdateOperationsInput | string
  }

  export type FamilyTreeCreateInput = {
    id?: string
    nokk: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    father?: PersonalCreateNestedOneWithoutFatherInput
    mother?: PersonalCreateNestedOneWithoutMotherInput
    wali?: PersonalCreateNestedOneWithoutWaliInput
    couple?: PersonalCreateNestedOneWithoutCoupleInput
    childs?: FamilyTreeChildCreateNestedManyWithoutKkInput
  }

  export type FamilyTreeUncheckedCreateInput = {
    id?: string
    nokk: string
    fatherId?: string | null
    motherId?: string | null
    waliId?: string | null
    coupleId?: string | null
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    childs?: FamilyTreeChildUncheckedCreateNestedManyWithoutKkInput
  }

  export type FamilyTreeUpdateInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    father?: PersonalUpdateOneWithoutFatherNestedInput
    mother?: PersonalUpdateOneWithoutMotherNestedInput
    wali?: PersonalUpdateOneWithoutWaliNestedInput
    couple?: PersonalUpdateOneWithoutCoupleNestedInput
    childs?: FamilyTreeChildUpdateManyWithoutKkNestedInput
  }

  export type FamilyTreeUncheckedUpdateInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    fatherId?: NullableStringFieldUpdateOperationsInput | string | null
    motherId?: NullableStringFieldUpdateOperationsInput | string | null
    waliId?: NullableStringFieldUpdateOperationsInput | string | null
    coupleId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    childs?: FamilyTreeChildUncheckedUpdateManyWithoutKkNestedInput
  }

  export type FamilyTreeCreateManyInput = {
    id?: string
    nokk: string
    fatherId?: string | null
    motherId?: string | null
    waliId?: string | null
    coupleId?: string | null
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
  }

  export type FamilyTreeUpdateManyMutationInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
  }

  export type FamilyTreeUncheckedUpdateManyInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    fatherId?: NullableStringFieldUpdateOperationsInput | string | null
    motherId?: NullableStringFieldUpdateOperationsInput | string | null
    waliId?: NullableStringFieldUpdateOperationsInput | string | null
    coupleId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
  }

  export type FamilyTreeChildCreateInput = {
    id?: string
    no: number
    type: ChildType
    kk: FamilyTreeCreateNestedOneWithoutChildsInput
    personal: PersonalCreateNestedOneWithoutChildInput
  }

  export type FamilyTreeChildUncheckedCreateInput = {
    id?: string
    no: number
    type: ChildType
    kkId: string
    personalId: string
  }

  export type FamilyTreeChildUpdateInput = {
    no?: IntFieldUpdateOperationsInput | number
    type?: EnumChildTypeFieldUpdateOperationsInput | ChildType
    kk?: FamilyTreeUpdateOneRequiredWithoutChildsNestedInput
    personal?: PersonalUpdateOneRequiredWithoutChildNestedInput
  }

  export type FamilyTreeChildUncheckedUpdateInput = {
    no?: IntFieldUpdateOperationsInput | number
    type?: EnumChildTypeFieldUpdateOperationsInput | ChildType
    kkId?: StringFieldUpdateOperationsInput | string
    personalId?: StringFieldUpdateOperationsInput | string
  }

  export type FamilyTreeChildCreateManyInput = {
    id?: string
    no: number
    type: ChildType
    kkId: string
    personalId: string
  }

  export type FamilyTreeChildUpdateManyMutationInput = {
    no?: IntFieldUpdateOperationsInput | number
    type?: EnumChildTypeFieldUpdateOperationsInput | ChildType
  }

  export type FamilyTreeChildUncheckedUpdateManyInput = {
    no?: IntFieldUpdateOperationsInput | number
    type?: EnumChildTypeFieldUpdateOperationsInput | ChildType
    kkId?: StringFieldUpdateOperationsInput | string
    personalId?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolYearCreateInput = {
    id?: string
    year: number
    departments?: SchoolYearCreatedepartmentsInput | Enumerable<string>
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    disable?: boolean
    instansi: InstansiCreateNestedOneWithoutSchoolYearInput
    classRoom?: ClassRoomCreateNestedManyWithoutYearInput
    students?: StudentCreateNestedManyWithoutStartYearInput
    calendar?: CalendarCreateNestedManyWithoutRefInput
    schedule?: ScheduleCreateNestedManyWithoutYearInput
    objective?: ObjectiveCreateNestedManyWithoutYearInput
    tracker?: TrackerCreateNestedManyWithoutTpInput
    TDevice?: TDeviceCreateNestedManyWithoutYearInput
  }

  export type SchoolYearUncheckedCreateInput = {
    id?: string
    year: number
    instansiId: string
    departments?: SchoolYearCreatedepartmentsInput | Enumerable<string>
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutYearInput
    students?: StudentUncheckedCreateNestedManyWithoutStartYearInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutRefInput
    schedule?: ScheduleUncheckedCreateNestedManyWithoutYearInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutYearInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTpInput
    TDevice?: TDeviceUncheckedCreateNestedManyWithoutYearInput
  }

  export type SchoolYearUpdateInput = {
    year?: IntFieldUpdateOperationsInput | number
    departments?: SchoolYearUpdatedepartmentsInput | Enumerable<string>
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    instansi?: InstansiUpdateOneRequiredWithoutSchoolYearNestedInput
    classRoom?: ClassRoomUpdateManyWithoutYearNestedInput
    students?: StudentUpdateManyWithoutStartYearNestedInput
    calendar?: CalendarUpdateManyWithoutRefNestedInput
    schedule?: ScheduleUpdateManyWithoutYearNestedInput
    objective?: ObjectiveUpdateManyWithoutYearNestedInput
    tracker?: TrackerUpdateManyWithoutTpNestedInput
    TDevice?: TDeviceUpdateManyWithoutYearNestedInput
  }

  export type SchoolYearUncheckedUpdateInput = {
    year?: IntFieldUpdateOperationsInput | number
    instansiId?: StringFieldUpdateOperationsInput | string
    departments?: SchoolYearUpdatedepartmentsInput | Enumerable<string>
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutYearNestedInput
    students?: StudentUncheckedUpdateManyWithoutStartYearNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutRefNestedInput
    schedule?: ScheduleUncheckedUpdateManyWithoutYearNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutYearNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTpNestedInput
    TDevice?: TDeviceUncheckedUpdateManyWithoutYearNestedInput
  }

  export type SchoolYearCreateManyInput = {
    id?: string
    year: number
    instansiId: string
    departments?: SchoolYearCreatedepartmentsInput | Enumerable<string>
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    disable?: boolean
  }

  export type SchoolYearUpdateManyMutationInput = {
    year?: IntFieldUpdateOperationsInput | number
    departments?: SchoolYearUpdatedepartmentsInput | Enumerable<string>
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SchoolYearUncheckedUpdateManyInput = {
    year?: IntFieldUpdateOperationsInput | number
    instansiId?: StringFieldUpdateOperationsInput | string
    departments?: SchoolYearUpdatedepartmentsInput | Enumerable<string>
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeacherCreateInput = {
    id?: string
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: Date | string | null
    tmtGol?: Date | string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    disable?: boolean
    personal: PersonalCreateNestedOneWithoutTeacherInput
    classRoom?: ClassRoomCreateNestedManyWithoutWaliInput
    instansi: InstansiCreateNestedOneWithoutTeacherInput
    event?: CalendarCreateNestedManyWithoutTeacherInput
    tracker?: TrackerCreateNestedManyWithoutTeacherInput
    teaching?: TeachingCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateInput = {
    id?: string
    personalId: string
    instansiId: string
    eventIds?: TeacherCreateeventIdsInput | Enumerable<string>
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: Date | string | null
    tmtGol?: Date | string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutWaliInput
    event?: CalendarUncheckedCreateNestedManyWithoutTeacherInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTeacherInput
    teaching?: TeachingUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUpdateInput = {
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tmtGol?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    personal?: PersonalUpdateOneRequiredWithoutTeacherNestedInput
    classRoom?: ClassRoomUpdateManyWithoutWaliNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutTeacherNestedInput
    event?: CalendarUpdateManyWithoutTeacherNestedInput
    tracker?: TrackerUpdateManyWithoutTeacherNestedInput
    teaching?: TeachingUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateInput = {
    personalId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: TeacherUpdateeventIdsInput | Enumerable<string>
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tmtGol?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutWaliNestedInput
    event?: CalendarUncheckedUpdateManyWithoutTeacherNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTeacherNestedInput
    teaching?: TeachingUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherCreateManyInput = {
    id?: string
    personalId: string
    instansiId: string
    eventIds?: TeacherCreateeventIdsInput | Enumerable<string>
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: Date | string | null
    tmtGol?: Date | string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    disable?: boolean
  }

  export type TeacherUpdateManyMutationInput = {
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tmtGol?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeacherUncheckedUpdateManyInput = {
    personalId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: TeacherUpdateeventIdsInput | Enumerable<string>
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tmtGol?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassRoomCreateInput = {
    id?: string
    name: string
    level: number
    property?: XOR<RoomPropertyNullableCreateEnvelopeInput, RoomPropertyCreateInput> | null
    disable?: boolean
    year: SchoolYearCreateNestedOneWithoutClassRoomInput
    wali: TeacherCreateNestedOneWithoutClassRoomInput
    major?: KonsentrasiKeahlianCreateNestedOneWithoutClassRoomInput
    students?: StudentCreateNestedManyWithoutClassRoomInput
    event?: CalendarCreateNestedManyWithoutClassRoomInput
    tracker?: TrackerCreateNestedManyWithoutKelasInput
    teaching?: TeachingCreateNestedManyWithoutClassRoomInput
    tDevice?: TDeviceCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomUncheckedCreateInput = {
    id?: string
    name: string
    yearId: string
    waliId: string
    level: number
    property?: XOR<RoomPropertyNullableCreateEnvelopeInput, RoomPropertyCreateInput> | null
    majorId?: string | null
    studentIds?: ClassRoomCreatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomCreateeventIdsInput | Enumerable<string>
    disable?: boolean
    teachingIds?: ClassRoomCreateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomCreatetDeviceIdsInput | Enumerable<string>
    students?: StudentUncheckedCreateNestedManyWithoutClassRoomInput
    event?: CalendarUncheckedCreateNestedManyWithoutClassRoomInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutKelasInput
    teaching?: TeachingUncheckedCreateNestedManyWithoutClassRoomInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    property?: XOR<RoomPropertyNullableUpdateEnvelopeInput, RoomPropertyCreateInput> | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    year?: SchoolYearUpdateOneRequiredWithoutClassRoomNestedInput
    wali?: TeacherUpdateOneRequiredWithoutClassRoomNestedInput
    major?: KonsentrasiKeahlianUpdateOneWithoutClassRoomNestedInput
    students?: StudentUpdateManyWithoutClassRoomNestedInput
    event?: CalendarUpdateManyWithoutClassRoomNestedInput
    tracker?: TrackerUpdateManyWithoutKelasNestedInput
    teaching?: TeachingUpdateManyWithoutClassRoomNestedInput
    tDevice?: TDeviceUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    waliId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    property?: XOR<RoomPropertyNullableUpdateEnvelopeInput, RoomPropertyCreateInput> | null
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    studentIds?: ClassRoomUpdatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomUpdateeventIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    teachingIds?: ClassRoomUpdateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomUpdatetDeviceIdsInput | Enumerable<string>
    students?: StudentUncheckedUpdateManyWithoutClassRoomNestedInput
    event?: CalendarUncheckedUpdateManyWithoutClassRoomNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutKelasNestedInput
    teaching?: TeachingUncheckedUpdateManyWithoutClassRoomNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomCreateManyInput = {
    id?: string
    name: string
    yearId: string
    waliId: string
    level: number
    property?: XOR<RoomPropertyNullableCreateEnvelopeInput, RoomPropertyCreateInput> | null
    majorId?: string | null
    studentIds?: ClassRoomCreatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomCreateeventIdsInput | Enumerable<string>
    disable?: boolean
    teachingIds?: ClassRoomCreateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomCreatetDeviceIdsInput | Enumerable<string>
  }

  export type ClassRoomUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    property?: XOR<RoomPropertyNullableUpdateEnvelopeInput, RoomPropertyCreateInput> | null
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassRoomUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    waliId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    property?: XOR<RoomPropertyNullableUpdateEnvelopeInput, RoomPropertyCreateInput> | null
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    studentIds?: ClassRoomUpdatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomUpdateeventIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    teachingIds?: ClassRoomUpdateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomUpdatetDeviceIdsInput | Enumerable<string>
  }

  export type StudentCreateInput = {
    id?: string
    nis: string
    lastSchool: string
    disable?: boolean
    personal: PersonalCreateNestedOneWithoutStudentInput
    major?: KonsentrasiKeahlianCreateNestedOneWithoutStudentInput
    classRoom?: ClassRoomCreateNestedManyWithoutStudentsInput
    startYear: SchoolYearCreateNestedOneWithoutStudentsInput
    instansi: InstansiCreateNestedOneWithoutStudentInput
    event?: CalendarCreateNestedManyWithoutStudentInput
    tracker?: TrackerCreateNestedManyWithoutMuridInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    nis: string
    lastSchool: string
    personalId: string
    majorId?: string | null
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    startYearId: string
    instansiId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutStudentsInput
    event?: CalendarUncheckedCreateNestedManyWithoutStudentInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutMuridInput
  }

  export type StudentUpdateInput = {
    nis?: StringFieldUpdateOperationsInput | string
    lastSchool?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    personal?: PersonalUpdateOneRequiredWithoutStudentNestedInput
    major?: KonsentrasiKeahlianUpdateOneWithoutStudentNestedInput
    classRoom?: ClassRoomUpdateManyWithoutStudentsNestedInput
    startYear?: SchoolYearUpdateOneRequiredWithoutStudentsNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutStudentNestedInput
    event?: CalendarUpdateManyWithoutStudentNestedInput
    tracker?: TrackerUpdateManyWithoutMuridNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    nis?: StringFieldUpdateOperationsInput | string
    lastSchool?: StringFieldUpdateOperationsInput | string
    personalId?: StringFieldUpdateOperationsInput | string
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomIds?: StudentUpdateclassRoomIdsInput | Enumerable<string>
    startYearId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: StudentUpdateeventIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutStudentsNestedInput
    event?: CalendarUncheckedUpdateManyWithoutStudentNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutMuridNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    nis: string
    lastSchool: string
    personalId: string
    majorId?: string | null
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    startYearId: string
    instansiId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
    disable?: boolean
  }

  export type StudentUpdateManyMutationInput = {
    nis?: StringFieldUpdateOperationsInput | string
    lastSchool?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentUncheckedUpdateManyInput = {
    nis?: StringFieldUpdateOperationsInput | string
    lastSchool?: StringFieldUpdateOperationsInput | string
    personalId?: StringFieldUpdateOperationsInput | string
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomIds?: StudentUpdateclassRoomIdsInput | Enumerable<string>
    startYearId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: StudentUpdateeventIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ScheduleCreateInput = {
    id?: string
    disable?: boolean
    year: SchoolYearCreateNestedOneWithoutScheduleInput
    mapel: MataPelajaranCreateNestedOneWithoutScheduleInput
    tracker?: TrackerCreateNestedManyWithoutJadwalInput
    teaching?: TeachingCreateNestedManyWithoutRefInput
  }

  export type ScheduleUncheckedCreateInput = {
    id?: string
    yearId: string
    mapelId: string
    disable?: boolean
    tracker?: TrackerUncheckedCreateNestedManyWithoutJadwalInput
    teaching?: TeachingUncheckedCreateNestedManyWithoutRefInput
  }

  export type ScheduleUpdateInput = {
    disable?: BoolFieldUpdateOperationsInput | boolean
    year?: SchoolYearUpdateOneRequiredWithoutScheduleNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutScheduleNestedInput
    tracker?: TrackerUpdateManyWithoutJadwalNestedInput
    teaching?: TeachingUpdateManyWithoutRefNestedInput
  }

  export type ScheduleUncheckedUpdateInput = {
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    tracker?: TrackerUncheckedUpdateManyWithoutJadwalNestedInput
    teaching?: TeachingUncheckedUpdateManyWithoutRefNestedInput
  }

  export type ScheduleCreateManyInput = {
    id?: string
    yearId: string
    mapelId: string
    disable?: boolean
  }

  export type ScheduleUpdateManyMutationInput = {
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ScheduleUncheckedUpdateManyInput = {
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeachingCreateInput = {
    id?: string
    level: number
    hours: number
    semester: Semester
    disable?: boolean
    ref: ScheduleCreateNestedOneWithoutTeachingInput
    teacher: TeacherCreateNestedOneWithoutTeachingInput
    classRoom?: ClassRoomCreateNestedManyWithoutTeachingInput
    elemen?: ElementCreateNestedManyWithoutScheduleClassInput
    tracker?: TrackerCreateNestedManyWithoutMengajarInput
    tDevice?: TDeviceCreateNestedManyWithoutTeachingInput
  }

  export type TeachingUncheckedCreateInput = {
    id?: string
    refId: string
    level: number
    hours: number
    semester: Semester
    teacherId: string
    classRoomIds?: TeachingCreateclassRoomIdsInput | Enumerable<string>
    elemenIds?: TeachingCreateelemenIdsInput | Enumerable<string>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutTeachingInput
    elemen?: ElementUncheckedCreateNestedManyWithoutScheduleClassInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutMengajarInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutTeachingInput
  }

  export type TeachingUpdateInput = {
    level?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    semester?: EnumSemesterFieldUpdateOperationsInput | Semester
    disable?: BoolFieldUpdateOperationsInput | boolean
    ref?: ScheduleUpdateOneRequiredWithoutTeachingNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutTeachingNestedInput
    classRoom?: ClassRoomUpdateManyWithoutTeachingNestedInput
    elemen?: ElementUpdateManyWithoutScheduleClassNestedInput
    tracker?: TrackerUpdateManyWithoutMengajarNestedInput
    tDevice?: TDeviceUpdateManyWithoutTeachingNestedInput
  }

  export type TeachingUncheckedUpdateInput = {
    refId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    semester?: EnumSemesterFieldUpdateOperationsInput | Semester
    teacherId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: TeachingUpdateclassRoomIdsInput | Enumerable<string>
    elemenIds?: TeachingUpdateelemenIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutTeachingNestedInput
    elemen?: ElementUncheckedUpdateManyWithoutScheduleClassNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutMengajarNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutTeachingNestedInput
  }

  export type TeachingCreateManyInput = {
    id?: string
    refId: string
    level: number
    hours: number
    semester: Semester
    teacherId: string
    classRoomIds?: TeachingCreateclassRoomIdsInput | Enumerable<string>
    elemenIds?: TeachingCreateelemenIdsInput | Enumerable<string>
    disable?: boolean
  }

  export type TeachingUpdateManyMutationInput = {
    level?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    semester?: EnumSemesterFieldUpdateOperationsInput | Semester
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeachingUncheckedUpdateManyInput = {
    refId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    semester?: EnumSemesterFieldUpdateOperationsInput | Semester
    teacherId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: TeachingUpdateclassRoomIdsInput | Enumerable<string>
    elemenIds?: TeachingUpdateelemenIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LinkCreateInput = {
    id?: string
    url?: string | null
    title: string
    description?: string | null
    image?: string | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLinkInput
    objResource?: OresourceCreateNestedManyWithoutLinkInput
  }

  export type LinkUncheckedCreateInput = {
    id?: string
    url?: string | null
    title: string
    description?: string | null
    image?: string | null
    width?: number | null
    height?: number | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    objResource?: OresourceUncheckedCreateNestedManyWithoutLinkInput
  }

  export type LinkUpdateInput = {
    url?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLinkNestedInput
    objResource?: OresourceUpdateManyWithoutLinkNestedInput
  }

  export type LinkUncheckedUpdateInput = {
    url?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    objResource?: OresourceUncheckedUpdateManyWithoutLinkNestedInput
  }

  export type LinkCreateManyInput = {
    id?: string
    url?: string | null
    title: string
    description?: string | null
    image?: string | null
    width?: number | null
    height?: number | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinkUpdateManyMutationInput = {
    url?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkUncheckedUpdateManyInput = {
    url?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAssessmentCreateInput = {
    id?: string
    type: string
    techs?: OAssessmentCreatetechsInput | Enumerable<string>
    ref: ObjectiveCreateNestedOneWithoutAssessmentsInput
  }

  export type OAssessmentUncheckedCreateInput = {
    id?: string
    refId: string
    type: string
    techs?: OAssessmentCreatetechsInput | Enumerable<string>
  }

  export type OAssessmentUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    techs?: OAssessmentUpdatetechsInput | Enumerable<string>
    ref?: ObjectiveUpdateOneRequiredWithoutAssessmentsNestedInput
  }

  export type OAssessmentUncheckedUpdateInput = {
    refId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    techs?: OAssessmentUpdatetechsInput | Enumerable<string>
  }

  export type OAssessmentCreateManyInput = {
    id?: string
    refId: string
    type: string
    techs?: OAssessmentCreatetechsInput | Enumerable<string>
  }

  export type OAssessmentUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    techs?: OAssessmentUpdatetechsInput | Enumerable<string>
  }

  export type OAssessmentUncheckedUpdateManyInput = {
    refId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    techs?: OAssessmentUpdatetechsInput | Enumerable<string>
  }

  export type ObjectiveCreateInput = {
    id?: string
    level: number
    fase: Fase
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    user: UserCreateNestedOneWithoutObjectiveInput
    instansi: InstansiCreateNestedOneWithoutObjectiveInput
    year: SchoolYearCreateNestedOneWithoutObjectiveInput
    mapel: MataPelajaranCreateNestedOneWithoutObjectiveInput
    elemen: ElementCreateNestedOneWithoutObjectiveInput
    achievement: AchievementCreateNestedOneWithoutObjectiveInput
    material?: OMaterialCreateNestedManyWithoutRefInput
    tracker?: TrackerCreateNestedManyWithoutTujuanInput
    resourse?: OresourceCreateNestedManyWithoutRefInput
    ppp?: OpppCreateNestedManyWithoutRefInput
    tool?: OhelperCreateNestedManyWithoutToolInput
    mate?: OhelperCreateNestedManyWithoutMateInput
    meth?: OhelperCreateNestedManyWithoutMethInput
    media?: OhelperCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentCreateNestedManyWithoutRefInput
    devices?: TDeviceDataCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveUncheckedCreateInput = {
    id?: string
    level: number
    fase: Fase
    userId: string
    instansiId: string
    yearId: string
    mapelId: string
    elementId: string
    achievementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedCreateNestedManyWithoutRefInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTujuanInput
    resourse?: OresourceUncheckedCreateNestedManyWithoutRefInput
    ppp?: OpppUncheckedCreateNestedManyWithoutRefInput
    tool?: OhelperUncheckedCreateNestedManyWithoutToolInput
    mate?: OhelperUncheckedCreateNestedManyWithoutMateInput
    meth?: OhelperUncheckedCreateNestedManyWithoutMethInput
    media?: OhelperUncheckedCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentUncheckedCreateNestedManyWithoutRefInput
    devices?: TDeviceDataUncheckedCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveUpdateInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutObjectiveNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutObjectiveNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutObjectiveNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutObjectiveNestedInput
    elemen?: ElementUpdateOneRequiredWithoutObjectiveNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutObjectiveNestedInput
    material?: OMaterialUpdateManyWithoutRefNestedInput
    tracker?: TrackerUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUpdateManyWithoutRefNestedInput
    ppp?: OpppUpdateManyWithoutRefNestedInput
    tool?: OhelperUpdateManyWithoutToolNestedInput
    mate?: OhelperUpdateManyWithoutMateNestedInput
    meth?: OhelperUpdateManyWithoutMethNestedInput
    media?: OhelperUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    toolIds?: ObjectiveUpdatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveUpdatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveUpdatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveUpdatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedUpdateManyWithoutRefNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUncheckedUpdateManyWithoutRefNestedInput
    ppp?: OpppUncheckedUpdateManyWithoutRefNestedInput
    tool?: OhelperUncheckedUpdateManyWithoutToolNestedInput
    mate?: OhelperUncheckedUpdateManyWithoutMateNestedInput
    meth?: OhelperUncheckedUpdateManyWithoutMethNestedInput
    media?: OhelperUncheckedUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUncheckedUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUncheckedUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveCreateManyInput = {
    id?: string
    level: number
    fase: Fase
    userId: string
    instansiId: string
    yearId: string
    mapelId: string
    elementId: string
    achievementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
  }

  export type ObjectiveUpdateManyMutationInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ObjectiveUncheckedUpdateManyInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    toolIds?: ObjectiveUpdatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveUpdatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveUpdatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveUpdatemediaIdsInput | Enumerable<string>
  }

  export type OMaterialCreateInput = {
    id?: string
    no: number
    content: string
    model: OMaterialModel
    ref: ObjectiveCreateNestedOneWithoutMaterialInput
    learning?: OLearningCreateNestedManyWithoutRefInput
  }

  export type OMaterialUncheckedCreateInput = {
    id?: string
    refId: string
    no: number
    content: string
    model: OMaterialModel
    learning?: OLearningUncheckedCreateNestedManyWithoutRefInput
  }

  export type OMaterialUpdateInput = {
    no?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    model?: EnumOMaterialModelFieldUpdateOperationsInput | OMaterialModel
    ref?: ObjectiveUpdateOneRequiredWithoutMaterialNestedInput
    learning?: OLearningUpdateManyWithoutRefNestedInput
  }

  export type OMaterialUncheckedUpdateInput = {
    refId?: StringFieldUpdateOperationsInput | string
    no?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    model?: EnumOMaterialModelFieldUpdateOperationsInput | OMaterialModel
    learning?: OLearningUncheckedUpdateManyWithoutRefNestedInput
  }

  export type OMaterialCreateManyInput = {
    id?: string
    refId: string
    no: number
    content: string
    model: OMaterialModel
  }

  export type OMaterialUpdateManyMutationInput = {
    no?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    model?: EnumOMaterialModelFieldUpdateOperationsInput | OMaterialModel
  }

  export type OMaterialUncheckedUpdateManyInput = {
    refId?: StringFieldUpdateOperationsInput | string
    no?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    model?: EnumOMaterialModelFieldUpdateOperationsInput | OMaterialModel
  }

  export type OLearningCreateInput = {
    id?: string
    no: number
    content: string
    taksonomi: Taksonomi
    sentence: string
    ref: OMaterialCreateNestedOneWithoutLearningInput
  }

  export type OLearningUncheckedCreateInput = {
    id?: string
    refId: string
    no: number
    content: string
    taksonomi: Taksonomi
    sentence: string
  }

  export type OLearningUpdateInput = {
    no?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    taksonomi?: EnumTaksonomiFieldUpdateOperationsInput | Taksonomi
    sentence?: StringFieldUpdateOperationsInput | string
    ref?: OMaterialUpdateOneRequiredWithoutLearningNestedInput
  }

  export type OLearningUncheckedUpdateInput = {
    refId?: StringFieldUpdateOperationsInput | string
    no?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    taksonomi?: EnumTaksonomiFieldUpdateOperationsInput | Taksonomi
    sentence?: StringFieldUpdateOperationsInput | string
  }

  export type OLearningCreateManyInput = {
    id?: string
    refId: string
    no: number
    content: string
    taksonomi: Taksonomi
    sentence: string
  }

  export type OLearningUpdateManyMutationInput = {
    no?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    taksonomi?: EnumTaksonomiFieldUpdateOperationsInput | Taksonomi
    sentence?: StringFieldUpdateOperationsInput | string
  }

  export type OLearningUncheckedUpdateManyInput = {
    refId?: StringFieldUpdateOperationsInput | string
    no?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    taksonomi?: EnumTaksonomiFieldUpdateOperationsInput | Taksonomi
    sentence?: StringFieldUpdateOperationsInput | string
  }

  export type OhelperCreateInput = {
    id?: string
    type: OhelperType
    name: string
    tool?: ObjectiveCreateNestedManyWithoutToolInput
    mate?: ObjectiveCreateNestedManyWithoutMateInput
    meth?: ObjectiveCreateNestedManyWithoutMethInput
    media?: ObjectiveCreateNestedManyWithoutMediaInput
  }

  export type OhelperUncheckedCreateInput = {
    id?: string
    type: OhelperType
    name: string
    toolIds?: OhelperCreatetoolIdsInput | Enumerable<string>
    mateIds?: OhelperCreatemateIdsInput | Enumerable<string>
    methIds?: OhelperCreatemethIdsInput | Enumerable<string>
    mediaIds?: OhelperCreatemediaIdsInput | Enumerable<string>
    tool?: ObjectiveUncheckedCreateNestedManyWithoutToolInput
    mate?: ObjectiveUncheckedCreateNestedManyWithoutMateInput
    meth?: ObjectiveUncheckedCreateNestedManyWithoutMethInput
    media?: ObjectiveUncheckedCreateNestedManyWithoutMediaInput
  }

  export type OhelperUpdateInput = {
    type?: EnumOhelperTypeFieldUpdateOperationsInput | OhelperType
    name?: StringFieldUpdateOperationsInput | string
    tool?: ObjectiveUpdateManyWithoutToolNestedInput
    mate?: ObjectiveUpdateManyWithoutMateNestedInput
    meth?: ObjectiveUpdateManyWithoutMethNestedInput
    media?: ObjectiveUpdateManyWithoutMediaNestedInput
  }

  export type OhelperUncheckedUpdateInput = {
    type?: EnumOhelperTypeFieldUpdateOperationsInput | OhelperType
    name?: StringFieldUpdateOperationsInput | string
    toolIds?: OhelperUpdatetoolIdsInput | Enumerable<string>
    mateIds?: OhelperUpdatemateIdsInput | Enumerable<string>
    methIds?: OhelperUpdatemethIdsInput | Enumerable<string>
    mediaIds?: OhelperUpdatemediaIdsInput | Enumerable<string>
    tool?: ObjectiveUncheckedUpdateManyWithoutToolNestedInput
    mate?: ObjectiveUncheckedUpdateManyWithoutMateNestedInput
    meth?: ObjectiveUncheckedUpdateManyWithoutMethNestedInput
    media?: ObjectiveUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type OhelperCreateManyInput = {
    id?: string
    type: OhelperType
    name: string
    toolIds?: OhelperCreatetoolIdsInput | Enumerable<string>
    mateIds?: OhelperCreatemateIdsInput | Enumerable<string>
    methIds?: OhelperCreatemethIdsInput | Enumerable<string>
    mediaIds?: OhelperCreatemediaIdsInput | Enumerable<string>
  }

  export type OhelperUpdateManyMutationInput = {
    type?: EnumOhelperTypeFieldUpdateOperationsInput | OhelperType
    name?: StringFieldUpdateOperationsInput | string
  }

  export type OhelperUncheckedUpdateManyInput = {
    type?: EnumOhelperTypeFieldUpdateOperationsInput | OhelperType
    name?: StringFieldUpdateOperationsInput | string
    toolIds?: OhelperUpdatetoolIdsInput | Enumerable<string>
    mateIds?: OhelperUpdatemateIdsInput | Enumerable<string>
    methIds?: OhelperUpdatemethIdsInput | Enumerable<string>
    mediaIds?: OhelperUpdatemediaIdsInput | Enumerable<string>
  }

  export type OpppCreateInput = {
    id?: string
    name: string
    description?: string | null
    ref: ObjectiveCreateNestedOneWithoutPppInput
  }

  export type OpppUncheckedCreateInput = {
    id?: string
    refId: string
    name: string
    description?: string | null
  }

  export type OpppUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ref?: ObjectiveUpdateOneRequiredWithoutPppNestedInput
  }

  export type OpppUncheckedUpdateInput = {
    refId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OpppCreateManyInput = {
    id?: string
    refId: string
    name: string
    description?: string | null
  }

  export type OpppUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OpppUncheckedUpdateManyInput = {
    refId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OresourceCreateInput = {
    id?: string
    name: string
    type: OresourceType
    ref: ObjectiveCreateNestedOneWithoutResourseInput
    link?: LinkCreateNestedOneWithoutObjResourceInput
  }

  export type OresourceUncheckedCreateInput = {
    id?: string
    name: string
    type: OresourceType
    refId: string
    linkId?: string | null
  }

  export type OresourceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumOresourceTypeFieldUpdateOperationsInput | OresourceType
    ref?: ObjectiveUpdateOneRequiredWithoutResourseNestedInput
    link?: LinkUpdateOneWithoutObjResourceNestedInput
  }

  export type OresourceUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumOresourceTypeFieldUpdateOperationsInput | OresourceType
    refId?: StringFieldUpdateOperationsInput | string
    linkId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OresourceCreateManyInput = {
    id?: string
    name: string
    type: OresourceType
    refId: string
    linkId?: string | null
  }

  export type OresourceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumOresourceTypeFieldUpdateOperationsInput | OresourceType
  }

  export type OresourceUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumOresourceTypeFieldUpdateOperationsInput | OresourceType
    refId?: StringFieldUpdateOperationsInput | string
    linkId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookCreateInput = {
    id?: string
    name: string
    description?: string | null
    author?: string | null
  }

  export type BookUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    author?: string | null
  }

  export type BookUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    author?: string | null
  }

  export type BookUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TDeviceCreateInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    teaching: TeachingCreateNestedOneWithoutTDeviceInput
    year: SchoolYearCreateNestedOneWithoutTDeviceInput
    user: UserCreateNestedOneWithoutTDeviceInput
    instansi: InstansiCreateNestedOneWithoutTDeviceInput
    mapel: MataPelajaranCreateNestedOneWithoutDeviceInput
    classRoom?: ClassRoomCreateNestedManyWithoutTDeviceInput
    tracker?: TrackerCreateNestedManyWithoutPerangkatInput
    data?: TDeviceDataCreateNestedManyWithoutRefInput
    children?: TDeviceCreateNestedManyWithoutParentInput
    parent?: TDeviceCreateNestedOneWithoutChildrenInput
  }

  export type TDeviceUncheckedCreateInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    teachingId: string
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    yearId: string
    userId: string
    instansiId: string
    mapelId: string
    classRoomIds?: TDeviceCreateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    parentId?: string | null
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutTDeviceInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutPerangkatInput
    data?: TDeviceDataUncheckedCreateNestedManyWithoutRefInput
    children?: TDeviceUncheckedCreateNestedManyWithoutParentInput
  }

  export type TDeviceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    teaching?: TeachingUpdateOneRequiredWithoutTDeviceNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutTDeviceNestedInput
    user?: UserUpdateOneRequiredWithoutTDeviceNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutTDeviceNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutDeviceNestedInput
    classRoom?: ClassRoomUpdateManyWithoutTDeviceNestedInput
    tracker?: TrackerUpdateManyWithoutPerangkatNestedInput
    data?: TDeviceDataUpdateManyWithoutRefNestedInput
    children?: TDeviceUpdateManyWithoutParentNestedInput
    parent?: TDeviceUpdateOneWithoutChildrenNestedInput
  }

  export type TDeviceUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    teachingId?: StringFieldUpdateOperationsInput | string
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    yearId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: TDeviceUpdateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutTDeviceNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutPerangkatNestedInput
    data?: TDeviceDataUncheckedUpdateManyWithoutRefNestedInput
    children?: TDeviceUncheckedUpdateManyWithoutParentNestedInput
  }

  export type TDeviceCreateManyInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    teachingId: string
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    yearId: string
    userId: string
    instansiId: string
    mapelId: string
    classRoomIds?: TDeviceCreateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    parentId?: string | null
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type TDeviceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type TDeviceUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    teachingId?: StringFieldUpdateOperationsInput | string
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    yearId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: TDeviceUpdateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type TDeviceDataCreateInput = {
    id?: string
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    ref: TDeviceCreateNestedOneWithoutDataInput
    objective: ObjectiveCreateNestedOneWithoutDevicesInput
  }

  export type TDeviceDataUncheckedCreateInput = {
    id?: string
    refId: string
    objectiveId: string
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type TDeviceDataUpdateInput = {
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    ref?: TDeviceUpdateOneRequiredWithoutDataNestedInput
    objective?: ObjectiveUpdateOneRequiredWithoutDevicesNestedInput
  }

  export type TDeviceDataUncheckedUpdateInput = {
    refId?: StringFieldUpdateOperationsInput | string
    objectiveId?: StringFieldUpdateOperationsInput | string
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type TDeviceDataCreateManyInput = {
    id?: string
    refId: string
    objectiveId: string
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type TDeviceDataUpdateManyMutationInput = {
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type TDeviceDataUncheckedUpdateManyInput = {
    refId?: StringFieldUpdateOperationsInput | string
    objectiveId?: StringFieldUpdateOperationsInput | string
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type CalendarCreateInput = {
    id?: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    disable?: boolean
    ref: SchoolYearCreateNestedOneWithoutCalendarInput
    classRoom?: ClassRoomCreateNestedManyWithoutEventInput
    student?: StudentCreateNestedManyWithoutEventInput
    teacher?: TeacherCreateNestedManyWithoutEventInput
    tracker?: TrackerCreateNestedManyWithoutKalenderInput
  }

  export type CalendarUncheckedCreateInput = {
    id?: string
    refId: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    classRoomIds?: CalendarCreateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarCreatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarCreateteacherIdsInput | Enumerable<string>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutEventInput
    student?: StudentUncheckedCreateNestedManyWithoutEventInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutEventInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutKalenderInput
  }

  export type CalendarUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    ref?: SchoolYearUpdateOneRequiredWithoutCalendarNestedInput
    classRoom?: ClassRoomUpdateManyWithoutEventNestedInput
    student?: StudentUpdateManyWithoutEventNestedInput
    teacher?: TeacherUpdateManyWithoutEventNestedInput
    tracker?: TrackerUpdateManyWithoutKalenderNestedInput
  }

  export type CalendarUncheckedUpdateInput = {
    refId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    classRoomIds?: CalendarUpdateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarUpdatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarUpdateteacherIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutEventNestedInput
    student?: StudentUncheckedUpdateManyWithoutEventNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutEventNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutKalenderNestedInput
  }

  export type CalendarCreateManyInput = {
    id?: string
    refId: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    classRoomIds?: CalendarCreateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarCreatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarCreateteacherIdsInput | Enumerable<string>
    disable?: boolean
  }

  export type CalendarUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CalendarUncheckedUpdateManyInput = {
    refId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    classRoomIds?: CalendarUpdateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarUpdatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarUpdateteacherIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DudiCreateInput = {
    id?: string
    name: string
    street: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    contact: XOR<ContactDudiCreateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiCreatecollabsInput | Enumerable<string>
    timework: XOR<DudiTimeWorkCreateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: boolean
    instansi: InstansiCreateNestedOneWithoutDudiInput
    major: KonsentrasiKeahlianCreateNestedOneWithoutDudiInput
    learning?: DudiLearningCreateNestedManyWithoutRefInput
    tracker?: TrackerCreateNestedManyWithoutDudiInput
    kkni?: KkniCreateNestedOneWithoutDudiInput
  }

  export type DudiUncheckedCreateInput = {
    id?: string
    name: string
    street: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    instansiId: string
    majorId: string
    contact: XOR<ContactDudiCreateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiCreatecollabsInput | Enumerable<string>
    timework: XOR<DudiTimeWorkCreateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: boolean
    kkniId?: string | null
    learning?: DudiLearningUncheckedCreateNestedManyWithoutRefInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutDudiInput
  }

  export type DudiUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    contact?: XOR<ContactDudiUpdateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiUpdatecollabsInput | Enumerable<string>
    timework?: XOR<DudiTimeWorkUpdateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    instansi?: InstansiUpdateOneRequiredWithoutDudiNestedInput
    major?: KonsentrasiKeahlianUpdateOneRequiredWithoutDudiNestedInput
    learning?: DudiLearningUpdateManyWithoutRefNestedInput
    tracker?: TrackerUpdateManyWithoutDudiNestedInput
    kkni?: KkniUpdateOneWithoutDudiNestedInput
  }

  export type DudiUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    instansiId?: StringFieldUpdateOperationsInput | string
    majorId?: StringFieldUpdateOperationsInput | string
    contact?: XOR<ContactDudiUpdateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiUpdatecollabsInput | Enumerable<string>
    timework?: XOR<DudiTimeWorkUpdateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
    learning?: DudiLearningUncheckedUpdateManyWithoutRefNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutDudiNestedInput
  }

  export type DudiCreateManyInput = {
    id?: string
    name: string
    street: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    instansiId: string
    majorId: string
    contact: XOR<ContactDudiCreateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiCreatecollabsInput | Enumerable<string>
    timework: XOR<DudiTimeWorkCreateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: boolean
    kkniId?: string | null
  }

  export type DudiUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    contact?: XOR<ContactDudiUpdateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiUpdatecollabsInput | Enumerable<string>
    timework?: XOR<DudiTimeWorkUpdateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DudiUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    instansiId?: StringFieldUpdateOperationsInput | string
    majorId?: StringFieldUpdateOperationsInput | string
    contact?: XOR<ContactDudiUpdateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiUpdatecollabsInput | Enumerable<string>
    timework?: XOR<DudiTimeWorkUpdateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DudiLearningCreateInput = {
    id?: string
    no: number
    code: string
    name: string
    indicator?: XOR<DudiIndicatorListCreateEnvelopeInput, Enumerable<DudiIndicatorCreateInput>>
    ref: DudiCreateNestedOneWithoutLearningInput
  }

  export type DudiLearningUncheckedCreateInput = {
    id?: string
    no: number
    refId: string
    code: string
    name: string
    indicator?: XOR<DudiIndicatorListCreateEnvelopeInput, Enumerable<DudiIndicatorCreateInput>>
  }

  export type DudiLearningUpdateInput = {
    no?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    indicator?: XOR<DudiIndicatorListUpdateEnvelopeInput, Enumerable<DudiIndicatorCreateInput>>
    ref?: DudiUpdateOneRequiredWithoutLearningNestedInput
  }

  export type DudiLearningUncheckedUpdateInput = {
    no?: IntFieldUpdateOperationsInput | number
    refId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    indicator?: XOR<DudiIndicatorListUpdateEnvelopeInput, Enumerable<DudiIndicatorCreateInput>>
  }

  export type DudiLearningCreateManyInput = {
    id?: string
    no: number
    refId: string
    code: string
    name: string
    indicator?: XOR<DudiIndicatorListCreateEnvelopeInput, Enumerable<DudiIndicatorCreateInput>>
  }

  export type DudiLearningUpdateManyMutationInput = {
    no?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    indicator?: XOR<DudiIndicatorListUpdateEnvelopeInput, Enumerable<DudiIndicatorCreateInput>>
  }

  export type DudiLearningUncheckedUpdateManyInput = {
    no?: IntFieldUpdateOperationsInput | number
    refId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    indicator?: XOR<DudiIndicatorListUpdateEnvelopeInput, Enumerable<DudiIndicatorCreateInput>>
  }

  export type KkniCreateInput = {
    id?: string
    no: number
    code: string
    name: string
    description?: string | null
    disable?: boolean
    konsentrasi: KonsentrasiKeahlianCreateNestedOneWithoutKkniInput
    dudi?: DudiCreateNestedManyWithoutKkniInput
    tracker?: TrackerCreateNestedManyWithoutKkniInput
  }

  export type KkniUncheckedCreateInput = {
    id?: string
    konsentrasiId: string
    no: number
    code: string
    name: string
    description?: string | null
    disable?: boolean
    dudi?: DudiUncheckedCreateNestedManyWithoutKkniInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutKkniInput
  }

  export type KkniUpdateInput = {
    no?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    konsentrasi?: KonsentrasiKeahlianUpdateOneRequiredWithoutKkniNestedInput
    dudi?: DudiUpdateManyWithoutKkniNestedInput
    tracker?: TrackerUpdateManyWithoutKkniNestedInput
  }

  export type KkniUncheckedUpdateInput = {
    konsentrasiId?: StringFieldUpdateOperationsInput | string
    no?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    dudi?: DudiUncheckedUpdateManyWithoutKkniNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutKkniNestedInput
  }

  export type KkniCreateManyInput = {
    id?: string
    konsentrasiId: string
    no: number
    code: string
    name: string
    description?: string | null
    disable?: boolean
  }

  export type KkniUpdateManyMutationInput = {
    no?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type KkniUncheckedUpdateManyInput = {
    konsentrasiId?: StringFieldUpdateOperationsInput | string
    no?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type EnumPointTrackerFilter = {
    equals?: PointTracker
    in?: Enumerable<PointTracker>
    notIn?: Enumerable<PointTracker>
    not?: NestedEnumPointTrackerFilter | PointTracker
  }

  export type EnumTypeTrackerFilter = {
    equals?: TypeTracker
    in?: Enumerable<TypeTracker>
    notIn?: Enumerable<TypeTracker>
    not?: NestedEnumTypeTrackerFilter | TypeTracker
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
    isSet?: boolean
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type InstansiRelationFilter = {
    is?: InstansiWhereInput
    isNot?: InstansiWhereInput
  }

  export type MataPelajaranRelationFilter = {
    is?: MataPelajaranWhereInput
    isNot?: MataPelajaranWhereInput
  }

  export type ElementRelationFilter = {
    is?: ElementWhereInput
    isNot?: ElementWhereInput
  }

  export type AchievementRelationFilter = {
    is?: AchievementWhereInput
    isNot?: AchievementWhereInput
  }

  export type BidangKeahlianRelationFilter = {
    is?: BidangKeahlianWhereInput | null
    isNot?: BidangKeahlianWhereInput | null
  }

  export type ProgramKeahlianRelationFilter = {
    is?: ProgramKeahlianWhereInput | null
    isNot?: ProgramKeahlianWhereInput | null
  }

  export type KonsentrasiKeahlianRelationFilter = {
    is?: KonsentrasiKeahlianWhereInput | null
    isNot?: KonsentrasiKeahlianWhereInput | null
  }

  export type SchoolYearRelationFilter = {
    is?: SchoolYearWhereInput
    isNot?: SchoolYearWhereInput
  }

  export type TeacherRelationFilter = {
    is?: TeacherWhereInput
    isNot?: TeacherWhereInput
  }

  export type ClassRoomRelationFilter = {
    is?: ClassRoomWhereInput | null
    isNot?: ClassRoomWhereInput | null
  }

  export type StudentRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type ScheduleRelationFilter = {
    is?: ScheduleWhereInput
    isNot?: ScheduleWhereInput
  }

  export type TeachingRelationFilter = {
    is?: TeachingWhereInput
    isNot?: TeachingWhereInput
  }

  export type ObjectiveRelationFilter = {
    is?: ObjectiveWhereInput
    isNot?: ObjectiveWhereInput
  }

  export type TDeviceRelationFilter = {
    is?: TDeviceWhereInput | null
    isNot?: TDeviceWhereInput | null
  }

  export type CalendarRelationFilter = {
    is?: CalendarWhereInput | null
    isNot?: CalendarWhereInput | null
  }

  export type DudiRelationFilter = {
    is?: DudiWhereInput
    isNot?: DudiWhereInput
  }

  export type KkniRelationFilter = {
    is?: KkniWhereInput | null
    isNot?: KkniWhereInput | null
  }

  export type TrackerCountOrderByAggregateInput = {
    id?: SortOrder
    point?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    refId?: SortOrder
    instansiId?: SortOrder
    createdAt?: SortOrder
    mapelId?: SortOrder
    elementId?: SortOrder
    cpId?: SortOrder
    bidangId?: SortOrder
    programId?: SortOrder
    konsentrasiId?: SortOrder
    tpId?: SortOrder
    teacherId?: SortOrder
    kelasId?: SortOrder
    muridId?: SortOrder
    jadwalId?: SortOrder
    mengajarId?: SortOrder
    tujuanId?: SortOrder
    perangkatId?: SortOrder
    kalenderId?: SortOrder
    dudiId?: SortOrder
    kkniId?: SortOrder
  }

  export type TrackerMaxOrderByAggregateInput = {
    id?: SortOrder
    point?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    refId?: SortOrder
    instansiId?: SortOrder
    createdAt?: SortOrder
    mapelId?: SortOrder
    elementId?: SortOrder
    cpId?: SortOrder
    bidangId?: SortOrder
    programId?: SortOrder
    konsentrasiId?: SortOrder
    tpId?: SortOrder
    teacherId?: SortOrder
    kelasId?: SortOrder
    muridId?: SortOrder
    jadwalId?: SortOrder
    mengajarId?: SortOrder
    tujuanId?: SortOrder
    perangkatId?: SortOrder
    kalenderId?: SortOrder
    dudiId?: SortOrder
    kkniId?: SortOrder
  }

  export type TrackerMinOrderByAggregateInput = {
    id?: SortOrder
    point?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    refId?: SortOrder
    instansiId?: SortOrder
    createdAt?: SortOrder
    mapelId?: SortOrder
    elementId?: SortOrder
    cpId?: SortOrder
    bidangId?: SortOrder
    programId?: SortOrder
    konsentrasiId?: SortOrder
    tpId?: SortOrder
    teacherId?: SortOrder
    kelasId?: SortOrder
    muridId?: SortOrder
    jadwalId?: SortOrder
    mengajarId?: SortOrder
    tujuanId?: SortOrder
    perangkatId?: SortOrder
    kalenderId?: SortOrder
    dudiId?: SortOrder
    kkniId?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type EnumPointTrackerWithAggregatesFilter = {
    equals?: PointTracker
    in?: Enumerable<PointTracker>
    notIn?: Enumerable<PointTracker>
    not?: NestedEnumPointTrackerWithAggregatesFilter | PointTracker
    _count?: NestedIntFilter
    _min?: NestedEnumPointTrackerFilter
    _max?: NestedEnumPointTrackerFilter
  }

  export type EnumTypeTrackerWithAggregatesFilter = {
    equals?: TypeTracker
    in?: Enumerable<TypeTracker>
    notIn?: Enumerable<TypeTracker>
    not?: NestedEnumTypeTrackerWithAggregatesFilter | TypeTracker
    _count?: NestedIntFilter
    _min?: NestedEnumTypeTrackerFilter
    _max?: NestedEnumTypeTrackerFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    isSet?: boolean
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type AddressCompositeFilter = {
    equals?: AddressObjectEqualityInput
    is?: AddressWhereInput
    isNot?: AddressWhereInput
  }

  export type AddressObjectEqualityInput = {
    provinsi: string
    kabupaten: string
    kecamatan: string
    kelurahan: string
    kodepos: string
    coordinate: CoordinateObjectEqualityInput
  }

  export type EnumLevelFilter = {
    equals?: Level
    in?: Enumerable<Level>
    notIn?: Enumerable<Level>
    not?: NestedEnumLevelFilter | Level
  }

  export type EnumReligionNullableFilter = {
    equals?: Religion | null
    in?: Enumerable<Religion> | null
    notIn?: Enumerable<Religion> | null
    not?: NestedEnumReligionNullableFilter | Religion | null
    isSet?: boolean
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
    isSet?: boolean
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type KonsentrasiKeahlianListRelationFilter = {
    every?: KonsentrasiKeahlianWhereInput
    some?: KonsentrasiKeahlianWhereInput
    none?: KonsentrasiKeahlianWhereInput
  }

  export type RoleListRelationFilter = {
    every?: RoleWhereInput
    some?: RoleWhereInput
    none?: RoleWhereInput
  }

  export type SchoolYearListRelationFilter = {
    every?: SchoolYearWhereInput
    some?: SchoolYearWhereInput
    none?: SchoolYearWhereInput
  }

  export type TeacherListRelationFilter = {
    every?: TeacherWhereInput
    some?: TeacherWhereInput
    none?: TeacherWhereInput
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type TrackerListRelationFilter = {
    every?: TrackerWhereInput
    some?: TrackerWhereInput
    none?: TrackerWhereInput
  }

  export type MataPelajaranListRelationFilter = {
    every?: MataPelajaranWhereInput
    some?: MataPelajaranWhereInput
    none?: MataPelajaranWhereInput
  }

  export type TDeviceListRelationFilter = {
    every?: TDeviceWhereInput
    some?: TDeviceWhereInput
    none?: TDeviceWhereInput
  }

  export type ObjectiveListRelationFilter = {
    every?: ObjectiveWhereInput
    some?: ObjectiveWhereInput
    none?: ObjectiveWhereInput
  }

  export type DudiListRelationFilter = {
    every?: DudiWhereInput
    some?: DudiWhereInput
    none?: DudiWhereInput
  }

  export type AddressOrderByInput = {
    provinsi?: SortOrder
    kabupaten?: SortOrder
    kecamatan?: SortOrder
    kelurahan?: SortOrder
    kodepos?: SortOrder
    coordinate?: CoordinateOrderByInput
  }

  export type KonsentrasiKeahlianOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolYearOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrackerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MataPelajaranOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TDeviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObjectiveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DudiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstansiCountOrderByAggregateInput = {
    id?: SortOrder
    npsn?: SortOrder
    name?: SortOrder
    isPrivate?: SortOrder
    level?: SortOrder
    religion?: SortOrder
    major?: SortOrder
    majorIds?: SortOrder
    disable?: SortOrder
  }

  export type InstansiMaxOrderByAggregateInput = {
    id?: SortOrder
    npsn?: SortOrder
    name?: SortOrder
    isPrivate?: SortOrder
    level?: SortOrder
    religion?: SortOrder
    major?: SortOrder
    disable?: SortOrder
  }

  export type InstansiMinOrderByAggregateInput = {
    id?: SortOrder
    npsn?: SortOrder
    name?: SortOrder
    isPrivate?: SortOrder
    level?: SortOrder
    religion?: SortOrder
    major?: SortOrder
    disable?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type EnumLevelWithAggregatesFilter = {
    equals?: Level
    in?: Enumerable<Level>
    notIn?: Enumerable<Level>
    not?: NestedEnumLevelWithAggregatesFilter | Level
    _count?: NestedIntFilter
    _min?: NestedEnumLevelFilter
    _max?: NestedEnumLevelFilter
  }

  export type EnumReligionNullableWithAggregatesFilter = {
    equals?: Religion | null
    in?: Enumerable<Religion> | null
    notIn?: Enumerable<Religion> | null
    not?: NestedEnumReligionNullableWithAggregatesFilter | Religion | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumReligionNullableFilter
    _max?: NestedEnumReligionNullableFilter
    isSet?: boolean
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
    isSet?: boolean
  }

  export type EnumLevelNullableFilter = {
    equals?: Level | null
    in?: Enumerable<Level> | null
    notIn?: Enumerable<Level> | null
    not?: NestedEnumLevelNullableFilter | Level | null
    isSet?: boolean
  }

  export type EnumMataPelajaranTypeFilter = {
    equals?: MataPelajaranType
    in?: Enumerable<MataPelajaranType>
    notIn?: Enumerable<MataPelajaranType>
    not?: NestedEnumMataPelajaranTypeFilter | MataPelajaranType
  }

  export type ElementListRelationFilter = {
    every?: ElementWhereInput
    some?: ElementWhereInput
    none?: ElementWhereInput
  }

  export type ScheduleListRelationFilter = {
    every?: ScheduleWhereInput
    some?: ScheduleWhereInput
    none?: ScheduleWhereInput
  }

  export type ElementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MataPelajaranNameMapelCompoundUniqueInput = {
    code: string
    name: string
  }

  export type MataPelajaranCountOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    type?: SortOrder
    no?: SortOrder
    code?: SortOrder
    name?: SortOrder
    religion?: SortOrder
    programId?: SortOrder
    keahlianid?: SortOrder
    instansiId?: SortOrder
    disable?: SortOrder
  }

  export type MataPelajaranMaxOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    type?: SortOrder
    no?: SortOrder
    code?: SortOrder
    name?: SortOrder
    religion?: SortOrder
    programId?: SortOrder
    keahlianid?: SortOrder
    instansiId?: SortOrder
    disable?: SortOrder
  }

  export type MataPelajaranMinOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    type?: SortOrder
    no?: SortOrder
    code?: SortOrder
    name?: SortOrder
    religion?: SortOrder
    programId?: SortOrder
    keahlianid?: SortOrder
    instansiId?: SortOrder
    disable?: SortOrder
  }

  export type EnumLevelNullableWithAggregatesFilter = {
    equals?: Level | null
    in?: Enumerable<Level> | null
    notIn?: Enumerable<Level> | null
    not?: NestedEnumLevelNullableWithAggregatesFilter | Level | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumLevelNullableFilter
    _max?: NestedEnumLevelNullableFilter
    isSet?: boolean
  }

  export type EnumMataPelajaranTypeWithAggregatesFilter = {
    equals?: MataPelajaranType
    in?: Enumerable<MataPelajaranType>
    notIn?: Enumerable<MataPelajaranType>
    not?: NestedEnumMataPelajaranTypeWithAggregatesFilter | MataPelajaranType
    _count?: NestedIntFilter
    _min?: NestedEnumMataPelajaranTypeFilter
    _max?: NestedEnumMataPelajaranTypeFilter
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type AchievementListRelationFilter = {
    every?: AchievementWhereInput
    some?: AchievementWhereInput
    none?: AchievementWhereInput
  }

  export type TeachingListRelationFilter = {
    every?: TeachingWhereInput
    some?: TeachingWhereInput
    none?: TeachingWhereInput
  }

  export type AchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeachingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ElementNameElementCompoundUniqueInput = {
    mapelId: string
    name: string
  }

  export type ElementCountOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    name?: SortOrder
    description?: SortOrder
    mapelId?: SortOrder
    disable?: SortOrder
    scheduleClassIds?: SortOrder
  }

  export type ElementAvgOrderByAggregateInput = {
    no?: SortOrder
  }

  export type ElementMaxOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    name?: SortOrder
    description?: SortOrder
    mapelId?: SortOrder
    disable?: SortOrder
  }

  export type ElementMinOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    name?: SortOrder
    description?: SortOrder
    mapelId?: SortOrder
    disable?: SortOrder
  }

  export type ElementSumOrderByAggregateInput = {
    no?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type EnumFaseFilter = {
    equals?: Fase
    in?: Enumerable<Fase>
    notIn?: Enumerable<Fase>
    not?: NestedEnumFaseFilter | Fase
  }

  export type AchievementNameCPCompoundUniqueInput = {
    elementId: string
    fase: Fase
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    fase?: SortOrder
    description?: SortOrder
    elementId?: SortOrder
    disable?: SortOrder
  }

  export type AchievementAvgOrderByAggregateInput = {
    no?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    fase?: SortOrder
    description?: SortOrder
    elementId?: SortOrder
    disable?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    fase?: SortOrder
    description?: SortOrder
    elementId?: SortOrder
    disable?: SortOrder
  }

  export type AchievementSumOrderByAggregateInput = {
    no?: SortOrder
  }

  export type EnumFaseWithAggregatesFilter = {
    equals?: Fase
    in?: Enumerable<Fase>
    notIn?: Enumerable<Fase>
    not?: NestedEnumFaseWithAggregatesFilter | Fase
    _count?: NestedIntFilter
    _min?: NestedEnumFaseFilter
    _max?: NestedEnumFaseFilter
  }

  export type ProgramKeahlianListRelationFilter = {
    every?: ProgramKeahlianWhereInput
    some?: ProgramKeahlianWhereInput
    none?: ProgramKeahlianWhereInput
  }

  export type ProgramKeahlianOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BidangKeahlianNameBidangCompoundUniqueInput = {
    code: string
    name: string
  }

  export type BidangKeahlianCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    disable?: SortOrder
  }

  export type BidangKeahlianMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    disable?: SortOrder
  }

  export type BidangKeahlianMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    disable?: SortOrder
  }

  export type ProgramKeahlianNameProgramCompoundUniqueInput = {
    code: string
    name: string
  }

  export type ProgramKeahlianCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    bidangId?: SortOrder
    disable?: SortOrder
  }

  export type ProgramKeahlianMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    bidangId?: SortOrder
    disable?: SortOrder
  }

  export type ProgramKeahlianMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    bidangId?: SortOrder
    disable?: SortOrder
  }

  export type InstansiListRelationFilter = {
    every?: InstansiWhereInput
    some?: InstansiWhereInput
    none?: InstansiWhereInput
  }

  export type ClassRoomListRelationFilter = {
    every?: ClassRoomWhereInput
    some?: ClassRoomWhereInput
    none?: ClassRoomWhereInput
  }

  export type KkniListRelationFilter = {
    every?: KkniWhereInput
    some?: KkniWhereInput
    none?: KkniWhereInput
  }

  export type InstansiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassRoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KkniOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KonsentrasiKeahlianNameKonsentrasiCompoundUniqueInput = {
    programId: string
    name: string
  }

  export type KonsentrasiKeahlianCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    programId?: SortOrder
    tahun?: SortOrder
    instansiIds?: SortOrder
    disable?: SortOrder
  }

  export type KonsentrasiKeahlianAvgOrderByAggregateInput = {
    tahun?: SortOrder
  }

  export type KonsentrasiKeahlianMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    programId?: SortOrder
    tahun?: SortOrder
    disable?: SortOrder
  }

  export type KonsentrasiKeahlianMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    programId?: SortOrder
    tahun?: SortOrder
    disable?: SortOrder
  }

  export type KonsentrasiKeahlianSumOrderByAggregateInput = {
    tahun?: SortOrder
  }

  export type EnumRolesFilter = {
    equals?: Roles
    in?: Enumerable<Roles>
    notIn?: Enumerable<Roles>
    not?: NestedEnumRolesFilter | Roles
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleNameRoleCompoundUniqueInput = {
    instansiId: string
    key: Roles
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    instansiId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    instansiId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    instansiId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRolesWithAggregatesFilter = {
    equals?: Roles
    in?: Enumerable<Roles>
    notIn?: Enumerable<Roles>
    not?: NestedEnumRolesWithAggregatesFilter | Roles
    _count?: NestedIntFilter
    _min?: NestedEnumRolesFilter
    _max?: NestedEnumRolesFilter
  }

  export type GoogleNullableCompositeFilter = {
    equals?: GoogleObjectEqualityInput | null
    is?: GoogleWhereInput | null
    isNot?: GoogleWhereInput | null
    isSet?: boolean
  }

  export type GoogleObjectEqualityInput = {
    scopes?: Enumerable<string>
    tokens: InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput | null
    isNot?: RoleWhereInput | null
  }

  export type AuthRelationFilter = {
    is?: AuthWhereInput | null
    isNot?: AuthWhereInput | null
  }

  export type LinkListRelationFilter = {
    every?: LinkWhereInput
    some?: LinkWhereInput
    none?: LinkWhereInput
  }

  export type GoogleOrderByInput = {
    scopes?: SortOrder
    tokens?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    picture?: SortOrder
    username?: SortOrder
    active?: SortOrder
    verify?: SortOrder
    password?: SortOrder
    passhash?: SortOrder
    roleId?: SortOrder
    disable?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    picture?: SortOrder
    username?: SortOrder
    active?: SortOrder
    verify?: SortOrder
    password?: SortOrder
    passhash?: SortOrder
    roleId?: SortOrder
    disable?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    picture?: SortOrder
    username?: SortOrder
    active?: SortOrder
    verify?: SortOrder
    password?: SortOrder
    passhash?: SortOrder
    roleId?: SortOrder
    disable?: SortOrder
  }

  export type EnumUploadTypeFilter = {
    equals?: UploadType
    in?: Enumerable<UploadType>
    notIn?: Enumerable<UploadType>
    not?: NestedEnumUploadTypeFilter | UploadType
  }

  export type UploadCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    url?: SortOrder
  }

  export type UploadMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    url?: SortOrder
  }

  export type UploadMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    url?: SortOrder
  }

  export type EnumUploadTypeWithAggregatesFilter = {
    equals?: UploadType
    in?: Enumerable<UploadType>
    notIn?: Enumerable<UploadType>
    not?: NestedEnumUploadTypeWithAggregatesFilter | UploadType
    _count?: NestedIntFilter
    _min?: NestedEnumUploadTypeFilter
    _max?: NestedEnumUploadTypeFilter
  }

  export type EnumTypePersonalFilter = {
    equals?: TypePersonal
    in?: Enumerable<TypePersonal>
    notIn?: Enumerable<TypePersonal>
    not?: NestedEnumTypePersonalFilter | TypePersonal
  }

  export type EnumGenderFilter = {
    equals?: Gender
    in?: Enumerable<Gender>
    notIn?: Enumerable<Gender>
    not?: NestedEnumGenderFilter | Gender
  }

  export type EnumReligionFilter = {
    equals?: Religion
    in?: Enumerable<Religion>
    notIn?: Enumerable<Religion>
    not?: NestedEnumReligionFilter | Religion
  }

  export type BornCompositeFilter = {
    equals?: BornObjectEqualityInput
    is?: BornWhereInput
    isNot?: BornWhereInput
  }

  export type BornObjectEqualityInput = {
    place: string
    date: Date | string
  }

  export type AddressNullableCompositeFilter = {
    equals?: AddressObjectEqualityInput | null
    is?: AddressWhereInput | null
    isNot?: AddressWhereInput | null
    isSet?: boolean
  }

  export type EducationCompositeListFilter = {
    equals?: Enumerable<EducationObjectEqualityInput>
    every?: EducationWhereInput
    some?: EducationWhereInput
    none?: EducationWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type EducationObjectEqualityInput = {
    instansi: string
    level: LevelEdu
    major?: string | null
    year: number
    attachment?: string | null
  }

  export type TrainingCompositeListFilter = {
    equals?: Enumerable<TrainingObjectEqualityInput>
    every?: TrainingWhereInput
    some?: TrainingWhereInput
    none?: TrainingWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type TrainingObjectEqualityInput = {
    name: string
    instansi: string
    long: number
    year: number
    place: string
    attachment?: string | null
  }

  export type EmploymentCompositeListFilter = {
    equals?: Enumerable<EmploymentObjectEqualityInput>
    every?: EmploymentWhereInput
    some?: EmploymentWhereInput
    none?: EmploymentWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type EmploymentObjectEqualityInput = {
    position: string
    year: number
    place: string
    note?: string | null
  }

  export type ProfessionCompositeListFilter = {
    equals?: Enumerable<ProfessionObjectEqualityInput>
    every?: ProfessionWhereInput
    some?: ProfessionWhereInput
    none?: ProfessionWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type ProfessionObjectEqualityInput = {
    name: string
    instansi: string
    year: number
    attachment?: string | null
  }

  export type OverseasCompositeListFilter = {
    equals?: Enumerable<OverseasObjectEqualityInput>
    every?: OverseasWhereInput
    some?: OverseasWhereInput
    none?: OverseasWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type OverseasObjectEqualityInput = {
    country: string
    instansi: string
    objective: string
    long: number
    year: number
    attachment?: string | null
  }

  export type ScientificCompositeListFilter = {
    equals?: Enumerable<ScientificObjectEqualityInput>
    every?: ScientificWhereInput
    some?: ScientificWhereInput
    none?: ScientificWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type ScientificObjectEqualityInput = {
    name: string
    instansi: string
    position: string
    place: string
    period: string
    attachment?: string | null
  }

  export type OrganizationCompositeListFilter = {
    equals?: Enumerable<OrganizationObjectEqualityInput>
    every?: OrganizationWhereInput
    some?: OrganizationWhereInput
    none?: OrganizationWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type OrganizationObjectEqualityInput = {
    name: string
    position: string
    period: string
    leader: string
    place: string
  }

  export type PapersCompositeListFilter = {
    equals?: Enumerable<PapersObjectEqualityInput>
    every?: PapersWhereInput
    some?: PapersWhereInput
    none?: PapersWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type PapersObjectEqualityInput = {
    name: string
    year: number
    published: string
  }

  export type InnovationCompositeListFilter = {
    equals?: Enumerable<InnovationObjectEqualityInput>
    every?: InnovationWhereInput
    some?: InnovationWhereInput
    none?: InnovationWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type InnovationObjectEqualityInput = {
    name: string
    year: number
    patent: boolean
  }

  export type AwardCompositeListFilter = {
    equals?: Enumerable<AwardObjectEqualityInput>
    every?: AwardWhereInput
    some?: AwardWhereInput
    none?: AwardWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type AwardObjectEqualityInput = {
    name: string
    year: number
    instansi: string
    attachment?: string | null
  }

  export type SourcePersonCompositeListFilter = {
    equals?: Enumerable<SourcePersonObjectEqualityInput>
    every?: SourcePersonWhereInput
    some?: SourcePersonWhereInput
    none?: SourcePersonWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type SourcePersonObjectEqualityInput = {
    name: string
    date: string
    instansi: string
    note?: string | null
    attachment?: string | null
  }

  export type ContestCompositeListFilter = {
    equals?: Enumerable<ContestObjectEqualityInput>
    every?: ContestWhereInput
    some?: ContestWhereInput
    none?: ContestWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type ContestObjectEqualityInput = {
    name: string
    date: string
    instansi: string
    level: string
    attachment?: string | null
  }

  export type DocumentsCompositeListFilter = {
    equals?: Enumerable<DocumentsObjectEqualityInput>
    every?: DocumentsWhereInput
    some?: DocumentsWhereInput
    none?: DocumentsWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type DocumentsObjectEqualityInput = {
    name: string
    date: string
    instansi: string
    note?: string | null
    attachment?: string | null
  }

  export type AdditionalCompositeListFilter = {
    equals?: Enumerable<AdditionalObjectEqualityInput>
    every?: AdditionalWhereInput
    some?: AdditionalWhereInput
    none?: AdditionalWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type AdditionalObjectEqualityInput = {
    position: string
    date: string
    instansi: string
    note?: string | null
    attachment?: string | null
  }

  export type FamilyTreeListRelationFilter = {
    every?: FamilyTreeWhereInput
    some?: FamilyTreeWhereInput
    none?: FamilyTreeWhereInput
  }

  export type FamilyTreeChildRelationFilter = {
    is?: FamilyTreeChildWhereInput | null
    isNot?: FamilyTreeChildWhereInput | null
  }

  export type BornOrderByInput = {
    place?: SortOrder
    date?: SortOrder
  }

  export type EducationOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type EmploymentOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type ProfessionOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type OverseasOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type ScientificOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type PapersOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type InnovationOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type AwardOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type SourcePersonOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type ContestOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentsOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type AdditionalOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type FamilyTreeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonalCountOrderByAggregateInput = {
    id?: SortOrder
    nik?: SortOrder
    nisn?: SortOrder
    type?: SortOrder
    fullname?: SortOrder
    gender?: SortOrder
    foreign?: SortOrder
    country?: SortOrder
    religion?: SortOrder
    email?: SortOrder
    belajarId?: SortOrder
    nophone?: SortOrder
    isLife?: SortOrder
    disable?: SortOrder
  }

  export type PersonalMaxOrderByAggregateInput = {
    id?: SortOrder
    nik?: SortOrder
    nisn?: SortOrder
    type?: SortOrder
    fullname?: SortOrder
    gender?: SortOrder
    foreign?: SortOrder
    country?: SortOrder
    religion?: SortOrder
    email?: SortOrder
    belajarId?: SortOrder
    nophone?: SortOrder
    isLife?: SortOrder
    disable?: SortOrder
  }

  export type PersonalMinOrderByAggregateInput = {
    id?: SortOrder
    nik?: SortOrder
    nisn?: SortOrder
    type?: SortOrder
    fullname?: SortOrder
    gender?: SortOrder
    foreign?: SortOrder
    country?: SortOrder
    religion?: SortOrder
    email?: SortOrder
    belajarId?: SortOrder
    nophone?: SortOrder
    isLife?: SortOrder
    disable?: SortOrder
  }

  export type EnumTypePersonalWithAggregatesFilter = {
    equals?: TypePersonal
    in?: Enumerable<TypePersonal>
    notIn?: Enumerable<TypePersonal>
    not?: NestedEnumTypePersonalWithAggregatesFilter | TypePersonal
    _count?: NestedIntFilter
    _min?: NestedEnumTypePersonalFilter
    _max?: NestedEnumTypePersonalFilter
  }

  export type EnumGenderWithAggregatesFilter = {
    equals?: Gender
    in?: Enumerable<Gender>
    notIn?: Enumerable<Gender>
    not?: NestedEnumGenderWithAggregatesFilter | Gender
    _count?: NestedIntFilter
    _min?: NestedEnumGenderFilter
    _max?: NestedEnumGenderFilter
  }

  export type EnumReligionWithAggregatesFilter = {
    equals?: Religion
    in?: Enumerable<Religion>
    notIn?: Enumerable<Religion>
    not?: NestedEnumReligionWithAggregatesFilter | Religion
    _count?: NestedIntFilter
    _min?: NestedEnumReligionFilter
    _max?: NestedEnumReligionFilter
  }

  export type PersonalRelationFilter = {
    is?: PersonalWhereInput
    isNot?: PersonalWhereInput
  }

  export type AuthAuthUserPersonalCompoundUniqueInput = {
    userId: string
    personalId: string
  }

  export type AuthCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    personalId?: SortOrder
  }

  export type AuthMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    personalId?: SortOrder
  }

  export type AuthMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    personalId?: SortOrder
  }

  export type FamilyTreeChildListRelationFilter = {
    every?: FamilyTreeChildWhereInput
    some?: FamilyTreeChildWhereInput
    none?: FamilyTreeChildWhereInput
  }

  export type FamilyTreeChildOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FamilyTreeCountOrderByAggregateInput = {
    id?: SortOrder
    nokk?: SortOrder
    fatherId?: SortOrder
    motherId?: SortOrder
    waliId?: SortOrder
    coupleId?: SortOrder
  }

  export type FamilyTreeMaxOrderByAggregateInput = {
    id?: SortOrder
    nokk?: SortOrder
    fatherId?: SortOrder
    motherId?: SortOrder
    waliId?: SortOrder
    coupleId?: SortOrder
  }

  export type FamilyTreeMinOrderByAggregateInput = {
    id?: SortOrder
    nokk?: SortOrder
    fatherId?: SortOrder
    motherId?: SortOrder
    waliId?: SortOrder
    coupleId?: SortOrder
  }

  export type EnumChildTypeFilter = {
    equals?: ChildType
    in?: Enumerable<ChildType>
    notIn?: Enumerable<ChildType>
    not?: NestedEnumChildTypeFilter | ChildType
  }

  export type FamilyTreeRelationFilter = {
    is?: FamilyTreeWhereInput
    isNot?: FamilyTreeWhereInput
  }

  export type FamilyTreeChildCountOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    type?: SortOrder
    kkId?: SortOrder
    personalId?: SortOrder
  }

  export type FamilyTreeChildAvgOrderByAggregateInput = {
    no?: SortOrder
  }

  export type FamilyTreeChildMaxOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    type?: SortOrder
    kkId?: SortOrder
    personalId?: SortOrder
  }

  export type FamilyTreeChildMinOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    type?: SortOrder
    kkId?: SortOrder
    personalId?: SortOrder
  }

  export type FamilyTreeChildSumOrderByAggregateInput = {
    no?: SortOrder
  }

  export type EnumChildTypeWithAggregatesFilter = {
    equals?: ChildType
    in?: Enumerable<ChildType>
    notIn?: Enumerable<ChildType>
    not?: NestedEnumChildTypeWithAggregatesFilter | ChildType
    _count?: NestedIntFilter
    _min?: NestedEnumChildTypeFilter
    _max?: NestedEnumChildTypeFilter
  }

  export type OrganizationalCompositeFilter = {
    equals?: OrganizationalObjectEqualityInput
    is?: OrganizationalWhereInput
    isNot?: OrganizationalWhereInput
  }

  export type OrganizationalObjectEqualityInput = {
    kepsek: string
    wakasek: string
    wakakur: string
    wakasiw: string
    wakapra: string
    wakahum?: string | null
  }

  export type CalendarListRelationFilter = {
    every?: CalendarWhereInput
    some?: CalendarWhereInput
    none?: CalendarWhereInput
  }

  export type OrganizationalOrderByInput = {
    kepsek?: SortOrder
    wakasek?: SortOrder
    wakakur?: SortOrder
    wakasiw?: SortOrder
    wakapra?: SortOrder
    wakahum?: SortOrder
  }

  export type CalendarOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolYearESchoolYearCompoundUniqueInput = {
    instansiId: string
    year: number
  }

  export type SchoolYearCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    instansiId?: SortOrder
    departments?: SortOrder
    disable?: SortOrder
  }

  export type SchoolYearAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type SchoolYearMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    instansiId?: SortOrder
    disable?: SortOrder
  }

  export type SchoolYearMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    instansiId?: SortOrder
    disable?: SortOrder
  }

  export type SchoolYearSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
    isSet?: boolean
  }

  export type TeacherTeachInCompoundUniqueInput = {
    personalId: string
    instansiId: string
  }

  export type TeacherCountOrderByAggregateInput = {
    id?: SortOrder
    personalId?: SortOrder
    instansiId?: SortOrder
    eventIds?: SortOrder
    nip?: SortOrder
    nrg?: SortOrder
    noKarpeg?: SortOrder
    tmtTugas?: SortOrder
    tmtGol?: SortOrder
    position?: SortOrder
    rank?: SortOrder
    period?: SortOrder
    certificate?: SortOrder
    disable?: SortOrder
  }

  export type TeacherMaxOrderByAggregateInput = {
    id?: SortOrder
    personalId?: SortOrder
    instansiId?: SortOrder
    nip?: SortOrder
    nrg?: SortOrder
    noKarpeg?: SortOrder
    tmtTugas?: SortOrder
    tmtGol?: SortOrder
    position?: SortOrder
    rank?: SortOrder
    period?: SortOrder
    certificate?: SortOrder
    disable?: SortOrder
  }

  export type TeacherMinOrderByAggregateInput = {
    id?: SortOrder
    personalId?: SortOrder
    instansiId?: SortOrder
    nip?: SortOrder
    nrg?: SortOrder
    noKarpeg?: SortOrder
    tmtTugas?: SortOrder
    tmtGol?: SortOrder
    position?: SortOrder
    rank?: SortOrder
    period?: SortOrder
    certificate?: SortOrder
    disable?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    isSet?: boolean
  }

  export type RoomPropertyNullableCompositeFilter = {
    equals?: RoomPropertyObjectEqualityInput | null
    is?: RoomPropertyWhereInput | null
    isNot?: RoomPropertyWhereInput | null
    isSet?: boolean
  }

  export type RoomPropertyObjectEqualityInput = {
    pkl?: boolean | null
  }

  export type RoomPropertyOrderByInput = {
    pkl?: SortOrder
  }

  export type ClassRoomNameClassRoomCompoundUniqueInput = {
    yearId: string
    name: string
  }

  export type ClassRoomCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    yearId?: SortOrder
    waliId?: SortOrder
    level?: SortOrder
    majorId?: SortOrder
    studentIds?: SortOrder
    eventIds?: SortOrder
    disable?: SortOrder
    teachingIds?: SortOrder
    tDeviceIds?: SortOrder
  }

  export type ClassRoomAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type ClassRoomMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    yearId?: SortOrder
    waliId?: SortOrder
    level?: SortOrder
    majorId?: SortOrder
    disable?: SortOrder
  }

  export type ClassRoomMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    yearId?: SortOrder
    waliId?: SortOrder
    level?: SortOrder
    majorId?: SortOrder
    disable?: SortOrder
  }

  export type ClassRoomSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type StudentStudyInCompoundUniqueInput = {
    personalId: string
    instansiId: string
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    nis?: SortOrder
    lastSchool?: SortOrder
    personalId?: SortOrder
    majorId?: SortOrder
    classRoomIds?: SortOrder
    startYearId?: SortOrder
    instansiId?: SortOrder
    eventIds?: SortOrder
    disable?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    nis?: SortOrder
    lastSchool?: SortOrder
    personalId?: SortOrder
    majorId?: SortOrder
    startYearId?: SortOrder
    instansiId?: SortOrder
    disable?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    nis?: SortOrder
    lastSchool?: SortOrder
    personalId?: SortOrder
    majorId?: SortOrder
    startYearId?: SortOrder
    instansiId?: SortOrder
    disable?: SortOrder
  }

  export type ScheduleYearIdMapelIdCompoundUniqueInput = {
    yearId: string
    mapelId: string
  }

  export type ScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    yearId?: SortOrder
    mapelId?: SortOrder
    disable?: SortOrder
  }

  export type ScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    yearId?: SortOrder
    mapelId?: SortOrder
    disable?: SortOrder
  }

  export type ScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    yearId?: SortOrder
    mapelId?: SortOrder
    disable?: SortOrder
  }

  export type EnumSemesterFilter = {
    equals?: Semester
    in?: Enumerable<Semester>
    notIn?: Enumerable<Semester>
    not?: NestedEnumSemesterFilter | Semester
  }

  export type TeachingLevelSemesterRefIdTeacherIdCompoundUniqueInput = {
    level: number
    semester: Semester
    refId: string
    teacherId: string
  }

  export type TeachingCountOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    level?: SortOrder
    hours?: SortOrder
    semester?: SortOrder
    teacherId?: SortOrder
    classRoomIds?: SortOrder
    elemenIds?: SortOrder
    disable?: SortOrder
  }

  export type TeachingAvgOrderByAggregateInput = {
    level?: SortOrder
    hours?: SortOrder
  }

  export type TeachingMaxOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    level?: SortOrder
    hours?: SortOrder
    semester?: SortOrder
    teacherId?: SortOrder
    disable?: SortOrder
  }

  export type TeachingMinOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    level?: SortOrder
    hours?: SortOrder
    semester?: SortOrder
    teacherId?: SortOrder
    disable?: SortOrder
  }

  export type TeachingSumOrderByAggregateInput = {
    level?: SortOrder
    hours?: SortOrder
  }

  export type EnumSemesterWithAggregatesFilter = {
    equals?: Semester
    in?: Enumerable<Semester>
    notIn?: Enumerable<Semester>
    not?: NestedEnumSemesterWithAggregatesFilter | Semester
    _count?: NestedIntFilter
    _min?: NestedEnumSemesterFilter
    _max?: NestedEnumSemesterFilter
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
    isSet?: boolean
  }

  export type OresourceListRelationFilter = {
    every?: OresourceWhereInput
    some?: OresourceWhereInput
    none?: OresourceWhereInput
  }

  export type OresourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LinkCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    width?: SortOrder
    height?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LinkAvgOrderByAggregateInput = {
    width?: SortOrder
    height?: SortOrder
  }

  export type LinkMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    width?: SortOrder
    height?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LinkMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    width?: SortOrder
    height?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LinkSumOrderByAggregateInput = {
    width?: SortOrder
    height?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    isSet?: boolean
  }

  export type OAssessmentCountOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    type?: SortOrder
    techs?: SortOrder
  }

  export type OAssessmentMaxOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    type?: SortOrder
  }

  export type OAssessmentMinOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    type?: SortOrder
  }

  export type OMaterialListRelationFilter = {
    every?: OMaterialWhereInput
    some?: OMaterialWhereInput
    none?: OMaterialWhereInput
  }

  export type OpppListRelationFilter = {
    every?: OpppWhereInput
    some?: OpppWhereInput
    none?: OpppWhereInput
  }

  export type OhelperListRelationFilter = {
    every?: OhelperWhereInput
    some?: OhelperWhereInput
    none?: OhelperWhereInput
  }

  export type OAssessmentListRelationFilter = {
    every?: OAssessmentWhereInput
    some?: OAssessmentWhereInput
    none?: OAssessmentWhereInput
  }

  export type TDeviceDataListRelationFilter = {
    every?: TDeviceDataWhereInput
    some?: TDeviceDataWhereInput
    none?: TDeviceDataWhereInput
  }

  export type OMaterialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OpppOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OhelperOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OAssessmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TDeviceDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObjectiveCountOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    fase?: SortOrder
    userId?: SortOrder
    instansiId?: SortOrder
    yearId?: SortOrder
    mapelId?: SortOrder
    elementId?: SortOrder
    achievementId?: SortOrder
    code?: SortOrder
    kkm?: SortOrder
    steps?: SortOrder
    subjectMatter?: SortOrder
    competencie?: SortOrder
    firstSkill?: SortOrder
    triggerQuest?: SortOrder
    disable?: SortOrder
    toolIds?: SortOrder
    mateIds?: SortOrder
    methIds?: SortOrder
    mediaIds?: SortOrder
  }

  export type ObjectiveAvgOrderByAggregateInput = {
    level?: SortOrder
    kkm?: SortOrder
    steps?: SortOrder
  }

  export type ObjectiveMaxOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    fase?: SortOrder
    userId?: SortOrder
    instansiId?: SortOrder
    yearId?: SortOrder
    mapelId?: SortOrder
    elementId?: SortOrder
    achievementId?: SortOrder
    code?: SortOrder
    kkm?: SortOrder
    steps?: SortOrder
    subjectMatter?: SortOrder
    disable?: SortOrder
  }

  export type ObjectiveMinOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    fase?: SortOrder
    userId?: SortOrder
    instansiId?: SortOrder
    yearId?: SortOrder
    mapelId?: SortOrder
    elementId?: SortOrder
    achievementId?: SortOrder
    code?: SortOrder
    kkm?: SortOrder
    steps?: SortOrder
    subjectMatter?: SortOrder
    disable?: SortOrder
  }

  export type ObjectiveSumOrderByAggregateInput = {
    level?: SortOrder
    kkm?: SortOrder
    steps?: SortOrder
  }

  export type EnumOMaterialModelFilter = {
    equals?: OMaterialModel
    in?: Enumerable<OMaterialModel>
    notIn?: Enumerable<OMaterialModel>
    not?: NestedEnumOMaterialModelFilter | OMaterialModel
  }

  export type OLearningListRelationFilter = {
    every?: OLearningWhereInput
    some?: OLearningWhereInput
    none?: OLearningWhereInput
  }

  export type OLearningOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OMaterialNoRefIdCompoundUniqueInput = {
    no: number
    refId: string
  }

  export type OMaterialCountOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    no?: SortOrder
    content?: SortOrder
    model?: SortOrder
  }

  export type OMaterialAvgOrderByAggregateInput = {
    no?: SortOrder
  }

  export type OMaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    no?: SortOrder
    content?: SortOrder
    model?: SortOrder
  }

  export type OMaterialMinOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    no?: SortOrder
    content?: SortOrder
    model?: SortOrder
  }

  export type OMaterialSumOrderByAggregateInput = {
    no?: SortOrder
  }

  export type EnumOMaterialModelWithAggregatesFilter = {
    equals?: OMaterialModel
    in?: Enumerable<OMaterialModel>
    notIn?: Enumerable<OMaterialModel>
    not?: NestedEnumOMaterialModelWithAggregatesFilter | OMaterialModel
    _count?: NestedIntFilter
    _min?: NestedEnumOMaterialModelFilter
    _max?: NestedEnumOMaterialModelFilter
  }

  export type EnumTaksonomiFilter = {
    equals?: Taksonomi
    in?: Enumerable<Taksonomi>
    notIn?: Enumerable<Taksonomi>
    not?: NestedEnumTaksonomiFilter | Taksonomi
  }

  export type OMaterialRelationFilter = {
    is?: OMaterialWhereInput
    isNot?: OMaterialWhereInput
  }

  export type OLearningNoRefIdCompoundUniqueInput = {
    no: number
    refId: string
  }

  export type OLearningCountOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    no?: SortOrder
    content?: SortOrder
    taksonomi?: SortOrder
    sentence?: SortOrder
  }

  export type OLearningAvgOrderByAggregateInput = {
    no?: SortOrder
  }

  export type OLearningMaxOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    no?: SortOrder
    content?: SortOrder
    taksonomi?: SortOrder
    sentence?: SortOrder
  }

  export type OLearningMinOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    no?: SortOrder
    content?: SortOrder
    taksonomi?: SortOrder
    sentence?: SortOrder
  }

  export type OLearningSumOrderByAggregateInput = {
    no?: SortOrder
  }

  export type EnumTaksonomiWithAggregatesFilter = {
    equals?: Taksonomi
    in?: Enumerable<Taksonomi>
    notIn?: Enumerable<Taksonomi>
    not?: NestedEnumTaksonomiWithAggregatesFilter | Taksonomi
    _count?: NestedIntFilter
    _min?: NestedEnumTaksonomiFilter
    _max?: NestedEnumTaksonomiFilter
  }

  export type EnumOhelperTypeFilter = {
    equals?: OhelperType
    in?: Enumerable<OhelperType>
    notIn?: Enumerable<OhelperType>
    not?: NestedEnumOhelperTypeFilter | OhelperType
  }

  export type OhelperTypeNameCompoundUniqueInput = {
    type: OhelperType
    name: string
  }

  export type OhelperCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    toolIds?: SortOrder
    mateIds?: SortOrder
    methIds?: SortOrder
    mediaIds?: SortOrder
  }

  export type OhelperMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
  }

  export type OhelperMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
  }

  export type EnumOhelperTypeWithAggregatesFilter = {
    equals?: OhelperType
    in?: Enumerable<OhelperType>
    notIn?: Enumerable<OhelperType>
    not?: NestedEnumOhelperTypeWithAggregatesFilter | OhelperType
    _count?: NestedIntFilter
    _min?: NestedEnumOhelperTypeFilter
    _max?: NestedEnumOhelperTypeFilter
  }

  export type OpppRefIdNameCompoundUniqueInput = {
    refId: string
    name: string
  }

  export type OpppCountOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type OpppMaxOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type OpppMinOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type EnumOresourceTypeFilter = {
    equals?: OresourceType
    in?: Enumerable<OresourceType>
    notIn?: Enumerable<OresourceType>
    not?: NestedEnumOresourceTypeFilter | OresourceType
  }

  export type LinkRelationFilter = {
    is?: LinkWhereInput | null
    isNot?: LinkWhereInput | null
  }

  export type OresourceKeysCompoundUniqueInput = {
    refId: string
    linkId: string
    name: string
  }

  export type OresourceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    refId?: SortOrder
    linkId?: SortOrder
  }

  export type OresourceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    refId?: SortOrder
    linkId?: SortOrder
  }

  export type OresourceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    refId?: SortOrder
    linkId?: SortOrder
  }

  export type EnumOresourceTypeWithAggregatesFilter = {
    equals?: OresourceType
    in?: Enumerable<OresourceType>
    notIn?: Enumerable<OresourceType>
    not?: NestedEnumOresourceTypeWithAggregatesFilter | OresourceType
    _count?: NestedIntFilter
    _min?: NestedEnumOresourceTypeFilter
    _max?: NestedEnumOresourceTypeFilter
  }

  export type BookCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    author?: SortOrder
  }

  export type BookMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    author?: SortOrder
  }

  export type BookMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    author?: SortOrder
  }

  export type TDevicePropsCompositeFilter = {
    equals?: TDevicePropsObjectEqualityInput
    is?: TDevicePropsWhereInput
    isNot?: TDevicePropsWhereInput
  }

  export type TDevicePropsObjectEqualityInput = {
    docDate: Date | string
    docAddr: string
    kepText: string
    kepUser: string
    ke3Text: string
    jabText: string
    ke3User: string
  }

  export type TDevicePosCompositeListFilter = {
    equals?: Enumerable<TDevicePosObjectEqualityInput>
    every?: TDevicePosWhereInput
    some?: TDevicePosWhereInput
    none?: TDevicePosWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type TDevicePosObjectEqualityInput = {
    mouth: number
    week: number
    active: boolean
  }

  export type TDevicePropsOrderByInput = {
    docDate?: SortOrder
    docAddr?: SortOrder
    kepText?: SortOrder
    kepUser?: SortOrder
    ke3Text?: SortOrder
    jabText?: SortOrder
    ke3User?: SortOrder
  }

  export type TDevicePosOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type TDeviceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    fase?: SortOrder
    teachingId?: SortOrder
    yearId?: SortOrder
    userId?: SortOrder
    instansiId?: SortOrder
    mapelId?: SortOrder
    classRoomIds?: SortOrder
    elemen?: SortOrder
    disable?: SortOrder
    parentId?: SortOrder
  }

  export type TDeviceAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type TDeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    fase?: SortOrder
    teachingId?: SortOrder
    yearId?: SortOrder
    userId?: SortOrder
    instansiId?: SortOrder
    mapelId?: SortOrder
    disable?: SortOrder
    parentId?: SortOrder
  }

  export type TDeviceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    fase?: SortOrder
    teachingId?: SortOrder
    yearId?: SortOrder
    userId?: SortOrder
    instansiId?: SortOrder
    mapelId?: SortOrder
    disable?: SortOrder
    parentId?: SortOrder
  }

  export type TDeviceSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type TDeviceDataCountOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    objectiveId?: SortOrder
  }

  export type TDeviceDataMaxOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    objectiveId?: SortOrder
  }

  export type TDeviceDataMinOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    objectiveId?: SortOrder
  }

  export type CalendarCountOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    start?: SortOrder
    end?: SortOrder
    color?: SortOrder
    classRoomIds?: SortOrder
    studentIds?: SortOrder
    teacherIds?: SortOrder
    disable?: SortOrder
  }

  export type CalendarMaxOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    start?: SortOrder
    end?: SortOrder
    color?: SortOrder
    disable?: SortOrder
  }

  export type CalendarMinOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    start?: SortOrder
    end?: SortOrder
    color?: SortOrder
    disable?: SortOrder
  }

  export type ContactDudiCompositeFilter = {
    equals?: ContactDudiObjectEqualityInput
    is?: ContactDudiWhereInput
    isNot?: ContactDudiWhereInput
  }

  export type ContactDudiObjectEqualityInput = {
    name: string
    position: string
    email: string
    phone: string
  }

  export type DudiTimeWorkCompositeFilter = {
    equals?: DudiTimeWorkObjectEqualityInput
    is?: DudiTimeWorkWhereInput
    isNot?: DudiTimeWorkWhereInput
  }

  export type DudiTimeWorkObjectEqualityInput = {
    holidays?: Enumerable<string>
    timeIn: string
    timeOut: string
    actifity: boolean
  }

  export type DudiLearningListRelationFilter = {
    every?: DudiLearningWhereInput
    some?: DudiLearningWhereInput
    none?: DudiLearningWhereInput
  }

  export type ContactDudiOrderByInput = {
    name?: SortOrder
    position?: SortOrder
    email?: SortOrder
    phone?: SortOrder
  }

  export type DudiTimeWorkOrderByInput = {
    holidays?: SortOrder
    timeIn?: SortOrder
    timeOut?: SortOrder
    actifity?: SortOrder
  }

  export type DudiLearningOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DudiCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    street?: SortOrder
    instansiId?: SortOrder
    majorId?: SortOrder
    collabs?: SortOrder
    disable?: SortOrder
    kkniId?: SortOrder
  }

  export type DudiMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    street?: SortOrder
    instansiId?: SortOrder
    majorId?: SortOrder
    disable?: SortOrder
    kkniId?: SortOrder
  }

  export type DudiMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    street?: SortOrder
    instansiId?: SortOrder
    majorId?: SortOrder
    disable?: SortOrder
    kkniId?: SortOrder
  }

  export type DudiIndicatorCompositeListFilter = {
    equals?: Enumerable<DudiIndicatorObjectEqualityInput>
    every?: DudiIndicatorWhereInput
    some?: DudiIndicatorWhereInput
    none?: DudiIndicatorWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type DudiIndicatorObjectEqualityInput = {
    no: number
    code: string
    name: string
  }

  export type DudiIndicatorOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type DudiLearningCountOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    refId?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type DudiLearningAvgOrderByAggregateInput = {
    no?: SortOrder
  }

  export type DudiLearningMaxOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    refId?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type DudiLearningMinOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    refId?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type DudiLearningSumOrderByAggregateInput = {
    no?: SortOrder
  }

  export type KkniCountOrderByAggregateInput = {
    id?: SortOrder
    konsentrasiId?: SortOrder
    no?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    disable?: SortOrder
  }

  export type KkniAvgOrderByAggregateInput = {
    no?: SortOrder
  }

  export type KkniMaxOrderByAggregateInput = {
    id?: SortOrder
    konsentrasiId?: SortOrder
    no?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    disable?: SortOrder
  }

  export type KkniMinOrderByAggregateInput = {
    id?: SortOrder
    konsentrasiId?: SortOrder
    no?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    disable?: SortOrder
  }

  export type KkniSumOrderByAggregateInput = {
    no?: SortOrder
  }

  export type UserCreateNestedOneWithoutTrackerInput = {
    create?: XOR<UserCreateWithoutTrackerInput, UserUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrackerInput
    connect?: UserWhereUniqueInput
  }

  export type InstansiCreateNestedOneWithoutHistoryInput = {
    create?: XOR<InstansiCreateWithoutHistoryInput, InstansiUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutHistoryInput
    connect?: InstansiWhereUniqueInput
  }

  export type InstansiCreateNestedOneWithoutTrackerInput = {
    create?: XOR<InstansiCreateWithoutTrackerInput, InstansiUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutTrackerInput
    connect?: InstansiWhereUniqueInput
  }

  export type MataPelajaranCreateNestedOneWithoutTrackerInput = {
    create?: XOR<MataPelajaranCreateWithoutTrackerInput, MataPelajaranUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: MataPelajaranCreateOrConnectWithoutTrackerInput
    connect?: MataPelajaranWhereUniqueInput
  }

  export type ElementCreateNestedOneWithoutTrackerInput = {
    create?: XOR<ElementCreateWithoutTrackerInput, ElementUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: ElementCreateOrConnectWithoutTrackerInput
    connect?: ElementWhereUniqueInput
  }

  export type AchievementCreateNestedOneWithoutTrackerInput = {
    create?: XOR<AchievementCreateWithoutTrackerInput, AchievementUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutTrackerInput
    connect?: AchievementWhereUniqueInput
  }

  export type BidangKeahlianCreateNestedOneWithoutTrackerInput = {
    create?: XOR<BidangKeahlianCreateWithoutTrackerInput, BidangKeahlianUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: BidangKeahlianCreateOrConnectWithoutTrackerInput
    connect?: BidangKeahlianWhereUniqueInput
  }

  export type ProgramKeahlianCreateNestedOneWithoutTrackerInput = {
    create?: XOR<ProgramKeahlianCreateWithoutTrackerInput, ProgramKeahlianUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: ProgramKeahlianCreateOrConnectWithoutTrackerInput
    connect?: ProgramKeahlianWhereUniqueInput
  }

  export type KonsentrasiKeahlianCreateNestedOneWithoutTrackerInput = {
    create?: XOR<KonsentrasiKeahlianCreateWithoutTrackerInput, KonsentrasiKeahlianUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: KonsentrasiKeahlianCreateOrConnectWithoutTrackerInput
    connect?: KonsentrasiKeahlianWhereUniqueInput
  }

  export type SchoolYearCreateNestedOneWithoutTrackerInput = {
    create?: XOR<SchoolYearCreateWithoutTrackerInput, SchoolYearUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: SchoolYearCreateOrConnectWithoutTrackerInput
    connect?: SchoolYearWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutTrackerInput = {
    create?: XOR<TeacherCreateWithoutTrackerInput, TeacherUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTrackerInput
    connect?: TeacherWhereUniqueInput
  }

  export type ClassRoomCreateNestedOneWithoutTrackerInput = {
    create?: XOR<ClassRoomCreateWithoutTrackerInput, ClassRoomUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: ClassRoomCreateOrConnectWithoutTrackerInput
    connect?: ClassRoomWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutTrackerInput = {
    create?: XOR<StudentCreateWithoutTrackerInput, StudentUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: StudentCreateOrConnectWithoutTrackerInput
    connect?: StudentWhereUniqueInput
  }

  export type ScheduleCreateNestedOneWithoutTrackerInput = {
    create?: XOR<ScheduleCreateWithoutTrackerInput, ScheduleUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutTrackerInput
    connect?: ScheduleWhereUniqueInput
  }

  export type TeachingCreateNestedOneWithoutTrackerInput = {
    create?: XOR<TeachingCreateWithoutTrackerInput, TeachingUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: TeachingCreateOrConnectWithoutTrackerInput
    connect?: TeachingWhereUniqueInput
  }

  export type ObjectiveCreateNestedOneWithoutTrackerInput = {
    create?: XOR<ObjectiveCreateWithoutTrackerInput, ObjectiveUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: ObjectiveCreateOrConnectWithoutTrackerInput
    connect?: ObjectiveWhereUniqueInput
  }

  export type TDeviceCreateNestedOneWithoutTrackerInput = {
    create?: XOR<TDeviceCreateWithoutTrackerInput, TDeviceUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: TDeviceCreateOrConnectWithoutTrackerInput
    connect?: TDeviceWhereUniqueInput
  }

  export type CalendarCreateNestedOneWithoutTrackerInput = {
    create?: XOR<CalendarCreateWithoutTrackerInput, CalendarUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: CalendarCreateOrConnectWithoutTrackerInput
    connect?: CalendarWhereUniqueInput
  }

  export type DudiCreateNestedOneWithoutTrackerInput = {
    create?: XOR<DudiCreateWithoutTrackerInput, DudiUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: DudiCreateOrConnectWithoutTrackerInput
    connect?: DudiWhereUniqueInput
  }

  export type KkniCreateNestedOneWithoutTrackerInput = {
    create?: XOR<KkniCreateWithoutTrackerInput, KkniUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: KkniCreateOrConnectWithoutTrackerInput
    connect?: KkniWhereUniqueInput
  }

  export type EnumPointTrackerFieldUpdateOperationsInput = {
    set?: PointTracker
  }

  export type EnumTypeTrackerFieldUpdateOperationsInput = {
    set?: TypeTracker
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutTrackerNestedInput = {
    create?: XOR<UserCreateWithoutTrackerInput, UserUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrackerInput
    upsert?: UserUpsertWithoutTrackerInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTrackerInput, UserUncheckedUpdateWithoutTrackerInput>
  }

  export type InstansiUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<InstansiCreateWithoutHistoryInput, InstansiUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutHistoryInput
    upsert?: InstansiUpsertWithoutHistoryInput
    connect?: InstansiWhereUniqueInput
    update?: XOR<InstansiUpdateWithoutHistoryInput, InstansiUncheckedUpdateWithoutHistoryInput>
  }

  export type InstansiUpdateOneWithoutTrackerNestedInput = {
    create?: XOR<InstansiCreateWithoutTrackerInput, InstansiUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutTrackerInput
    upsert?: InstansiUpsertWithoutTrackerInput
    disconnect?: boolean
    delete?: boolean
    connect?: InstansiWhereUniqueInput
    update?: XOR<InstansiUpdateWithoutTrackerInput, InstansiUncheckedUpdateWithoutTrackerInput>
  }

  export type MataPelajaranUpdateOneWithoutTrackerNestedInput = {
    create?: XOR<MataPelajaranCreateWithoutTrackerInput, MataPelajaranUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: MataPelajaranCreateOrConnectWithoutTrackerInput
    upsert?: MataPelajaranUpsertWithoutTrackerInput
    disconnect?: boolean
    delete?: boolean
    connect?: MataPelajaranWhereUniqueInput
    update?: XOR<MataPelajaranUpdateWithoutTrackerInput, MataPelajaranUncheckedUpdateWithoutTrackerInput>
  }

  export type ElementUpdateOneWithoutTrackerNestedInput = {
    create?: XOR<ElementCreateWithoutTrackerInput, ElementUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: ElementCreateOrConnectWithoutTrackerInput
    upsert?: ElementUpsertWithoutTrackerInput
    disconnect?: boolean
    delete?: boolean
    connect?: ElementWhereUniqueInput
    update?: XOR<ElementUpdateWithoutTrackerInput, ElementUncheckedUpdateWithoutTrackerInput>
  }

  export type AchievementUpdateOneWithoutTrackerNestedInput = {
    create?: XOR<AchievementCreateWithoutTrackerInput, AchievementUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutTrackerInput
    upsert?: AchievementUpsertWithoutTrackerInput
    disconnect?: boolean
    delete?: boolean
    connect?: AchievementWhereUniqueInput
    update?: XOR<AchievementUpdateWithoutTrackerInput, AchievementUncheckedUpdateWithoutTrackerInput>
  }

  export type BidangKeahlianUpdateOneWithoutTrackerNestedInput = {
    create?: XOR<BidangKeahlianCreateWithoutTrackerInput, BidangKeahlianUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: BidangKeahlianCreateOrConnectWithoutTrackerInput
    upsert?: BidangKeahlianUpsertWithoutTrackerInput
    disconnect?: boolean
    delete?: boolean
    connect?: BidangKeahlianWhereUniqueInput
    update?: XOR<BidangKeahlianUpdateWithoutTrackerInput, BidangKeahlianUncheckedUpdateWithoutTrackerInput>
  }

  export type ProgramKeahlianUpdateOneWithoutTrackerNestedInput = {
    create?: XOR<ProgramKeahlianCreateWithoutTrackerInput, ProgramKeahlianUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: ProgramKeahlianCreateOrConnectWithoutTrackerInput
    upsert?: ProgramKeahlianUpsertWithoutTrackerInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProgramKeahlianWhereUniqueInput
    update?: XOR<ProgramKeahlianUpdateWithoutTrackerInput, ProgramKeahlianUncheckedUpdateWithoutTrackerInput>
  }

  export type KonsentrasiKeahlianUpdateOneWithoutTrackerNestedInput = {
    create?: XOR<KonsentrasiKeahlianCreateWithoutTrackerInput, KonsentrasiKeahlianUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: KonsentrasiKeahlianCreateOrConnectWithoutTrackerInput
    upsert?: KonsentrasiKeahlianUpsertWithoutTrackerInput
    disconnect?: boolean
    delete?: boolean
    connect?: KonsentrasiKeahlianWhereUniqueInput
    update?: XOR<KonsentrasiKeahlianUpdateWithoutTrackerInput, KonsentrasiKeahlianUncheckedUpdateWithoutTrackerInput>
  }

  export type SchoolYearUpdateOneWithoutTrackerNestedInput = {
    create?: XOR<SchoolYearCreateWithoutTrackerInput, SchoolYearUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: SchoolYearCreateOrConnectWithoutTrackerInput
    upsert?: SchoolYearUpsertWithoutTrackerInput
    disconnect?: boolean
    delete?: boolean
    connect?: SchoolYearWhereUniqueInput
    update?: XOR<SchoolYearUpdateWithoutTrackerInput, SchoolYearUncheckedUpdateWithoutTrackerInput>
  }

  export type TeacherUpdateOneWithoutTrackerNestedInput = {
    create?: XOR<TeacherCreateWithoutTrackerInput, TeacherUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTrackerInput
    upsert?: TeacherUpsertWithoutTrackerInput
    disconnect?: boolean
    delete?: boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<TeacherUpdateWithoutTrackerInput, TeacherUncheckedUpdateWithoutTrackerInput>
  }

  export type ClassRoomUpdateOneWithoutTrackerNestedInput = {
    create?: XOR<ClassRoomCreateWithoutTrackerInput, ClassRoomUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: ClassRoomCreateOrConnectWithoutTrackerInput
    upsert?: ClassRoomUpsertWithoutTrackerInput
    disconnect?: boolean
    delete?: boolean
    connect?: ClassRoomWhereUniqueInput
    update?: XOR<ClassRoomUpdateWithoutTrackerInput, ClassRoomUncheckedUpdateWithoutTrackerInput>
  }

  export type StudentUpdateOneWithoutTrackerNestedInput = {
    create?: XOR<StudentCreateWithoutTrackerInput, StudentUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: StudentCreateOrConnectWithoutTrackerInput
    upsert?: StudentUpsertWithoutTrackerInput
    disconnect?: boolean
    delete?: boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<StudentUpdateWithoutTrackerInput, StudentUncheckedUpdateWithoutTrackerInput>
  }

  export type ScheduleUpdateOneWithoutTrackerNestedInput = {
    create?: XOR<ScheduleCreateWithoutTrackerInput, ScheduleUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutTrackerInput
    upsert?: ScheduleUpsertWithoutTrackerInput
    disconnect?: boolean
    delete?: boolean
    connect?: ScheduleWhereUniqueInput
    update?: XOR<ScheduleUpdateWithoutTrackerInput, ScheduleUncheckedUpdateWithoutTrackerInput>
  }

  export type TeachingUpdateOneWithoutTrackerNestedInput = {
    create?: XOR<TeachingCreateWithoutTrackerInput, TeachingUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: TeachingCreateOrConnectWithoutTrackerInput
    upsert?: TeachingUpsertWithoutTrackerInput
    disconnect?: boolean
    delete?: boolean
    connect?: TeachingWhereUniqueInput
    update?: XOR<TeachingUpdateWithoutTrackerInput, TeachingUncheckedUpdateWithoutTrackerInput>
  }

  export type ObjectiveUpdateOneWithoutTrackerNestedInput = {
    create?: XOR<ObjectiveCreateWithoutTrackerInput, ObjectiveUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: ObjectiveCreateOrConnectWithoutTrackerInput
    upsert?: ObjectiveUpsertWithoutTrackerInput
    disconnect?: boolean
    delete?: boolean
    connect?: ObjectiveWhereUniqueInput
    update?: XOR<ObjectiveUpdateWithoutTrackerInput, ObjectiveUncheckedUpdateWithoutTrackerInput>
  }

  export type TDeviceUpdateOneWithoutTrackerNestedInput = {
    create?: XOR<TDeviceCreateWithoutTrackerInput, TDeviceUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: TDeviceCreateOrConnectWithoutTrackerInput
    upsert?: TDeviceUpsertWithoutTrackerInput
    disconnect?: boolean
    delete?: boolean
    connect?: TDeviceWhereUniqueInput
    update?: XOR<TDeviceUpdateWithoutTrackerInput, TDeviceUncheckedUpdateWithoutTrackerInput>
  }

  export type CalendarUpdateOneWithoutTrackerNestedInput = {
    create?: XOR<CalendarCreateWithoutTrackerInput, CalendarUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: CalendarCreateOrConnectWithoutTrackerInput
    upsert?: CalendarUpsertWithoutTrackerInput
    disconnect?: boolean
    delete?: boolean
    connect?: CalendarWhereUniqueInput
    update?: XOR<CalendarUpdateWithoutTrackerInput, CalendarUncheckedUpdateWithoutTrackerInput>
  }

  export type DudiUpdateOneWithoutTrackerNestedInput = {
    create?: XOR<DudiCreateWithoutTrackerInput, DudiUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: DudiCreateOrConnectWithoutTrackerInput
    upsert?: DudiUpsertWithoutTrackerInput
    disconnect?: boolean
    delete?: boolean
    connect?: DudiWhereUniqueInput
    update?: XOR<DudiUpdateWithoutTrackerInput, DudiUncheckedUpdateWithoutTrackerInput>
  }

  export type KkniUpdateOneWithoutTrackerNestedInput = {
    create?: XOR<KkniCreateWithoutTrackerInput, KkniUncheckedCreateWithoutTrackerInput>
    connectOrCreate?: KkniCreateOrConnectWithoutTrackerInput
    upsert?: KkniUpsertWithoutTrackerInput
    disconnect?: boolean
    delete?: boolean
    connect?: KkniWhereUniqueInput
    update?: XOR<KkniUpdateWithoutTrackerInput, KkniUncheckedUpdateWithoutTrackerInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type AddressCreateEnvelopeInput = {
    set?: AddressCreateInput
  }

  export type AddressCreateInput = {
    provinsi: string
    kabupaten: string
    kecamatan: string
    kelurahan: string
    kodepos: string
    coordinate: CoordinateCreateInput
  }

  export type KonsentrasiKeahlianCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<KonsentrasiKeahlianCreateWithoutInstansiInput>, Enumerable<KonsentrasiKeahlianUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<KonsentrasiKeahlianCreateOrConnectWithoutInstansiInput>
    connect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
  }

  export type RoleCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<RoleCreateWithoutInstansiInput>, Enumerable<RoleUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutInstansiInput>
    createMany?: RoleCreateManyInstansiInputEnvelope
    connect?: Enumerable<RoleWhereUniqueInput>
  }

  export type SchoolYearCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<SchoolYearCreateWithoutInstansiInput>, Enumerable<SchoolYearUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<SchoolYearCreateOrConnectWithoutInstansiInput>
    createMany?: SchoolYearCreateManyInstansiInputEnvelope
    connect?: Enumerable<SchoolYearWhereUniqueInput>
  }

  export type TeacherCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<TeacherCreateWithoutInstansiInput>, Enumerable<TeacherUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<TeacherCreateOrConnectWithoutInstansiInput>
    createMany?: TeacherCreateManyInstansiInputEnvelope
    connect?: Enumerable<TeacherWhereUniqueInput>
  }

  export type StudentCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<StudentCreateWithoutInstansiInput>, Enumerable<StudentUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutInstansiInput>
    createMany?: StudentCreateManyInstansiInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type TrackerCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutInstansiInput>, Enumerable<TrackerUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutInstansiInput>
    createMany?: TrackerCreateManyInstansiInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type TrackerCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutRefInput>, Enumerable<TrackerUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutRefInput>
    createMany?: TrackerCreateManyRefInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type MataPelajaranCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<MataPelajaranCreateWithoutInstansiInput>, Enumerable<MataPelajaranUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<MataPelajaranCreateOrConnectWithoutInstansiInput>
    createMany?: MataPelajaranCreateManyInstansiInputEnvelope
    connect?: Enumerable<MataPelajaranWhereUniqueInput>
  }

  export type TDeviceCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutInstansiInput>, Enumerable<TDeviceUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutInstansiInput>
    createMany?: TDeviceCreateManyInstansiInputEnvelope
    connect?: Enumerable<TDeviceWhereUniqueInput>
  }

  export type ObjectiveCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutInstansiInput>, Enumerable<ObjectiveUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutInstansiInput>
    createMany?: ObjectiveCreateManyInstansiInputEnvelope
    connect?: Enumerable<ObjectiveWhereUniqueInput>
  }

  export type DudiCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<DudiCreateWithoutInstansiInput>, Enumerable<DudiUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<DudiCreateOrConnectWithoutInstansiInput>
    createMany?: DudiCreateManyInstansiInputEnvelope
    connect?: Enumerable<DudiWhereUniqueInput>
  }

  export type InstansiCreatemajorIdsInput = {
    set: Enumerable<string>
  }

  export type KonsentrasiKeahlianUncheckedCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<KonsentrasiKeahlianCreateWithoutInstansiInput>, Enumerable<KonsentrasiKeahlianUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<KonsentrasiKeahlianCreateOrConnectWithoutInstansiInput>
    connect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
  }

  export type RoleUncheckedCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<RoleCreateWithoutInstansiInput>, Enumerable<RoleUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutInstansiInput>
    createMany?: RoleCreateManyInstansiInputEnvelope
    connect?: Enumerable<RoleWhereUniqueInput>
  }

  export type SchoolYearUncheckedCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<SchoolYearCreateWithoutInstansiInput>, Enumerable<SchoolYearUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<SchoolYearCreateOrConnectWithoutInstansiInput>
    createMany?: SchoolYearCreateManyInstansiInputEnvelope
    connect?: Enumerable<SchoolYearWhereUniqueInput>
  }

  export type TeacherUncheckedCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<TeacherCreateWithoutInstansiInput>, Enumerable<TeacherUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<TeacherCreateOrConnectWithoutInstansiInput>
    createMany?: TeacherCreateManyInstansiInputEnvelope
    connect?: Enumerable<TeacherWhereUniqueInput>
  }

  export type StudentUncheckedCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<StudentCreateWithoutInstansiInput>, Enumerable<StudentUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutInstansiInput>
    createMany?: StudentCreateManyInstansiInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type TrackerUncheckedCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutInstansiInput>, Enumerable<TrackerUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutInstansiInput>
    createMany?: TrackerCreateManyInstansiInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type TrackerUncheckedCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutRefInput>, Enumerable<TrackerUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutRefInput>
    createMany?: TrackerCreateManyRefInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type MataPelajaranUncheckedCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<MataPelajaranCreateWithoutInstansiInput>, Enumerable<MataPelajaranUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<MataPelajaranCreateOrConnectWithoutInstansiInput>
    createMany?: MataPelajaranCreateManyInstansiInputEnvelope
    connect?: Enumerable<MataPelajaranWhereUniqueInput>
  }

  export type TDeviceUncheckedCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutInstansiInput>, Enumerable<TDeviceUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutInstansiInput>
    createMany?: TDeviceCreateManyInstansiInputEnvelope
    connect?: Enumerable<TDeviceWhereUniqueInput>
  }

  export type ObjectiveUncheckedCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutInstansiInput>, Enumerable<ObjectiveUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutInstansiInput>
    createMany?: ObjectiveCreateManyInstansiInputEnvelope
    connect?: Enumerable<ObjectiveWhereUniqueInput>
  }

  export type DudiUncheckedCreateNestedManyWithoutInstansiInput = {
    create?: XOR<Enumerable<DudiCreateWithoutInstansiInput>, Enumerable<DudiUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<DudiCreateOrConnectWithoutInstansiInput>
    createMany?: DudiCreateManyInstansiInputEnvelope
    connect?: Enumerable<DudiWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AddressUpdateEnvelopeInput = {
    set?: AddressCreateInput
    update?: AddressUpdateInput
  }

  export type EnumLevelFieldUpdateOperationsInput = {
    set?: Level
  }

  export type NullableEnumReligionFieldUpdateOperationsInput = {
    set?: Religion | null
    unset?: boolean
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
    unset?: boolean
  }

  export type KonsentrasiKeahlianUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<KonsentrasiKeahlianCreateWithoutInstansiInput>, Enumerable<KonsentrasiKeahlianUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<KonsentrasiKeahlianCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<KonsentrasiKeahlianUpsertWithWhereUniqueWithoutInstansiInput>
    set?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    disconnect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    delete?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    connect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    update?: Enumerable<KonsentrasiKeahlianUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<KonsentrasiKeahlianUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<KonsentrasiKeahlianScalarWhereInput>
  }

  export type RoleUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<RoleCreateWithoutInstansiInput>, Enumerable<RoleUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<RoleUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: RoleCreateManyInstansiInputEnvelope
    set?: Enumerable<RoleWhereUniqueInput>
    disconnect?: Enumerable<RoleWhereUniqueInput>
    delete?: Enumerable<RoleWhereUniqueInput>
    connect?: Enumerable<RoleWhereUniqueInput>
    update?: Enumerable<RoleUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<RoleUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<RoleScalarWhereInput>
  }

  export type SchoolYearUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<SchoolYearCreateWithoutInstansiInput>, Enumerable<SchoolYearUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<SchoolYearCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<SchoolYearUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: SchoolYearCreateManyInstansiInputEnvelope
    set?: Enumerable<SchoolYearWhereUniqueInput>
    disconnect?: Enumerable<SchoolYearWhereUniqueInput>
    delete?: Enumerable<SchoolYearWhereUniqueInput>
    connect?: Enumerable<SchoolYearWhereUniqueInput>
    update?: Enumerable<SchoolYearUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<SchoolYearUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<SchoolYearScalarWhereInput>
  }

  export type TeacherUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<TeacherCreateWithoutInstansiInput>, Enumerable<TeacherUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<TeacherCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<TeacherUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: TeacherCreateManyInstansiInputEnvelope
    set?: Enumerable<TeacherWhereUniqueInput>
    disconnect?: Enumerable<TeacherWhereUniqueInput>
    delete?: Enumerable<TeacherWhereUniqueInput>
    connect?: Enumerable<TeacherWhereUniqueInput>
    update?: Enumerable<TeacherUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<TeacherUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<TeacherScalarWhereInput>
  }

  export type StudentUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutInstansiInput>, Enumerable<StudentUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: StudentCreateManyInstansiInputEnvelope
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type TrackerUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutInstansiInput>, Enumerable<TrackerUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: TrackerCreateManyInstansiInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type TrackerUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutRefInput>, Enumerable<TrackerUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutRefInput>
    createMany?: TrackerCreateManyRefInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type MataPelajaranUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<MataPelajaranCreateWithoutInstansiInput>, Enumerable<MataPelajaranUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<MataPelajaranCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<MataPelajaranUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: MataPelajaranCreateManyInstansiInputEnvelope
    set?: Enumerable<MataPelajaranWhereUniqueInput>
    disconnect?: Enumerable<MataPelajaranWhereUniqueInput>
    delete?: Enumerable<MataPelajaranWhereUniqueInput>
    connect?: Enumerable<MataPelajaranWhereUniqueInput>
    update?: Enumerable<MataPelajaranUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<MataPelajaranUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<MataPelajaranScalarWhereInput>
  }

  export type TDeviceUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutInstansiInput>, Enumerable<TDeviceUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<TDeviceUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: TDeviceCreateManyInstansiInputEnvelope
    set?: Enumerable<TDeviceWhereUniqueInput>
    disconnect?: Enumerable<TDeviceWhereUniqueInput>
    delete?: Enumerable<TDeviceWhereUniqueInput>
    connect?: Enumerable<TDeviceWhereUniqueInput>
    update?: Enumerable<TDeviceUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<TDeviceUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<TDeviceScalarWhereInput>
  }

  export type ObjectiveUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutInstansiInput>, Enumerable<ObjectiveUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<ObjectiveUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: ObjectiveCreateManyInstansiInputEnvelope
    set?: Enumerable<ObjectiveWhereUniqueInput>
    disconnect?: Enumerable<ObjectiveWhereUniqueInput>
    delete?: Enumerable<ObjectiveWhereUniqueInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
    update?: Enumerable<ObjectiveUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<ObjectiveUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<ObjectiveScalarWhereInput>
  }

  export type DudiUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<DudiCreateWithoutInstansiInput>, Enumerable<DudiUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<DudiCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<DudiUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: DudiCreateManyInstansiInputEnvelope
    set?: Enumerable<DudiWhereUniqueInput>
    disconnect?: Enumerable<DudiWhereUniqueInput>
    delete?: Enumerable<DudiWhereUniqueInput>
    connect?: Enumerable<DudiWhereUniqueInput>
    update?: Enumerable<DudiUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<DudiUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<DudiScalarWhereInput>
  }

  export type InstansiUpdatemajorIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type KonsentrasiKeahlianUncheckedUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<KonsentrasiKeahlianCreateWithoutInstansiInput>, Enumerable<KonsentrasiKeahlianUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<KonsentrasiKeahlianCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<KonsentrasiKeahlianUpsertWithWhereUniqueWithoutInstansiInput>
    set?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    disconnect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    delete?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    connect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    update?: Enumerable<KonsentrasiKeahlianUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<KonsentrasiKeahlianUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<KonsentrasiKeahlianScalarWhereInput>
  }

  export type RoleUncheckedUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<RoleCreateWithoutInstansiInput>, Enumerable<RoleUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<RoleUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: RoleCreateManyInstansiInputEnvelope
    set?: Enumerable<RoleWhereUniqueInput>
    disconnect?: Enumerable<RoleWhereUniqueInput>
    delete?: Enumerable<RoleWhereUniqueInput>
    connect?: Enumerable<RoleWhereUniqueInput>
    update?: Enumerable<RoleUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<RoleUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<RoleScalarWhereInput>
  }

  export type SchoolYearUncheckedUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<SchoolYearCreateWithoutInstansiInput>, Enumerable<SchoolYearUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<SchoolYearCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<SchoolYearUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: SchoolYearCreateManyInstansiInputEnvelope
    set?: Enumerable<SchoolYearWhereUniqueInput>
    disconnect?: Enumerable<SchoolYearWhereUniqueInput>
    delete?: Enumerable<SchoolYearWhereUniqueInput>
    connect?: Enumerable<SchoolYearWhereUniqueInput>
    update?: Enumerable<SchoolYearUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<SchoolYearUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<SchoolYearScalarWhereInput>
  }

  export type TeacherUncheckedUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<TeacherCreateWithoutInstansiInput>, Enumerable<TeacherUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<TeacherCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<TeacherUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: TeacherCreateManyInstansiInputEnvelope
    set?: Enumerable<TeacherWhereUniqueInput>
    disconnect?: Enumerable<TeacherWhereUniqueInput>
    delete?: Enumerable<TeacherWhereUniqueInput>
    connect?: Enumerable<TeacherWhereUniqueInput>
    update?: Enumerable<TeacherUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<TeacherUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<TeacherScalarWhereInput>
  }

  export type StudentUncheckedUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutInstansiInput>, Enumerable<StudentUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: StudentCreateManyInstansiInputEnvelope
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type TrackerUncheckedUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutInstansiInput>, Enumerable<TrackerUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: TrackerCreateManyInstansiInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type TrackerUncheckedUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutRefInput>, Enumerable<TrackerUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutRefInput>
    createMany?: TrackerCreateManyRefInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type MataPelajaranUncheckedUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<MataPelajaranCreateWithoutInstansiInput>, Enumerable<MataPelajaranUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<MataPelajaranCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<MataPelajaranUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: MataPelajaranCreateManyInstansiInputEnvelope
    set?: Enumerable<MataPelajaranWhereUniqueInput>
    disconnect?: Enumerable<MataPelajaranWhereUniqueInput>
    delete?: Enumerable<MataPelajaranWhereUniqueInput>
    connect?: Enumerable<MataPelajaranWhereUniqueInput>
    update?: Enumerable<MataPelajaranUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<MataPelajaranUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<MataPelajaranScalarWhereInput>
  }

  export type TDeviceUncheckedUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutInstansiInput>, Enumerable<TDeviceUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<TDeviceUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: TDeviceCreateManyInstansiInputEnvelope
    set?: Enumerable<TDeviceWhereUniqueInput>
    disconnect?: Enumerable<TDeviceWhereUniqueInput>
    delete?: Enumerable<TDeviceWhereUniqueInput>
    connect?: Enumerable<TDeviceWhereUniqueInput>
    update?: Enumerable<TDeviceUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<TDeviceUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<TDeviceScalarWhereInput>
  }

  export type ObjectiveUncheckedUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutInstansiInput>, Enumerable<ObjectiveUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<ObjectiveUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: ObjectiveCreateManyInstansiInputEnvelope
    set?: Enumerable<ObjectiveWhereUniqueInput>
    disconnect?: Enumerable<ObjectiveWhereUniqueInput>
    delete?: Enumerable<ObjectiveWhereUniqueInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
    update?: Enumerable<ObjectiveUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<ObjectiveUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<ObjectiveScalarWhereInput>
  }

  export type DudiUncheckedUpdateManyWithoutInstansiNestedInput = {
    create?: XOR<Enumerable<DudiCreateWithoutInstansiInput>, Enumerable<DudiUncheckedCreateWithoutInstansiInput>>
    connectOrCreate?: Enumerable<DudiCreateOrConnectWithoutInstansiInput>
    upsert?: Enumerable<DudiUpsertWithWhereUniqueWithoutInstansiInput>
    createMany?: DudiCreateManyInstansiInputEnvelope
    set?: Enumerable<DudiWhereUniqueInput>
    disconnect?: Enumerable<DudiWhereUniqueInput>
    delete?: Enumerable<DudiWhereUniqueInput>
    connect?: Enumerable<DudiWhereUniqueInput>
    update?: Enumerable<DudiUpdateWithWhereUniqueWithoutInstansiInput>
    updateMany?: Enumerable<DudiUpdateManyWithWhereWithoutInstansiInput>
    deleteMany?: Enumerable<DudiScalarWhereInput>
  }

  export type ProgramKeahlianCreateNestedOneWithoutMapelInput = {
    create?: XOR<ProgramKeahlianCreateWithoutMapelInput, ProgramKeahlianUncheckedCreateWithoutMapelInput>
    connectOrCreate?: ProgramKeahlianCreateOrConnectWithoutMapelInput
    connect?: ProgramKeahlianWhereUniqueInput
  }

  export type KonsentrasiKeahlianCreateNestedOneWithoutMapelInput = {
    create?: XOR<KonsentrasiKeahlianCreateWithoutMapelInput, KonsentrasiKeahlianUncheckedCreateWithoutMapelInput>
    connectOrCreate?: KonsentrasiKeahlianCreateOrConnectWithoutMapelInput
    connect?: KonsentrasiKeahlianWhereUniqueInput
  }

  export type InstansiCreateNestedOneWithoutUnikMapelsInput = {
    create?: XOR<InstansiCreateWithoutUnikMapelsInput, InstansiUncheckedCreateWithoutUnikMapelsInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutUnikMapelsInput
    connect?: InstansiWhereUniqueInput
  }

  export type ElementCreateNestedManyWithoutMapelInput = {
    create?: XOR<Enumerable<ElementCreateWithoutMapelInput>, Enumerable<ElementUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<ElementCreateOrConnectWithoutMapelInput>
    createMany?: ElementCreateManyMapelInputEnvelope
    connect?: Enumerable<ElementWhereUniqueInput>
  }

  export type ScheduleCreateNestedManyWithoutMapelInput = {
    create?: XOR<Enumerable<ScheduleCreateWithoutMapelInput>, Enumerable<ScheduleUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<ScheduleCreateOrConnectWithoutMapelInput>
    createMany?: ScheduleCreateManyMapelInputEnvelope
    connect?: Enumerable<ScheduleWhereUniqueInput>
  }

  export type TrackerCreateNestedManyWithoutMapelInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutMapelInput>, Enumerable<TrackerUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutMapelInput>
    createMany?: TrackerCreateManyMapelInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type ObjectiveCreateNestedManyWithoutMapelInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutMapelInput>, Enumerable<ObjectiveUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutMapelInput>
    createMany?: ObjectiveCreateManyMapelInputEnvelope
    connect?: Enumerable<ObjectiveWhereUniqueInput>
  }

  export type TDeviceCreateNestedManyWithoutMapelInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutMapelInput>, Enumerable<TDeviceUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutMapelInput>
    createMany?: TDeviceCreateManyMapelInputEnvelope
    connect?: Enumerable<TDeviceWhereUniqueInput>
  }

  export type ElementUncheckedCreateNestedManyWithoutMapelInput = {
    create?: XOR<Enumerable<ElementCreateWithoutMapelInput>, Enumerable<ElementUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<ElementCreateOrConnectWithoutMapelInput>
    createMany?: ElementCreateManyMapelInputEnvelope
    connect?: Enumerable<ElementWhereUniqueInput>
  }

  export type ScheduleUncheckedCreateNestedManyWithoutMapelInput = {
    create?: XOR<Enumerable<ScheduleCreateWithoutMapelInput>, Enumerable<ScheduleUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<ScheduleCreateOrConnectWithoutMapelInput>
    createMany?: ScheduleCreateManyMapelInputEnvelope
    connect?: Enumerable<ScheduleWhereUniqueInput>
  }

  export type TrackerUncheckedCreateNestedManyWithoutMapelInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutMapelInput>, Enumerable<TrackerUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutMapelInput>
    createMany?: TrackerCreateManyMapelInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type ObjectiveUncheckedCreateNestedManyWithoutMapelInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutMapelInput>, Enumerable<ObjectiveUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutMapelInput>
    createMany?: ObjectiveCreateManyMapelInputEnvelope
    connect?: Enumerable<ObjectiveWhereUniqueInput>
  }

  export type TDeviceUncheckedCreateNestedManyWithoutMapelInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutMapelInput>, Enumerable<TDeviceUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutMapelInput>
    createMany?: TDeviceCreateManyMapelInputEnvelope
    connect?: Enumerable<TDeviceWhereUniqueInput>
  }

  export type NullableEnumLevelFieldUpdateOperationsInput = {
    set?: Level | null
    unset?: boolean
  }

  export type EnumMataPelajaranTypeFieldUpdateOperationsInput = {
    set?: MataPelajaranType
  }

  export type ProgramKeahlianUpdateOneWithoutMapelNestedInput = {
    create?: XOR<ProgramKeahlianCreateWithoutMapelInput, ProgramKeahlianUncheckedCreateWithoutMapelInput>
    connectOrCreate?: ProgramKeahlianCreateOrConnectWithoutMapelInput
    upsert?: ProgramKeahlianUpsertWithoutMapelInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProgramKeahlianWhereUniqueInput
    update?: XOR<ProgramKeahlianUpdateWithoutMapelInput, ProgramKeahlianUncheckedUpdateWithoutMapelInput>
  }

  export type KonsentrasiKeahlianUpdateOneWithoutMapelNestedInput = {
    create?: XOR<KonsentrasiKeahlianCreateWithoutMapelInput, KonsentrasiKeahlianUncheckedCreateWithoutMapelInput>
    connectOrCreate?: KonsentrasiKeahlianCreateOrConnectWithoutMapelInput
    upsert?: KonsentrasiKeahlianUpsertWithoutMapelInput
    disconnect?: boolean
    delete?: boolean
    connect?: KonsentrasiKeahlianWhereUniqueInput
    update?: XOR<KonsentrasiKeahlianUpdateWithoutMapelInput, KonsentrasiKeahlianUncheckedUpdateWithoutMapelInput>
  }

  export type InstansiUpdateOneWithoutUnikMapelsNestedInput = {
    create?: XOR<InstansiCreateWithoutUnikMapelsInput, InstansiUncheckedCreateWithoutUnikMapelsInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutUnikMapelsInput
    upsert?: InstansiUpsertWithoutUnikMapelsInput
    disconnect?: boolean
    delete?: boolean
    connect?: InstansiWhereUniqueInput
    update?: XOR<InstansiUpdateWithoutUnikMapelsInput, InstansiUncheckedUpdateWithoutUnikMapelsInput>
  }

  export type ElementUpdateManyWithoutMapelNestedInput = {
    create?: XOR<Enumerable<ElementCreateWithoutMapelInput>, Enumerable<ElementUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<ElementCreateOrConnectWithoutMapelInput>
    upsert?: Enumerable<ElementUpsertWithWhereUniqueWithoutMapelInput>
    createMany?: ElementCreateManyMapelInputEnvelope
    set?: Enumerable<ElementWhereUniqueInput>
    disconnect?: Enumerable<ElementWhereUniqueInput>
    delete?: Enumerable<ElementWhereUniqueInput>
    connect?: Enumerable<ElementWhereUniqueInput>
    update?: Enumerable<ElementUpdateWithWhereUniqueWithoutMapelInput>
    updateMany?: Enumerable<ElementUpdateManyWithWhereWithoutMapelInput>
    deleteMany?: Enumerable<ElementScalarWhereInput>
  }

  export type ScheduleUpdateManyWithoutMapelNestedInput = {
    create?: XOR<Enumerable<ScheduleCreateWithoutMapelInput>, Enumerable<ScheduleUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<ScheduleCreateOrConnectWithoutMapelInput>
    upsert?: Enumerable<ScheduleUpsertWithWhereUniqueWithoutMapelInput>
    createMany?: ScheduleCreateManyMapelInputEnvelope
    set?: Enumerable<ScheduleWhereUniqueInput>
    disconnect?: Enumerable<ScheduleWhereUniqueInput>
    delete?: Enumerable<ScheduleWhereUniqueInput>
    connect?: Enumerable<ScheduleWhereUniqueInput>
    update?: Enumerable<ScheduleUpdateWithWhereUniqueWithoutMapelInput>
    updateMany?: Enumerable<ScheduleUpdateManyWithWhereWithoutMapelInput>
    deleteMany?: Enumerable<ScheduleScalarWhereInput>
  }

  export type TrackerUpdateManyWithoutMapelNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutMapelInput>, Enumerable<TrackerUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutMapelInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutMapelInput>
    createMany?: TrackerCreateManyMapelInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutMapelInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutMapelInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type ObjectiveUpdateManyWithoutMapelNestedInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutMapelInput>, Enumerable<ObjectiveUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutMapelInput>
    upsert?: Enumerable<ObjectiveUpsertWithWhereUniqueWithoutMapelInput>
    createMany?: ObjectiveCreateManyMapelInputEnvelope
    set?: Enumerable<ObjectiveWhereUniqueInput>
    disconnect?: Enumerable<ObjectiveWhereUniqueInput>
    delete?: Enumerable<ObjectiveWhereUniqueInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
    update?: Enumerable<ObjectiveUpdateWithWhereUniqueWithoutMapelInput>
    updateMany?: Enumerable<ObjectiveUpdateManyWithWhereWithoutMapelInput>
    deleteMany?: Enumerable<ObjectiveScalarWhereInput>
  }

  export type TDeviceUpdateManyWithoutMapelNestedInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutMapelInput>, Enumerable<TDeviceUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutMapelInput>
    upsert?: Enumerable<TDeviceUpsertWithWhereUniqueWithoutMapelInput>
    createMany?: TDeviceCreateManyMapelInputEnvelope
    set?: Enumerable<TDeviceWhereUniqueInput>
    disconnect?: Enumerable<TDeviceWhereUniqueInput>
    delete?: Enumerable<TDeviceWhereUniqueInput>
    connect?: Enumerable<TDeviceWhereUniqueInput>
    update?: Enumerable<TDeviceUpdateWithWhereUniqueWithoutMapelInput>
    updateMany?: Enumerable<TDeviceUpdateManyWithWhereWithoutMapelInput>
    deleteMany?: Enumerable<TDeviceScalarWhereInput>
  }

  export type ElementUncheckedUpdateManyWithoutMapelNestedInput = {
    create?: XOR<Enumerable<ElementCreateWithoutMapelInput>, Enumerable<ElementUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<ElementCreateOrConnectWithoutMapelInput>
    upsert?: Enumerable<ElementUpsertWithWhereUniqueWithoutMapelInput>
    createMany?: ElementCreateManyMapelInputEnvelope
    set?: Enumerable<ElementWhereUniqueInput>
    disconnect?: Enumerable<ElementWhereUniqueInput>
    delete?: Enumerable<ElementWhereUniqueInput>
    connect?: Enumerable<ElementWhereUniqueInput>
    update?: Enumerable<ElementUpdateWithWhereUniqueWithoutMapelInput>
    updateMany?: Enumerable<ElementUpdateManyWithWhereWithoutMapelInput>
    deleteMany?: Enumerable<ElementScalarWhereInput>
  }

  export type ScheduleUncheckedUpdateManyWithoutMapelNestedInput = {
    create?: XOR<Enumerable<ScheduleCreateWithoutMapelInput>, Enumerable<ScheduleUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<ScheduleCreateOrConnectWithoutMapelInput>
    upsert?: Enumerable<ScheduleUpsertWithWhereUniqueWithoutMapelInput>
    createMany?: ScheduleCreateManyMapelInputEnvelope
    set?: Enumerable<ScheduleWhereUniqueInput>
    disconnect?: Enumerable<ScheduleWhereUniqueInput>
    delete?: Enumerable<ScheduleWhereUniqueInput>
    connect?: Enumerable<ScheduleWhereUniqueInput>
    update?: Enumerable<ScheduleUpdateWithWhereUniqueWithoutMapelInput>
    updateMany?: Enumerable<ScheduleUpdateManyWithWhereWithoutMapelInput>
    deleteMany?: Enumerable<ScheduleScalarWhereInput>
  }

  export type TrackerUncheckedUpdateManyWithoutMapelNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutMapelInput>, Enumerable<TrackerUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutMapelInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutMapelInput>
    createMany?: TrackerCreateManyMapelInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutMapelInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutMapelInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type ObjectiveUncheckedUpdateManyWithoutMapelNestedInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutMapelInput>, Enumerable<ObjectiveUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutMapelInput>
    upsert?: Enumerable<ObjectiveUpsertWithWhereUniqueWithoutMapelInput>
    createMany?: ObjectiveCreateManyMapelInputEnvelope
    set?: Enumerable<ObjectiveWhereUniqueInput>
    disconnect?: Enumerable<ObjectiveWhereUniqueInput>
    delete?: Enumerable<ObjectiveWhereUniqueInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
    update?: Enumerable<ObjectiveUpdateWithWhereUniqueWithoutMapelInput>
    updateMany?: Enumerable<ObjectiveUpdateManyWithWhereWithoutMapelInput>
    deleteMany?: Enumerable<ObjectiveScalarWhereInput>
  }

  export type TDeviceUncheckedUpdateManyWithoutMapelNestedInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutMapelInput>, Enumerable<TDeviceUncheckedCreateWithoutMapelInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutMapelInput>
    upsert?: Enumerable<TDeviceUpsertWithWhereUniqueWithoutMapelInput>
    createMany?: TDeviceCreateManyMapelInputEnvelope
    set?: Enumerable<TDeviceWhereUniqueInput>
    disconnect?: Enumerable<TDeviceWhereUniqueInput>
    delete?: Enumerable<TDeviceWhereUniqueInput>
    connect?: Enumerable<TDeviceWhereUniqueInput>
    update?: Enumerable<TDeviceUpdateWithWhereUniqueWithoutMapelInput>
    updateMany?: Enumerable<TDeviceUpdateManyWithWhereWithoutMapelInput>
    deleteMany?: Enumerable<TDeviceScalarWhereInput>
  }

  export type AchievementCreateNestedManyWithoutElementInput = {
    create?: XOR<Enumerable<AchievementCreateWithoutElementInput>, Enumerable<AchievementUncheckedCreateWithoutElementInput>>
    connectOrCreate?: Enumerable<AchievementCreateOrConnectWithoutElementInput>
    createMany?: AchievementCreateManyElementInputEnvelope
    connect?: Enumerable<AchievementWhereUniqueInput>
  }

  export type MataPelajaranCreateNestedOneWithoutElementInput = {
    create?: XOR<MataPelajaranCreateWithoutElementInput, MataPelajaranUncheckedCreateWithoutElementInput>
    connectOrCreate?: MataPelajaranCreateOrConnectWithoutElementInput
    connect?: MataPelajaranWhereUniqueInput
  }

  export type TrackerCreateNestedManyWithoutElemenInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutElemenInput>, Enumerable<TrackerUncheckedCreateWithoutElemenInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutElemenInput>
    createMany?: TrackerCreateManyElemenInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type TeachingCreateNestedManyWithoutElemenInput = {
    create?: XOR<Enumerable<TeachingCreateWithoutElemenInput>, Enumerable<TeachingUncheckedCreateWithoutElemenInput>>
    connectOrCreate?: Enumerable<TeachingCreateOrConnectWithoutElemenInput>
    connect?: Enumerable<TeachingWhereUniqueInput>
  }

  export type ObjectiveCreateNestedManyWithoutElemenInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutElemenInput>, Enumerable<ObjectiveUncheckedCreateWithoutElemenInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutElemenInput>
    createMany?: ObjectiveCreateManyElemenInputEnvelope
    connect?: Enumerable<ObjectiveWhereUniqueInput>
  }

  export type ElementCreatescheduleClassIdsInput = {
    set: Enumerable<string>
  }

  export type AchievementUncheckedCreateNestedManyWithoutElementInput = {
    create?: XOR<Enumerable<AchievementCreateWithoutElementInput>, Enumerable<AchievementUncheckedCreateWithoutElementInput>>
    connectOrCreate?: Enumerable<AchievementCreateOrConnectWithoutElementInput>
    createMany?: AchievementCreateManyElementInputEnvelope
    connect?: Enumerable<AchievementWhereUniqueInput>
  }

  export type TrackerUncheckedCreateNestedManyWithoutElemenInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutElemenInput>, Enumerable<TrackerUncheckedCreateWithoutElemenInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutElemenInput>
    createMany?: TrackerCreateManyElemenInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type TeachingUncheckedCreateNestedManyWithoutElemenInput = {
    create?: XOR<Enumerable<TeachingCreateWithoutElemenInput>, Enumerable<TeachingUncheckedCreateWithoutElemenInput>>
    connectOrCreate?: Enumerable<TeachingCreateOrConnectWithoutElemenInput>
    connect?: Enumerable<TeachingWhereUniqueInput>
  }

  export type ObjectiveUncheckedCreateNestedManyWithoutElemenInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutElemenInput>, Enumerable<ObjectiveUncheckedCreateWithoutElemenInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutElemenInput>
    createMany?: ObjectiveCreateManyElemenInputEnvelope
    connect?: Enumerable<ObjectiveWhereUniqueInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AchievementUpdateManyWithoutElementNestedInput = {
    create?: XOR<Enumerable<AchievementCreateWithoutElementInput>, Enumerable<AchievementUncheckedCreateWithoutElementInput>>
    connectOrCreate?: Enumerable<AchievementCreateOrConnectWithoutElementInput>
    upsert?: Enumerable<AchievementUpsertWithWhereUniqueWithoutElementInput>
    createMany?: AchievementCreateManyElementInputEnvelope
    set?: Enumerable<AchievementWhereUniqueInput>
    disconnect?: Enumerable<AchievementWhereUniqueInput>
    delete?: Enumerable<AchievementWhereUniqueInput>
    connect?: Enumerable<AchievementWhereUniqueInput>
    update?: Enumerable<AchievementUpdateWithWhereUniqueWithoutElementInput>
    updateMany?: Enumerable<AchievementUpdateManyWithWhereWithoutElementInput>
    deleteMany?: Enumerable<AchievementScalarWhereInput>
  }

  export type MataPelajaranUpdateOneRequiredWithoutElementNestedInput = {
    create?: XOR<MataPelajaranCreateWithoutElementInput, MataPelajaranUncheckedCreateWithoutElementInput>
    connectOrCreate?: MataPelajaranCreateOrConnectWithoutElementInput
    upsert?: MataPelajaranUpsertWithoutElementInput
    connect?: MataPelajaranWhereUniqueInput
    update?: XOR<MataPelajaranUpdateWithoutElementInput, MataPelajaranUncheckedUpdateWithoutElementInput>
  }

  export type TrackerUpdateManyWithoutElemenNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutElemenInput>, Enumerable<TrackerUncheckedCreateWithoutElemenInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutElemenInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutElemenInput>
    createMany?: TrackerCreateManyElemenInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutElemenInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutElemenInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type TeachingUpdateManyWithoutElemenNestedInput = {
    create?: XOR<Enumerable<TeachingCreateWithoutElemenInput>, Enumerable<TeachingUncheckedCreateWithoutElemenInput>>
    connectOrCreate?: Enumerable<TeachingCreateOrConnectWithoutElemenInput>
    upsert?: Enumerable<TeachingUpsertWithWhereUniqueWithoutElemenInput>
    set?: Enumerable<TeachingWhereUniqueInput>
    disconnect?: Enumerable<TeachingWhereUniqueInput>
    delete?: Enumerable<TeachingWhereUniqueInput>
    connect?: Enumerable<TeachingWhereUniqueInput>
    update?: Enumerable<TeachingUpdateWithWhereUniqueWithoutElemenInput>
    updateMany?: Enumerable<TeachingUpdateManyWithWhereWithoutElemenInput>
    deleteMany?: Enumerable<TeachingScalarWhereInput>
  }

  export type ObjectiveUpdateManyWithoutElemenNestedInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutElemenInput>, Enumerable<ObjectiveUncheckedCreateWithoutElemenInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutElemenInput>
    upsert?: Enumerable<ObjectiveUpsertWithWhereUniqueWithoutElemenInput>
    createMany?: ObjectiveCreateManyElemenInputEnvelope
    set?: Enumerable<ObjectiveWhereUniqueInput>
    disconnect?: Enumerable<ObjectiveWhereUniqueInput>
    delete?: Enumerable<ObjectiveWhereUniqueInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
    update?: Enumerable<ObjectiveUpdateWithWhereUniqueWithoutElemenInput>
    updateMany?: Enumerable<ObjectiveUpdateManyWithWhereWithoutElemenInput>
    deleteMany?: Enumerable<ObjectiveScalarWhereInput>
  }

  export type ElementUpdatescheduleClassIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type AchievementUncheckedUpdateManyWithoutElementNestedInput = {
    create?: XOR<Enumerable<AchievementCreateWithoutElementInput>, Enumerable<AchievementUncheckedCreateWithoutElementInput>>
    connectOrCreate?: Enumerable<AchievementCreateOrConnectWithoutElementInput>
    upsert?: Enumerable<AchievementUpsertWithWhereUniqueWithoutElementInput>
    createMany?: AchievementCreateManyElementInputEnvelope
    set?: Enumerable<AchievementWhereUniqueInput>
    disconnect?: Enumerable<AchievementWhereUniqueInput>
    delete?: Enumerable<AchievementWhereUniqueInput>
    connect?: Enumerable<AchievementWhereUniqueInput>
    update?: Enumerable<AchievementUpdateWithWhereUniqueWithoutElementInput>
    updateMany?: Enumerable<AchievementUpdateManyWithWhereWithoutElementInput>
    deleteMany?: Enumerable<AchievementScalarWhereInput>
  }

  export type TrackerUncheckedUpdateManyWithoutElemenNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutElemenInput>, Enumerable<TrackerUncheckedCreateWithoutElemenInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutElemenInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutElemenInput>
    createMany?: TrackerCreateManyElemenInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutElemenInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutElemenInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type TeachingUncheckedUpdateManyWithoutElemenNestedInput = {
    create?: XOR<Enumerable<TeachingCreateWithoutElemenInput>, Enumerable<TeachingUncheckedCreateWithoutElemenInput>>
    connectOrCreate?: Enumerable<TeachingCreateOrConnectWithoutElemenInput>
    upsert?: Enumerable<TeachingUpsertWithWhereUniqueWithoutElemenInput>
    set?: Enumerable<TeachingWhereUniqueInput>
    disconnect?: Enumerable<TeachingWhereUniqueInput>
    delete?: Enumerable<TeachingWhereUniqueInput>
    connect?: Enumerable<TeachingWhereUniqueInput>
    update?: Enumerable<TeachingUpdateWithWhereUniqueWithoutElemenInput>
    updateMany?: Enumerable<TeachingUpdateManyWithWhereWithoutElemenInput>
    deleteMany?: Enumerable<TeachingScalarWhereInput>
  }

  export type ObjectiveUncheckedUpdateManyWithoutElemenNestedInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutElemenInput>, Enumerable<ObjectiveUncheckedCreateWithoutElemenInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutElemenInput>
    upsert?: Enumerable<ObjectiveUpsertWithWhereUniqueWithoutElemenInput>
    createMany?: ObjectiveCreateManyElemenInputEnvelope
    set?: Enumerable<ObjectiveWhereUniqueInput>
    disconnect?: Enumerable<ObjectiveWhereUniqueInput>
    delete?: Enumerable<ObjectiveWhereUniqueInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
    update?: Enumerable<ObjectiveUpdateWithWhereUniqueWithoutElemenInput>
    updateMany?: Enumerable<ObjectiveUpdateManyWithWhereWithoutElemenInput>
    deleteMany?: Enumerable<ObjectiveScalarWhereInput>
  }

  export type ElementCreateNestedOneWithoutAchievementInput = {
    create?: XOR<ElementCreateWithoutAchievementInput, ElementUncheckedCreateWithoutAchievementInput>
    connectOrCreate?: ElementCreateOrConnectWithoutAchievementInput
    connect?: ElementWhereUniqueInput
  }

  export type ObjectiveCreateNestedManyWithoutAchievementInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutAchievementInput>, Enumerable<ObjectiveUncheckedCreateWithoutAchievementInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutAchievementInput>
    createMany?: ObjectiveCreateManyAchievementInputEnvelope
    connect?: Enumerable<ObjectiveWhereUniqueInput>
  }

  export type TrackerCreateNestedManyWithoutCpInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutCpInput>, Enumerable<TrackerUncheckedCreateWithoutCpInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutCpInput>
    createMany?: TrackerCreateManyCpInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type ObjectiveUncheckedCreateNestedManyWithoutAchievementInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutAchievementInput>, Enumerable<ObjectiveUncheckedCreateWithoutAchievementInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutAchievementInput>
    createMany?: ObjectiveCreateManyAchievementInputEnvelope
    connect?: Enumerable<ObjectiveWhereUniqueInput>
  }

  export type TrackerUncheckedCreateNestedManyWithoutCpInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutCpInput>, Enumerable<TrackerUncheckedCreateWithoutCpInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutCpInput>
    createMany?: TrackerCreateManyCpInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type EnumFaseFieldUpdateOperationsInput = {
    set?: Fase
  }

  export type ElementUpdateOneRequiredWithoutAchievementNestedInput = {
    create?: XOR<ElementCreateWithoutAchievementInput, ElementUncheckedCreateWithoutAchievementInput>
    connectOrCreate?: ElementCreateOrConnectWithoutAchievementInput
    upsert?: ElementUpsertWithoutAchievementInput
    connect?: ElementWhereUniqueInput
    update?: XOR<ElementUpdateWithoutAchievementInput, ElementUncheckedUpdateWithoutAchievementInput>
  }

  export type ObjectiveUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutAchievementInput>, Enumerable<ObjectiveUncheckedCreateWithoutAchievementInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutAchievementInput>
    upsert?: Enumerable<ObjectiveUpsertWithWhereUniqueWithoutAchievementInput>
    createMany?: ObjectiveCreateManyAchievementInputEnvelope
    set?: Enumerable<ObjectiveWhereUniqueInput>
    disconnect?: Enumerable<ObjectiveWhereUniqueInput>
    delete?: Enumerable<ObjectiveWhereUniqueInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
    update?: Enumerable<ObjectiveUpdateWithWhereUniqueWithoutAchievementInput>
    updateMany?: Enumerable<ObjectiveUpdateManyWithWhereWithoutAchievementInput>
    deleteMany?: Enumerable<ObjectiveScalarWhereInput>
  }

  export type TrackerUpdateManyWithoutCpNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutCpInput>, Enumerable<TrackerUncheckedCreateWithoutCpInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutCpInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutCpInput>
    createMany?: TrackerCreateManyCpInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutCpInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutCpInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type ObjectiveUncheckedUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutAchievementInput>, Enumerable<ObjectiveUncheckedCreateWithoutAchievementInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutAchievementInput>
    upsert?: Enumerable<ObjectiveUpsertWithWhereUniqueWithoutAchievementInput>
    createMany?: ObjectiveCreateManyAchievementInputEnvelope
    set?: Enumerable<ObjectiveWhereUniqueInput>
    disconnect?: Enumerable<ObjectiveWhereUniqueInput>
    delete?: Enumerable<ObjectiveWhereUniqueInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
    update?: Enumerable<ObjectiveUpdateWithWhereUniqueWithoutAchievementInput>
    updateMany?: Enumerable<ObjectiveUpdateManyWithWhereWithoutAchievementInput>
    deleteMany?: Enumerable<ObjectiveScalarWhereInput>
  }

  export type TrackerUncheckedUpdateManyWithoutCpNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutCpInput>, Enumerable<TrackerUncheckedCreateWithoutCpInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutCpInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutCpInput>
    createMany?: TrackerCreateManyCpInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutCpInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutCpInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type ProgramKeahlianCreateNestedManyWithoutBidangInput = {
    create?: XOR<Enumerable<ProgramKeahlianCreateWithoutBidangInput>, Enumerable<ProgramKeahlianUncheckedCreateWithoutBidangInput>>
    connectOrCreate?: Enumerable<ProgramKeahlianCreateOrConnectWithoutBidangInput>
    createMany?: ProgramKeahlianCreateManyBidangInputEnvelope
    connect?: Enumerable<ProgramKeahlianWhereUniqueInput>
  }

  export type TrackerCreateNestedManyWithoutBidangInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutBidangInput>, Enumerable<TrackerUncheckedCreateWithoutBidangInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutBidangInput>
    createMany?: TrackerCreateManyBidangInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type ProgramKeahlianUncheckedCreateNestedManyWithoutBidangInput = {
    create?: XOR<Enumerable<ProgramKeahlianCreateWithoutBidangInput>, Enumerable<ProgramKeahlianUncheckedCreateWithoutBidangInput>>
    connectOrCreate?: Enumerable<ProgramKeahlianCreateOrConnectWithoutBidangInput>
    createMany?: ProgramKeahlianCreateManyBidangInputEnvelope
    connect?: Enumerable<ProgramKeahlianWhereUniqueInput>
  }

  export type TrackerUncheckedCreateNestedManyWithoutBidangInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutBidangInput>, Enumerable<TrackerUncheckedCreateWithoutBidangInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutBidangInput>
    createMany?: TrackerCreateManyBidangInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type ProgramKeahlianUpdateManyWithoutBidangNestedInput = {
    create?: XOR<Enumerable<ProgramKeahlianCreateWithoutBidangInput>, Enumerable<ProgramKeahlianUncheckedCreateWithoutBidangInput>>
    connectOrCreate?: Enumerable<ProgramKeahlianCreateOrConnectWithoutBidangInput>
    upsert?: Enumerable<ProgramKeahlianUpsertWithWhereUniqueWithoutBidangInput>
    createMany?: ProgramKeahlianCreateManyBidangInputEnvelope
    set?: Enumerable<ProgramKeahlianWhereUniqueInput>
    disconnect?: Enumerable<ProgramKeahlianWhereUniqueInput>
    delete?: Enumerable<ProgramKeahlianWhereUniqueInput>
    connect?: Enumerable<ProgramKeahlianWhereUniqueInput>
    update?: Enumerable<ProgramKeahlianUpdateWithWhereUniqueWithoutBidangInput>
    updateMany?: Enumerable<ProgramKeahlianUpdateManyWithWhereWithoutBidangInput>
    deleteMany?: Enumerable<ProgramKeahlianScalarWhereInput>
  }

  export type TrackerUpdateManyWithoutBidangNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutBidangInput>, Enumerable<TrackerUncheckedCreateWithoutBidangInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutBidangInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutBidangInput>
    createMany?: TrackerCreateManyBidangInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutBidangInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutBidangInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type ProgramKeahlianUncheckedUpdateManyWithoutBidangNestedInput = {
    create?: XOR<Enumerable<ProgramKeahlianCreateWithoutBidangInput>, Enumerable<ProgramKeahlianUncheckedCreateWithoutBidangInput>>
    connectOrCreate?: Enumerable<ProgramKeahlianCreateOrConnectWithoutBidangInput>
    upsert?: Enumerable<ProgramKeahlianUpsertWithWhereUniqueWithoutBidangInput>
    createMany?: ProgramKeahlianCreateManyBidangInputEnvelope
    set?: Enumerable<ProgramKeahlianWhereUniqueInput>
    disconnect?: Enumerable<ProgramKeahlianWhereUniqueInput>
    delete?: Enumerable<ProgramKeahlianWhereUniqueInput>
    connect?: Enumerable<ProgramKeahlianWhereUniqueInput>
    update?: Enumerable<ProgramKeahlianUpdateWithWhereUniqueWithoutBidangInput>
    updateMany?: Enumerable<ProgramKeahlianUpdateManyWithWhereWithoutBidangInput>
    deleteMany?: Enumerable<ProgramKeahlianScalarWhereInput>
  }

  export type TrackerUncheckedUpdateManyWithoutBidangNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutBidangInput>, Enumerable<TrackerUncheckedCreateWithoutBidangInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutBidangInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutBidangInput>
    createMany?: TrackerCreateManyBidangInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutBidangInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutBidangInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type BidangKeahlianCreateNestedOneWithoutProgramInput = {
    create?: XOR<BidangKeahlianCreateWithoutProgramInput, BidangKeahlianUncheckedCreateWithoutProgramInput>
    connectOrCreate?: BidangKeahlianCreateOrConnectWithoutProgramInput
    connect?: BidangKeahlianWhereUniqueInput
  }

  export type KonsentrasiKeahlianCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<KonsentrasiKeahlianCreateWithoutProgramInput>, Enumerable<KonsentrasiKeahlianUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<KonsentrasiKeahlianCreateOrConnectWithoutProgramInput>
    createMany?: KonsentrasiKeahlianCreateManyProgramInputEnvelope
    connect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
  }

  export type TrackerCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutProgramInput>, Enumerable<TrackerUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutProgramInput>
    createMany?: TrackerCreateManyProgramInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type MataPelajaranCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<MataPelajaranCreateWithoutProgramInput>, Enumerable<MataPelajaranUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<MataPelajaranCreateOrConnectWithoutProgramInput>
    createMany?: MataPelajaranCreateManyProgramInputEnvelope
    connect?: Enumerable<MataPelajaranWhereUniqueInput>
  }

  export type KonsentrasiKeahlianUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<KonsentrasiKeahlianCreateWithoutProgramInput>, Enumerable<KonsentrasiKeahlianUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<KonsentrasiKeahlianCreateOrConnectWithoutProgramInput>
    createMany?: KonsentrasiKeahlianCreateManyProgramInputEnvelope
    connect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
  }

  export type TrackerUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutProgramInput>, Enumerable<TrackerUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutProgramInput>
    createMany?: TrackerCreateManyProgramInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type MataPelajaranUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<Enumerable<MataPelajaranCreateWithoutProgramInput>, Enumerable<MataPelajaranUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<MataPelajaranCreateOrConnectWithoutProgramInput>
    createMany?: MataPelajaranCreateManyProgramInputEnvelope
    connect?: Enumerable<MataPelajaranWhereUniqueInput>
  }

  export type BidangKeahlianUpdateOneRequiredWithoutProgramNestedInput = {
    create?: XOR<BidangKeahlianCreateWithoutProgramInput, BidangKeahlianUncheckedCreateWithoutProgramInput>
    connectOrCreate?: BidangKeahlianCreateOrConnectWithoutProgramInput
    upsert?: BidangKeahlianUpsertWithoutProgramInput
    connect?: BidangKeahlianWhereUniqueInput
    update?: XOR<BidangKeahlianUpdateWithoutProgramInput, BidangKeahlianUncheckedUpdateWithoutProgramInput>
  }

  export type KonsentrasiKeahlianUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<KonsentrasiKeahlianCreateWithoutProgramInput>, Enumerable<KonsentrasiKeahlianUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<KonsentrasiKeahlianCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<KonsentrasiKeahlianUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: KonsentrasiKeahlianCreateManyProgramInputEnvelope
    set?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    disconnect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    delete?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    connect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    update?: Enumerable<KonsentrasiKeahlianUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<KonsentrasiKeahlianUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<KonsentrasiKeahlianScalarWhereInput>
  }

  export type TrackerUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutProgramInput>, Enumerable<TrackerUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: TrackerCreateManyProgramInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type MataPelajaranUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<MataPelajaranCreateWithoutProgramInput>, Enumerable<MataPelajaranUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<MataPelajaranCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<MataPelajaranUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: MataPelajaranCreateManyProgramInputEnvelope
    set?: Enumerable<MataPelajaranWhereUniqueInput>
    disconnect?: Enumerable<MataPelajaranWhereUniqueInput>
    delete?: Enumerable<MataPelajaranWhereUniqueInput>
    connect?: Enumerable<MataPelajaranWhereUniqueInput>
    update?: Enumerable<MataPelajaranUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<MataPelajaranUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<MataPelajaranScalarWhereInput>
  }

  export type KonsentrasiKeahlianUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<KonsentrasiKeahlianCreateWithoutProgramInput>, Enumerable<KonsentrasiKeahlianUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<KonsentrasiKeahlianCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<KonsentrasiKeahlianUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: KonsentrasiKeahlianCreateManyProgramInputEnvelope
    set?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    disconnect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    delete?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    connect?: Enumerable<KonsentrasiKeahlianWhereUniqueInput>
    update?: Enumerable<KonsentrasiKeahlianUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<KonsentrasiKeahlianUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<KonsentrasiKeahlianScalarWhereInput>
  }

  export type TrackerUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutProgramInput>, Enumerable<TrackerUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: TrackerCreateManyProgramInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type MataPelajaranUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<Enumerable<MataPelajaranCreateWithoutProgramInput>, Enumerable<MataPelajaranUncheckedCreateWithoutProgramInput>>
    connectOrCreate?: Enumerable<MataPelajaranCreateOrConnectWithoutProgramInput>
    upsert?: Enumerable<MataPelajaranUpsertWithWhereUniqueWithoutProgramInput>
    createMany?: MataPelajaranCreateManyProgramInputEnvelope
    set?: Enumerable<MataPelajaranWhereUniqueInput>
    disconnect?: Enumerable<MataPelajaranWhereUniqueInput>
    delete?: Enumerable<MataPelajaranWhereUniqueInput>
    connect?: Enumerable<MataPelajaranWhereUniqueInput>
    update?: Enumerable<MataPelajaranUpdateWithWhereUniqueWithoutProgramInput>
    updateMany?: Enumerable<MataPelajaranUpdateManyWithWhereWithoutProgramInput>
    deleteMany?: Enumerable<MataPelajaranScalarWhereInput>
  }

  export type ProgramKeahlianCreateNestedOneWithoutKonsentrasiInput = {
    create?: XOR<ProgramKeahlianCreateWithoutKonsentrasiInput, ProgramKeahlianUncheckedCreateWithoutKonsentrasiInput>
    connectOrCreate?: ProgramKeahlianCreateOrConnectWithoutKonsentrasiInput
    connect?: ProgramKeahlianWhereUniqueInput
  }

  export type StudentCreateNestedManyWithoutMajorInput = {
    create?: XOR<Enumerable<StudentCreateWithoutMajorInput>, Enumerable<StudentUncheckedCreateWithoutMajorInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutMajorInput>
    createMany?: StudentCreateManyMajorInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type InstansiCreateNestedManyWithoutMajorsInput = {
    create?: XOR<Enumerable<InstansiCreateWithoutMajorsInput>, Enumerable<InstansiUncheckedCreateWithoutMajorsInput>>
    connectOrCreate?: Enumerable<InstansiCreateOrConnectWithoutMajorsInput>
    connect?: Enumerable<InstansiWhereUniqueInput>
  }

  export type ClassRoomCreateNestedManyWithoutMajorInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutMajorInput>, Enumerable<ClassRoomUncheckedCreateWithoutMajorInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutMajorInput>
    createMany?: ClassRoomCreateManyMajorInputEnvelope
    connect?: Enumerable<ClassRoomWhereUniqueInput>
  }

  export type TrackerCreateNestedManyWithoutKonsentrasiInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutKonsentrasiInput>, Enumerable<TrackerUncheckedCreateWithoutKonsentrasiInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutKonsentrasiInput>
    createMany?: TrackerCreateManyKonsentrasiInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type MataPelajaranCreateNestedManyWithoutKeahlianInput = {
    create?: XOR<Enumerable<MataPelajaranCreateWithoutKeahlianInput>, Enumerable<MataPelajaranUncheckedCreateWithoutKeahlianInput>>
    connectOrCreate?: Enumerable<MataPelajaranCreateOrConnectWithoutKeahlianInput>
    createMany?: MataPelajaranCreateManyKeahlianInputEnvelope
    connect?: Enumerable<MataPelajaranWhereUniqueInput>
  }

  export type DudiCreateNestedManyWithoutMajorInput = {
    create?: XOR<Enumerable<DudiCreateWithoutMajorInput>, Enumerable<DudiUncheckedCreateWithoutMajorInput>>
    connectOrCreate?: Enumerable<DudiCreateOrConnectWithoutMajorInput>
    createMany?: DudiCreateManyMajorInputEnvelope
    connect?: Enumerable<DudiWhereUniqueInput>
  }

  export type KkniCreateNestedManyWithoutKonsentrasiInput = {
    create?: XOR<Enumerable<KkniCreateWithoutKonsentrasiInput>, Enumerable<KkniUncheckedCreateWithoutKonsentrasiInput>>
    connectOrCreate?: Enumerable<KkniCreateOrConnectWithoutKonsentrasiInput>
    createMany?: KkniCreateManyKonsentrasiInputEnvelope
    connect?: Enumerable<KkniWhereUniqueInput>
  }

  export type KonsentrasiKeahlianCreateinstansiIdsInput = {
    set: Enumerable<string>
  }

  export type StudentUncheckedCreateNestedManyWithoutMajorInput = {
    create?: XOR<Enumerable<StudentCreateWithoutMajorInput>, Enumerable<StudentUncheckedCreateWithoutMajorInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutMajorInput>
    createMany?: StudentCreateManyMajorInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type InstansiUncheckedCreateNestedManyWithoutMajorsInput = {
    create?: XOR<Enumerable<InstansiCreateWithoutMajorsInput>, Enumerable<InstansiUncheckedCreateWithoutMajorsInput>>
    connectOrCreate?: Enumerable<InstansiCreateOrConnectWithoutMajorsInput>
    connect?: Enumerable<InstansiWhereUniqueInput>
  }

  export type ClassRoomUncheckedCreateNestedManyWithoutMajorInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutMajorInput>, Enumerable<ClassRoomUncheckedCreateWithoutMajorInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutMajorInput>
    createMany?: ClassRoomCreateManyMajorInputEnvelope
    connect?: Enumerable<ClassRoomWhereUniqueInput>
  }

  export type TrackerUncheckedCreateNestedManyWithoutKonsentrasiInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutKonsentrasiInput>, Enumerable<TrackerUncheckedCreateWithoutKonsentrasiInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutKonsentrasiInput>
    createMany?: TrackerCreateManyKonsentrasiInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type MataPelajaranUncheckedCreateNestedManyWithoutKeahlianInput = {
    create?: XOR<Enumerable<MataPelajaranCreateWithoutKeahlianInput>, Enumerable<MataPelajaranUncheckedCreateWithoutKeahlianInput>>
    connectOrCreate?: Enumerable<MataPelajaranCreateOrConnectWithoutKeahlianInput>
    createMany?: MataPelajaranCreateManyKeahlianInputEnvelope
    connect?: Enumerable<MataPelajaranWhereUniqueInput>
  }

  export type DudiUncheckedCreateNestedManyWithoutMajorInput = {
    create?: XOR<Enumerable<DudiCreateWithoutMajorInput>, Enumerable<DudiUncheckedCreateWithoutMajorInput>>
    connectOrCreate?: Enumerable<DudiCreateOrConnectWithoutMajorInput>
    createMany?: DudiCreateManyMajorInputEnvelope
    connect?: Enumerable<DudiWhereUniqueInput>
  }

  export type KkniUncheckedCreateNestedManyWithoutKonsentrasiInput = {
    create?: XOR<Enumerable<KkniCreateWithoutKonsentrasiInput>, Enumerable<KkniUncheckedCreateWithoutKonsentrasiInput>>
    connectOrCreate?: Enumerable<KkniCreateOrConnectWithoutKonsentrasiInput>
    createMany?: KkniCreateManyKonsentrasiInputEnvelope
    connect?: Enumerable<KkniWhereUniqueInput>
  }

  export type ProgramKeahlianUpdateOneRequiredWithoutKonsentrasiNestedInput = {
    create?: XOR<ProgramKeahlianCreateWithoutKonsentrasiInput, ProgramKeahlianUncheckedCreateWithoutKonsentrasiInput>
    connectOrCreate?: ProgramKeahlianCreateOrConnectWithoutKonsentrasiInput
    upsert?: ProgramKeahlianUpsertWithoutKonsentrasiInput
    connect?: ProgramKeahlianWhereUniqueInput
    update?: XOR<ProgramKeahlianUpdateWithoutKonsentrasiInput, ProgramKeahlianUncheckedUpdateWithoutKonsentrasiInput>
  }

  export type StudentUpdateManyWithoutMajorNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutMajorInput>, Enumerable<StudentUncheckedCreateWithoutMajorInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutMajorInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutMajorInput>
    createMany?: StudentCreateManyMajorInputEnvelope
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutMajorInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutMajorInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type InstansiUpdateManyWithoutMajorsNestedInput = {
    create?: XOR<Enumerable<InstansiCreateWithoutMajorsInput>, Enumerable<InstansiUncheckedCreateWithoutMajorsInput>>
    connectOrCreate?: Enumerable<InstansiCreateOrConnectWithoutMajorsInput>
    upsert?: Enumerable<InstansiUpsertWithWhereUniqueWithoutMajorsInput>
    set?: Enumerable<InstansiWhereUniqueInput>
    disconnect?: Enumerable<InstansiWhereUniqueInput>
    delete?: Enumerable<InstansiWhereUniqueInput>
    connect?: Enumerable<InstansiWhereUniqueInput>
    update?: Enumerable<InstansiUpdateWithWhereUniqueWithoutMajorsInput>
    updateMany?: Enumerable<InstansiUpdateManyWithWhereWithoutMajorsInput>
    deleteMany?: Enumerable<InstansiScalarWhereInput>
  }

  export type ClassRoomUpdateManyWithoutMajorNestedInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutMajorInput>, Enumerable<ClassRoomUncheckedCreateWithoutMajorInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutMajorInput>
    upsert?: Enumerable<ClassRoomUpsertWithWhereUniqueWithoutMajorInput>
    createMany?: ClassRoomCreateManyMajorInputEnvelope
    set?: Enumerable<ClassRoomWhereUniqueInput>
    disconnect?: Enumerable<ClassRoomWhereUniqueInput>
    delete?: Enumerable<ClassRoomWhereUniqueInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
    update?: Enumerable<ClassRoomUpdateWithWhereUniqueWithoutMajorInput>
    updateMany?: Enumerable<ClassRoomUpdateManyWithWhereWithoutMajorInput>
    deleteMany?: Enumerable<ClassRoomScalarWhereInput>
  }

  export type TrackerUpdateManyWithoutKonsentrasiNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutKonsentrasiInput>, Enumerable<TrackerUncheckedCreateWithoutKonsentrasiInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutKonsentrasiInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutKonsentrasiInput>
    createMany?: TrackerCreateManyKonsentrasiInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutKonsentrasiInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutKonsentrasiInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type MataPelajaranUpdateManyWithoutKeahlianNestedInput = {
    create?: XOR<Enumerable<MataPelajaranCreateWithoutKeahlianInput>, Enumerable<MataPelajaranUncheckedCreateWithoutKeahlianInput>>
    connectOrCreate?: Enumerable<MataPelajaranCreateOrConnectWithoutKeahlianInput>
    upsert?: Enumerable<MataPelajaranUpsertWithWhereUniqueWithoutKeahlianInput>
    createMany?: MataPelajaranCreateManyKeahlianInputEnvelope
    set?: Enumerable<MataPelajaranWhereUniqueInput>
    disconnect?: Enumerable<MataPelajaranWhereUniqueInput>
    delete?: Enumerable<MataPelajaranWhereUniqueInput>
    connect?: Enumerable<MataPelajaranWhereUniqueInput>
    update?: Enumerable<MataPelajaranUpdateWithWhereUniqueWithoutKeahlianInput>
    updateMany?: Enumerable<MataPelajaranUpdateManyWithWhereWithoutKeahlianInput>
    deleteMany?: Enumerable<MataPelajaranScalarWhereInput>
  }

  export type DudiUpdateManyWithoutMajorNestedInput = {
    create?: XOR<Enumerable<DudiCreateWithoutMajorInput>, Enumerable<DudiUncheckedCreateWithoutMajorInput>>
    connectOrCreate?: Enumerable<DudiCreateOrConnectWithoutMajorInput>
    upsert?: Enumerable<DudiUpsertWithWhereUniqueWithoutMajorInput>
    createMany?: DudiCreateManyMajorInputEnvelope
    set?: Enumerable<DudiWhereUniqueInput>
    disconnect?: Enumerable<DudiWhereUniqueInput>
    delete?: Enumerable<DudiWhereUniqueInput>
    connect?: Enumerable<DudiWhereUniqueInput>
    update?: Enumerable<DudiUpdateWithWhereUniqueWithoutMajorInput>
    updateMany?: Enumerable<DudiUpdateManyWithWhereWithoutMajorInput>
    deleteMany?: Enumerable<DudiScalarWhereInput>
  }

  export type KkniUpdateManyWithoutKonsentrasiNestedInput = {
    create?: XOR<Enumerable<KkniCreateWithoutKonsentrasiInput>, Enumerable<KkniUncheckedCreateWithoutKonsentrasiInput>>
    connectOrCreate?: Enumerable<KkniCreateOrConnectWithoutKonsentrasiInput>
    upsert?: Enumerable<KkniUpsertWithWhereUniqueWithoutKonsentrasiInput>
    createMany?: KkniCreateManyKonsentrasiInputEnvelope
    set?: Enumerable<KkniWhereUniqueInput>
    disconnect?: Enumerable<KkniWhereUniqueInput>
    delete?: Enumerable<KkniWhereUniqueInput>
    connect?: Enumerable<KkniWhereUniqueInput>
    update?: Enumerable<KkniUpdateWithWhereUniqueWithoutKonsentrasiInput>
    updateMany?: Enumerable<KkniUpdateManyWithWhereWithoutKonsentrasiInput>
    deleteMany?: Enumerable<KkniScalarWhereInput>
  }

  export type KonsentrasiKeahlianUpdateinstansiIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type StudentUncheckedUpdateManyWithoutMajorNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutMajorInput>, Enumerable<StudentUncheckedCreateWithoutMajorInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutMajorInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutMajorInput>
    createMany?: StudentCreateManyMajorInputEnvelope
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutMajorInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutMajorInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type InstansiUncheckedUpdateManyWithoutMajorsNestedInput = {
    create?: XOR<Enumerable<InstansiCreateWithoutMajorsInput>, Enumerable<InstansiUncheckedCreateWithoutMajorsInput>>
    connectOrCreate?: Enumerable<InstansiCreateOrConnectWithoutMajorsInput>
    upsert?: Enumerable<InstansiUpsertWithWhereUniqueWithoutMajorsInput>
    set?: Enumerable<InstansiWhereUniqueInput>
    disconnect?: Enumerable<InstansiWhereUniqueInput>
    delete?: Enumerable<InstansiWhereUniqueInput>
    connect?: Enumerable<InstansiWhereUniqueInput>
    update?: Enumerable<InstansiUpdateWithWhereUniqueWithoutMajorsInput>
    updateMany?: Enumerable<InstansiUpdateManyWithWhereWithoutMajorsInput>
    deleteMany?: Enumerable<InstansiScalarWhereInput>
  }

  export type ClassRoomUncheckedUpdateManyWithoutMajorNestedInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutMajorInput>, Enumerable<ClassRoomUncheckedCreateWithoutMajorInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutMajorInput>
    upsert?: Enumerable<ClassRoomUpsertWithWhereUniqueWithoutMajorInput>
    createMany?: ClassRoomCreateManyMajorInputEnvelope
    set?: Enumerable<ClassRoomWhereUniqueInput>
    disconnect?: Enumerable<ClassRoomWhereUniqueInput>
    delete?: Enumerable<ClassRoomWhereUniqueInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
    update?: Enumerable<ClassRoomUpdateWithWhereUniqueWithoutMajorInput>
    updateMany?: Enumerable<ClassRoomUpdateManyWithWhereWithoutMajorInput>
    deleteMany?: Enumerable<ClassRoomScalarWhereInput>
  }

  export type TrackerUncheckedUpdateManyWithoutKonsentrasiNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutKonsentrasiInput>, Enumerable<TrackerUncheckedCreateWithoutKonsentrasiInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutKonsentrasiInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutKonsentrasiInput>
    createMany?: TrackerCreateManyKonsentrasiInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutKonsentrasiInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutKonsentrasiInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type MataPelajaranUncheckedUpdateManyWithoutKeahlianNestedInput = {
    create?: XOR<Enumerable<MataPelajaranCreateWithoutKeahlianInput>, Enumerable<MataPelajaranUncheckedCreateWithoutKeahlianInput>>
    connectOrCreate?: Enumerable<MataPelajaranCreateOrConnectWithoutKeahlianInput>
    upsert?: Enumerable<MataPelajaranUpsertWithWhereUniqueWithoutKeahlianInput>
    createMany?: MataPelajaranCreateManyKeahlianInputEnvelope
    set?: Enumerable<MataPelajaranWhereUniqueInput>
    disconnect?: Enumerable<MataPelajaranWhereUniqueInput>
    delete?: Enumerable<MataPelajaranWhereUniqueInput>
    connect?: Enumerable<MataPelajaranWhereUniqueInput>
    update?: Enumerable<MataPelajaranUpdateWithWhereUniqueWithoutKeahlianInput>
    updateMany?: Enumerable<MataPelajaranUpdateManyWithWhereWithoutKeahlianInput>
    deleteMany?: Enumerable<MataPelajaranScalarWhereInput>
  }

  export type DudiUncheckedUpdateManyWithoutMajorNestedInput = {
    create?: XOR<Enumerable<DudiCreateWithoutMajorInput>, Enumerable<DudiUncheckedCreateWithoutMajorInput>>
    connectOrCreate?: Enumerable<DudiCreateOrConnectWithoutMajorInput>
    upsert?: Enumerable<DudiUpsertWithWhereUniqueWithoutMajorInput>
    createMany?: DudiCreateManyMajorInputEnvelope
    set?: Enumerable<DudiWhereUniqueInput>
    disconnect?: Enumerable<DudiWhereUniqueInput>
    delete?: Enumerable<DudiWhereUniqueInput>
    connect?: Enumerable<DudiWhereUniqueInput>
    update?: Enumerable<DudiUpdateWithWhereUniqueWithoutMajorInput>
    updateMany?: Enumerable<DudiUpdateManyWithWhereWithoutMajorInput>
    deleteMany?: Enumerable<DudiScalarWhereInput>
  }

  export type KkniUncheckedUpdateManyWithoutKonsentrasiNestedInput = {
    create?: XOR<Enumerable<KkniCreateWithoutKonsentrasiInput>, Enumerable<KkniUncheckedCreateWithoutKonsentrasiInput>>
    connectOrCreate?: Enumerable<KkniCreateOrConnectWithoutKonsentrasiInput>
    upsert?: Enumerable<KkniUpsertWithWhereUniqueWithoutKonsentrasiInput>
    createMany?: KkniCreateManyKonsentrasiInputEnvelope
    set?: Enumerable<KkniWhereUniqueInput>
    disconnect?: Enumerable<KkniWhereUniqueInput>
    delete?: Enumerable<KkniWhereUniqueInput>
    connect?: Enumerable<KkniWhereUniqueInput>
    update?: Enumerable<KkniUpdateWithWhereUniqueWithoutKonsentrasiInput>
    updateMany?: Enumerable<KkniUpdateManyWithWhereWithoutKonsentrasiInput>
    deleteMany?: Enumerable<KkniScalarWhereInput>
  }

  export type InstansiCreateNestedOneWithoutRoleInput = {
    create?: XOR<InstansiCreateWithoutRoleInput, InstansiUncheckedCreateWithoutRoleInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutRoleInput
    connect?: InstansiWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<UserCreateWithoutRoleInput>, Enumerable<UserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<UserCreateWithoutRoleInput>, Enumerable<UserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type EnumRolesFieldUpdateOperationsInput = {
    set?: Roles
  }

  export type InstansiUpdateOneRequiredWithoutRoleNestedInput = {
    create?: XOR<InstansiCreateWithoutRoleInput, InstansiUncheckedCreateWithoutRoleInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutRoleInput
    upsert?: InstansiUpsertWithoutRoleInput
    connect?: InstansiWhereUniqueInput
    update?: XOR<InstansiUpdateWithoutRoleInput, InstansiUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutRoleInput>, Enumerable<UserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: UserCreateManyRoleInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutRoleInput>, Enumerable<UserUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: UserCreateManyRoleInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type GoogleNullableCreateEnvelopeInput = {
    set?: GoogleCreateInput | null
  }

  export type GoogleCreateInput = {
    scopes?: GoogleCreatescopesInput | Enumerable<string>
    tokens: InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type AuthCreateNestedOneWithoutUserInput = {
    create?: XOR<AuthCreateWithoutUserInput, AuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: AuthCreateOrConnectWithoutUserInput
    connect?: AuthWhereUniqueInput
  }

  export type TrackerCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutUserInput>, Enumerable<TrackerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutUserInput>
    createMany?: TrackerCreateManyUserInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type ObjectiveCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutUserInput>, Enumerable<ObjectiveUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutUserInput>
    createMany?: ObjectiveCreateManyUserInputEnvelope
    connect?: Enumerable<ObjectiveWhereUniqueInput>
  }

  export type LinkCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LinkCreateWithoutUserInput>, Enumerable<LinkUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LinkCreateOrConnectWithoutUserInput>
    createMany?: LinkCreateManyUserInputEnvelope
    connect?: Enumerable<LinkWhereUniqueInput>
  }

  export type TDeviceCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutUserInput>, Enumerable<TDeviceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutUserInput>
    createMany?: TDeviceCreateManyUserInputEnvelope
    connect?: Enumerable<TDeviceWhereUniqueInput>
  }

  export type AuthUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AuthCreateWithoutUserInput, AuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: AuthCreateOrConnectWithoutUserInput
    connect?: AuthWhereUniqueInput
  }

  export type TrackerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutUserInput>, Enumerable<TrackerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutUserInput>
    createMany?: TrackerCreateManyUserInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type ObjectiveUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutUserInput>, Enumerable<ObjectiveUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutUserInput>
    createMany?: ObjectiveCreateManyUserInputEnvelope
    connect?: Enumerable<ObjectiveWhereUniqueInput>
  }

  export type LinkUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LinkCreateWithoutUserInput>, Enumerable<LinkUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LinkCreateOrConnectWithoutUserInput>
    createMany?: LinkCreateManyUserInputEnvelope
    connect?: Enumerable<LinkWhereUniqueInput>
  }

  export type TDeviceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutUserInput>, Enumerable<TDeviceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutUserInput>
    createMany?: TDeviceCreateManyUserInputEnvelope
    connect?: Enumerable<TDeviceWhereUniqueInput>
  }

  export type GoogleNullableUpdateEnvelopeInput = {
    set?: GoogleCreateInput | null
    upsert?: GoogleUpsertInput
    unset?: boolean
  }

  export type RoleUpdateOneWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: RoleWhereUniqueInput
    update?: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type AuthUpdateOneWithoutUserNestedInput = {
    create?: XOR<AuthCreateWithoutUserInput, AuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: AuthCreateOrConnectWithoutUserInput
    upsert?: AuthUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: AuthWhereUniqueInput
    update?: XOR<AuthUpdateWithoutUserInput, AuthUncheckedUpdateWithoutUserInput>
  }

  export type TrackerUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutUserInput>, Enumerable<TrackerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TrackerCreateManyUserInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type ObjectiveUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutUserInput>, Enumerable<ObjectiveUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ObjectiveUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ObjectiveCreateManyUserInputEnvelope
    set?: Enumerable<ObjectiveWhereUniqueInput>
    disconnect?: Enumerable<ObjectiveWhereUniqueInput>
    delete?: Enumerable<ObjectiveWhereUniqueInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
    update?: Enumerable<ObjectiveUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ObjectiveUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ObjectiveScalarWhereInput>
  }

  export type LinkUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<LinkCreateWithoutUserInput>, Enumerable<LinkUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LinkCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LinkUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LinkCreateManyUserInputEnvelope
    set?: Enumerable<LinkWhereUniqueInput>
    disconnect?: Enumerable<LinkWhereUniqueInput>
    delete?: Enumerable<LinkWhereUniqueInput>
    connect?: Enumerable<LinkWhereUniqueInput>
    update?: Enumerable<LinkUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LinkUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LinkScalarWhereInput>
  }

  export type TDeviceUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutUserInput>, Enumerable<TDeviceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TDeviceUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TDeviceCreateManyUserInputEnvelope
    set?: Enumerable<TDeviceWhereUniqueInput>
    disconnect?: Enumerable<TDeviceWhereUniqueInput>
    delete?: Enumerable<TDeviceWhereUniqueInput>
    connect?: Enumerable<TDeviceWhereUniqueInput>
    update?: Enumerable<TDeviceUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TDeviceUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TDeviceScalarWhereInput>
  }

  export type AuthUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AuthCreateWithoutUserInput, AuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: AuthCreateOrConnectWithoutUserInput
    upsert?: AuthUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: AuthWhereUniqueInput
    update?: XOR<AuthUpdateWithoutUserInput, AuthUncheckedUpdateWithoutUserInput>
  }

  export type TrackerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutUserInput>, Enumerable<TrackerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TrackerCreateManyUserInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type ObjectiveUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutUserInput>, Enumerable<ObjectiveUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ObjectiveUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ObjectiveCreateManyUserInputEnvelope
    set?: Enumerable<ObjectiveWhereUniqueInput>
    disconnect?: Enumerable<ObjectiveWhereUniqueInput>
    delete?: Enumerable<ObjectiveWhereUniqueInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
    update?: Enumerable<ObjectiveUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ObjectiveUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ObjectiveScalarWhereInput>
  }

  export type LinkUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<LinkCreateWithoutUserInput>, Enumerable<LinkUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LinkCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LinkUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LinkCreateManyUserInputEnvelope
    set?: Enumerable<LinkWhereUniqueInput>
    disconnect?: Enumerable<LinkWhereUniqueInput>
    delete?: Enumerable<LinkWhereUniqueInput>
    connect?: Enumerable<LinkWhereUniqueInput>
    update?: Enumerable<LinkUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LinkUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LinkScalarWhereInput>
  }

  export type TDeviceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutUserInput>, Enumerable<TDeviceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TDeviceUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TDeviceCreateManyUserInputEnvelope
    set?: Enumerable<TDeviceWhereUniqueInput>
    disconnect?: Enumerable<TDeviceWhereUniqueInput>
    delete?: Enumerable<TDeviceWhereUniqueInput>
    connect?: Enumerable<TDeviceWhereUniqueInput>
    update?: Enumerable<TDeviceUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TDeviceUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TDeviceScalarWhereInput>
  }

  export type EnumUploadTypeFieldUpdateOperationsInput = {
    set?: UploadType
  }

  export type BornCreateEnvelopeInput = {
    set?: BornCreateInput
  }

  export type BornCreateInput = {
    place: string
    date: Date | string
  }

  export type AddressNullableCreateEnvelopeInput = {
    set?: AddressCreateInput | null
  }

  export type EducationListCreateEnvelopeInput = {
    set?: Enumerable<EducationCreateInput>
  }

  export type EducationCreateInput = {
    instansi: string
    level: LevelEdu
    major?: string | null
    year: number
    attachment?: string | null
  }

  export type TrainingListCreateEnvelopeInput = {
    set?: Enumerable<TrainingCreateInput>
  }

  export type TrainingCreateInput = {
    name: string
    instansi: string
    long: number
    year: number
    place: string
    attachment?: string | null
  }

  export type EmploymentListCreateEnvelopeInput = {
    set?: Enumerable<EmploymentCreateInput>
  }

  export type EmploymentCreateInput = {
    position: string
    year: number
    place: string
    note?: string | null
  }

  export type ProfessionListCreateEnvelopeInput = {
    set?: Enumerable<ProfessionCreateInput>
  }

  export type ProfessionCreateInput = {
    name: string
    instansi: string
    year: number
    attachment?: string | null
  }

  export type OverseasListCreateEnvelopeInput = {
    set?: Enumerable<OverseasCreateInput>
  }

  export type OverseasCreateInput = {
    country: string
    instansi: string
    objective: string
    long: number
    year: number
    attachment?: string | null
  }

  export type ScientificListCreateEnvelopeInput = {
    set?: Enumerable<ScientificCreateInput>
  }

  export type ScientificCreateInput = {
    name: string
    instansi: string
    position: string
    place: string
    period: string
    attachment?: string | null
  }

  export type OrganizationListCreateEnvelopeInput = {
    set?: Enumerable<OrganizationCreateInput>
  }

  export type OrganizationCreateInput = {
    name: string
    position: string
    period: string
    leader: string
    place: string
  }

  export type PapersListCreateEnvelopeInput = {
    set?: Enumerable<PapersCreateInput>
  }

  export type PapersCreateInput = {
    name: string
    year: number
    published: string
  }

  export type InnovationListCreateEnvelopeInput = {
    set?: Enumerable<InnovationCreateInput>
  }

  export type InnovationCreateInput = {
    name: string
    year: number
    patent: boolean
  }

  export type AwardListCreateEnvelopeInput = {
    set?: Enumerable<AwardCreateInput>
  }

  export type AwardCreateInput = {
    name: string
    year: number
    instansi: string
    attachment?: string | null
  }

  export type SourcePersonListCreateEnvelopeInput = {
    set?: Enumerable<SourcePersonCreateInput>
  }

  export type SourcePersonCreateInput = {
    name: string
    date: string
    instansi: string
    note?: string | null
    attachment?: string | null
  }

  export type ContestListCreateEnvelopeInput = {
    set?: Enumerable<ContestCreateInput>
  }

  export type ContestCreateInput = {
    name: string
    date: string
    instansi: string
    level: string
    attachment?: string | null
  }

  export type DocumentsListCreateEnvelopeInput = {
    set?: Enumerable<DocumentsCreateInput>
  }

  export type DocumentsCreateInput = {
    name: string
    date: string
    instansi: string
    note?: string | null
    attachment?: string | null
  }

  export type AdditionalListCreateEnvelopeInput = {
    set?: Enumerable<AdditionalCreateInput>
  }

  export type AdditionalCreateInput = {
    position: string
    date: string
    instansi: string
    note?: string | null
    attachment?: string | null
  }

  export type AuthCreateNestedOneWithoutPersonalInput = {
    create?: XOR<AuthCreateWithoutPersonalInput, AuthUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: AuthCreateOrConnectWithoutPersonalInput
    connect?: AuthWhereUniqueInput
  }

  export type FamilyTreeCreateNestedManyWithoutFatherInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutFatherInput>, Enumerable<FamilyTreeUncheckedCreateWithoutFatherInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutFatherInput>
    createMany?: FamilyTreeCreateManyFatherInputEnvelope
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
  }

  export type FamilyTreeCreateNestedManyWithoutMotherInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutMotherInput>, Enumerable<FamilyTreeUncheckedCreateWithoutMotherInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutMotherInput>
    createMany?: FamilyTreeCreateManyMotherInputEnvelope
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
  }

  export type FamilyTreeCreateNestedManyWithoutWaliInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutWaliInput>, Enumerable<FamilyTreeUncheckedCreateWithoutWaliInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutWaliInput>
    createMany?: FamilyTreeCreateManyWaliInputEnvelope
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
  }

  export type FamilyTreeCreateNestedManyWithoutCoupleInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutCoupleInput>, Enumerable<FamilyTreeUncheckedCreateWithoutCoupleInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutCoupleInput>
    createMany?: FamilyTreeCreateManyCoupleInputEnvelope
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
  }

  export type FamilyTreeChildCreateNestedOneWithoutPersonalInput = {
    create?: XOR<FamilyTreeChildCreateWithoutPersonalInput, FamilyTreeChildUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: FamilyTreeChildCreateOrConnectWithoutPersonalInput
    connect?: FamilyTreeChildWhereUniqueInput
  }

  export type StudentCreateNestedManyWithoutPersonalInput = {
    create?: XOR<Enumerable<StudentCreateWithoutPersonalInput>, Enumerable<StudentUncheckedCreateWithoutPersonalInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutPersonalInput>
    createMany?: StudentCreateManyPersonalInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type TeacherCreateNestedManyWithoutPersonalInput = {
    create?: XOR<Enumerable<TeacherCreateWithoutPersonalInput>, Enumerable<TeacherUncheckedCreateWithoutPersonalInput>>
    connectOrCreate?: Enumerable<TeacherCreateOrConnectWithoutPersonalInput>
    createMany?: TeacherCreateManyPersonalInputEnvelope
    connect?: Enumerable<TeacherWhereUniqueInput>
  }

  export type AuthUncheckedCreateNestedOneWithoutPersonalInput = {
    create?: XOR<AuthCreateWithoutPersonalInput, AuthUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: AuthCreateOrConnectWithoutPersonalInput
    connect?: AuthWhereUniqueInput
  }

  export type FamilyTreeUncheckedCreateNestedManyWithoutFatherInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutFatherInput>, Enumerable<FamilyTreeUncheckedCreateWithoutFatherInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutFatherInput>
    createMany?: FamilyTreeCreateManyFatherInputEnvelope
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
  }

  export type FamilyTreeUncheckedCreateNestedManyWithoutMotherInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutMotherInput>, Enumerable<FamilyTreeUncheckedCreateWithoutMotherInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutMotherInput>
    createMany?: FamilyTreeCreateManyMotherInputEnvelope
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
  }

  export type FamilyTreeUncheckedCreateNestedManyWithoutWaliInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutWaliInput>, Enumerable<FamilyTreeUncheckedCreateWithoutWaliInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutWaliInput>
    createMany?: FamilyTreeCreateManyWaliInputEnvelope
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
  }

  export type FamilyTreeUncheckedCreateNestedManyWithoutCoupleInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutCoupleInput>, Enumerable<FamilyTreeUncheckedCreateWithoutCoupleInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutCoupleInput>
    createMany?: FamilyTreeCreateManyCoupleInputEnvelope
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
  }

  export type FamilyTreeChildUncheckedCreateNestedOneWithoutPersonalInput = {
    create?: XOR<FamilyTreeChildCreateWithoutPersonalInput, FamilyTreeChildUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: FamilyTreeChildCreateOrConnectWithoutPersonalInput
    connect?: FamilyTreeChildWhereUniqueInput
  }

  export type StudentUncheckedCreateNestedManyWithoutPersonalInput = {
    create?: XOR<Enumerable<StudentCreateWithoutPersonalInput>, Enumerable<StudentUncheckedCreateWithoutPersonalInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutPersonalInput>
    createMany?: StudentCreateManyPersonalInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type TeacherUncheckedCreateNestedManyWithoutPersonalInput = {
    create?: XOR<Enumerable<TeacherCreateWithoutPersonalInput>, Enumerable<TeacherUncheckedCreateWithoutPersonalInput>>
    connectOrCreate?: Enumerable<TeacherCreateOrConnectWithoutPersonalInput>
    createMany?: TeacherCreateManyPersonalInputEnvelope
    connect?: Enumerable<TeacherWhereUniqueInput>
  }

  export type EnumTypePersonalFieldUpdateOperationsInput = {
    set?: TypePersonal
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: Gender
  }

  export type EnumReligionFieldUpdateOperationsInput = {
    set?: Religion
  }

  export type BornUpdateEnvelopeInput = {
    set?: BornCreateInput
    update?: BornUpdateInput
  }

  export type AddressNullableUpdateEnvelopeInput = {
    set?: AddressCreateInput | null
    upsert?: AddressUpsertInput
    unset?: boolean
  }

  export type EducationListUpdateEnvelopeInput = {
    set?: Enumerable<EducationCreateInput>
    push?: Enumerable<EducationCreateInput>
    updateMany?: EducationUpdateManyInput
    deleteMany?: EducationDeleteManyInput
  }

  export type TrainingListUpdateEnvelopeInput = {
    set?: Enumerable<TrainingCreateInput>
    push?: Enumerable<TrainingCreateInput>
    updateMany?: TrainingUpdateManyInput
    deleteMany?: TrainingDeleteManyInput
  }

  export type EmploymentListUpdateEnvelopeInput = {
    set?: Enumerable<EmploymentCreateInput>
    push?: Enumerable<EmploymentCreateInput>
    updateMany?: EmploymentUpdateManyInput
    deleteMany?: EmploymentDeleteManyInput
  }

  export type ProfessionListUpdateEnvelopeInput = {
    set?: Enumerable<ProfessionCreateInput>
    push?: Enumerable<ProfessionCreateInput>
    updateMany?: ProfessionUpdateManyInput
    deleteMany?: ProfessionDeleteManyInput
  }

  export type OverseasListUpdateEnvelopeInput = {
    set?: Enumerable<OverseasCreateInput>
    push?: Enumerable<OverseasCreateInput>
    updateMany?: OverseasUpdateManyInput
    deleteMany?: OverseasDeleteManyInput
  }

  export type ScientificListUpdateEnvelopeInput = {
    set?: Enumerable<ScientificCreateInput>
    push?: Enumerable<ScientificCreateInput>
    updateMany?: ScientificUpdateManyInput
    deleteMany?: ScientificDeleteManyInput
  }

  export type OrganizationListUpdateEnvelopeInput = {
    set?: Enumerable<OrganizationCreateInput>
    push?: Enumerable<OrganizationCreateInput>
    updateMany?: OrganizationUpdateManyInput
    deleteMany?: OrganizationDeleteManyInput
  }

  export type PapersListUpdateEnvelopeInput = {
    set?: Enumerable<PapersCreateInput>
    push?: Enumerable<PapersCreateInput>
    updateMany?: PapersUpdateManyInput
    deleteMany?: PapersDeleteManyInput
  }

  export type InnovationListUpdateEnvelopeInput = {
    set?: Enumerable<InnovationCreateInput>
    push?: Enumerable<InnovationCreateInput>
    updateMany?: InnovationUpdateManyInput
    deleteMany?: InnovationDeleteManyInput
  }

  export type AwardListUpdateEnvelopeInput = {
    set?: Enumerable<AwardCreateInput>
    push?: Enumerable<AwardCreateInput>
    updateMany?: AwardUpdateManyInput
    deleteMany?: AwardDeleteManyInput
  }

  export type SourcePersonListUpdateEnvelopeInput = {
    set?: Enumerable<SourcePersonCreateInput>
    push?: Enumerable<SourcePersonCreateInput>
    updateMany?: SourcePersonUpdateManyInput
    deleteMany?: SourcePersonDeleteManyInput
  }

  export type ContestListUpdateEnvelopeInput = {
    set?: Enumerable<ContestCreateInput>
    push?: Enumerable<ContestCreateInput>
    updateMany?: ContestUpdateManyInput
    deleteMany?: ContestDeleteManyInput
  }

  export type DocumentsListUpdateEnvelopeInput = {
    set?: Enumerable<DocumentsCreateInput>
    push?: Enumerable<DocumentsCreateInput>
    updateMany?: DocumentsUpdateManyInput
    deleteMany?: DocumentsDeleteManyInput
  }

  export type AdditionalListUpdateEnvelopeInput = {
    set?: Enumerable<AdditionalCreateInput>
    push?: Enumerable<AdditionalCreateInput>
    updateMany?: AdditionalUpdateManyInput
    deleteMany?: AdditionalDeleteManyInput
  }

  export type AuthUpdateOneWithoutPersonalNestedInput = {
    create?: XOR<AuthCreateWithoutPersonalInput, AuthUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: AuthCreateOrConnectWithoutPersonalInput
    upsert?: AuthUpsertWithoutPersonalInput
    disconnect?: boolean
    delete?: boolean
    connect?: AuthWhereUniqueInput
    update?: XOR<AuthUpdateWithoutPersonalInput, AuthUncheckedUpdateWithoutPersonalInput>
  }

  export type FamilyTreeUpdateManyWithoutFatherNestedInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutFatherInput>, Enumerable<FamilyTreeUncheckedCreateWithoutFatherInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutFatherInput>
    upsert?: Enumerable<FamilyTreeUpsertWithWhereUniqueWithoutFatherInput>
    createMany?: FamilyTreeCreateManyFatherInputEnvelope
    set?: Enumerable<FamilyTreeWhereUniqueInput>
    disconnect?: Enumerable<FamilyTreeWhereUniqueInput>
    delete?: Enumerable<FamilyTreeWhereUniqueInput>
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
    update?: Enumerable<FamilyTreeUpdateWithWhereUniqueWithoutFatherInput>
    updateMany?: Enumerable<FamilyTreeUpdateManyWithWhereWithoutFatherInput>
    deleteMany?: Enumerable<FamilyTreeScalarWhereInput>
  }

  export type FamilyTreeUpdateManyWithoutMotherNestedInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutMotherInput>, Enumerable<FamilyTreeUncheckedCreateWithoutMotherInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutMotherInput>
    upsert?: Enumerable<FamilyTreeUpsertWithWhereUniqueWithoutMotherInput>
    createMany?: FamilyTreeCreateManyMotherInputEnvelope
    set?: Enumerable<FamilyTreeWhereUniqueInput>
    disconnect?: Enumerable<FamilyTreeWhereUniqueInput>
    delete?: Enumerable<FamilyTreeWhereUniqueInput>
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
    update?: Enumerable<FamilyTreeUpdateWithWhereUniqueWithoutMotherInput>
    updateMany?: Enumerable<FamilyTreeUpdateManyWithWhereWithoutMotherInput>
    deleteMany?: Enumerable<FamilyTreeScalarWhereInput>
  }

  export type FamilyTreeUpdateManyWithoutWaliNestedInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutWaliInput>, Enumerable<FamilyTreeUncheckedCreateWithoutWaliInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutWaliInput>
    upsert?: Enumerable<FamilyTreeUpsertWithWhereUniqueWithoutWaliInput>
    createMany?: FamilyTreeCreateManyWaliInputEnvelope
    set?: Enumerable<FamilyTreeWhereUniqueInput>
    disconnect?: Enumerable<FamilyTreeWhereUniqueInput>
    delete?: Enumerable<FamilyTreeWhereUniqueInput>
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
    update?: Enumerable<FamilyTreeUpdateWithWhereUniqueWithoutWaliInput>
    updateMany?: Enumerable<FamilyTreeUpdateManyWithWhereWithoutWaliInput>
    deleteMany?: Enumerable<FamilyTreeScalarWhereInput>
  }

  export type FamilyTreeUpdateManyWithoutCoupleNestedInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutCoupleInput>, Enumerable<FamilyTreeUncheckedCreateWithoutCoupleInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutCoupleInput>
    upsert?: Enumerable<FamilyTreeUpsertWithWhereUniqueWithoutCoupleInput>
    createMany?: FamilyTreeCreateManyCoupleInputEnvelope
    set?: Enumerable<FamilyTreeWhereUniqueInput>
    disconnect?: Enumerable<FamilyTreeWhereUniqueInput>
    delete?: Enumerable<FamilyTreeWhereUniqueInput>
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
    update?: Enumerable<FamilyTreeUpdateWithWhereUniqueWithoutCoupleInput>
    updateMany?: Enumerable<FamilyTreeUpdateManyWithWhereWithoutCoupleInput>
    deleteMany?: Enumerable<FamilyTreeScalarWhereInput>
  }

  export type FamilyTreeChildUpdateOneWithoutPersonalNestedInput = {
    create?: XOR<FamilyTreeChildCreateWithoutPersonalInput, FamilyTreeChildUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: FamilyTreeChildCreateOrConnectWithoutPersonalInput
    upsert?: FamilyTreeChildUpsertWithoutPersonalInput
    disconnect?: boolean
    delete?: boolean
    connect?: FamilyTreeChildWhereUniqueInput
    update?: XOR<FamilyTreeChildUpdateWithoutPersonalInput, FamilyTreeChildUncheckedUpdateWithoutPersonalInput>
  }

  export type StudentUpdateManyWithoutPersonalNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutPersonalInput>, Enumerable<StudentUncheckedCreateWithoutPersonalInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutPersonalInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutPersonalInput>
    createMany?: StudentCreateManyPersonalInputEnvelope
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutPersonalInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutPersonalInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type TeacherUpdateManyWithoutPersonalNestedInput = {
    create?: XOR<Enumerable<TeacherCreateWithoutPersonalInput>, Enumerable<TeacherUncheckedCreateWithoutPersonalInput>>
    connectOrCreate?: Enumerable<TeacherCreateOrConnectWithoutPersonalInput>
    upsert?: Enumerable<TeacherUpsertWithWhereUniqueWithoutPersonalInput>
    createMany?: TeacherCreateManyPersonalInputEnvelope
    set?: Enumerable<TeacherWhereUniqueInput>
    disconnect?: Enumerable<TeacherWhereUniqueInput>
    delete?: Enumerable<TeacherWhereUniqueInput>
    connect?: Enumerable<TeacherWhereUniqueInput>
    update?: Enumerable<TeacherUpdateWithWhereUniqueWithoutPersonalInput>
    updateMany?: Enumerable<TeacherUpdateManyWithWhereWithoutPersonalInput>
    deleteMany?: Enumerable<TeacherScalarWhereInput>
  }

  export type AuthUncheckedUpdateOneWithoutPersonalNestedInput = {
    create?: XOR<AuthCreateWithoutPersonalInput, AuthUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: AuthCreateOrConnectWithoutPersonalInput
    upsert?: AuthUpsertWithoutPersonalInput
    disconnect?: boolean
    delete?: boolean
    connect?: AuthWhereUniqueInput
    update?: XOR<AuthUpdateWithoutPersonalInput, AuthUncheckedUpdateWithoutPersonalInput>
  }

  export type FamilyTreeUncheckedUpdateManyWithoutFatherNestedInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutFatherInput>, Enumerable<FamilyTreeUncheckedCreateWithoutFatherInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutFatherInput>
    upsert?: Enumerable<FamilyTreeUpsertWithWhereUniqueWithoutFatherInput>
    createMany?: FamilyTreeCreateManyFatherInputEnvelope
    set?: Enumerable<FamilyTreeWhereUniqueInput>
    disconnect?: Enumerable<FamilyTreeWhereUniqueInput>
    delete?: Enumerable<FamilyTreeWhereUniqueInput>
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
    update?: Enumerable<FamilyTreeUpdateWithWhereUniqueWithoutFatherInput>
    updateMany?: Enumerable<FamilyTreeUpdateManyWithWhereWithoutFatherInput>
    deleteMany?: Enumerable<FamilyTreeScalarWhereInput>
  }

  export type FamilyTreeUncheckedUpdateManyWithoutMotherNestedInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutMotherInput>, Enumerable<FamilyTreeUncheckedCreateWithoutMotherInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutMotherInput>
    upsert?: Enumerable<FamilyTreeUpsertWithWhereUniqueWithoutMotherInput>
    createMany?: FamilyTreeCreateManyMotherInputEnvelope
    set?: Enumerable<FamilyTreeWhereUniqueInput>
    disconnect?: Enumerable<FamilyTreeWhereUniqueInput>
    delete?: Enumerable<FamilyTreeWhereUniqueInput>
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
    update?: Enumerable<FamilyTreeUpdateWithWhereUniqueWithoutMotherInput>
    updateMany?: Enumerable<FamilyTreeUpdateManyWithWhereWithoutMotherInput>
    deleteMany?: Enumerable<FamilyTreeScalarWhereInput>
  }

  export type FamilyTreeUncheckedUpdateManyWithoutWaliNestedInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutWaliInput>, Enumerable<FamilyTreeUncheckedCreateWithoutWaliInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutWaliInput>
    upsert?: Enumerable<FamilyTreeUpsertWithWhereUniqueWithoutWaliInput>
    createMany?: FamilyTreeCreateManyWaliInputEnvelope
    set?: Enumerable<FamilyTreeWhereUniqueInput>
    disconnect?: Enumerable<FamilyTreeWhereUniqueInput>
    delete?: Enumerable<FamilyTreeWhereUniqueInput>
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
    update?: Enumerable<FamilyTreeUpdateWithWhereUniqueWithoutWaliInput>
    updateMany?: Enumerable<FamilyTreeUpdateManyWithWhereWithoutWaliInput>
    deleteMany?: Enumerable<FamilyTreeScalarWhereInput>
  }

  export type FamilyTreeUncheckedUpdateManyWithoutCoupleNestedInput = {
    create?: XOR<Enumerable<FamilyTreeCreateWithoutCoupleInput>, Enumerable<FamilyTreeUncheckedCreateWithoutCoupleInput>>
    connectOrCreate?: Enumerable<FamilyTreeCreateOrConnectWithoutCoupleInput>
    upsert?: Enumerable<FamilyTreeUpsertWithWhereUniqueWithoutCoupleInput>
    createMany?: FamilyTreeCreateManyCoupleInputEnvelope
    set?: Enumerable<FamilyTreeWhereUniqueInput>
    disconnect?: Enumerable<FamilyTreeWhereUniqueInput>
    delete?: Enumerable<FamilyTreeWhereUniqueInput>
    connect?: Enumerable<FamilyTreeWhereUniqueInput>
    update?: Enumerable<FamilyTreeUpdateWithWhereUniqueWithoutCoupleInput>
    updateMany?: Enumerable<FamilyTreeUpdateManyWithWhereWithoutCoupleInput>
    deleteMany?: Enumerable<FamilyTreeScalarWhereInput>
  }

  export type FamilyTreeChildUncheckedUpdateOneWithoutPersonalNestedInput = {
    create?: XOR<FamilyTreeChildCreateWithoutPersonalInput, FamilyTreeChildUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: FamilyTreeChildCreateOrConnectWithoutPersonalInput
    upsert?: FamilyTreeChildUpsertWithoutPersonalInput
    disconnect?: boolean
    delete?: boolean
    connect?: FamilyTreeChildWhereUniqueInput
    update?: XOR<FamilyTreeChildUpdateWithoutPersonalInput, FamilyTreeChildUncheckedUpdateWithoutPersonalInput>
  }

  export type StudentUncheckedUpdateManyWithoutPersonalNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutPersonalInput>, Enumerable<StudentUncheckedCreateWithoutPersonalInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutPersonalInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutPersonalInput>
    createMany?: StudentCreateManyPersonalInputEnvelope
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutPersonalInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutPersonalInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type TeacherUncheckedUpdateManyWithoutPersonalNestedInput = {
    create?: XOR<Enumerable<TeacherCreateWithoutPersonalInput>, Enumerable<TeacherUncheckedCreateWithoutPersonalInput>>
    connectOrCreate?: Enumerable<TeacherCreateOrConnectWithoutPersonalInput>
    upsert?: Enumerable<TeacherUpsertWithWhereUniqueWithoutPersonalInput>
    createMany?: TeacherCreateManyPersonalInputEnvelope
    set?: Enumerable<TeacherWhereUniqueInput>
    disconnect?: Enumerable<TeacherWhereUniqueInput>
    delete?: Enumerable<TeacherWhereUniqueInput>
    connect?: Enumerable<TeacherWhereUniqueInput>
    update?: Enumerable<TeacherUpdateWithWhereUniqueWithoutPersonalInput>
    updateMany?: Enumerable<TeacherUpdateManyWithWhereWithoutPersonalInput>
    deleteMany?: Enumerable<TeacherScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutAuthInput = {
    create?: XOR<UserCreateWithoutAuthInput, UserUncheckedCreateWithoutAuthInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthInput
    connect?: UserWhereUniqueInput
  }

  export type PersonalCreateNestedOneWithoutAuthInput = {
    create?: XOR<PersonalCreateWithoutAuthInput, PersonalUncheckedCreateWithoutAuthInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutAuthInput
    connect?: PersonalWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuthNestedInput = {
    create?: XOR<UserCreateWithoutAuthInput, UserUncheckedCreateWithoutAuthInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthInput
    upsert?: UserUpsertWithoutAuthInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAuthInput, UserUncheckedUpdateWithoutAuthInput>
  }

  export type PersonalUpdateOneRequiredWithoutAuthNestedInput = {
    create?: XOR<PersonalCreateWithoutAuthInput, PersonalUncheckedCreateWithoutAuthInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutAuthInput
    upsert?: PersonalUpsertWithoutAuthInput
    connect?: PersonalWhereUniqueInput
    update?: XOR<PersonalUpdateWithoutAuthInput, PersonalUncheckedUpdateWithoutAuthInput>
  }

  export type PersonalCreateNestedOneWithoutFatherInput = {
    create?: XOR<PersonalCreateWithoutFatherInput, PersonalUncheckedCreateWithoutFatherInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutFatherInput
    connect?: PersonalWhereUniqueInput
  }

  export type PersonalCreateNestedOneWithoutMotherInput = {
    create?: XOR<PersonalCreateWithoutMotherInput, PersonalUncheckedCreateWithoutMotherInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutMotherInput
    connect?: PersonalWhereUniqueInput
  }

  export type PersonalCreateNestedOneWithoutWaliInput = {
    create?: XOR<PersonalCreateWithoutWaliInput, PersonalUncheckedCreateWithoutWaliInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutWaliInput
    connect?: PersonalWhereUniqueInput
  }

  export type PersonalCreateNestedOneWithoutCoupleInput = {
    create?: XOR<PersonalCreateWithoutCoupleInput, PersonalUncheckedCreateWithoutCoupleInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutCoupleInput
    connect?: PersonalWhereUniqueInput
  }

  export type FamilyTreeChildCreateNestedManyWithoutKkInput = {
    create?: XOR<Enumerable<FamilyTreeChildCreateWithoutKkInput>, Enumerable<FamilyTreeChildUncheckedCreateWithoutKkInput>>
    connectOrCreate?: Enumerable<FamilyTreeChildCreateOrConnectWithoutKkInput>
    createMany?: FamilyTreeChildCreateManyKkInputEnvelope
    connect?: Enumerable<FamilyTreeChildWhereUniqueInput>
  }

  export type FamilyTreeChildUncheckedCreateNestedManyWithoutKkInput = {
    create?: XOR<Enumerable<FamilyTreeChildCreateWithoutKkInput>, Enumerable<FamilyTreeChildUncheckedCreateWithoutKkInput>>
    connectOrCreate?: Enumerable<FamilyTreeChildCreateOrConnectWithoutKkInput>
    createMany?: FamilyTreeChildCreateManyKkInputEnvelope
    connect?: Enumerable<FamilyTreeChildWhereUniqueInput>
  }

  export type PersonalUpdateOneWithoutFatherNestedInput = {
    create?: XOR<PersonalCreateWithoutFatherInput, PersonalUncheckedCreateWithoutFatherInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutFatherInput
    upsert?: PersonalUpsertWithoutFatherInput
    disconnect?: boolean
    delete?: boolean
    connect?: PersonalWhereUniqueInput
    update?: XOR<PersonalUpdateWithoutFatherInput, PersonalUncheckedUpdateWithoutFatherInput>
  }

  export type PersonalUpdateOneWithoutMotherNestedInput = {
    create?: XOR<PersonalCreateWithoutMotherInput, PersonalUncheckedCreateWithoutMotherInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutMotherInput
    upsert?: PersonalUpsertWithoutMotherInput
    disconnect?: boolean
    delete?: boolean
    connect?: PersonalWhereUniqueInput
    update?: XOR<PersonalUpdateWithoutMotherInput, PersonalUncheckedUpdateWithoutMotherInput>
  }

  export type PersonalUpdateOneWithoutWaliNestedInput = {
    create?: XOR<PersonalCreateWithoutWaliInput, PersonalUncheckedCreateWithoutWaliInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutWaliInput
    upsert?: PersonalUpsertWithoutWaliInput
    disconnect?: boolean
    delete?: boolean
    connect?: PersonalWhereUniqueInput
    update?: XOR<PersonalUpdateWithoutWaliInput, PersonalUncheckedUpdateWithoutWaliInput>
  }

  export type PersonalUpdateOneWithoutCoupleNestedInput = {
    create?: XOR<PersonalCreateWithoutCoupleInput, PersonalUncheckedCreateWithoutCoupleInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutCoupleInput
    upsert?: PersonalUpsertWithoutCoupleInput
    disconnect?: boolean
    delete?: boolean
    connect?: PersonalWhereUniqueInput
    update?: XOR<PersonalUpdateWithoutCoupleInput, PersonalUncheckedUpdateWithoutCoupleInput>
  }

  export type FamilyTreeChildUpdateManyWithoutKkNestedInput = {
    create?: XOR<Enumerable<FamilyTreeChildCreateWithoutKkInput>, Enumerable<FamilyTreeChildUncheckedCreateWithoutKkInput>>
    connectOrCreate?: Enumerable<FamilyTreeChildCreateOrConnectWithoutKkInput>
    upsert?: Enumerable<FamilyTreeChildUpsertWithWhereUniqueWithoutKkInput>
    createMany?: FamilyTreeChildCreateManyKkInputEnvelope
    set?: Enumerable<FamilyTreeChildWhereUniqueInput>
    disconnect?: Enumerable<FamilyTreeChildWhereUniqueInput>
    delete?: Enumerable<FamilyTreeChildWhereUniqueInput>
    connect?: Enumerable<FamilyTreeChildWhereUniqueInput>
    update?: Enumerable<FamilyTreeChildUpdateWithWhereUniqueWithoutKkInput>
    updateMany?: Enumerable<FamilyTreeChildUpdateManyWithWhereWithoutKkInput>
    deleteMany?: Enumerable<FamilyTreeChildScalarWhereInput>
  }

  export type FamilyTreeChildUncheckedUpdateManyWithoutKkNestedInput = {
    create?: XOR<Enumerable<FamilyTreeChildCreateWithoutKkInput>, Enumerable<FamilyTreeChildUncheckedCreateWithoutKkInput>>
    connectOrCreate?: Enumerable<FamilyTreeChildCreateOrConnectWithoutKkInput>
    upsert?: Enumerable<FamilyTreeChildUpsertWithWhereUniqueWithoutKkInput>
    createMany?: FamilyTreeChildCreateManyKkInputEnvelope
    set?: Enumerable<FamilyTreeChildWhereUniqueInput>
    disconnect?: Enumerable<FamilyTreeChildWhereUniqueInput>
    delete?: Enumerable<FamilyTreeChildWhereUniqueInput>
    connect?: Enumerable<FamilyTreeChildWhereUniqueInput>
    update?: Enumerable<FamilyTreeChildUpdateWithWhereUniqueWithoutKkInput>
    updateMany?: Enumerable<FamilyTreeChildUpdateManyWithWhereWithoutKkInput>
    deleteMany?: Enumerable<FamilyTreeChildScalarWhereInput>
  }

  export type FamilyTreeCreateNestedOneWithoutChildsInput = {
    create?: XOR<FamilyTreeCreateWithoutChildsInput, FamilyTreeUncheckedCreateWithoutChildsInput>
    connectOrCreate?: FamilyTreeCreateOrConnectWithoutChildsInput
    connect?: FamilyTreeWhereUniqueInput
  }

  export type PersonalCreateNestedOneWithoutChildInput = {
    create?: XOR<PersonalCreateWithoutChildInput, PersonalUncheckedCreateWithoutChildInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutChildInput
    connect?: PersonalWhereUniqueInput
  }

  export type EnumChildTypeFieldUpdateOperationsInput = {
    set?: ChildType
  }

  export type FamilyTreeUpdateOneRequiredWithoutChildsNestedInput = {
    create?: XOR<FamilyTreeCreateWithoutChildsInput, FamilyTreeUncheckedCreateWithoutChildsInput>
    connectOrCreate?: FamilyTreeCreateOrConnectWithoutChildsInput
    upsert?: FamilyTreeUpsertWithoutChildsInput
    connect?: FamilyTreeWhereUniqueInput
    update?: XOR<FamilyTreeUpdateWithoutChildsInput, FamilyTreeUncheckedUpdateWithoutChildsInput>
  }

  export type PersonalUpdateOneRequiredWithoutChildNestedInput = {
    create?: XOR<PersonalCreateWithoutChildInput, PersonalUncheckedCreateWithoutChildInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutChildInput
    upsert?: PersonalUpsertWithoutChildInput
    connect?: PersonalWhereUniqueInput
    update?: XOR<PersonalUpdateWithoutChildInput, PersonalUncheckedUpdateWithoutChildInput>
  }

  export type SchoolYearCreatedepartmentsInput = {
    set: Enumerable<string>
  }

  export type OrganizationalCreateEnvelopeInput = {
    set?: OrganizationalCreateInput
  }

  export type OrganizationalCreateInput = {
    kepsek: string
    wakasek: string
    wakakur: string
    wakasiw: string
    wakapra: string
    wakahum?: string | null
  }

  export type InstansiCreateNestedOneWithoutSchoolYearInput = {
    create?: XOR<InstansiCreateWithoutSchoolYearInput, InstansiUncheckedCreateWithoutSchoolYearInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutSchoolYearInput
    connect?: InstansiWhereUniqueInput
  }

  export type ClassRoomCreateNestedManyWithoutYearInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutYearInput>, Enumerable<ClassRoomUncheckedCreateWithoutYearInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutYearInput>
    createMany?: ClassRoomCreateManyYearInputEnvelope
    connect?: Enumerable<ClassRoomWhereUniqueInput>
  }

  export type StudentCreateNestedManyWithoutStartYearInput = {
    create?: XOR<Enumerable<StudentCreateWithoutStartYearInput>, Enumerable<StudentUncheckedCreateWithoutStartYearInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutStartYearInput>
    createMany?: StudentCreateManyStartYearInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type CalendarCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutRefInput>, Enumerable<CalendarUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutRefInput>
    createMany?: CalendarCreateManyRefInputEnvelope
    connect?: Enumerable<CalendarWhereUniqueInput>
  }

  export type ScheduleCreateNestedManyWithoutYearInput = {
    create?: XOR<Enumerable<ScheduleCreateWithoutYearInput>, Enumerable<ScheduleUncheckedCreateWithoutYearInput>>
    connectOrCreate?: Enumerable<ScheduleCreateOrConnectWithoutYearInput>
    createMany?: ScheduleCreateManyYearInputEnvelope
    connect?: Enumerable<ScheduleWhereUniqueInput>
  }

  export type ObjectiveCreateNestedManyWithoutYearInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutYearInput>, Enumerable<ObjectiveUncheckedCreateWithoutYearInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutYearInput>
    createMany?: ObjectiveCreateManyYearInputEnvelope
    connect?: Enumerable<ObjectiveWhereUniqueInput>
  }

  export type TrackerCreateNestedManyWithoutTpInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutTpInput>, Enumerable<TrackerUncheckedCreateWithoutTpInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutTpInput>
    createMany?: TrackerCreateManyTpInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type TDeviceCreateNestedManyWithoutYearInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutYearInput>, Enumerable<TDeviceUncheckedCreateWithoutYearInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutYearInput>
    createMany?: TDeviceCreateManyYearInputEnvelope
    connect?: Enumerable<TDeviceWhereUniqueInput>
  }

  export type ClassRoomUncheckedCreateNestedManyWithoutYearInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutYearInput>, Enumerable<ClassRoomUncheckedCreateWithoutYearInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutYearInput>
    createMany?: ClassRoomCreateManyYearInputEnvelope
    connect?: Enumerable<ClassRoomWhereUniqueInput>
  }

  export type StudentUncheckedCreateNestedManyWithoutStartYearInput = {
    create?: XOR<Enumerable<StudentCreateWithoutStartYearInput>, Enumerable<StudentUncheckedCreateWithoutStartYearInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutStartYearInput>
    createMany?: StudentCreateManyStartYearInputEnvelope
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type CalendarUncheckedCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutRefInput>, Enumerable<CalendarUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutRefInput>
    createMany?: CalendarCreateManyRefInputEnvelope
    connect?: Enumerable<CalendarWhereUniqueInput>
  }

  export type ScheduleUncheckedCreateNestedManyWithoutYearInput = {
    create?: XOR<Enumerable<ScheduleCreateWithoutYearInput>, Enumerable<ScheduleUncheckedCreateWithoutYearInput>>
    connectOrCreate?: Enumerable<ScheduleCreateOrConnectWithoutYearInput>
    createMany?: ScheduleCreateManyYearInputEnvelope
    connect?: Enumerable<ScheduleWhereUniqueInput>
  }

  export type ObjectiveUncheckedCreateNestedManyWithoutYearInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutYearInput>, Enumerable<ObjectiveUncheckedCreateWithoutYearInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutYearInput>
    createMany?: ObjectiveCreateManyYearInputEnvelope
    connect?: Enumerable<ObjectiveWhereUniqueInput>
  }

  export type TrackerUncheckedCreateNestedManyWithoutTpInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutTpInput>, Enumerable<TrackerUncheckedCreateWithoutTpInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutTpInput>
    createMany?: TrackerCreateManyTpInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type TDeviceUncheckedCreateNestedManyWithoutYearInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutYearInput>, Enumerable<TDeviceUncheckedCreateWithoutYearInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutYearInput>
    createMany?: TDeviceCreateManyYearInputEnvelope
    connect?: Enumerable<TDeviceWhereUniqueInput>
  }

  export type SchoolYearUpdatedepartmentsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type OrganizationalUpdateEnvelopeInput = {
    set?: OrganizationalCreateInput
    update?: OrganizationalUpdateInput
  }

  export type InstansiUpdateOneRequiredWithoutSchoolYearNestedInput = {
    create?: XOR<InstansiCreateWithoutSchoolYearInput, InstansiUncheckedCreateWithoutSchoolYearInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutSchoolYearInput
    upsert?: InstansiUpsertWithoutSchoolYearInput
    connect?: InstansiWhereUniqueInput
    update?: XOR<InstansiUpdateWithoutSchoolYearInput, InstansiUncheckedUpdateWithoutSchoolYearInput>
  }

  export type ClassRoomUpdateManyWithoutYearNestedInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutYearInput>, Enumerable<ClassRoomUncheckedCreateWithoutYearInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutYearInput>
    upsert?: Enumerable<ClassRoomUpsertWithWhereUniqueWithoutYearInput>
    createMany?: ClassRoomCreateManyYearInputEnvelope
    set?: Enumerable<ClassRoomWhereUniqueInput>
    disconnect?: Enumerable<ClassRoomWhereUniqueInput>
    delete?: Enumerable<ClassRoomWhereUniqueInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
    update?: Enumerable<ClassRoomUpdateWithWhereUniqueWithoutYearInput>
    updateMany?: Enumerable<ClassRoomUpdateManyWithWhereWithoutYearInput>
    deleteMany?: Enumerable<ClassRoomScalarWhereInput>
  }

  export type StudentUpdateManyWithoutStartYearNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutStartYearInput>, Enumerable<StudentUncheckedCreateWithoutStartYearInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutStartYearInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutStartYearInput>
    createMany?: StudentCreateManyStartYearInputEnvelope
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutStartYearInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutStartYearInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type CalendarUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutRefInput>, Enumerable<CalendarUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<CalendarUpsertWithWhereUniqueWithoutRefInput>
    createMany?: CalendarCreateManyRefInputEnvelope
    set?: Enumerable<CalendarWhereUniqueInput>
    disconnect?: Enumerable<CalendarWhereUniqueInput>
    delete?: Enumerable<CalendarWhereUniqueInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
    update?: Enumerable<CalendarUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<CalendarUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<CalendarScalarWhereInput>
  }

  export type ScheduleUpdateManyWithoutYearNestedInput = {
    create?: XOR<Enumerable<ScheduleCreateWithoutYearInput>, Enumerable<ScheduleUncheckedCreateWithoutYearInput>>
    connectOrCreate?: Enumerable<ScheduleCreateOrConnectWithoutYearInput>
    upsert?: Enumerable<ScheduleUpsertWithWhereUniqueWithoutYearInput>
    createMany?: ScheduleCreateManyYearInputEnvelope
    set?: Enumerable<ScheduleWhereUniqueInput>
    disconnect?: Enumerable<ScheduleWhereUniqueInput>
    delete?: Enumerable<ScheduleWhereUniqueInput>
    connect?: Enumerable<ScheduleWhereUniqueInput>
    update?: Enumerable<ScheduleUpdateWithWhereUniqueWithoutYearInput>
    updateMany?: Enumerable<ScheduleUpdateManyWithWhereWithoutYearInput>
    deleteMany?: Enumerable<ScheduleScalarWhereInput>
  }

  export type ObjectiveUpdateManyWithoutYearNestedInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutYearInput>, Enumerable<ObjectiveUncheckedCreateWithoutYearInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutYearInput>
    upsert?: Enumerable<ObjectiveUpsertWithWhereUniqueWithoutYearInput>
    createMany?: ObjectiveCreateManyYearInputEnvelope
    set?: Enumerable<ObjectiveWhereUniqueInput>
    disconnect?: Enumerable<ObjectiveWhereUniqueInput>
    delete?: Enumerable<ObjectiveWhereUniqueInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
    update?: Enumerable<ObjectiveUpdateWithWhereUniqueWithoutYearInput>
    updateMany?: Enumerable<ObjectiveUpdateManyWithWhereWithoutYearInput>
    deleteMany?: Enumerable<ObjectiveScalarWhereInput>
  }

  export type TrackerUpdateManyWithoutTpNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutTpInput>, Enumerable<TrackerUncheckedCreateWithoutTpInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutTpInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutTpInput>
    createMany?: TrackerCreateManyTpInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutTpInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutTpInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type TDeviceUpdateManyWithoutYearNestedInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutYearInput>, Enumerable<TDeviceUncheckedCreateWithoutYearInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutYearInput>
    upsert?: Enumerable<TDeviceUpsertWithWhereUniqueWithoutYearInput>
    createMany?: TDeviceCreateManyYearInputEnvelope
    set?: Enumerable<TDeviceWhereUniqueInput>
    disconnect?: Enumerable<TDeviceWhereUniqueInput>
    delete?: Enumerable<TDeviceWhereUniqueInput>
    connect?: Enumerable<TDeviceWhereUniqueInput>
    update?: Enumerable<TDeviceUpdateWithWhereUniqueWithoutYearInput>
    updateMany?: Enumerable<TDeviceUpdateManyWithWhereWithoutYearInput>
    deleteMany?: Enumerable<TDeviceScalarWhereInput>
  }

  export type ClassRoomUncheckedUpdateManyWithoutYearNestedInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutYearInput>, Enumerable<ClassRoomUncheckedCreateWithoutYearInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutYearInput>
    upsert?: Enumerable<ClassRoomUpsertWithWhereUniqueWithoutYearInput>
    createMany?: ClassRoomCreateManyYearInputEnvelope
    set?: Enumerable<ClassRoomWhereUniqueInput>
    disconnect?: Enumerable<ClassRoomWhereUniqueInput>
    delete?: Enumerable<ClassRoomWhereUniqueInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
    update?: Enumerable<ClassRoomUpdateWithWhereUniqueWithoutYearInput>
    updateMany?: Enumerable<ClassRoomUpdateManyWithWhereWithoutYearInput>
    deleteMany?: Enumerable<ClassRoomScalarWhereInput>
  }

  export type StudentUncheckedUpdateManyWithoutStartYearNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutStartYearInput>, Enumerable<StudentUncheckedCreateWithoutStartYearInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutStartYearInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutStartYearInput>
    createMany?: StudentCreateManyStartYearInputEnvelope
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutStartYearInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutStartYearInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type CalendarUncheckedUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutRefInput>, Enumerable<CalendarUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<CalendarUpsertWithWhereUniqueWithoutRefInput>
    createMany?: CalendarCreateManyRefInputEnvelope
    set?: Enumerable<CalendarWhereUniqueInput>
    disconnect?: Enumerable<CalendarWhereUniqueInput>
    delete?: Enumerable<CalendarWhereUniqueInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
    update?: Enumerable<CalendarUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<CalendarUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<CalendarScalarWhereInput>
  }

  export type ScheduleUncheckedUpdateManyWithoutYearNestedInput = {
    create?: XOR<Enumerable<ScheduleCreateWithoutYearInput>, Enumerable<ScheduleUncheckedCreateWithoutYearInput>>
    connectOrCreate?: Enumerable<ScheduleCreateOrConnectWithoutYearInput>
    upsert?: Enumerable<ScheduleUpsertWithWhereUniqueWithoutYearInput>
    createMany?: ScheduleCreateManyYearInputEnvelope
    set?: Enumerable<ScheduleWhereUniqueInput>
    disconnect?: Enumerable<ScheduleWhereUniqueInput>
    delete?: Enumerable<ScheduleWhereUniqueInput>
    connect?: Enumerable<ScheduleWhereUniqueInput>
    update?: Enumerable<ScheduleUpdateWithWhereUniqueWithoutYearInput>
    updateMany?: Enumerable<ScheduleUpdateManyWithWhereWithoutYearInput>
    deleteMany?: Enumerable<ScheduleScalarWhereInput>
  }

  export type ObjectiveUncheckedUpdateManyWithoutYearNestedInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutYearInput>, Enumerable<ObjectiveUncheckedCreateWithoutYearInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutYearInput>
    upsert?: Enumerable<ObjectiveUpsertWithWhereUniqueWithoutYearInput>
    createMany?: ObjectiveCreateManyYearInputEnvelope
    set?: Enumerable<ObjectiveWhereUniqueInput>
    disconnect?: Enumerable<ObjectiveWhereUniqueInput>
    delete?: Enumerable<ObjectiveWhereUniqueInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
    update?: Enumerable<ObjectiveUpdateWithWhereUniqueWithoutYearInput>
    updateMany?: Enumerable<ObjectiveUpdateManyWithWhereWithoutYearInput>
    deleteMany?: Enumerable<ObjectiveScalarWhereInput>
  }

  export type TrackerUncheckedUpdateManyWithoutTpNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutTpInput>, Enumerable<TrackerUncheckedCreateWithoutTpInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutTpInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutTpInput>
    createMany?: TrackerCreateManyTpInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutTpInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutTpInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type TDeviceUncheckedUpdateManyWithoutYearNestedInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutYearInput>, Enumerable<TDeviceUncheckedCreateWithoutYearInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutYearInput>
    upsert?: Enumerable<TDeviceUpsertWithWhereUniqueWithoutYearInput>
    createMany?: TDeviceCreateManyYearInputEnvelope
    set?: Enumerable<TDeviceWhereUniqueInput>
    disconnect?: Enumerable<TDeviceWhereUniqueInput>
    delete?: Enumerable<TDeviceWhereUniqueInput>
    connect?: Enumerable<TDeviceWhereUniqueInput>
    update?: Enumerable<TDeviceUpdateWithWhereUniqueWithoutYearInput>
    updateMany?: Enumerable<TDeviceUpdateManyWithWhereWithoutYearInput>
    deleteMany?: Enumerable<TDeviceScalarWhereInput>
  }

  export type PersonalCreateNestedOneWithoutTeacherInput = {
    create?: XOR<PersonalCreateWithoutTeacherInput, PersonalUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutTeacherInput
    connect?: PersonalWhereUniqueInput
  }

  export type ClassRoomCreateNestedManyWithoutWaliInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutWaliInput>, Enumerable<ClassRoomUncheckedCreateWithoutWaliInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutWaliInput>
    createMany?: ClassRoomCreateManyWaliInputEnvelope
    connect?: Enumerable<ClassRoomWhereUniqueInput>
  }

  export type InstansiCreateNestedOneWithoutTeacherInput = {
    create?: XOR<InstansiCreateWithoutTeacherInput, InstansiUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutTeacherInput
    connect?: InstansiWhereUniqueInput
  }

  export type CalendarCreateNestedManyWithoutTeacherInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutTeacherInput>, Enumerable<CalendarUncheckedCreateWithoutTeacherInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutTeacherInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
  }

  export type TrackerCreateNestedManyWithoutTeacherInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutTeacherInput>, Enumerable<TrackerUncheckedCreateWithoutTeacherInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutTeacherInput>
    createMany?: TrackerCreateManyTeacherInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type TeachingCreateNestedManyWithoutTeacherInput = {
    create?: XOR<Enumerable<TeachingCreateWithoutTeacherInput>, Enumerable<TeachingUncheckedCreateWithoutTeacherInput>>
    connectOrCreate?: Enumerable<TeachingCreateOrConnectWithoutTeacherInput>
    createMany?: TeachingCreateManyTeacherInputEnvelope
    connect?: Enumerable<TeachingWhereUniqueInput>
  }

  export type TeacherCreateeventIdsInput = {
    set: Enumerable<string>
  }

  export type ClassRoomUncheckedCreateNestedManyWithoutWaliInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutWaliInput>, Enumerable<ClassRoomUncheckedCreateWithoutWaliInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutWaliInput>
    createMany?: ClassRoomCreateManyWaliInputEnvelope
    connect?: Enumerable<ClassRoomWhereUniqueInput>
  }

  export type CalendarUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutTeacherInput>, Enumerable<CalendarUncheckedCreateWithoutTeacherInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutTeacherInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
  }

  export type TrackerUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutTeacherInput>, Enumerable<TrackerUncheckedCreateWithoutTeacherInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutTeacherInput>
    createMany?: TrackerCreateManyTeacherInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type TeachingUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<Enumerable<TeachingCreateWithoutTeacherInput>, Enumerable<TeachingUncheckedCreateWithoutTeacherInput>>
    connectOrCreate?: Enumerable<TeachingCreateOrConnectWithoutTeacherInput>
    createMany?: TeachingCreateManyTeacherInputEnvelope
    connect?: Enumerable<TeachingWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type PersonalUpdateOneRequiredWithoutTeacherNestedInput = {
    create?: XOR<PersonalCreateWithoutTeacherInput, PersonalUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutTeacherInput
    upsert?: PersonalUpsertWithoutTeacherInput
    connect?: PersonalWhereUniqueInput
    update?: XOR<PersonalUpdateWithoutTeacherInput, PersonalUncheckedUpdateWithoutTeacherInput>
  }

  export type ClassRoomUpdateManyWithoutWaliNestedInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutWaliInput>, Enumerable<ClassRoomUncheckedCreateWithoutWaliInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutWaliInput>
    upsert?: Enumerable<ClassRoomUpsertWithWhereUniqueWithoutWaliInput>
    createMany?: ClassRoomCreateManyWaliInputEnvelope
    set?: Enumerable<ClassRoomWhereUniqueInput>
    disconnect?: Enumerable<ClassRoomWhereUniqueInput>
    delete?: Enumerable<ClassRoomWhereUniqueInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
    update?: Enumerable<ClassRoomUpdateWithWhereUniqueWithoutWaliInput>
    updateMany?: Enumerable<ClassRoomUpdateManyWithWhereWithoutWaliInput>
    deleteMany?: Enumerable<ClassRoomScalarWhereInput>
  }

  export type InstansiUpdateOneRequiredWithoutTeacherNestedInput = {
    create?: XOR<InstansiCreateWithoutTeacherInput, InstansiUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutTeacherInput
    upsert?: InstansiUpsertWithoutTeacherInput
    connect?: InstansiWhereUniqueInput
    update?: XOR<InstansiUpdateWithoutTeacherInput, InstansiUncheckedUpdateWithoutTeacherInput>
  }

  export type CalendarUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutTeacherInput>, Enumerable<CalendarUncheckedCreateWithoutTeacherInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutTeacherInput>
    upsert?: Enumerable<CalendarUpsertWithWhereUniqueWithoutTeacherInput>
    set?: Enumerable<CalendarWhereUniqueInput>
    disconnect?: Enumerable<CalendarWhereUniqueInput>
    delete?: Enumerable<CalendarWhereUniqueInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
    update?: Enumerable<CalendarUpdateWithWhereUniqueWithoutTeacherInput>
    updateMany?: Enumerable<CalendarUpdateManyWithWhereWithoutTeacherInput>
    deleteMany?: Enumerable<CalendarScalarWhereInput>
  }

  export type TrackerUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutTeacherInput>, Enumerable<TrackerUncheckedCreateWithoutTeacherInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutTeacherInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutTeacherInput>
    createMany?: TrackerCreateManyTeacherInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutTeacherInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutTeacherInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type TeachingUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<Enumerable<TeachingCreateWithoutTeacherInput>, Enumerable<TeachingUncheckedCreateWithoutTeacherInput>>
    connectOrCreate?: Enumerable<TeachingCreateOrConnectWithoutTeacherInput>
    upsert?: Enumerable<TeachingUpsertWithWhereUniqueWithoutTeacherInput>
    createMany?: TeachingCreateManyTeacherInputEnvelope
    set?: Enumerable<TeachingWhereUniqueInput>
    disconnect?: Enumerable<TeachingWhereUniqueInput>
    delete?: Enumerable<TeachingWhereUniqueInput>
    connect?: Enumerable<TeachingWhereUniqueInput>
    update?: Enumerable<TeachingUpdateWithWhereUniqueWithoutTeacherInput>
    updateMany?: Enumerable<TeachingUpdateManyWithWhereWithoutTeacherInput>
    deleteMany?: Enumerable<TeachingScalarWhereInput>
  }

  export type TeacherUpdateeventIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ClassRoomUncheckedUpdateManyWithoutWaliNestedInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutWaliInput>, Enumerable<ClassRoomUncheckedCreateWithoutWaliInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutWaliInput>
    upsert?: Enumerable<ClassRoomUpsertWithWhereUniqueWithoutWaliInput>
    createMany?: ClassRoomCreateManyWaliInputEnvelope
    set?: Enumerable<ClassRoomWhereUniqueInput>
    disconnect?: Enumerable<ClassRoomWhereUniqueInput>
    delete?: Enumerable<ClassRoomWhereUniqueInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
    update?: Enumerable<ClassRoomUpdateWithWhereUniqueWithoutWaliInput>
    updateMany?: Enumerable<ClassRoomUpdateManyWithWhereWithoutWaliInput>
    deleteMany?: Enumerable<ClassRoomScalarWhereInput>
  }

  export type CalendarUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutTeacherInput>, Enumerable<CalendarUncheckedCreateWithoutTeacherInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutTeacherInput>
    upsert?: Enumerable<CalendarUpsertWithWhereUniqueWithoutTeacherInput>
    set?: Enumerable<CalendarWhereUniqueInput>
    disconnect?: Enumerable<CalendarWhereUniqueInput>
    delete?: Enumerable<CalendarWhereUniqueInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
    update?: Enumerable<CalendarUpdateWithWhereUniqueWithoutTeacherInput>
    updateMany?: Enumerable<CalendarUpdateManyWithWhereWithoutTeacherInput>
    deleteMany?: Enumerable<CalendarScalarWhereInput>
  }

  export type TrackerUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutTeacherInput>, Enumerable<TrackerUncheckedCreateWithoutTeacherInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutTeacherInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutTeacherInput>
    createMany?: TrackerCreateManyTeacherInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutTeacherInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutTeacherInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type TeachingUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<Enumerable<TeachingCreateWithoutTeacherInput>, Enumerable<TeachingUncheckedCreateWithoutTeacherInput>>
    connectOrCreate?: Enumerable<TeachingCreateOrConnectWithoutTeacherInput>
    upsert?: Enumerable<TeachingUpsertWithWhereUniqueWithoutTeacherInput>
    createMany?: TeachingCreateManyTeacherInputEnvelope
    set?: Enumerable<TeachingWhereUniqueInput>
    disconnect?: Enumerable<TeachingWhereUniqueInput>
    delete?: Enumerable<TeachingWhereUniqueInput>
    connect?: Enumerable<TeachingWhereUniqueInput>
    update?: Enumerable<TeachingUpdateWithWhereUniqueWithoutTeacherInput>
    updateMany?: Enumerable<TeachingUpdateManyWithWhereWithoutTeacherInput>
    deleteMany?: Enumerable<TeachingScalarWhereInput>
  }

  export type RoomPropertyNullableCreateEnvelopeInput = {
    set?: RoomPropertyCreateInput | null
  }

  export type RoomPropertyCreateInput = {
    pkl?: boolean | null
  }

  export type SchoolYearCreateNestedOneWithoutClassRoomInput = {
    create?: XOR<SchoolYearCreateWithoutClassRoomInput, SchoolYearUncheckedCreateWithoutClassRoomInput>
    connectOrCreate?: SchoolYearCreateOrConnectWithoutClassRoomInput
    connect?: SchoolYearWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutClassRoomInput = {
    create?: XOR<TeacherCreateWithoutClassRoomInput, TeacherUncheckedCreateWithoutClassRoomInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutClassRoomInput
    connect?: TeacherWhereUniqueInput
  }

  export type KonsentrasiKeahlianCreateNestedOneWithoutClassRoomInput = {
    create?: XOR<KonsentrasiKeahlianCreateWithoutClassRoomInput, KonsentrasiKeahlianUncheckedCreateWithoutClassRoomInput>
    connectOrCreate?: KonsentrasiKeahlianCreateOrConnectWithoutClassRoomInput
    connect?: KonsentrasiKeahlianWhereUniqueInput
  }

  export type StudentCreateNestedManyWithoutClassRoomInput = {
    create?: XOR<Enumerable<StudentCreateWithoutClassRoomInput>, Enumerable<StudentUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutClassRoomInput>
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type CalendarCreateNestedManyWithoutClassRoomInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutClassRoomInput>, Enumerable<CalendarUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutClassRoomInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
  }

  export type TrackerCreateNestedManyWithoutKelasInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutKelasInput>, Enumerable<TrackerUncheckedCreateWithoutKelasInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutKelasInput>
    createMany?: TrackerCreateManyKelasInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type TeachingCreateNestedManyWithoutClassRoomInput = {
    create?: XOR<Enumerable<TeachingCreateWithoutClassRoomInput>, Enumerable<TeachingUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<TeachingCreateOrConnectWithoutClassRoomInput>
    connect?: Enumerable<TeachingWhereUniqueInput>
  }

  export type TDeviceCreateNestedManyWithoutClassRoomInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutClassRoomInput>, Enumerable<TDeviceUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutClassRoomInput>
    connect?: Enumerable<TDeviceWhereUniqueInput>
  }

  export type ClassRoomCreatestudentIdsInput = {
    set: Enumerable<string>
  }

  export type ClassRoomCreateeventIdsInput = {
    set: Enumerable<string>
  }

  export type ClassRoomCreateteachingIdsInput = {
    set: Enumerable<string>
  }

  export type ClassRoomCreatetDeviceIdsInput = {
    set: Enumerable<string>
  }

  export type StudentUncheckedCreateNestedManyWithoutClassRoomInput = {
    create?: XOR<Enumerable<StudentCreateWithoutClassRoomInput>, Enumerable<StudentUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutClassRoomInput>
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type CalendarUncheckedCreateNestedManyWithoutClassRoomInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutClassRoomInput>, Enumerable<CalendarUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutClassRoomInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
  }

  export type TrackerUncheckedCreateNestedManyWithoutKelasInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutKelasInput>, Enumerable<TrackerUncheckedCreateWithoutKelasInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutKelasInput>
    createMany?: TrackerCreateManyKelasInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type TeachingUncheckedCreateNestedManyWithoutClassRoomInput = {
    create?: XOR<Enumerable<TeachingCreateWithoutClassRoomInput>, Enumerable<TeachingUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<TeachingCreateOrConnectWithoutClassRoomInput>
    connect?: Enumerable<TeachingWhereUniqueInput>
  }

  export type TDeviceUncheckedCreateNestedManyWithoutClassRoomInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutClassRoomInput>, Enumerable<TDeviceUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutClassRoomInput>
    connect?: Enumerable<TDeviceWhereUniqueInput>
  }

  export type RoomPropertyNullableUpdateEnvelopeInput = {
    set?: RoomPropertyCreateInput | null
    upsert?: RoomPropertyUpsertInput
    unset?: boolean
  }

  export type SchoolYearUpdateOneRequiredWithoutClassRoomNestedInput = {
    create?: XOR<SchoolYearCreateWithoutClassRoomInput, SchoolYearUncheckedCreateWithoutClassRoomInput>
    connectOrCreate?: SchoolYearCreateOrConnectWithoutClassRoomInput
    upsert?: SchoolYearUpsertWithoutClassRoomInput
    connect?: SchoolYearWhereUniqueInput
    update?: XOR<SchoolYearUpdateWithoutClassRoomInput, SchoolYearUncheckedUpdateWithoutClassRoomInput>
  }

  export type TeacherUpdateOneRequiredWithoutClassRoomNestedInput = {
    create?: XOR<TeacherCreateWithoutClassRoomInput, TeacherUncheckedCreateWithoutClassRoomInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutClassRoomInput
    upsert?: TeacherUpsertWithoutClassRoomInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<TeacherUpdateWithoutClassRoomInput, TeacherUncheckedUpdateWithoutClassRoomInput>
  }

  export type KonsentrasiKeahlianUpdateOneWithoutClassRoomNestedInput = {
    create?: XOR<KonsentrasiKeahlianCreateWithoutClassRoomInput, KonsentrasiKeahlianUncheckedCreateWithoutClassRoomInput>
    connectOrCreate?: KonsentrasiKeahlianCreateOrConnectWithoutClassRoomInput
    upsert?: KonsentrasiKeahlianUpsertWithoutClassRoomInput
    disconnect?: boolean
    delete?: boolean
    connect?: KonsentrasiKeahlianWhereUniqueInput
    update?: XOR<KonsentrasiKeahlianUpdateWithoutClassRoomInput, KonsentrasiKeahlianUncheckedUpdateWithoutClassRoomInput>
  }

  export type StudentUpdateManyWithoutClassRoomNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutClassRoomInput>, Enumerable<StudentUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutClassRoomInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutClassRoomInput>
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutClassRoomInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutClassRoomInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type CalendarUpdateManyWithoutClassRoomNestedInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutClassRoomInput>, Enumerable<CalendarUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutClassRoomInput>
    upsert?: Enumerable<CalendarUpsertWithWhereUniqueWithoutClassRoomInput>
    set?: Enumerable<CalendarWhereUniqueInput>
    disconnect?: Enumerable<CalendarWhereUniqueInput>
    delete?: Enumerable<CalendarWhereUniqueInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
    update?: Enumerable<CalendarUpdateWithWhereUniqueWithoutClassRoomInput>
    updateMany?: Enumerable<CalendarUpdateManyWithWhereWithoutClassRoomInput>
    deleteMany?: Enumerable<CalendarScalarWhereInput>
  }

  export type TrackerUpdateManyWithoutKelasNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutKelasInput>, Enumerable<TrackerUncheckedCreateWithoutKelasInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutKelasInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutKelasInput>
    createMany?: TrackerCreateManyKelasInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutKelasInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutKelasInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type TeachingUpdateManyWithoutClassRoomNestedInput = {
    create?: XOR<Enumerable<TeachingCreateWithoutClassRoomInput>, Enumerable<TeachingUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<TeachingCreateOrConnectWithoutClassRoomInput>
    upsert?: Enumerable<TeachingUpsertWithWhereUniqueWithoutClassRoomInput>
    set?: Enumerable<TeachingWhereUniqueInput>
    disconnect?: Enumerable<TeachingWhereUniqueInput>
    delete?: Enumerable<TeachingWhereUniqueInput>
    connect?: Enumerable<TeachingWhereUniqueInput>
    update?: Enumerable<TeachingUpdateWithWhereUniqueWithoutClassRoomInput>
    updateMany?: Enumerable<TeachingUpdateManyWithWhereWithoutClassRoomInput>
    deleteMany?: Enumerable<TeachingScalarWhereInput>
  }

  export type TDeviceUpdateManyWithoutClassRoomNestedInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutClassRoomInput>, Enumerable<TDeviceUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutClassRoomInput>
    upsert?: Enumerable<TDeviceUpsertWithWhereUniqueWithoutClassRoomInput>
    set?: Enumerable<TDeviceWhereUniqueInput>
    disconnect?: Enumerable<TDeviceWhereUniqueInput>
    delete?: Enumerable<TDeviceWhereUniqueInput>
    connect?: Enumerable<TDeviceWhereUniqueInput>
    update?: Enumerable<TDeviceUpdateWithWhereUniqueWithoutClassRoomInput>
    updateMany?: Enumerable<TDeviceUpdateManyWithWhereWithoutClassRoomInput>
    deleteMany?: Enumerable<TDeviceScalarWhereInput>
  }

  export type ClassRoomUpdatestudentIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ClassRoomUpdateeventIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ClassRoomUpdateteachingIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ClassRoomUpdatetDeviceIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type StudentUncheckedUpdateManyWithoutClassRoomNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutClassRoomInput>, Enumerable<StudentUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutClassRoomInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutClassRoomInput>
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutClassRoomInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutClassRoomInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type CalendarUncheckedUpdateManyWithoutClassRoomNestedInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutClassRoomInput>, Enumerable<CalendarUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutClassRoomInput>
    upsert?: Enumerable<CalendarUpsertWithWhereUniqueWithoutClassRoomInput>
    set?: Enumerable<CalendarWhereUniqueInput>
    disconnect?: Enumerable<CalendarWhereUniqueInput>
    delete?: Enumerable<CalendarWhereUniqueInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
    update?: Enumerable<CalendarUpdateWithWhereUniqueWithoutClassRoomInput>
    updateMany?: Enumerable<CalendarUpdateManyWithWhereWithoutClassRoomInput>
    deleteMany?: Enumerable<CalendarScalarWhereInput>
  }

  export type TrackerUncheckedUpdateManyWithoutKelasNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutKelasInput>, Enumerable<TrackerUncheckedCreateWithoutKelasInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutKelasInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutKelasInput>
    createMany?: TrackerCreateManyKelasInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutKelasInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutKelasInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type TeachingUncheckedUpdateManyWithoutClassRoomNestedInput = {
    create?: XOR<Enumerable<TeachingCreateWithoutClassRoomInput>, Enumerable<TeachingUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<TeachingCreateOrConnectWithoutClassRoomInput>
    upsert?: Enumerable<TeachingUpsertWithWhereUniqueWithoutClassRoomInput>
    set?: Enumerable<TeachingWhereUniqueInput>
    disconnect?: Enumerable<TeachingWhereUniqueInput>
    delete?: Enumerable<TeachingWhereUniqueInput>
    connect?: Enumerable<TeachingWhereUniqueInput>
    update?: Enumerable<TeachingUpdateWithWhereUniqueWithoutClassRoomInput>
    updateMany?: Enumerable<TeachingUpdateManyWithWhereWithoutClassRoomInput>
    deleteMany?: Enumerable<TeachingScalarWhereInput>
  }

  export type TDeviceUncheckedUpdateManyWithoutClassRoomNestedInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutClassRoomInput>, Enumerable<TDeviceUncheckedCreateWithoutClassRoomInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutClassRoomInput>
    upsert?: Enumerable<TDeviceUpsertWithWhereUniqueWithoutClassRoomInput>
    set?: Enumerable<TDeviceWhereUniqueInput>
    disconnect?: Enumerable<TDeviceWhereUniqueInput>
    delete?: Enumerable<TDeviceWhereUniqueInput>
    connect?: Enumerable<TDeviceWhereUniqueInput>
    update?: Enumerable<TDeviceUpdateWithWhereUniqueWithoutClassRoomInput>
    updateMany?: Enumerable<TDeviceUpdateManyWithWhereWithoutClassRoomInput>
    deleteMany?: Enumerable<TDeviceScalarWhereInput>
  }

  export type PersonalCreateNestedOneWithoutStudentInput = {
    create?: XOR<PersonalCreateWithoutStudentInput, PersonalUncheckedCreateWithoutStudentInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutStudentInput
    connect?: PersonalWhereUniqueInput
  }

  export type KonsentrasiKeahlianCreateNestedOneWithoutStudentInput = {
    create?: XOR<KonsentrasiKeahlianCreateWithoutStudentInput, KonsentrasiKeahlianUncheckedCreateWithoutStudentInput>
    connectOrCreate?: KonsentrasiKeahlianCreateOrConnectWithoutStudentInput
    connect?: KonsentrasiKeahlianWhereUniqueInput
  }

  export type ClassRoomCreateNestedManyWithoutStudentsInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutStudentsInput>, Enumerable<ClassRoomUncheckedCreateWithoutStudentsInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutStudentsInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
  }

  export type SchoolYearCreateNestedOneWithoutStudentsInput = {
    create?: XOR<SchoolYearCreateWithoutStudentsInput, SchoolYearUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: SchoolYearCreateOrConnectWithoutStudentsInput
    connect?: SchoolYearWhereUniqueInput
  }

  export type InstansiCreateNestedOneWithoutStudentInput = {
    create?: XOR<InstansiCreateWithoutStudentInput, InstansiUncheckedCreateWithoutStudentInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutStudentInput
    connect?: InstansiWhereUniqueInput
  }

  export type CalendarCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutStudentInput>, Enumerable<CalendarUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutStudentInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
  }

  export type TrackerCreateNestedManyWithoutMuridInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutMuridInput>, Enumerable<TrackerUncheckedCreateWithoutMuridInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutMuridInput>
    createMany?: TrackerCreateManyMuridInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type StudentCreateclassRoomIdsInput = {
    set: Enumerable<string>
  }

  export type StudentCreateeventIdsInput = {
    set: Enumerable<string>
  }

  export type ClassRoomUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutStudentsInput>, Enumerable<ClassRoomUncheckedCreateWithoutStudentsInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutStudentsInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
  }

  export type CalendarUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutStudentInput>, Enumerable<CalendarUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutStudentInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
  }

  export type TrackerUncheckedCreateNestedManyWithoutMuridInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutMuridInput>, Enumerable<TrackerUncheckedCreateWithoutMuridInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutMuridInput>
    createMany?: TrackerCreateManyMuridInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type PersonalUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<PersonalCreateWithoutStudentInput, PersonalUncheckedCreateWithoutStudentInput>
    connectOrCreate?: PersonalCreateOrConnectWithoutStudentInput
    upsert?: PersonalUpsertWithoutStudentInput
    connect?: PersonalWhereUniqueInput
    update?: XOR<PersonalUpdateWithoutStudentInput, PersonalUncheckedUpdateWithoutStudentInput>
  }

  export type KonsentrasiKeahlianUpdateOneWithoutStudentNestedInput = {
    create?: XOR<KonsentrasiKeahlianCreateWithoutStudentInput, KonsentrasiKeahlianUncheckedCreateWithoutStudentInput>
    connectOrCreate?: KonsentrasiKeahlianCreateOrConnectWithoutStudentInput
    upsert?: KonsentrasiKeahlianUpsertWithoutStudentInput
    disconnect?: boolean
    delete?: boolean
    connect?: KonsentrasiKeahlianWhereUniqueInput
    update?: XOR<KonsentrasiKeahlianUpdateWithoutStudentInput, KonsentrasiKeahlianUncheckedUpdateWithoutStudentInput>
  }

  export type ClassRoomUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutStudentsInput>, Enumerable<ClassRoomUncheckedCreateWithoutStudentsInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutStudentsInput>
    upsert?: Enumerable<ClassRoomUpsertWithWhereUniqueWithoutStudentsInput>
    set?: Enumerable<ClassRoomWhereUniqueInput>
    disconnect?: Enumerable<ClassRoomWhereUniqueInput>
    delete?: Enumerable<ClassRoomWhereUniqueInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
    update?: Enumerable<ClassRoomUpdateWithWhereUniqueWithoutStudentsInput>
    updateMany?: Enumerable<ClassRoomUpdateManyWithWhereWithoutStudentsInput>
    deleteMany?: Enumerable<ClassRoomScalarWhereInput>
  }

  export type SchoolYearUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<SchoolYearCreateWithoutStudentsInput, SchoolYearUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: SchoolYearCreateOrConnectWithoutStudentsInput
    upsert?: SchoolYearUpsertWithoutStudentsInput
    connect?: SchoolYearWhereUniqueInput
    update?: XOR<SchoolYearUpdateWithoutStudentsInput, SchoolYearUncheckedUpdateWithoutStudentsInput>
  }

  export type InstansiUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<InstansiCreateWithoutStudentInput, InstansiUncheckedCreateWithoutStudentInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutStudentInput
    upsert?: InstansiUpsertWithoutStudentInput
    connect?: InstansiWhereUniqueInput
    update?: XOR<InstansiUpdateWithoutStudentInput, InstansiUncheckedUpdateWithoutStudentInput>
  }

  export type CalendarUpdateManyWithoutStudentNestedInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutStudentInput>, Enumerable<CalendarUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<CalendarUpsertWithWhereUniqueWithoutStudentInput>
    set?: Enumerable<CalendarWhereUniqueInput>
    disconnect?: Enumerable<CalendarWhereUniqueInput>
    delete?: Enumerable<CalendarWhereUniqueInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
    update?: Enumerable<CalendarUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<CalendarUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<CalendarScalarWhereInput>
  }

  export type TrackerUpdateManyWithoutMuridNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutMuridInput>, Enumerable<TrackerUncheckedCreateWithoutMuridInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutMuridInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutMuridInput>
    createMany?: TrackerCreateManyMuridInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutMuridInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutMuridInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type StudentUpdateclassRoomIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type StudentUpdateeventIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ClassRoomUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutStudentsInput>, Enumerable<ClassRoomUncheckedCreateWithoutStudentsInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutStudentsInput>
    upsert?: Enumerable<ClassRoomUpsertWithWhereUniqueWithoutStudentsInput>
    set?: Enumerable<ClassRoomWhereUniqueInput>
    disconnect?: Enumerable<ClassRoomWhereUniqueInput>
    delete?: Enumerable<ClassRoomWhereUniqueInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
    update?: Enumerable<ClassRoomUpdateWithWhereUniqueWithoutStudentsInput>
    updateMany?: Enumerable<ClassRoomUpdateManyWithWhereWithoutStudentsInput>
    deleteMany?: Enumerable<ClassRoomScalarWhereInput>
  }

  export type CalendarUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<Enumerable<CalendarCreateWithoutStudentInput>, Enumerable<CalendarUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<CalendarCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<CalendarUpsertWithWhereUniqueWithoutStudentInput>
    set?: Enumerable<CalendarWhereUniqueInput>
    disconnect?: Enumerable<CalendarWhereUniqueInput>
    delete?: Enumerable<CalendarWhereUniqueInput>
    connect?: Enumerable<CalendarWhereUniqueInput>
    update?: Enumerable<CalendarUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<CalendarUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<CalendarScalarWhereInput>
  }

  export type TrackerUncheckedUpdateManyWithoutMuridNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutMuridInput>, Enumerable<TrackerUncheckedCreateWithoutMuridInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutMuridInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutMuridInput>
    createMany?: TrackerCreateManyMuridInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutMuridInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutMuridInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type SchoolYearCreateNestedOneWithoutScheduleInput = {
    create?: XOR<SchoolYearCreateWithoutScheduleInput, SchoolYearUncheckedCreateWithoutScheduleInput>
    connectOrCreate?: SchoolYearCreateOrConnectWithoutScheduleInput
    connect?: SchoolYearWhereUniqueInput
  }

  export type MataPelajaranCreateNestedOneWithoutScheduleInput = {
    create?: XOR<MataPelajaranCreateWithoutScheduleInput, MataPelajaranUncheckedCreateWithoutScheduleInput>
    connectOrCreate?: MataPelajaranCreateOrConnectWithoutScheduleInput
    connect?: MataPelajaranWhereUniqueInput
  }

  export type TrackerCreateNestedManyWithoutJadwalInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutJadwalInput>, Enumerable<TrackerUncheckedCreateWithoutJadwalInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutJadwalInput>
    createMany?: TrackerCreateManyJadwalInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type TeachingCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<TeachingCreateWithoutRefInput>, Enumerable<TeachingUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<TeachingCreateOrConnectWithoutRefInput>
    createMany?: TeachingCreateManyRefInputEnvelope
    connect?: Enumerable<TeachingWhereUniqueInput>
  }

  export type TrackerUncheckedCreateNestedManyWithoutJadwalInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutJadwalInput>, Enumerable<TrackerUncheckedCreateWithoutJadwalInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutJadwalInput>
    createMany?: TrackerCreateManyJadwalInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type TeachingUncheckedCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<TeachingCreateWithoutRefInput>, Enumerable<TeachingUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<TeachingCreateOrConnectWithoutRefInput>
    createMany?: TeachingCreateManyRefInputEnvelope
    connect?: Enumerable<TeachingWhereUniqueInput>
  }

  export type SchoolYearUpdateOneRequiredWithoutScheduleNestedInput = {
    create?: XOR<SchoolYearCreateWithoutScheduleInput, SchoolYearUncheckedCreateWithoutScheduleInput>
    connectOrCreate?: SchoolYearCreateOrConnectWithoutScheduleInput
    upsert?: SchoolYearUpsertWithoutScheduleInput
    connect?: SchoolYearWhereUniqueInput
    update?: XOR<SchoolYearUpdateWithoutScheduleInput, SchoolYearUncheckedUpdateWithoutScheduleInput>
  }

  export type MataPelajaranUpdateOneRequiredWithoutScheduleNestedInput = {
    create?: XOR<MataPelajaranCreateWithoutScheduleInput, MataPelajaranUncheckedCreateWithoutScheduleInput>
    connectOrCreate?: MataPelajaranCreateOrConnectWithoutScheduleInput
    upsert?: MataPelajaranUpsertWithoutScheduleInput
    connect?: MataPelajaranWhereUniqueInput
    update?: XOR<MataPelajaranUpdateWithoutScheduleInput, MataPelajaranUncheckedUpdateWithoutScheduleInput>
  }

  export type TrackerUpdateManyWithoutJadwalNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutJadwalInput>, Enumerable<TrackerUncheckedCreateWithoutJadwalInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutJadwalInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutJadwalInput>
    createMany?: TrackerCreateManyJadwalInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutJadwalInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutJadwalInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type TeachingUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<TeachingCreateWithoutRefInput>, Enumerable<TeachingUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<TeachingCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<TeachingUpsertWithWhereUniqueWithoutRefInput>
    createMany?: TeachingCreateManyRefInputEnvelope
    set?: Enumerable<TeachingWhereUniqueInput>
    disconnect?: Enumerable<TeachingWhereUniqueInput>
    delete?: Enumerable<TeachingWhereUniqueInput>
    connect?: Enumerable<TeachingWhereUniqueInput>
    update?: Enumerable<TeachingUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<TeachingUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<TeachingScalarWhereInput>
  }

  export type TrackerUncheckedUpdateManyWithoutJadwalNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutJadwalInput>, Enumerable<TrackerUncheckedCreateWithoutJadwalInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutJadwalInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutJadwalInput>
    createMany?: TrackerCreateManyJadwalInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutJadwalInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutJadwalInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type TeachingUncheckedUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<TeachingCreateWithoutRefInput>, Enumerable<TeachingUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<TeachingCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<TeachingUpsertWithWhereUniqueWithoutRefInput>
    createMany?: TeachingCreateManyRefInputEnvelope
    set?: Enumerable<TeachingWhereUniqueInput>
    disconnect?: Enumerable<TeachingWhereUniqueInput>
    delete?: Enumerable<TeachingWhereUniqueInput>
    connect?: Enumerable<TeachingWhereUniqueInput>
    update?: Enumerable<TeachingUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<TeachingUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<TeachingScalarWhereInput>
  }

  export type ScheduleCreateNestedOneWithoutTeachingInput = {
    create?: XOR<ScheduleCreateWithoutTeachingInput, ScheduleUncheckedCreateWithoutTeachingInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutTeachingInput
    connect?: ScheduleWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutTeachingInput = {
    create?: XOR<TeacherCreateWithoutTeachingInput, TeacherUncheckedCreateWithoutTeachingInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTeachingInput
    connect?: TeacherWhereUniqueInput
  }

  export type ClassRoomCreateNestedManyWithoutTeachingInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutTeachingInput>, Enumerable<ClassRoomUncheckedCreateWithoutTeachingInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutTeachingInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
  }

  export type ElementCreateNestedManyWithoutScheduleClassInput = {
    create?: XOR<Enumerable<ElementCreateWithoutScheduleClassInput>, Enumerable<ElementUncheckedCreateWithoutScheduleClassInput>>
    connectOrCreate?: Enumerable<ElementCreateOrConnectWithoutScheduleClassInput>
    connect?: Enumerable<ElementWhereUniqueInput>
  }

  export type TrackerCreateNestedManyWithoutMengajarInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutMengajarInput>, Enumerable<TrackerUncheckedCreateWithoutMengajarInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutMengajarInput>
    createMany?: TrackerCreateManyMengajarInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type TDeviceCreateNestedManyWithoutTeachingInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutTeachingInput>, Enumerable<TDeviceUncheckedCreateWithoutTeachingInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutTeachingInput>
    createMany?: TDeviceCreateManyTeachingInputEnvelope
    connect?: Enumerable<TDeviceWhereUniqueInput>
  }

  export type TeachingCreateclassRoomIdsInput = {
    set: Enumerable<string>
  }

  export type TeachingCreateelemenIdsInput = {
    set: Enumerable<string>
  }

  export type ClassRoomUncheckedCreateNestedManyWithoutTeachingInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutTeachingInput>, Enumerable<ClassRoomUncheckedCreateWithoutTeachingInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutTeachingInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
  }

  export type ElementUncheckedCreateNestedManyWithoutScheduleClassInput = {
    create?: XOR<Enumerable<ElementCreateWithoutScheduleClassInput>, Enumerable<ElementUncheckedCreateWithoutScheduleClassInput>>
    connectOrCreate?: Enumerable<ElementCreateOrConnectWithoutScheduleClassInput>
    connect?: Enumerable<ElementWhereUniqueInput>
  }

  export type TrackerUncheckedCreateNestedManyWithoutMengajarInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutMengajarInput>, Enumerable<TrackerUncheckedCreateWithoutMengajarInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutMengajarInput>
    createMany?: TrackerCreateManyMengajarInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type TDeviceUncheckedCreateNestedManyWithoutTeachingInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutTeachingInput>, Enumerable<TDeviceUncheckedCreateWithoutTeachingInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutTeachingInput>
    createMany?: TDeviceCreateManyTeachingInputEnvelope
    connect?: Enumerable<TDeviceWhereUniqueInput>
  }

  export type EnumSemesterFieldUpdateOperationsInput = {
    set?: Semester
  }

  export type ScheduleUpdateOneRequiredWithoutTeachingNestedInput = {
    create?: XOR<ScheduleCreateWithoutTeachingInput, ScheduleUncheckedCreateWithoutTeachingInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutTeachingInput
    upsert?: ScheduleUpsertWithoutTeachingInput
    connect?: ScheduleWhereUniqueInput
    update?: XOR<ScheduleUpdateWithoutTeachingInput, ScheduleUncheckedUpdateWithoutTeachingInput>
  }

  export type TeacherUpdateOneRequiredWithoutTeachingNestedInput = {
    create?: XOR<TeacherCreateWithoutTeachingInput, TeacherUncheckedCreateWithoutTeachingInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTeachingInput
    upsert?: TeacherUpsertWithoutTeachingInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<TeacherUpdateWithoutTeachingInput, TeacherUncheckedUpdateWithoutTeachingInput>
  }

  export type ClassRoomUpdateManyWithoutTeachingNestedInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutTeachingInput>, Enumerable<ClassRoomUncheckedCreateWithoutTeachingInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutTeachingInput>
    upsert?: Enumerable<ClassRoomUpsertWithWhereUniqueWithoutTeachingInput>
    set?: Enumerable<ClassRoomWhereUniqueInput>
    disconnect?: Enumerable<ClassRoomWhereUniqueInput>
    delete?: Enumerable<ClassRoomWhereUniqueInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
    update?: Enumerable<ClassRoomUpdateWithWhereUniqueWithoutTeachingInput>
    updateMany?: Enumerable<ClassRoomUpdateManyWithWhereWithoutTeachingInput>
    deleteMany?: Enumerable<ClassRoomScalarWhereInput>
  }

  export type ElementUpdateManyWithoutScheduleClassNestedInput = {
    create?: XOR<Enumerable<ElementCreateWithoutScheduleClassInput>, Enumerable<ElementUncheckedCreateWithoutScheduleClassInput>>
    connectOrCreate?: Enumerable<ElementCreateOrConnectWithoutScheduleClassInput>
    upsert?: Enumerable<ElementUpsertWithWhereUniqueWithoutScheduleClassInput>
    set?: Enumerable<ElementWhereUniqueInput>
    disconnect?: Enumerable<ElementWhereUniqueInput>
    delete?: Enumerable<ElementWhereUniqueInput>
    connect?: Enumerable<ElementWhereUniqueInput>
    update?: Enumerable<ElementUpdateWithWhereUniqueWithoutScheduleClassInput>
    updateMany?: Enumerable<ElementUpdateManyWithWhereWithoutScheduleClassInput>
    deleteMany?: Enumerable<ElementScalarWhereInput>
  }

  export type TrackerUpdateManyWithoutMengajarNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutMengajarInput>, Enumerable<TrackerUncheckedCreateWithoutMengajarInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutMengajarInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutMengajarInput>
    createMany?: TrackerCreateManyMengajarInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutMengajarInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutMengajarInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type TDeviceUpdateManyWithoutTeachingNestedInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutTeachingInput>, Enumerable<TDeviceUncheckedCreateWithoutTeachingInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutTeachingInput>
    upsert?: Enumerable<TDeviceUpsertWithWhereUniqueWithoutTeachingInput>
    createMany?: TDeviceCreateManyTeachingInputEnvelope
    set?: Enumerable<TDeviceWhereUniqueInput>
    disconnect?: Enumerable<TDeviceWhereUniqueInput>
    delete?: Enumerable<TDeviceWhereUniqueInput>
    connect?: Enumerable<TDeviceWhereUniqueInput>
    update?: Enumerable<TDeviceUpdateWithWhereUniqueWithoutTeachingInput>
    updateMany?: Enumerable<TDeviceUpdateManyWithWhereWithoutTeachingInput>
    deleteMany?: Enumerable<TDeviceScalarWhereInput>
  }

  export type TeachingUpdateclassRoomIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type TeachingUpdateelemenIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ClassRoomUncheckedUpdateManyWithoutTeachingNestedInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutTeachingInput>, Enumerable<ClassRoomUncheckedCreateWithoutTeachingInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutTeachingInput>
    upsert?: Enumerable<ClassRoomUpsertWithWhereUniqueWithoutTeachingInput>
    set?: Enumerable<ClassRoomWhereUniqueInput>
    disconnect?: Enumerable<ClassRoomWhereUniqueInput>
    delete?: Enumerable<ClassRoomWhereUniqueInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
    update?: Enumerable<ClassRoomUpdateWithWhereUniqueWithoutTeachingInput>
    updateMany?: Enumerable<ClassRoomUpdateManyWithWhereWithoutTeachingInput>
    deleteMany?: Enumerable<ClassRoomScalarWhereInput>
  }

  export type ElementUncheckedUpdateManyWithoutScheduleClassNestedInput = {
    create?: XOR<Enumerable<ElementCreateWithoutScheduleClassInput>, Enumerable<ElementUncheckedCreateWithoutScheduleClassInput>>
    connectOrCreate?: Enumerable<ElementCreateOrConnectWithoutScheduleClassInput>
    upsert?: Enumerable<ElementUpsertWithWhereUniqueWithoutScheduleClassInput>
    set?: Enumerable<ElementWhereUniqueInput>
    disconnect?: Enumerable<ElementWhereUniqueInput>
    delete?: Enumerable<ElementWhereUniqueInput>
    connect?: Enumerable<ElementWhereUniqueInput>
    update?: Enumerable<ElementUpdateWithWhereUniqueWithoutScheduleClassInput>
    updateMany?: Enumerable<ElementUpdateManyWithWhereWithoutScheduleClassInput>
    deleteMany?: Enumerable<ElementScalarWhereInput>
  }

  export type TrackerUncheckedUpdateManyWithoutMengajarNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutMengajarInput>, Enumerable<TrackerUncheckedCreateWithoutMengajarInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutMengajarInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutMengajarInput>
    createMany?: TrackerCreateManyMengajarInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutMengajarInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutMengajarInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type TDeviceUncheckedUpdateManyWithoutTeachingNestedInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutTeachingInput>, Enumerable<TDeviceUncheckedCreateWithoutTeachingInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutTeachingInput>
    upsert?: Enumerable<TDeviceUpsertWithWhereUniqueWithoutTeachingInput>
    createMany?: TDeviceCreateManyTeachingInputEnvelope
    set?: Enumerable<TDeviceWhereUniqueInput>
    disconnect?: Enumerable<TDeviceWhereUniqueInput>
    delete?: Enumerable<TDeviceWhereUniqueInput>
    connect?: Enumerable<TDeviceWhereUniqueInput>
    update?: Enumerable<TDeviceUpdateWithWhereUniqueWithoutTeachingInput>
    updateMany?: Enumerable<TDeviceUpdateManyWithWhereWithoutTeachingInput>
    deleteMany?: Enumerable<TDeviceScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutLinkInput = {
    create?: XOR<UserCreateWithoutLinkInput, UserUncheckedCreateWithoutLinkInput>
    connectOrCreate?: UserCreateOrConnectWithoutLinkInput
    connect?: UserWhereUniqueInput
  }

  export type OresourceCreateNestedManyWithoutLinkInput = {
    create?: XOR<Enumerable<OresourceCreateWithoutLinkInput>, Enumerable<OresourceUncheckedCreateWithoutLinkInput>>
    connectOrCreate?: Enumerable<OresourceCreateOrConnectWithoutLinkInput>
    createMany?: OresourceCreateManyLinkInputEnvelope
    connect?: Enumerable<OresourceWhereUniqueInput>
  }

  export type OresourceUncheckedCreateNestedManyWithoutLinkInput = {
    create?: XOR<Enumerable<OresourceCreateWithoutLinkInput>, Enumerable<OresourceUncheckedCreateWithoutLinkInput>>
    connectOrCreate?: Enumerable<OresourceCreateOrConnectWithoutLinkInput>
    createMany?: OresourceCreateManyLinkInputEnvelope
    connect?: Enumerable<OresourceWhereUniqueInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type UserUpdateOneRequiredWithoutLinkNestedInput = {
    create?: XOR<UserCreateWithoutLinkInput, UserUncheckedCreateWithoutLinkInput>
    connectOrCreate?: UserCreateOrConnectWithoutLinkInput
    upsert?: UserUpsertWithoutLinkInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutLinkInput, UserUncheckedUpdateWithoutLinkInput>
  }

  export type OresourceUpdateManyWithoutLinkNestedInput = {
    create?: XOR<Enumerable<OresourceCreateWithoutLinkInput>, Enumerable<OresourceUncheckedCreateWithoutLinkInput>>
    connectOrCreate?: Enumerable<OresourceCreateOrConnectWithoutLinkInput>
    upsert?: Enumerable<OresourceUpsertWithWhereUniqueWithoutLinkInput>
    createMany?: OresourceCreateManyLinkInputEnvelope
    set?: Enumerable<OresourceWhereUniqueInput>
    disconnect?: Enumerable<OresourceWhereUniqueInput>
    delete?: Enumerable<OresourceWhereUniqueInput>
    connect?: Enumerable<OresourceWhereUniqueInput>
    update?: Enumerable<OresourceUpdateWithWhereUniqueWithoutLinkInput>
    updateMany?: Enumerable<OresourceUpdateManyWithWhereWithoutLinkInput>
    deleteMany?: Enumerable<OresourceScalarWhereInput>
  }

  export type OresourceUncheckedUpdateManyWithoutLinkNestedInput = {
    create?: XOR<Enumerable<OresourceCreateWithoutLinkInput>, Enumerable<OresourceUncheckedCreateWithoutLinkInput>>
    connectOrCreate?: Enumerable<OresourceCreateOrConnectWithoutLinkInput>
    upsert?: Enumerable<OresourceUpsertWithWhereUniqueWithoutLinkInput>
    createMany?: OresourceCreateManyLinkInputEnvelope
    set?: Enumerable<OresourceWhereUniqueInput>
    disconnect?: Enumerable<OresourceWhereUniqueInput>
    delete?: Enumerable<OresourceWhereUniqueInput>
    connect?: Enumerable<OresourceWhereUniqueInput>
    update?: Enumerable<OresourceUpdateWithWhereUniqueWithoutLinkInput>
    updateMany?: Enumerable<OresourceUpdateManyWithWhereWithoutLinkInput>
    deleteMany?: Enumerable<OresourceScalarWhereInput>
  }

  export type OAssessmentCreatetechsInput = {
    set: Enumerable<string>
  }

  export type ObjectiveCreateNestedOneWithoutAssessmentsInput = {
    create?: XOR<ObjectiveCreateWithoutAssessmentsInput, ObjectiveUncheckedCreateWithoutAssessmentsInput>
    connectOrCreate?: ObjectiveCreateOrConnectWithoutAssessmentsInput
    connect?: ObjectiveWhereUniqueInput
  }

  export type OAssessmentUpdatetechsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ObjectiveUpdateOneRequiredWithoutAssessmentsNestedInput = {
    create?: XOR<ObjectiveCreateWithoutAssessmentsInput, ObjectiveUncheckedCreateWithoutAssessmentsInput>
    connectOrCreate?: ObjectiveCreateOrConnectWithoutAssessmentsInput
    upsert?: ObjectiveUpsertWithoutAssessmentsInput
    connect?: ObjectiveWhereUniqueInput
    update?: XOR<ObjectiveUpdateWithoutAssessmentsInput, ObjectiveUncheckedUpdateWithoutAssessmentsInput>
  }

  export type ObjectiveCreatecompetencieInput = {
    set: Enumerable<string>
  }

  export type ObjectiveCreatefirstSkillInput = {
    set: Enumerable<string>
  }

  export type ObjectiveCreatetriggerQuestInput = {
    set: Enumerable<string>
  }

  export type UserCreateNestedOneWithoutObjectiveInput = {
    create?: XOR<UserCreateWithoutObjectiveInput, UserUncheckedCreateWithoutObjectiveInput>
    connectOrCreate?: UserCreateOrConnectWithoutObjectiveInput
    connect?: UserWhereUniqueInput
  }

  export type InstansiCreateNestedOneWithoutObjectiveInput = {
    create?: XOR<InstansiCreateWithoutObjectiveInput, InstansiUncheckedCreateWithoutObjectiveInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutObjectiveInput
    connect?: InstansiWhereUniqueInput
  }

  export type SchoolYearCreateNestedOneWithoutObjectiveInput = {
    create?: XOR<SchoolYearCreateWithoutObjectiveInput, SchoolYearUncheckedCreateWithoutObjectiveInput>
    connectOrCreate?: SchoolYearCreateOrConnectWithoutObjectiveInput
    connect?: SchoolYearWhereUniqueInput
  }

  export type MataPelajaranCreateNestedOneWithoutObjectiveInput = {
    create?: XOR<MataPelajaranCreateWithoutObjectiveInput, MataPelajaranUncheckedCreateWithoutObjectiveInput>
    connectOrCreate?: MataPelajaranCreateOrConnectWithoutObjectiveInput
    connect?: MataPelajaranWhereUniqueInput
  }

  export type ElementCreateNestedOneWithoutObjectiveInput = {
    create?: XOR<ElementCreateWithoutObjectiveInput, ElementUncheckedCreateWithoutObjectiveInput>
    connectOrCreate?: ElementCreateOrConnectWithoutObjectiveInput
    connect?: ElementWhereUniqueInput
  }

  export type AchievementCreateNestedOneWithoutObjectiveInput = {
    create?: XOR<AchievementCreateWithoutObjectiveInput, AchievementUncheckedCreateWithoutObjectiveInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutObjectiveInput
    connect?: AchievementWhereUniqueInput
  }

  export type OMaterialCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<OMaterialCreateWithoutRefInput>, Enumerable<OMaterialUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<OMaterialCreateOrConnectWithoutRefInput>
    createMany?: OMaterialCreateManyRefInputEnvelope
    connect?: Enumerable<OMaterialWhereUniqueInput>
  }

  export type TrackerCreateNestedManyWithoutTujuanInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutTujuanInput>, Enumerable<TrackerUncheckedCreateWithoutTujuanInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutTujuanInput>
    createMany?: TrackerCreateManyTujuanInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type OresourceCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<OresourceCreateWithoutRefInput>, Enumerable<OresourceUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<OresourceCreateOrConnectWithoutRefInput>
    createMany?: OresourceCreateManyRefInputEnvelope
    connect?: Enumerable<OresourceWhereUniqueInput>
  }

  export type OpppCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<OpppCreateWithoutRefInput>, Enumerable<OpppUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<OpppCreateOrConnectWithoutRefInput>
    createMany?: OpppCreateManyRefInputEnvelope
    connect?: Enumerable<OpppWhereUniqueInput>
  }

  export type OhelperCreateNestedManyWithoutToolInput = {
    create?: XOR<Enumerable<OhelperCreateWithoutToolInput>, Enumerable<OhelperUncheckedCreateWithoutToolInput>>
    connectOrCreate?: Enumerable<OhelperCreateOrConnectWithoutToolInput>
    connect?: Enumerable<OhelperWhereUniqueInput>
  }

  export type OhelperCreateNestedManyWithoutMateInput = {
    create?: XOR<Enumerable<OhelperCreateWithoutMateInput>, Enumerable<OhelperUncheckedCreateWithoutMateInput>>
    connectOrCreate?: Enumerable<OhelperCreateOrConnectWithoutMateInput>
    connect?: Enumerable<OhelperWhereUniqueInput>
  }

  export type OhelperCreateNestedManyWithoutMethInput = {
    create?: XOR<Enumerable<OhelperCreateWithoutMethInput>, Enumerable<OhelperUncheckedCreateWithoutMethInput>>
    connectOrCreate?: Enumerable<OhelperCreateOrConnectWithoutMethInput>
    connect?: Enumerable<OhelperWhereUniqueInput>
  }

  export type OhelperCreateNestedManyWithoutMediaInput = {
    create?: XOR<Enumerable<OhelperCreateWithoutMediaInput>, Enumerable<OhelperUncheckedCreateWithoutMediaInput>>
    connectOrCreate?: Enumerable<OhelperCreateOrConnectWithoutMediaInput>
    connect?: Enumerable<OhelperWhereUniqueInput>
  }

  export type OAssessmentCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<OAssessmentCreateWithoutRefInput>, Enumerable<OAssessmentUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<OAssessmentCreateOrConnectWithoutRefInput>
    createMany?: OAssessmentCreateManyRefInputEnvelope
    connect?: Enumerable<OAssessmentWhereUniqueInput>
  }

  export type TDeviceDataCreateNestedManyWithoutObjectiveInput = {
    create?: XOR<Enumerable<TDeviceDataCreateWithoutObjectiveInput>, Enumerable<TDeviceDataUncheckedCreateWithoutObjectiveInput>>
    connectOrCreate?: Enumerable<TDeviceDataCreateOrConnectWithoutObjectiveInput>
    createMany?: TDeviceDataCreateManyObjectiveInputEnvelope
    connect?: Enumerable<TDeviceDataWhereUniqueInput>
  }

  export type ObjectiveCreatetoolIdsInput = {
    set: Enumerable<string>
  }

  export type ObjectiveCreatemateIdsInput = {
    set: Enumerable<string>
  }

  export type ObjectiveCreatemethIdsInput = {
    set: Enumerable<string>
  }

  export type ObjectiveCreatemediaIdsInput = {
    set: Enumerable<string>
  }

  export type OMaterialUncheckedCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<OMaterialCreateWithoutRefInput>, Enumerable<OMaterialUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<OMaterialCreateOrConnectWithoutRefInput>
    createMany?: OMaterialCreateManyRefInputEnvelope
    connect?: Enumerable<OMaterialWhereUniqueInput>
  }

  export type TrackerUncheckedCreateNestedManyWithoutTujuanInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutTujuanInput>, Enumerable<TrackerUncheckedCreateWithoutTujuanInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutTujuanInput>
    createMany?: TrackerCreateManyTujuanInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type OresourceUncheckedCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<OresourceCreateWithoutRefInput>, Enumerable<OresourceUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<OresourceCreateOrConnectWithoutRefInput>
    createMany?: OresourceCreateManyRefInputEnvelope
    connect?: Enumerable<OresourceWhereUniqueInput>
  }

  export type OpppUncheckedCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<OpppCreateWithoutRefInput>, Enumerable<OpppUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<OpppCreateOrConnectWithoutRefInput>
    createMany?: OpppCreateManyRefInputEnvelope
    connect?: Enumerable<OpppWhereUniqueInput>
  }

  export type OhelperUncheckedCreateNestedManyWithoutToolInput = {
    create?: XOR<Enumerable<OhelperCreateWithoutToolInput>, Enumerable<OhelperUncheckedCreateWithoutToolInput>>
    connectOrCreate?: Enumerable<OhelperCreateOrConnectWithoutToolInput>
    connect?: Enumerable<OhelperWhereUniqueInput>
  }

  export type OhelperUncheckedCreateNestedManyWithoutMateInput = {
    create?: XOR<Enumerable<OhelperCreateWithoutMateInput>, Enumerable<OhelperUncheckedCreateWithoutMateInput>>
    connectOrCreate?: Enumerable<OhelperCreateOrConnectWithoutMateInput>
    connect?: Enumerable<OhelperWhereUniqueInput>
  }

  export type OhelperUncheckedCreateNestedManyWithoutMethInput = {
    create?: XOR<Enumerable<OhelperCreateWithoutMethInput>, Enumerable<OhelperUncheckedCreateWithoutMethInput>>
    connectOrCreate?: Enumerable<OhelperCreateOrConnectWithoutMethInput>
    connect?: Enumerable<OhelperWhereUniqueInput>
  }

  export type OhelperUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<Enumerable<OhelperCreateWithoutMediaInput>, Enumerable<OhelperUncheckedCreateWithoutMediaInput>>
    connectOrCreate?: Enumerable<OhelperCreateOrConnectWithoutMediaInput>
    connect?: Enumerable<OhelperWhereUniqueInput>
  }

  export type OAssessmentUncheckedCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<OAssessmentCreateWithoutRefInput>, Enumerable<OAssessmentUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<OAssessmentCreateOrConnectWithoutRefInput>
    createMany?: OAssessmentCreateManyRefInputEnvelope
    connect?: Enumerable<OAssessmentWhereUniqueInput>
  }

  export type TDeviceDataUncheckedCreateNestedManyWithoutObjectiveInput = {
    create?: XOR<Enumerable<TDeviceDataCreateWithoutObjectiveInput>, Enumerable<TDeviceDataUncheckedCreateWithoutObjectiveInput>>
    connectOrCreate?: Enumerable<TDeviceDataCreateOrConnectWithoutObjectiveInput>
    createMany?: TDeviceDataCreateManyObjectiveInputEnvelope
    connect?: Enumerable<TDeviceDataWhereUniqueInput>
  }

  export type ObjectiveUpdatecompetencieInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ObjectiveUpdatefirstSkillInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ObjectiveUpdatetriggerQuestInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type UserUpdateOneRequiredWithoutObjectiveNestedInput = {
    create?: XOR<UserCreateWithoutObjectiveInput, UserUncheckedCreateWithoutObjectiveInput>
    connectOrCreate?: UserCreateOrConnectWithoutObjectiveInput
    upsert?: UserUpsertWithoutObjectiveInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutObjectiveInput, UserUncheckedUpdateWithoutObjectiveInput>
  }

  export type InstansiUpdateOneRequiredWithoutObjectiveNestedInput = {
    create?: XOR<InstansiCreateWithoutObjectiveInput, InstansiUncheckedCreateWithoutObjectiveInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutObjectiveInput
    upsert?: InstansiUpsertWithoutObjectiveInput
    connect?: InstansiWhereUniqueInput
    update?: XOR<InstansiUpdateWithoutObjectiveInput, InstansiUncheckedUpdateWithoutObjectiveInput>
  }

  export type SchoolYearUpdateOneRequiredWithoutObjectiveNestedInput = {
    create?: XOR<SchoolYearCreateWithoutObjectiveInput, SchoolYearUncheckedCreateWithoutObjectiveInput>
    connectOrCreate?: SchoolYearCreateOrConnectWithoutObjectiveInput
    upsert?: SchoolYearUpsertWithoutObjectiveInput
    connect?: SchoolYearWhereUniqueInput
    update?: XOR<SchoolYearUpdateWithoutObjectiveInput, SchoolYearUncheckedUpdateWithoutObjectiveInput>
  }

  export type MataPelajaranUpdateOneRequiredWithoutObjectiveNestedInput = {
    create?: XOR<MataPelajaranCreateWithoutObjectiveInput, MataPelajaranUncheckedCreateWithoutObjectiveInput>
    connectOrCreate?: MataPelajaranCreateOrConnectWithoutObjectiveInput
    upsert?: MataPelajaranUpsertWithoutObjectiveInput
    connect?: MataPelajaranWhereUniqueInput
    update?: XOR<MataPelajaranUpdateWithoutObjectiveInput, MataPelajaranUncheckedUpdateWithoutObjectiveInput>
  }

  export type ElementUpdateOneRequiredWithoutObjectiveNestedInput = {
    create?: XOR<ElementCreateWithoutObjectiveInput, ElementUncheckedCreateWithoutObjectiveInput>
    connectOrCreate?: ElementCreateOrConnectWithoutObjectiveInput
    upsert?: ElementUpsertWithoutObjectiveInput
    connect?: ElementWhereUniqueInput
    update?: XOR<ElementUpdateWithoutObjectiveInput, ElementUncheckedUpdateWithoutObjectiveInput>
  }

  export type AchievementUpdateOneRequiredWithoutObjectiveNestedInput = {
    create?: XOR<AchievementCreateWithoutObjectiveInput, AchievementUncheckedCreateWithoutObjectiveInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutObjectiveInput
    upsert?: AchievementUpsertWithoutObjectiveInput
    connect?: AchievementWhereUniqueInput
    update?: XOR<AchievementUpdateWithoutObjectiveInput, AchievementUncheckedUpdateWithoutObjectiveInput>
  }

  export type OMaterialUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<OMaterialCreateWithoutRefInput>, Enumerable<OMaterialUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<OMaterialCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<OMaterialUpsertWithWhereUniqueWithoutRefInput>
    createMany?: OMaterialCreateManyRefInputEnvelope
    set?: Enumerable<OMaterialWhereUniqueInput>
    disconnect?: Enumerable<OMaterialWhereUniqueInput>
    delete?: Enumerable<OMaterialWhereUniqueInput>
    connect?: Enumerable<OMaterialWhereUniqueInput>
    update?: Enumerable<OMaterialUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<OMaterialUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<OMaterialScalarWhereInput>
  }

  export type TrackerUpdateManyWithoutTujuanNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutTujuanInput>, Enumerable<TrackerUncheckedCreateWithoutTujuanInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutTujuanInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutTujuanInput>
    createMany?: TrackerCreateManyTujuanInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutTujuanInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutTujuanInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type OresourceUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<OresourceCreateWithoutRefInput>, Enumerable<OresourceUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<OresourceCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<OresourceUpsertWithWhereUniqueWithoutRefInput>
    createMany?: OresourceCreateManyRefInputEnvelope
    set?: Enumerable<OresourceWhereUniqueInput>
    disconnect?: Enumerable<OresourceWhereUniqueInput>
    delete?: Enumerable<OresourceWhereUniqueInput>
    connect?: Enumerable<OresourceWhereUniqueInput>
    update?: Enumerable<OresourceUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<OresourceUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<OresourceScalarWhereInput>
  }

  export type OpppUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<OpppCreateWithoutRefInput>, Enumerable<OpppUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<OpppCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<OpppUpsertWithWhereUniqueWithoutRefInput>
    createMany?: OpppCreateManyRefInputEnvelope
    set?: Enumerable<OpppWhereUniqueInput>
    disconnect?: Enumerable<OpppWhereUniqueInput>
    delete?: Enumerable<OpppWhereUniqueInput>
    connect?: Enumerable<OpppWhereUniqueInput>
    update?: Enumerable<OpppUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<OpppUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<OpppScalarWhereInput>
  }

  export type OhelperUpdateManyWithoutToolNestedInput = {
    create?: XOR<Enumerable<OhelperCreateWithoutToolInput>, Enumerable<OhelperUncheckedCreateWithoutToolInput>>
    connectOrCreate?: Enumerable<OhelperCreateOrConnectWithoutToolInput>
    upsert?: Enumerable<OhelperUpsertWithWhereUniqueWithoutToolInput>
    set?: Enumerable<OhelperWhereUniqueInput>
    disconnect?: Enumerable<OhelperWhereUniqueInput>
    delete?: Enumerable<OhelperWhereUniqueInput>
    connect?: Enumerable<OhelperWhereUniqueInput>
    update?: Enumerable<OhelperUpdateWithWhereUniqueWithoutToolInput>
    updateMany?: Enumerable<OhelperUpdateManyWithWhereWithoutToolInput>
    deleteMany?: Enumerable<OhelperScalarWhereInput>
  }

  export type OhelperUpdateManyWithoutMateNestedInput = {
    create?: XOR<Enumerable<OhelperCreateWithoutMateInput>, Enumerable<OhelperUncheckedCreateWithoutMateInput>>
    connectOrCreate?: Enumerable<OhelperCreateOrConnectWithoutMateInput>
    upsert?: Enumerable<OhelperUpsertWithWhereUniqueWithoutMateInput>
    set?: Enumerable<OhelperWhereUniqueInput>
    disconnect?: Enumerable<OhelperWhereUniqueInput>
    delete?: Enumerable<OhelperWhereUniqueInput>
    connect?: Enumerable<OhelperWhereUniqueInput>
    update?: Enumerable<OhelperUpdateWithWhereUniqueWithoutMateInput>
    updateMany?: Enumerable<OhelperUpdateManyWithWhereWithoutMateInput>
    deleteMany?: Enumerable<OhelperScalarWhereInput>
  }

  export type OhelperUpdateManyWithoutMethNestedInput = {
    create?: XOR<Enumerable<OhelperCreateWithoutMethInput>, Enumerable<OhelperUncheckedCreateWithoutMethInput>>
    connectOrCreate?: Enumerable<OhelperCreateOrConnectWithoutMethInput>
    upsert?: Enumerable<OhelperUpsertWithWhereUniqueWithoutMethInput>
    set?: Enumerable<OhelperWhereUniqueInput>
    disconnect?: Enumerable<OhelperWhereUniqueInput>
    delete?: Enumerable<OhelperWhereUniqueInput>
    connect?: Enumerable<OhelperWhereUniqueInput>
    update?: Enumerable<OhelperUpdateWithWhereUniqueWithoutMethInput>
    updateMany?: Enumerable<OhelperUpdateManyWithWhereWithoutMethInput>
    deleteMany?: Enumerable<OhelperScalarWhereInput>
  }

  export type OhelperUpdateManyWithoutMediaNestedInput = {
    create?: XOR<Enumerable<OhelperCreateWithoutMediaInput>, Enumerable<OhelperUncheckedCreateWithoutMediaInput>>
    connectOrCreate?: Enumerable<OhelperCreateOrConnectWithoutMediaInput>
    upsert?: Enumerable<OhelperUpsertWithWhereUniqueWithoutMediaInput>
    set?: Enumerable<OhelperWhereUniqueInput>
    disconnect?: Enumerable<OhelperWhereUniqueInput>
    delete?: Enumerable<OhelperWhereUniqueInput>
    connect?: Enumerable<OhelperWhereUniqueInput>
    update?: Enumerable<OhelperUpdateWithWhereUniqueWithoutMediaInput>
    updateMany?: Enumerable<OhelperUpdateManyWithWhereWithoutMediaInput>
    deleteMany?: Enumerable<OhelperScalarWhereInput>
  }

  export type OAssessmentUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<OAssessmentCreateWithoutRefInput>, Enumerable<OAssessmentUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<OAssessmentCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<OAssessmentUpsertWithWhereUniqueWithoutRefInput>
    createMany?: OAssessmentCreateManyRefInputEnvelope
    set?: Enumerable<OAssessmentWhereUniqueInput>
    disconnect?: Enumerable<OAssessmentWhereUniqueInput>
    delete?: Enumerable<OAssessmentWhereUniqueInput>
    connect?: Enumerable<OAssessmentWhereUniqueInput>
    update?: Enumerable<OAssessmentUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<OAssessmentUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<OAssessmentScalarWhereInput>
  }

  export type TDeviceDataUpdateManyWithoutObjectiveNestedInput = {
    create?: XOR<Enumerable<TDeviceDataCreateWithoutObjectiveInput>, Enumerable<TDeviceDataUncheckedCreateWithoutObjectiveInput>>
    connectOrCreate?: Enumerable<TDeviceDataCreateOrConnectWithoutObjectiveInput>
    upsert?: Enumerable<TDeviceDataUpsertWithWhereUniqueWithoutObjectiveInput>
    createMany?: TDeviceDataCreateManyObjectiveInputEnvelope
    set?: Enumerable<TDeviceDataWhereUniqueInput>
    disconnect?: Enumerable<TDeviceDataWhereUniqueInput>
    delete?: Enumerable<TDeviceDataWhereUniqueInput>
    connect?: Enumerable<TDeviceDataWhereUniqueInput>
    update?: Enumerable<TDeviceDataUpdateWithWhereUniqueWithoutObjectiveInput>
    updateMany?: Enumerable<TDeviceDataUpdateManyWithWhereWithoutObjectiveInput>
    deleteMany?: Enumerable<TDeviceDataScalarWhereInput>
  }

  export type ObjectiveUpdatetoolIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ObjectiveUpdatemateIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ObjectiveUpdatemethIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ObjectiveUpdatemediaIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type OMaterialUncheckedUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<OMaterialCreateWithoutRefInput>, Enumerable<OMaterialUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<OMaterialCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<OMaterialUpsertWithWhereUniqueWithoutRefInput>
    createMany?: OMaterialCreateManyRefInputEnvelope
    set?: Enumerable<OMaterialWhereUniqueInput>
    disconnect?: Enumerable<OMaterialWhereUniqueInput>
    delete?: Enumerable<OMaterialWhereUniqueInput>
    connect?: Enumerable<OMaterialWhereUniqueInput>
    update?: Enumerable<OMaterialUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<OMaterialUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<OMaterialScalarWhereInput>
  }

  export type TrackerUncheckedUpdateManyWithoutTujuanNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutTujuanInput>, Enumerable<TrackerUncheckedCreateWithoutTujuanInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutTujuanInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutTujuanInput>
    createMany?: TrackerCreateManyTujuanInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutTujuanInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutTujuanInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type OresourceUncheckedUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<OresourceCreateWithoutRefInput>, Enumerable<OresourceUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<OresourceCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<OresourceUpsertWithWhereUniqueWithoutRefInput>
    createMany?: OresourceCreateManyRefInputEnvelope
    set?: Enumerable<OresourceWhereUniqueInput>
    disconnect?: Enumerable<OresourceWhereUniqueInput>
    delete?: Enumerable<OresourceWhereUniqueInput>
    connect?: Enumerable<OresourceWhereUniqueInput>
    update?: Enumerable<OresourceUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<OresourceUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<OresourceScalarWhereInput>
  }

  export type OpppUncheckedUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<OpppCreateWithoutRefInput>, Enumerable<OpppUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<OpppCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<OpppUpsertWithWhereUniqueWithoutRefInput>
    createMany?: OpppCreateManyRefInputEnvelope
    set?: Enumerable<OpppWhereUniqueInput>
    disconnect?: Enumerable<OpppWhereUniqueInput>
    delete?: Enumerable<OpppWhereUniqueInput>
    connect?: Enumerable<OpppWhereUniqueInput>
    update?: Enumerable<OpppUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<OpppUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<OpppScalarWhereInput>
  }

  export type OhelperUncheckedUpdateManyWithoutToolNestedInput = {
    create?: XOR<Enumerable<OhelperCreateWithoutToolInput>, Enumerable<OhelperUncheckedCreateWithoutToolInput>>
    connectOrCreate?: Enumerable<OhelperCreateOrConnectWithoutToolInput>
    upsert?: Enumerable<OhelperUpsertWithWhereUniqueWithoutToolInput>
    set?: Enumerable<OhelperWhereUniqueInput>
    disconnect?: Enumerable<OhelperWhereUniqueInput>
    delete?: Enumerable<OhelperWhereUniqueInput>
    connect?: Enumerable<OhelperWhereUniqueInput>
    update?: Enumerable<OhelperUpdateWithWhereUniqueWithoutToolInput>
    updateMany?: Enumerable<OhelperUpdateManyWithWhereWithoutToolInput>
    deleteMany?: Enumerable<OhelperScalarWhereInput>
  }

  export type OhelperUncheckedUpdateManyWithoutMateNestedInput = {
    create?: XOR<Enumerable<OhelperCreateWithoutMateInput>, Enumerable<OhelperUncheckedCreateWithoutMateInput>>
    connectOrCreate?: Enumerable<OhelperCreateOrConnectWithoutMateInput>
    upsert?: Enumerable<OhelperUpsertWithWhereUniqueWithoutMateInput>
    set?: Enumerable<OhelperWhereUniqueInput>
    disconnect?: Enumerable<OhelperWhereUniqueInput>
    delete?: Enumerable<OhelperWhereUniqueInput>
    connect?: Enumerable<OhelperWhereUniqueInput>
    update?: Enumerable<OhelperUpdateWithWhereUniqueWithoutMateInput>
    updateMany?: Enumerable<OhelperUpdateManyWithWhereWithoutMateInput>
    deleteMany?: Enumerable<OhelperScalarWhereInput>
  }

  export type OhelperUncheckedUpdateManyWithoutMethNestedInput = {
    create?: XOR<Enumerable<OhelperCreateWithoutMethInput>, Enumerable<OhelperUncheckedCreateWithoutMethInput>>
    connectOrCreate?: Enumerable<OhelperCreateOrConnectWithoutMethInput>
    upsert?: Enumerable<OhelperUpsertWithWhereUniqueWithoutMethInput>
    set?: Enumerable<OhelperWhereUniqueInput>
    disconnect?: Enumerable<OhelperWhereUniqueInput>
    delete?: Enumerable<OhelperWhereUniqueInput>
    connect?: Enumerable<OhelperWhereUniqueInput>
    update?: Enumerable<OhelperUpdateWithWhereUniqueWithoutMethInput>
    updateMany?: Enumerable<OhelperUpdateManyWithWhereWithoutMethInput>
    deleteMany?: Enumerable<OhelperScalarWhereInput>
  }

  export type OhelperUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<Enumerable<OhelperCreateWithoutMediaInput>, Enumerable<OhelperUncheckedCreateWithoutMediaInput>>
    connectOrCreate?: Enumerable<OhelperCreateOrConnectWithoutMediaInput>
    upsert?: Enumerable<OhelperUpsertWithWhereUniqueWithoutMediaInput>
    set?: Enumerable<OhelperWhereUniqueInput>
    disconnect?: Enumerable<OhelperWhereUniqueInput>
    delete?: Enumerable<OhelperWhereUniqueInput>
    connect?: Enumerable<OhelperWhereUniqueInput>
    update?: Enumerable<OhelperUpdateWithWhereUniqueWithoutMediaInput>
    updateMany?: Enumerable<OhelperUpdateManyWithWhereWithoutMediaInput>
    deleteMany?: Enumerable<OhelperScalarWhereInput>
  }

  export type OAssessmentUncheckedUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<OAssessmentCreateWithoutRefInput>, Enumerable<OAssessmentUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<OAssessmentCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<OAssessmentUpsertWithWhereUniqueWithoutRefInput>
    createMany?: OAssessmentCreateManyRefInputEnvelope
    set?: Enumerable<OAssessmentWhereUniqueInput>
    disconnect?: Enumerable<OAssessmentWhereUniqueInput>
    delete?: Enumerable<OAssessmentWhereUniqueInput>
    connect?: Enumerable<OAssessmentWhereUniqueInput>
    update?: Enumerable<OAssessmentUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<OAssessmentUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<OAssessmentScalarWhereInput>
  }

  export type TDeviceDataUncheckedUpdateManyWithoutObjectiveNestedInput = {
    create?: XOR<Enumerable<TDeviceDataCreateWithoutObjectiveInput>, Enumerable<TDeviceDataUncheckedCreateWithoutObjectiveInput>>
    connectOrCreate?: Enumerable<TDeviceDataCreateOrConnectWithoutObjectiveInput>
    upsert?: Enumerable<TDeviceDataUpsertWithWhereUniqueWithoutObjectiveInput>
    createMany?: TDeviceDataCreateManyObjectiveInputEnvelope
    set?: Enumerable<TDeviceDataWhereUniqueInput>
    disconnect?: Enumerable<TDeviceDataWhereUniqueInput>
    delete?: Enumerable<TDeviceDataWhereUniqueInput>
    connect?: Enumerable<TDeviceDataWhereUniqueInput>
    update?: Enumerable<TDeviceDataUpdateWithWhereUniqueWithoutObjectiveInput>
    updateMany?: Enumerable<TDeviceDataUpdateManyWithWhereWithoutObjectiveInput>
    deleteMany?: Enumerable<TDeviceDataScalarWhereInput>
  }

  export type ObjectiveCreateNestedOneWithoutMaterialInput = {
    create?: XOR<ObjectiveCreateWithoutMaterialInput, ObjectiveUncheckedCreateWithoutMaterialInput>
    connectOrCreate?: ObjectiveCreateOrConnectWithoutMaterialInput
    connect?: ObjectiveWhereUniqueInput
  }

  export type OLearningCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<OLearningCreateWithoutRefInput>, Enumerable<OLearningUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<OLearningCreateOrConnectWithoutRefInput>
    createMany?: OLearningCreateManyRefInputEnvelope
    connect?: Enumerable<OLearningWhereUniqueInput>
  }

  export type OLearningUncheckedCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<OLearningCreateWithoutRefInput>, Enumerable<OLearningUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<OLearningCreateOrConnectWithoutRefInput>
    createMany?: OLearningCreateManyRefInputEnvelope
    connect?: Enumerable<OLearningWhereUniqueInput>
  }

  export type EnumOMaterialModelFieldUpdateOperationsInput = {
    set?: OMaterialModel
  }

  export type ObjectiveUpdateOneRequiredWithoutMaterialNestedInput = {
    create?: XOR<ObjectiveCreateWithoutMaterialInput, ObjectiveUncheckedCreateWithoutMaterialInput>
    connectOrCreate?: ObjectiveCreateOrConnectWithoutMaterialInput
    upsert?: ObjectiveUpsertWithoutMaterialInput
    connect?: ObjectiveWhereUniqueInput
    update?: XOR<ObjectiveUpdateWithoutMaterialInput, ObjectiveUncheckedUpdateWithoutMaterialInput>
  }

  export type OLearningUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<OLearningCreateWithoutRefInput>, Enumerable<OLearningUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<OLearningCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<OLearningUpsertWithWhereUniqueWithoutRefInput>
    createMany?: OLearningCreateManyRefInputEnvelope
    set?: Enumerable<OLearningWhereUniqueInput>
    disconnect?: Enumerable<OLearningWhereUniqueInput>
    delete?: Enumerable<OLearningWhereUniqueInput>
    connect?: Enumerable<OLearningWhereUniqueInput>
    update?: Enumerable<OLearningUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<OLearningUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<OLearningScalarWhereInput>
  }

  export type OLearningUncheckedUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<OLearningCreateWithoutRefInput>, Enumerable<OLearningUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<OLearningCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<OLearningUpsertWithWhereUniqueWithoutRefInput>
    createMany?: OLearningCreateManyRefInputEnvelope
    set?: Enumerable<OLearningWhereUniqueInput>
    disconnect?: Enumerable<OLearningWhereUniqueInput>
    delete?: Enumerable<OLearningWhereUniqueInput>
    connect?: Enumerable<OLearningWhereUniqueInput>
    update?: Enumerable<OLearningUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<OLearningUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<OLearningScalarWhereInput>
  }

  export type OMaterialCreateNestedOneWithoutLearningInput = {
    create?: XOR<OMaterialCreateWithoutLearningInput, OMaterialUncheckedCreateWithoutLearningInput>
    connectOrCreate?: OMaterialCreateOrConnectWithoutLearningInput
    connect?: OMaterialWhereUniqueInput
  }

  export type EnumTaksonomiFieldUpdateOperationsInput = {
    set?: Taksonomi
  }

  export type OMaterialUpdateOneRequiredWithoutLearningNestedInput = {
    create?: XOR<OMaterialCreateWithoutLearningInput, OMaterialUncheckedCreateWithoutLearningInput>
    connectOrCreate?: OMaterialCreateOrConnectWithoutLearningInput
    upsert?: OMaterialUpsertWithoutLearningInput
    connect?: OMaterialWhereUniqueInput
    update?: XOR<OMaterialUpdateWithoutLearningInput, OMaterialUncheckedUpdateWithoutLearningInput>
  }

  export type ObjectiveCreateNestedManyWithoutToolInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutToolInput>, Enumerable<ObjectiveUncheckedCreateWithoutToolInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutToolInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
  }

  export type ObjectiveCreateNestedManyWithoutMateInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutMateInput>, Enumerable<ObjectiveUncheckedCreateWithoutMateInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutMateInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
  }

  export type ObjectiveCreateNestedManyWithoutMethInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutMethInput>, Enumerable<ObjectiveUncheckedCreateWithoutMethInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutMethInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
  }

  export type ObjectiveCreateNestedManyWithoutMediaInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutMediaInput>, Enumerable<ObjectiveUncheckedCreateWithoutMediaInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutMediaInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
  }

  export type OhelperCreatetoolIdsInput = {
    set: Enumerable<string>
  }

  export type OhelperCreatemateIdsInput = {
    set: Enumerable<string>
  }

  export type OhelperCreatemethIdsInput = {
    set: Enumerable<string>
  }

  export type OhelperCreatemediaIdsInput = {
    set: Enumerable<string>
  }

  export type ObjectiveUncheckedCreateNestedManyWithoutToolInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutToolInput>, Enumerable<ObjectiveUncheckedCreateWithoutToolInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutToolInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
  }

  export type ObjectiveUncheckedCreateNestedManyWithoutMateInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutMateInput>, Enumerable<ObjectiveUncheckedCreateWithoutMateInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutMateInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
  }

  export type ObjectiveUncheckedCreateNestedManyWithoutMethInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutMethInput>, Enumerable<ObjectiveUncheckedCreateWithoutMethInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutMethInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
  }

  export type ObjectiveUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutMediaInput>, Enumerable<ObjectiveUncheckedCreateWithoutMediaInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutMediaInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
  }

  export type EnumOhelperTypeFieldUpdateOperationsInput = {
    set?: OhelperType
  }

  export type ObjectiveUpdateManyWithoutToolNestedInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutToolInput>, Enumerable<ObjectiveUncheckedCreateWithoutToolInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutToolInput>
    upsert?: Enumerable<ObjectiveUpsertWithWhereUniqueWithoutToolInput>
    set?: Enumerable<ObjectiveWhereUniqueInput>
    disconnect?: Enumerable<ObjectiveWhereUniqueInput>
    delete?: Enumerable<ObjectiveWhereUniqueInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
    update?: Enumerable<ObjectiveUpdateWithWhereUniqueWithoutToolInput>
    updateMany?: Enumerable<ObjectiveUpdateManyWithWhereWithoutToolInput>
    deleteMany?: Enumerable<ObjectiveScalarWhereInput>
  }

  export type ObjectiveUpdateManyWithoutMateNestedInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutMateInput>, Enumerable<ObjectiveUncheckedCreateWithoutMateInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutMateInput>
    upsert?: Enumerable<ObjectiveUpsertWithWhereUniqueWithoutMateInput>
    set?: Enumerable<ObjectiveWhereUniqueInput>
    disconnect?: Enumerable<ObjectiveWhereUniqueInput>
    delete?: Enumerable<ObjectiveWhereUniqueInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
    update?: Enumerable<ObjectiveUpdateWithWhereUniqueWithoutMateInput>
    updateMany?: Enumerable<ObjectiveUpdateManyWithWhereWithoutMateInput>
    deleteMany?: Enumerable<ObjectiveScalarWhereInput>
  }

  export type ObjectiveUpdateManyWithoutMethNestedInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutMethInput>, Enumerable<ObjectiveUncheckedCreateWithoutMethInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutMethInput>
    upsert?: Enumerable<ObjectiveUpsertWithWhereUniqueWithoutMethInput>
    set?: Enumerable<ObjectiveWhereUniqueInput>
    disconnect?: Enumerable<ObjectiveWhereUniqueInput>
    delete?: Enumerable<ObjectiveWhereUniqueInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
    update?: Enumerable<ObjectiveUpdateWithWhereUniqueWithoutMethInput>
    updateMany?: Enumerable<ObjectiveUpdateManyWithWhereWithoutMethInput>
    deleteMany?: Enumerable<ObjectiveScalarWhereInput>
  }

  export type ObjectiveUpdateManyWithoutMediaNestedInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutMediaInput>, Enumerable<ObjectiveUncheckedCreateWithoutMediaInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutMediaInput>
    upsert?: Enumerable<ObjectiveUpsertWithWhereUniqueWithoutMediaInput>
    set?: Enumerable<ObjectiveWhereUniqueInput>
    disconnect?: Enumerable<ObjectiveWhereUniqueInput>
    delete?: Enumerable<ObjectiveWhereUniqueInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
    update?: Enumerable<ObjectiveUpdateWithWhereUniqueWithoutMediaInput>
    updateMany?: Enumerable<ObjectiveUpdateManyWithWhereWithoutMediaInput>
    deleteMany?: Enumerable<ObjectiveScalarWhereInput>
  }

  export type OhelperUpdatetoolIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type OhelperUpdatemateIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type OhelperUpdatemethIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type OhelperUpdatemediaIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ObjectiveUncheckedUpdateManyWithoutToolNestedInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutToolInput>, Enumerable<ObjectiveUncheckedCreateWithoutToolInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutToolInput>
    upsert?: Enumerable<ObjectiveUpsertWithWhereUniqueWithoutToolInput>
    set?: Enumerable<ObjectiveWhereUniqueInput>
    disconnect?: Enumerable<ObjectiveWhereUniqueInput>
    delete?: Enumerable<ObjectiveWhereUniqueInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
    update?: Enumerable<ObjectiveUpdateWithWhereUniqueWithoutToolInput>
    updateMany?: Enumerable<ObjectiveUpdateManyWithWhereWithoutToolInput>
    deleteMany?: Enumerable<ObjectiveScalarWhereInput>
  }

  export type ObjectiveUncheckedUpdateManyWithoutMateNestedInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutMateInput>, Enumerable<ObjectiveUncheckedCreateWithoutMateInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutMateInput>
    upsert?: Enumerable<ObjectiveUpsertWithWhereUniqueWithoutMateInput>
    set?: Enumerable<ObjectiveWhereUniqueInput>
    disconnect?: Enumerable<ObjectiveWhereUniqueInput>
    delete?: Enumerable<ObjectiveWhereUniqueInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
    update?: Enumerable<ObjectiveUpdateWithWhereUniqueWithoutMateInput>
    updateMany?: Enumerable<ObjectiveUpdateManyWithWhereWithoutMateInput>
    deleteMany?: Enumerable<ObjectiveScalarWhereInput>
  }

  export type ObjectiveUncheckedUpdateManyWithoutMethNestedInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutMethInput>, Enumerable<ObjectiveUncheckedCreateWithoutMethInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutMethInput>
    upsert?: Enumerable<ObjectiveUpsertWithWhereUniqueWithoutMethInput>
    set?: Enumerable<ObjectiveWhereUniqueInput>
    disconnect?: Enumerable<ObjectiveWhereUniqueInput>
    delete?: Enumerable<ObjectiveWhereUniqueInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
    update?: Enumerable<ObjectiveUpdateWithWhereUniqueWithoutMethInput>
    updateMany?: Enumerable<ObjectiveUpdateManyWithWhereWithoutMethInput>
    deleteMany?: Enumerable<ObjectiveScalarWhereInput>
  }

  export type ObjectiveUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<Enumerable<ObjectiveCreateWithoutMediaInput>, Enumerable<ObjectiveUncheckedCreateWithoutMediaInput>>
    connectOrCreate?: Enumerable<ObjectiveCreateOrConnectWithoutMediaInput>
    upsert?: Enumerable<ObjectiveUpsertWithWhereUniqueWithoutMediaInput>
    set?: Enumerable<ObjectiveWhereUniqueInput>
    disconnect?: Enumerable<ObjectiveWhereUniqueInput>
    delete?: Enumerable<ObjectiveWhereUniqueInput>
    connect?: Enumerable<ObjectiveWhereUniqueInput>
    update?: Enumerable<ObjectiveUpdateWithWhereUniqueWithoutMediaInput>
    updateMany?: Enumerable<ObjectiveUpdateManyWithWhereWithoutMediaInput>
    deleteMany?: Enumerable<ObjectiveScalarWhereInput>
  }

  export type ObjectiveCreateNestedOneWithoutPppInput = {
    create?: XOR<ObjectiveCreateWithoutPppInput, ObjectiveUncheckedCreateWithoutPppInput>
    connectOrCreate?: ObjectiveCreateOrConnectWithoutPppInput
    connect?: ObjectiveWhereUniqueInput
  }

  export type ObjectiveUpdateOneRequiredWithoutPppNestedInput = {
    create?: XOR<ObjectiveCreateWithoutPppInput, ObjectiveUncheckedCreateWithoutPppInput>
    connectOrCreate?: ObjectiveCreateOrConnectWithoutPppInput
    upsert?: ObjectiveUpsertWithoutPppInput
    connect?: ObjectiveWhereUniqueInput
    update?: XOR<ObjectiveUpdateWithoutPppInput, ObjectiveUncheckedUpdateWithoutPppInput>
  }

  export type ObjectiveCreateNestedOneWithoutResourseInput = {
    create?: XOR<ObjectiveCreateWithoutResourseInput, ObjectiveUncheckedCreateWithoutResourseInput>
    connectOrCreate?: ObjectiveCreateOrConnectWithoutResourseInput
    connect?: ObjectiveWhereUniqueInput
  }

  export type LinkCreateNestedOneWithoutObjResourceInput = {
    create?: XOR<LinkCreateWithoutObjResourceInput, LinkUncheckedCreateWithoutObjResourceInput>
    connectOrCreate?: LinkCreateOrConnectWithoutObjResourceInput
    connect?: LinkWhereUniqueInput
  }

  export type EnumOresourceTypeFieldUpdateOperationsInput = {
    set?: OresourceType
  }

  export type ObjectiveUpdateOneRequiredWithoutResourseNestedInput = {
    create?: XOR<ObjectiveCreateWithoutResourseInput, ObjectiveUncheckedCreateWithoutResourseInput>
    connectOrCreate?: ObjectiveCreateOrConnectWithoutResourseInput
    upsert?: ObjectiveUpsertWithoutResourseInput
    connect?: ObjectiveWhereUniqueInput
    update?: XOR<ObjectiveUpdateWithoutResourseInput, ObjectiveUncheckedUpdateWithoutResourseInput>
  }

  export type LinkUpdateOneWithoutObjResourceNestedInput = {
    create?: XOR<LinkCreateWithoutObjResourceInput, LinkUncheckedCreateWithoutObjResourceInput>
    connectOrCreate?: LinkCreateOrConnectWithoutObjResourceInput
    upsert?: LinkUpsertWithoutObjResourceInput
    disconnect?: boolean
    delete?: boolean
    connect?: LinkWhereUniqueInput
    update?: XOR<LinkUpdateWithoutObjResourceInput, LinkUncheckedUpdateWithoutObjResourceInput>
  }

  export type TDevicePropsCreateEnvelopeInput = {
    set?: TDevicePropsCreateInput
  }

  export type TDevicePropsCreateInput = {
    docDate: Date | string
    docAddr: string
    kepText: string
    kepUser: string
    ke3Text: string
    jabText: string
    ke3User: string
  }

  export type TDeviceCreateelemenInput = {
    set: Enumerable<string>
  }

  export type TDevicePosListCreateEnvelopeInput = {
    set?: Enumerable<TDevicePosCreateInput>
  }

  export type TDevicePosCreateInput = {
    mouth: number
    week: number
    active: boolean
  }

  export type TeachingCreateNestedOneWithoutTDeviceInput = {
    create?: XOR<TeachingCreateWithoutTDeviceInput, TeachingUncheckedCreateWithoutTDeviceInput>
    connectOrCreate?: TeachingCreateOrConnectWithoutTDeviceInput
    connect?: TeachingWhereUniqueInput
  }

  export type SchoolYearCreateNestedOneWithoutTDeviceInput = {
    create?: XOR<SchoolYearCreateWithoutTDeviceInput, SchoolYearUncheckedCreateWithoutTDeviceInput>
    connectOrCreate?: SchoolYearCreateOrConnectWithoutTDeviceInput
    connect?: SchoolYearWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTDeviceInput = {
    create?: XOR<UserCreateWithoutTDeviceInput, UserUncheckedCreateWithoutTDeviceInput>
    connectOrCreate?: UserCreateOrConnectWithoutTDeviceInput
    connect?: UserWhereUniqueInput
  }

  export type InstansiCreateNestedOneWithoutTDeviceInput = {
    create?: XOR<InstansiCreateWithoutTDeviceInput, InstansiUncheckedCreateWithoutTDeviceInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutTDeviceInput
    connect?: InstansiWhereUniqueInput
  }

  export type MataPelajaranCreateNestedOneWithoutDeviceInput = {
    create?: XOR<MataPelajaranCreateWithoutDeviceInput, MataPelajaranUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: MataPelajaranCreateOrConnectWithoutDeviceInput
    connect?: MataPelajaranWhereUniqueInput
  }

  export type ClassRoomCreateNestedManyWithoutTDeviceInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutTDeviceInput>, Enumerable<ClassRoomUncheckedCreateWithoutTDeviceInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutTDeviceInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
  }

  export type TrackerCreateNestedManyWithoutPerangkatInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutPerangkatInput>, Enumerable<TrackerUncheckedCreateWithoutPerangkatInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutPerangkatInput>
    createMany?: TrackerCreateManyPerangkatInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type TDeviceDataCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<TDeviceDataCreateWithoutRefInput>, Enumerable<TDeviceDataUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<TDeviceDataCreateOrConnectWithoutRefInput>
    createMany?: TDeviceDataCreateManyRefInputEnvelope
    connect?: Enumerable<TDeviceDataWhereUniqueInput>
  }

  export type TDeviceCreateNestedManyWithoutParentInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutParentInput>, Enumerable<TDeviceUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutParentInput>
    createMany?: TDeviceCreateManyParentInputEnvelope
    connect?: Enumerable<TDeviceWhereUniqueInput>
  }

  export type TDeviceCreateNestedOneWithoutChildrenInput = {
    create?: XOR<TDeviceCreateWithoutChildrenInput, TDeviceUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: TDeviceCreateOrConnectWithoutChildrenInput
    connect?: TDeviceWhereUniqueInput
  }

  export type TDeviceCreateclassRoomIdsInput = {
    set: Enumerable<string>
  }

  export type ClassRoomUncheckedCreateNestedManyWithoutTDeviceInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutTDeviceInput>, Enumerable<ClassRoomUncheckedCreateWithoutTDeviceInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutTDeviceInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
  }

  export type TrackerUncheckedCreateNestedManyWithoutPerangkatInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutPerangkatInput>, Enumerable<TrackerUncheckedCreateWithoutPerangkatInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutPerangkatInput>
    createMany?: TrackerCreateManyPerangkatInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type TDeviceDataUncheckedCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<TDeviceDataCreateWithoutRefInput>, Enumerable<TDeviceDataUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<TDeviceDataCreateOrConnectWithoutRefInput>
    createMany?: TDeviceDataCreateManyRefInputEnvelope
    connect?: Enumerable<TDeviceDataWhereUniqueInput>
  }

  export type TDeviceUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutParentInput>, Enumerable<TDeviceUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutParentInput>
    createMany?: TDeviceCreateManyParentInputEnvelope
    connect?: Enumerable<TDeviceWhereUniqueInput>
  }

  export type TDevicePropsUpdateEnvelopeInput = {
    set?: TDevicePropsCreateInput
    update?: TDevicePropsUpdateInput
  }

  export type TDeviceUpdateelemenInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type TDevicePosListUpdateEnvelopeInput = {
    set?: Enumerable<TDevicePosCreateInput>
    push?: Enumerable<TDevicePosCreateInput>
    updateMany?: TDevicePosUpdateManyInput
    deleteMany?: TDevicePosDeleteManyInput
  }

  export type TeachingUpdateOneRequiredWithoutTDeviceNestedInput = {
    create?: XOR<TeachingCreateWithoutTDeviceInput, TeachingUncheckedCreateWithoutTDeviceInput>
    connectOrCreate?: TeachingCreateOrConnectWithoutTDeviceInput
    upsert?: TeachingUpsertWithoutTDeviceInput
    connect?: TeachingWhereUniqueInput
    update?: XOR<TeachingUpdateWithoutTDeviceInput, TeachingUncheckedUpdateWithoutTDeviceInput>
  }

  export type SchoolYearUpdateOneRequiredWithoutTDeviceNestedInput = {
    create?: XOR<SchoolYearCreateWithoutTDeviceInput, SchoolYearUncheckedCreateWithoutTDeviceInput>
    connectOrCreate?: SchoolYearCreateOrConnectWithoutTDeviceInput
    upsert?: SchoolYearUpsertWithoutTDeviceInput
    connect?: SchoolYearWhereUniqueInput
    update?: XOR<SchoolYearUpdateWithoutTDeviceInput, SchoolYearUncheckedUpdateWithoutTDeviceInput>
  }

  export type UserUpdateOneRequiredWithoutTDeviceNestedInput = {
    create?: XOR<UserCreateWithoutTDeviceInput, UserUncheckedCreateWithoutTDeviceInput>
    connectOrCreate?: UserCreateOrConnectWithoutTDeviceInput
    upsert?: UserUpsertWithoutTDeviceInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTDeviceInput, UserUncheckedUpdateWithoutTDeviceInput>
  }

  export type InstansiUpdateOneRequiredWithoutTDeviceNestedInput = {
    create?: XOR<InstansiCreateWithoutTDeviceInput, InstansiUncheckedCreateWithoutTDeviceInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutTDeviceInput
    upsert?: InstansiUpsertWithoutTDeviceInput
    connect?: InstansiWhereUniqueInput
    update?: XOR<InstansiUpdateWithoutTDeviceInput, InstansiUncheckedUpdateWithoutTDeviceInput>
  }

  export type MataPelajaranUpdateOneRequiredWithoutDeviceNestedInput = {
    create?: XOR<MataPelajaranCreateWithoutDeviceInput, MataPelajaranUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: MataPelajaranCreateOrConnectWithoutDeviceInput
    upsert?: MataPelajaranUpsertWithoutDeviceInput
    connect?: MataPelajaranWhereUniqueInput
    update?: XOR<MataPelajaranUpdateWithoutDeviceInput, MataPelajaranUncheckedUpdateWithoutDeviceInput>
  }

  export type ClassRoomUpdateManyWithoutTDeviceNestedInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutTDeviceInput>, Enumerable<ClassRoomUncheckedCreateWithoutTDeviceInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutTDeviceInput>
    upsert?: Enumerable<ClassRoomUpsertWithWhereUniqueWithoutTDeviceInput>
    set?: Enumerable<ClassRoomWhereUniqueInput>
    disconnect?: Enumerable<ClassRoomWhereUniqueInput>
    delete?: Enumerable<ClassRoomWhereUniqueInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
    update?: Enumerable<ClassRoomUpdateWithWhereUniqueWithoutTDeviceInput>
    updateMany?: Enumerable<ClassRoomUpdateManyWithWhereWithoutTDeviceInput>
    deleteMany?: Enumerable<ClassRoomScalarWhereInput>
  }

  export type TrackerUpdateManyWithoutPerangkatNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutPerangkatInput>, Enumerable<TrackerUncheckedCreateWithoutPerangkatInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutPerangkatInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutPerangkatInput>
    createMany?: TrackerCreateManyPerangkatInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutPerangkatInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutPerangkatInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type TDeviceDataUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<TDeviceDataCreateWithoutRefInput>, Enumerable<TDeviceDataUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<TDeviceDataCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<TDeviceDataUpsertWithWhereUniqueWithoutRefInput>
    createMany?: TDeviceDataCreateManyRefInputEnvelope
    set?: Enumerable<TDeviceDataWhereUniqueInput>
    disconnect?: Enumerable<TDeviceDataWhereUniqueInput>
    delete?: Enumerable<TDeviceDataWhereUniqueInput>
    connect?: Enumerable<TDeviceDataWhereUniqueInput>
    update?: Enumerable<TDeviceDataUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<TDeviceDataUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<TDeviceDataScalarWhereInput>
  }

  export type TDeviceUpdateManyWithoutParentNestedInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutParentInput>, Enumerable<TDeviceUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutParentInput>
    upsert?: Enumerable<TDeviceUpsertWithWhereUniqueWithoutParentInput>
    createMany?: TDeviceCreateManyParentInputEnvelope
    set?: Enumerable<TDeviceWhereUniqueInput>
    disconnect?: Enumerable<TDeviceWhereUniqueInput>
    delete?: Enumerable<TDeviceWhereUniqueInput>
    connect?: Enumerable<TDeviceWhereUniqueInput>
    update?: Enumerable<TDeviceUpdateWithWhereUniqueWithoutParentInput>
    updateMany?: Enumerable<TDeviceUpdateManyWithWhereWithoutParentInput>
    deleteMany?: Enumerable<TDeviceScalarWhereInput>
  }

  export type TDeviceUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<TDeviceCreateWithoutChildrenInput, TDeviceUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: TDeviceCreateOrConnectWithoutChildrenInput
    upsert?: TDeviceUpsertWithoutChildrenInput
    disconnect?: boolean
    delete?: boolean
    connect?: TDeviceWhereUniqueInput
    update?: XOR<TDeviceUpdateWithoutChildrenInput, TDeviceUncheckedUpdateWithoutChildrenInput>
  }

  export type TDeviceUpdateclassRoomIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ClassRoomUncheckedUpdateManyWithoutTDeviceNestedInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutTDeviceInput>, Enumerable<ClassRoomUncheckedCreateWithoutTDeviceInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutTDeviceInput>
    upsert?: Enumerable<ClassRoomUpsertWithWhereUniqueWithoutTDeviceInput>
    set?: Enumerable<ClassRoomWhereUniqueInput>
    disconnect?: Enumerable<ClassRoomWhereUniqueInput>
    delete?: Enumerable<ClassRoomWhereUniqueInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
    update?: Enumerable<ClassRoomUpdateWithWhereUniqueWithoutTDeviceInput>
    updateMany?: Enumerable<ClassRoomUpdateManyWithWhereWithoutTDeviceInput>
    deleteMany?: Enumerable<ClassRoomScalarWhereInput>
  }

  export type TrackerUncheckedUpdateManyWithoutPerangkatNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutPerangkatInput>, Enumerable<TrackerUncheckedCreateWithoutPerangkatInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutPerangkatInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutPerangkatInput>
    createMany?: TrackerCreateManyPerangkatInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutPerangkatInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutPerangkatInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type TDeviceDataUncheckedUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<TDeviceDataCreateWithoutRefInput>, Enumerable<TDeviceDataUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<TDeviceDataCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<TDeviceDataUpsertWithWhereUniqueWithoutRefInput>
    createMany?: TDeviceDataCreateManyRefInputEnvelope
    set?: Enumerable<TDeviceDataWhereUniqueInput>
    disconnect?: Enumerable<TDeviceDataWhereUniqueInput>
    delete?: Enumerable<TDeviceDataWhereUniqueInput>
    connect?: Enumerable<TDeviceDataWhereUniqueInput>
    update?: Enumerable<TDeviceDataUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<TDeviceDataUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<TDeviceDataScalarWhereInput>
  }

  export type TDeviceUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<Enumerable<TDeviceCreateWithoutParentInput>, Enumerable<TDeviceUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<TDeviceCreateOrConnectWithoutParentInput>
    upsert?: Enumerable<TDeviceUpsertWithWhereUniqueWithoutParentInput>
    createMany?: TDeviceCreateManyParentInputEnvelope
    set?: Enumerable<TDeviceWhereUniqueInput>
    disconnect?: Enumerable<TDeviceWhereUniqueInput>
    delete?: Enumerable<TDeviceWhereUniqueInput>
    connect?: Enumerable<TDeviceWhereUniqueInput>
    update?: Enumerable<TDeviceUpdateWithWhereUniqueWithoutParentInput>
    updateMany?: Enumerable<TDeviceUpdateManyWithWhereWithoutParentInput>
    deleteMany?: Enumerable<TDeviceScalarWhereInput>
  }

  export type TDeviceCreateNestedOneWithoutDataInput = {
    create?: XOR<TDeviceCreateWithoutDataInput, TDeviceUncheckedCreateWithoutDataInput>
    connectOrCreate?: TDeviceCreateOrConnectWithoutDataInput
    connect?: TDeviceWhereUniqueInput
  }

  export type ObjectiveCreateNestedOneWithoutDevicesInput = {
    create?: XOR<ObjectiveCreateWithoutDevicesInput, ObjectiveUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: ObjectiveCreateOrConnectWithoutDevicesInput
    connect?: ObjectiveWhereUniqueInput
  }

  export type TDeviceUpdateOneRequiredWithoutDataNestedInput = {
    create?: XOR<TDeviceCreateWithoutDataInput, TDeviceUncheckedCreateWithoutDataInput>
    connectOrCreate?: TDeviceCreateOrConnectWithoutDataInput
    upsert?: TDeviceUpsertWithoutDataInput
    connect?: TDeviceWhereUniqueInput
    update?: XOR<TDeviceUpdateWithoutDataInput, TDeviceUncheckedUpdateWithoutDataInput>
  }

  export type ObjectiveUpdateOneRequiredWithoutDevicesNestedInput = {
    create?: XOR<ObjectiveCreateWithoutDevicesInput, ObjectiveUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: ObjectiveCreateOrConnectWithoutDevicesInput
    upsert?: ObjectiveUpsertWithoutDevicesInput
    connect?: ObjectiveWhereUniqueInput
    update?: XOR<ObjectiveUpdateWithoutDevicesInput, ObjectiveUncheckedUpdateWithoutDevicesInput>
  }

  export type SchoolYearCreateNestedOneWithoutCalendarInput = {
    create?: XOR<SchoolYearCreateWithoutCalendarInput, SchoolYearUncheckedCreateWithoutCalendarInput>
    connectOrCreate?: SchoolYearCreateOrConnectWithoutCalendarInput
    connect?: SchoolYearWhereUniqueInput
  }

  export type ClassRoomCreateNestedManyWithoutEventInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutEventInput>, Enumerable<ClassRoomUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutEventInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
  }

  export type StudentCreateNestedManyWithoutEventInput = {
    create?: XOR<Enumerable<StudentCreateWithoutEventInput>, Enumerable<StudentUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutEventInput>
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type TeacherCreateNestedManyWithoutEventInput = {
    create?: XOR<Enumerable<TeacherCreateWithoutEventInput>, Enumerable<TeacherUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<TeacherCreateOrConnectWithoutEventInput>
    connect?: Enumerable<TeacherWhereUniqueInput>
  }

  export type TrackerCreateNestedManyWithoutKalenderInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutKalenderInput>, Enumerable<TrackerUncheckedCreateWithoutKalenderInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutKalenderInput>
    createMany?: TrackerCreateManyKalenderInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type CalendarCreateclassRoomIdsInput = {
    set: Enumerable<string>
  }

  export type CalendarCreatestudentIdsInput = {
    set: Enumerable<string>
  }

  export type CalendarCreateteacherIdsInput = {
    set: Enumerable<string>
  }

  export type ClassRoomUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutEventInput>, Enumerable<ClassRoomUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutEventInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
  }

  export type StudentUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<Enumerable<StudentCreateWithoutEventInput>, Enumerable<StudentUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutEventInput>
    connect?: Enumerable<StudentWhereUniqueInput>
  }

  export type TeacherUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<Enumerable<TeacherCreateWithoutEventInput>, Enumerable<TeacherUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<TeacherCreateOrConnectWithoutEventInput>
    connect?: Enumerable<TeacherWhereUniqueInput>
  }

  export type TrackerUncheckedCreateNestedManyWithoutKalenderInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutKalenderInput>, Enumerable<TrackerUncheckedCreateWithoutKalenderInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutKalenderInput>
    createMany?: TrackerCreateManyKalenderInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type SchoolYearUpdateOneRequiredWithoutCalendarNestedInput = {
    create?: XOR<SchoolYearCreateWithoutCalendarInput, SchoolYearUncheckedCreateWithoutCalendarInput>
    connectOrCreate?: SchoolYearCreateOrConnectWithoutCalendarInput
    upsert?: SchoolYearUpsertWithoutCalendarInput
    connect?: SchoolYearWhereUniqueInput
    update?: XOR<SchoolYearUpdateWithoutCalendarInput, SchoolYearUncheckedUpdateWithoutCalendarInput>
  }

  export type ClassRoomUpdateManyWithoutEventNestedInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutEventInput>, Enumerable<ClassRoomUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutEventInput>
    upsert?: Enumerable<ClassRoomUpsertWithWhereUniqueWithoutEventInput>
    set?: Enumerable<ClassRoomWhereUniqueInput>
    disconnect?: Enumerable<ClassRoomWhereUniqueInput>
    delete?: Enumerable<ClassRoomWhereUniqueInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
    update?: Enumerable<ClassRoomUpdateWithWhereUniqueWithoutEventInput>
    updateMany?: Enumerable<ClassRoomUpdateManyWithWhereWithoutEventInput>
    deleteMany?: Enumerable<ClassRoomScalarWhereInput>
  }

  export type StudentUpdateManyWithoutEventNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutEventInput>, Enumerable<StudentUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutEventInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutEventInput>
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutEventInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutEventInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type TeacherUpdateManyWithoutEventNestedInput = {
    create?: XOR<Enumerable<TeacherCreateWithoutEventInput>, Enumerable<TeacherUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<TeacherCreateOrConnectWithoutEventInput>
    upsert?: Enumerable<TeacherUpsertWithWhereUniqueWithoutEventInput>
    set?: Enumerable<TeacherWhereUniqueInput>
    disconnect?: Enumerable<TeacherWhereUniqueInput>
    delete?: Enumerable<TeacherWhereUniqueInput>
    connect?: Enumerable<TeacherWhereUniqueInput>
    update?: Enumerable<TeacherUpdateWithWhereUniqueWithoutEventInput>
    updateMany?: Enumerable<TeacherUpdateManyWithWhereWithoutEventInput>
    deleteMany?: Enumerable<TeacherScalarWhereInput>
  }

  export type TrackerUpdateManyWithoutKalenderNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutKalenderInput>, Enumerable<TrackerUncheckedCreateWithoutKalenderInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutKalenderInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutKalenderInput>
    createMany?: TrackerCreateManyKalenderInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutKalenderInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutKalenderInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type CalendarUpdateclassRoomIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type CalendarUpdatestudentIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type CalendarUpdateteacherIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ClassRoomUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<Enumerable<ClassRoomCreateWithoutEventInput>, Enumerable<ClassRoomUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<ClassRoomCreateOrConnectWithoutEventInput>
    upsert?: Enumerable<ClassRoomUpsertWithWhereUniqueWithoutEventInput>
    set?: Enumerable<ClassRoomWhereUniqueInput>
    disconnect?: Enumerable<ClassRoomWhereUniqueInput>
    delete?: Enumerable<ClassRoomWhereUniqueInput>
    connect?: Enumerable<ClassRoomWhereUniqueInput>
    update?: Enumerable<ClassRoomUpdateWithWhereUniqueWithoutEventInput>
    updateMany?: Enumerable<ClassRoomUpdateManyWithWhereWithoutEventInput>
    deleteMany?: Enumerable<ClassRoomScalarWhereInput>
  }

  export type StudentUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<Enumerable<StudentCreateWithoutEventInput>, Enumerable<StudentUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<StudentCreateOrConnectWithoutEventInput>
    upsert?: Enumerable<StudentUpsertWithWhereUniqueWithoutEventInput>
    set?: Enumerable<StudentWhereUniqueInput>
    disconnect?: Enumerable<StudentWhereUniqueInput>
    delete?: Enumerable<StudentWhereUniqueInput>
    connect?: Enumerable<StudentWhereUniqueInput>
    update?: Enumerable<StudentUpdateWithWhereUniqueWithoutEventInput>
    updateMany?: Enumerable<StudentUpdateManyWithWhereWithoutEventInput>
    deleteMany?: Enumerable<StudentScalarWhereInput>
  }

  export type TeacherUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<Enumerable<TeacherCreateWithoutEventInput>, Enumerable<TeacherUncheckedCreateWithoutEventInput>>
    connectOrCreate?: Enumerable<TeacherCreateOrConnectWithoutEventInput>
    upsert?: Enumerable<TeacherUpsertWithWhereUniqueWithoutEventInput>
    set?: Enumerable<TeacherWhereUniqueInput>
    disconnect?: Enumerable<TeacherWhereUniqueInput>
    delete?: Enumerable<TeacherWhereUniqueInput>
    connect?: Enumerable<TeacherWhereUniqueInput>
    update?: Enumerable<TeacherUpdateWithWhereUniqueWithoutEventInput>
    updateMany?: Enumerable<TeacherUpdateManyWithWhereWithoutEventInput>
    deleteMany?: Enumerable<TeacherScalarWhereInput>
  }

  export type TrackerUncheckedUpdateManyWithoutKalenderNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutKalenderInput>, Enumerable<TrackerUncheckedCreateWithoutKalenderInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutKalenderInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutKalenderInput>
    createMany?: TrackerCreateManyKalenderInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutKalenderInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutKalenderInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type ContactDudiCreateEnvelopeInput = {
    set?: ContactDudiCreateInput
  }

  export type ContactDudiCreateInput = {
    name: string
    position: string
    email: string
    phone: string
  }

  export type DudiCreatecollabsInput = {
    set: Enumerable<string>
  }

  export type DudiTimeWorkCreateEnvelopeInput = {
    set?: DudiTimeWorkCreateInput
  }

  export type DudiTimeWorkCreateInput = {
    holidays?: DudiTimeWorkCreateholidaysInput | Enumerable<string>
    timeIn: string
    timeOut: string
    actifity: boolean
  }

  export type InstansiCreateNestedOneWithoutDudiInput = {
    create?: XOR<InstansiCreateWithoutDudiInput, InstansiUncheckedCreateWithoutDudiInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutDudiInput
    connect?: InstansiWhereUniqueInput
  }

  export type KonsentrasiKeahlianCreateNestedOneWithoutDudiInput = {
    create?: XOR<KonsentrasiKeahlianCreateWithoutDudiInput, KonsentrasiKeahlianUncheckedCreateWithoutDudiInput>
    connectOrCreate?: KonsentrasiKeahlianCreateOrConnectWithoutDudiInput
    connect?: KonsentrasiKeahlianWhereUniqueInput
  }

  export type DudiLearningCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<DudiLearningCreateWithoutRefInput>, Enumerable<DudiLearningUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<DudiLearningCreateOrConnectWithoutRefInput>
    createMany?: DudiLearningCreateManyRefInputEnvelope
    connect?: Enumerable<DudiLearningWhereUniqueInput>
  }

  export type TrackerCreateNestedManyWithoutDudiInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutDudiInput>, Enumerable<TrackerUncheckedCreateWithoutDudiInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutDudiInput>
    createMany?: TrackerCreateManyDudiInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type KkniCreateNestedOneWithoutDudiInput = {
    create?: XOR<KkniCreateWithoutDudiInput, KkniUncheckedCreateWithoutDudiInput>
    connectOrCreate?: KkniCreateOrConnectWithoutDudiInput
    connect?: KkniWhereUniqueInput
  }

  export type DudiLearningUncheckedCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<DudiLearningCreateWithoutRefInput>, Enumerable<DudiLearningUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<DudiLearningCreateOrConnectWithoutRefInput>
    createMany?: DudiLearningCreateManyRefInputEnvelope
    connect?: Enumerable<DudiLearningWhereUniqueInput>
  }

  export type TrackerUncheckedCreateNestedManyWithoutDudiInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutDudiInput>, Enumerable<TrackerUncheckedCreateWithoutDudiInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutDudiInput>
    createMany?: TrackerCreateManyDudiInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type ContactDudiUpdateEnvelopeInput = {
    set?: ContactDudiCreateInput
    update?: ContactDudiUpdateInput
  }

  export type DudiUpdatecollabsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type DudiTimeWorkUpdateEnvelopeInput = {
    set?: DudiTimeWorkCreateInput
    update?: DudiTimeWorkUpdateInput
  }

  export type InstansiUpdateOneRequiredWithoutDudiNestedInput = {
    create?: XOR<InstansiCreateWithoutDudiInput, InstansiUncheckedCreateWithoutDudiInput>
    connectOrCreate?: InstansiCreateOrConnectWithoutDudiInput
    upsert?: InstansiUpsertWithoutDudiInput
    connect?: InstansiWhereUniqueInput
    update?: XOR<InstansiUpdateWithoutDudiInput, InstansiUncheckedUpdateWithoutDudiInput>
  }

  export type KonsentrasiKeahlianUpdateOneRequiredWithoutDudiNestedInput = {
    create?: XOR<KonsentrasiKeahlianCreateWithoutDudiInput, KonsentrasiKeahlianUncheckedCreateWithoutDudiInput>
    connectOrCreate?: KonsentrasiKeahlianCreateOrConnectWithoutDudiInput
    upsert?: KonsentrasiKeahlianUpsertWithoutDudiInput
    connect?: KonsentrasiKeahlianWhereUniqueInput
    update?: XOR<KonsentrasiKeahlianUpdateWithoutDudiInput, KonsentrasiKeahlianUncheckedUpdateWithoutDudiInput>
  }

  export type DudiLearningUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<DudiLearningCreateWithoutRefInput>, Enumerable<DudiLearningUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<DudiLearningCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<DudiLearningUpsertWithWhereUniqueWithoutRefInput>
    createMany?: DudiLearningCreateManyRefInputEnvelope
    set?: Enumerable<DudiLearningWhereUniqueInput>
    disconnect?: Enumerable<DudiLearningWhereUniqueInput>
    delete?: Enumerable<DudiLearningWhereUniqueInput>
    connect?: Enumerable<DudiLearningWhereUniqueInput>
    update?: Enumerable<DudiLearningUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<DudiLearningUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<DudiLearningScalarWhereInput>
  }

  export type TrackerUpdateManyWithoutDudiNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutDudiInput>, Enumerable<TrackerUncheckedCreateWithoutDudiInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutDudiInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutDudiInput>
    createMany?: TrackerCreateManyDudiInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutDudiInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutDudiInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type KkniUpdateOneWithoutDudiNestedInput = {
    create?: XOR<KkniCreateWithoutDudiInput, KkniUncheckedCreateWithoutDudiInput>
    connectOrCreate?: KkniCreateOrConnectWithoutDudiInput
    upsert?: KkniUpsertWithoutDudiInput
    disconnect?: boolean
    delete?: boolean
    connect?: KkniWhereUniqueInput
    update?: XOR<KkniUpdateWithoutDudiInput, KkniUncheckedUpdateWithoutDudiInput>
  }

  export type DudiLearningUncheckedUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<DudiLearningCreateWithoutRefInput>, Enumerable<DudiLearningUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<DudiLearningCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<DudiLearningUpsertWithWhereUniqueWithoutRefInput>
    createMany?: DudiLearningCreateManyRefInputEnvelope
    set?: Enumerable<DudiLearningWhereUniqueInput>
    disconnect?: Enumerable<DudiLearningWhereUniqueInput>
    delete?: Enumerable<DudiLearningWhereUniqueInput>
    connect?: Enumerable<DudiLearningWhereUniqueInput>
    update?: Enumerable<DudiLearningUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<DudiLearningUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<DudiLearningScalarWhereInput>
  }

  export type TrackerUncheckedUpdateManyWithoutDudiNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutDudiInput>, Enumerable<TrackerUncheckedCreateWithoutDudiInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutDudiInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutDudiInput>
    createMany?: TrackerCreateManyDudiInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutDudiInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutDudiInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type DudiIndicatorListCreateEnvelopeInput = {
    set?: Enumerable<DudiIndicatorCreateInput>
  }

  export type DudiIndicatorCreateInput = {
    no: number
    code: string
    name: string
  }

  export type DudiCreateNestedOneWithoutLearningInput = {
    create?: XOR<DudiCreateWithoutLearningInput, DudiUncheckedCreateWithoutLearningInput>
    connectOrCreate?: DudiCreateOrConnectWithoutLearningInput
    connect?: DudiWhereUniqueInput
  }

  export type DudiIndicatorListUpdateEnvelopeInput = {
    set?: Enumerable<DudiIndicatorCreateInput>
    push?: Enumerable<DudiIndicatorCreateInput>
    updateMany?: DudiIndicatorUpdateManyInput
    deleteMany?: DudiIndicatorDeleteManyInput
  }

  export type DudiUpdateOneRequiredWithoutLearningNestedInput = {
    create?: XOR<DudiCreateWithoutLearningInput, DudiUncheckedCreateWithoutLearningInput>
    connectOrCreate?: DudiCreateOrConnectWithoutLearningInput
    upsert?: DudiUpsertWithoutLearningInput
    connect?: DudiWhereUniqueInput
    update?: XOR<DudiUpdateWithoutLearningInput, DudiUncheckedUpdateWithoutLearningInput>
  }

  export type KonsentrasiKeahlianCreateNestedOneWithoutKkniInput = {
    create?: XOR<KonsentrasiKeahlianCreateWithoutKkniInput, KonsentrasiKeahlianUncheckedCreateWithoutKkniInput>
    connectOrCreate?: KonsentrasiKeahlianCreateOrConnectWithoutKkniInput
    connect?: KonsentrasiKeahlianWhereUniqueInput
  }

  export type DudiCreateNestedManyWithoutKkniInput = {
    create?: XOR<Enumerable<DudiCreateWithoutKkniInput>, Enumerable<DudiUncheckedCreateWithoutKkniInput>>
    connectOrCreate?: Enumerable<DudiCreateOrConnectWithoutKkniInput>
    createMany?: DudiCreateManyKkniInputEnvelope
    connect?: Enumerable<DudiWhereUniqueInput>
  }

  export type TrackerCreateNestedManyWithoutKkniInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutKkniInput>, Enumerable<TrackerUncheckedCreateWithoutKkniInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutKkniInput>
    createMany?: TrackerCreateManyKkniInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type DudiUncheckedCreateNestedManyWithoutKkniInput = {
    create?: XOR<Enumerable<DudiCreateWithoutKkniInput>, Enumerable<DudiUncheckedCreateWithoutKkniInput>>
    connectOrCreate?: Enumerable<DudiCreateOrConnectWithoutKkniInput>
    createMany?: DudiCreateManyKkniInputEnvelope
    connect?: Enumerable<DudiWhereUniqueInput>
  }

  export type TrackerUncheckedCreateNestedManyWithoutKkniInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutKkniInput>, Enumerable<TrackerUncheckedCreateWithoutKkniInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutKkniInput>
    createMany?: TrackerCreateManyKkniInputEnvelope
    connect?: Enumerable<TrackerWhereUniqueInput>
  }

  export type KonsentrasiKeahlianUpdateOneRequiredWithoutKkniNestedInput = {
    create?: XOR<KonsentrasiKeahlianCreateWithoutKkniInput, KonsentrasiKeahlianUncheckedCreateWithoutKkniInput>
    connectOrCreate?: KonsentrasiKeahlianCreateOrConnectWithoutKkniInput
    upsert?: KonsentrasiKeahlianUpsertWithoutKkniInput
    connect?: KonsentrasiKeahlianWhereUniqueInput
    update?: XOR<KonsentrasiKeahlianUpdateWithoutKkniInput, KonsentrasiKeahlianUncheckedUpdateWithoutKkniInput>
  }

  export type DudiUpdateManyWithoutKkniNestedInput = {
    create?: XOR<Enumerable<DudiCreateWithoutKkniInput>, Enumerable<DudiUncheckedCreateWithoutKkniInput>>
    connectOrCreate?: Enumerable<DudiCreateOrConnectWithoutKkniInput>
    upsert?: Enumerable<DudiUpsertWithWhereUniqueWithoutKkniInput>
    createMany?: DudiCreateManyKkniInputEnvelope
    set?: Enumerable<DudiWhereUniqueInput>
    disconnect?: Enumerable<DudiWhereUniqueInput>
    delete?: Enumerable<DudiWhereUniqueInput>
    connect?: Enumerable<DudiWhereUniqueInput>
    update?: Enumerable<DudiUpdateWithWhereUniqueWithoutKkniInput>
    updateMany?: Enumerable<DudiUpdateManyWithWhereWithoutKkniInput>
    deleteMany?: Enumerable<DudiScalarWhereInput>
  }

  export type TrackerUpdateManyWithoutKkniNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutKkniInput>, Enumerable<TrackerUncheckedCreateWithoutKkniInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutKkniInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutKkniInput>
    createMany?: TrackerCreateManyKkniInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutKkniInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutKkniInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type DudiUncheckedUpdateManyWithoutKkniNestedInput = {
    create?: XOR<Enumerable<DudiCreateWithoutKkniInput>, Enumerable<DudiUncheckedCreateWithoutKkniInput>>
    connectOrCreate?: Enumerable<DudiCreateOrConnectWithoutKkniInput>
    upsert?: Enumerable<DudiUpsertWithWhereUniqueWithoutKkniInput>
    createMany?: DudiCreateManyKkniInputEnvelope
    set?: Enumerable<DudiWhereUniqueInput>
    disconnect?: Enumerable<DudiWhereUniqueInput>
    delete?: Enumerable<DudiWhereUniqueInput>
    connect?: Enumerable<DudiWhereUniqueInput>
    update?: Enumerable<DudiUpdateWithWhereUniqueWithoutKkniInput>
    updateMany?: Enumerable<DudiUpdateManyWithWhereWithoutKkniInput>
    deleteMany?: Enumerable<DudiScalarWhereInput>
  }

  export type TrackerUncheckedUpdateManyWithoutKkniNestedInput = {
    create?: XOR<Enumerable<TrackerCreateWithoutKkniInput>, Enumerable<TrackerUncheckedCreateWithoutKkniInput>>
    connectOrCreate?: Enumerable<TrackerCreateOrConnectWithoutKkniInput>
    upsert?: Enumerable<TrackerUpsertWithWhereUniqueWithoutKkniInput>
    createMany?: TrackerCreateManyKkniInputEnvelope
    set?: Enumerable<TrackerWhereUniqueInput>
    disconnect?: Enumerable<TrackerWhereUniqueInput>
    delete?: Enumerable<TrackerWhereUniqueInput>
    connect?: Enumerable<TrackerWhereUniqueInput>
    update?: Enumerable<TrackerUpdateWithWhereUniqueWithoutKkniInput>
    updateMany?: Enumerable<TrackerUpdateManyWithWhereWithoutKkniInput>
    deleteMany?: Enumerable<TrackerScalarWhereInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedEnumPointTrackerFilter = {
    equals?: PointTracker
    in?: Enumerable<PointTracker>
    notIn?: Enumerable<PointTracker>
    not?: NestedEnumPointTrackerFilter | PointTracker
  }

  export type NestedEnumTypeTrackerFilter = {
    equals?: TypeTracker
    in?: Enumerable<TypeTracker>
    notIn?: Enumerable<TypeTracker>
    not?: NestedEnumTypeTrackerFilter | TypeTracker
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
    isSet?: boolean
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedEnumPointTrackerWithAggregatesFilter = {
    equals?: PointTracker
    in?: Enumerable<PointTracker>
    notIn?: Enumerable<PointTracker>
    not?: NestedEnumPointTrackerWithAggregatesFilter | PointTracker
    _count?: NestedIntFilter
    _min?: NestedEnumPointTrackerFilter
    _max?: NestedEnumPointTrackerFilter
  }

  export type NestedEnumTypeTrackerWithAggregatesFilter = {
    equals?: TypeTracker
    in?: Enumerable<TypeTracker>
    notIn?: Enumerable<TypeTracker>
    not?: NestedEnumTypeTrackerWithAggregatesFilter | TypeTracker
    _count?: NestedIntFilter
    _min?: NestedEnumTypeTrackerFilter
    _max?: NestedEnumTypeTrackerFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    isSet?: boolean
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
    isSet?: boolean
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type AddressWhereInput = {
    AND?: Enumerable<AddressWhereInput>
    OR?: Enumerable<AddressWhereInput>
    NOT?: Enumerable<AddressWhereInput>
    provinsi?: StringFilter | string
    kabupaten?: StringFilter | string
    kecamatan?: StringFilter | string
    kelurahan?: StringFilter | string
    kodepos?: StringFilter | string
    coordinate?: XOR<CoordinateCompositeFilter, CoordinateObjectEqualityInput>
  }

  export type CoordinateObjectEqualityInput = {
    longitude: number
    latitude: number
  }

  export type NestedEnumLevelFilter = {
    equals?: Level
    in?: Enumerable<Level>
    notIn?: Enumerable<Level>
    not?: NestedEnumLevelFilter | Level
  }

  export type NestedEnumReligionNullableFilter = {
    equals?: Religion | null
    in?: Enumerable<Religion> | null
    notIn?: Enumerable<Religion> | null
    not?: NestedEnumReligionNullableFilter | Religion | null
    isSet?: boolean
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
    isSet?: boolean
  }

  export type CoordinateOrderByInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedEnumLevelWithAggregatesFilter = {
    equals?: Level
    in?: Enumerable<Level>
    notIn?: Enumerable<Level>
    not?: NestedEnumLevelWithAggregatesFilter | Level
    _count?: NestedIntFilter
    _min?: NestedEnumLevelFilter
    _max?: NestedEnumLevelFilter
  }

  export type NestedEnumReligionNullableWithAggregatesFilter = {
    equals?: Religion | null
    in?: Enumerable<Religion> | null
    notIn?: Enumerable<Religion> | null
    not?: NestedEnumReligionNullableWithAggregatesFilter | Religion | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumReligionNullableFilter
    _max?: NestedEnumReligionNullableFilter
    isSet?: boolean
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
    isSet?: boolean
  }

  export type NestedEnumLevelNullableFilter = {
    equals?: Level | null
    in?: Enumerable<Level> | null
    notIn?: Enumerable<Level> | null
    not?: NestedEnumLevelNullableFilter | Level | null
    isSet?: boolean
  }

  export type NestedEnumMataPelajaranTypeFilter = {
    equals?: MataPelajaranType
    in?: Enumerable<MataPelajaranType>
    notIn?: Enumerable<MataPelajaranType>
    not?: NestedEnumMataPelajaranTypeFilter | MataPelajaranType
  }

  export type NestedEnumLevelNullableWithAggregatesFilter = {
    equals?: Level | null
    in?: Enumerable<Level> | null
    notIn?: Enumerable<Level> | null
    not?: NestedEnumLevelNullableWithAggregatesFilter | Level | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumLevelNullableFilter
    _max?: NestedEnumLevelNullableFilter
    isSet?: boolean
  }

  export type NestedEnumMataPelajaranTypeWithAggregatesFilter = {
    equals?: MataPelajaranType
    in?: Enumerable<MataPelajaranType>
    notIn?: Enumerable<MataPelajaranType>
    not?: NestedEnumMataPelajaranTypeWithAggregatesFilter | MataPelajaranType
    _count?: NestedIntFilter
    _min?: NestedEnumMataPelajaranTypeFilter
    _max?: NestedEnumMataPelajaranTypeFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedEnumFaseFilter = {
    equals?: Fase
    in?: Enumerable<Fase>
    notIn?: Enumerable<Fase>
    not?: NestedEnumFaseFilter | Fase
  }

  export type NestedEnumFaseWithAggregatesFilter = {
    equals?: Fase
    in?: Enumerable<Fase>
    notIn?: Enumerable<Fase>
    not?: NestedEnumFaseWithAggregatesFilter | Fase
    _count?: NestedIntFilter
    _min?: NestedEnumFaseFilter
    _max?: NestedEnumFaseFilter
  }

  export type NestedEnumRolesFilter = {
    equals?: Roles
    in?: Enumerable<Roles>
    notIn?: Enumerable<Roles>
    not?: NestedEnumRolesFilter | Roles
  }

  export type NestedEnumRolesWithAggregatesFilter = {
    equals?: Roles
    in?: Enumerable<Roles>
    notIn?: Enumerable<Roles>
    not?: NestedEnumRolesWithAggregatesFilter | Roles
    _count?: NestedIntFilter
    _min?: NestedEnumRolesFilter
    _max?: NestedEnumRolesFilter
  }

  export type GoogleWhereInput = {
    AND?: Enumerable<GoogleWhereInput>
    OR?: Enumerable<GoogleWhereInput>
    NOT?: Enumerable<GoogleWhereInput>
    scopes?: StringNullableListFilter
    tokens?: JsonFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type NestedEnumUploadTypeFilter = {
    equals?: UploadType
    in?: Enumerable<UploadType>
    notIn?: Enumerable<UploadType>
    not?: NestedEnumUploadTypeFilter | UploadType
  }

  export type NestedEnumUploadTypeWithAggregatesFilter = {
    equals?: UploadType
    in?: Enumerable<UploadType>
    notIn?: Enumerable<UploadType>
    not?: NestedEnumUploadTypeWithAggregatesFilter | UploadType
    _count?: NestedIntFilter
    _min?: NestedEnumUploadTypeFilter
    _max?: NestedEnumUploadTypeFilter
  }

  export type NestedEnumTypePersonalFilter = {
    equals?: TypePersonal
    in?: Enumerable<TypePersonal>
    notIn?: Enumerable<TypePersonal>
    not?: NestedEnumTypePersonalFilter | TypePersonal
  }

  export type NestedEnumGenderFilter = {
    equals?: Gender
    in?: Enumerable<Gender>
    notIn?: Enumerable<Gender>
    not?: NestedEnumGenderFilter | Gender
  }

  export type NestedEnumReligionFilter = {
    equals?: Religion
    in?: Enumerable<Religion>
    notIn?: Enumerable<Religion>
    not?: NestedEnumReligionFilter | Religion
  }

  export type BornWhereInput = {
    AND?: Enumerable<BornWhereInput>
    OR?: Enumerable<BornWhereInput>
    NOT?: Enumerable<BornWhereInput>
    place?: StringFilter | string
    date?: DateTimeFilter | Date | string
  }

  export type EducationWhereInput = {
    AND?: Enumerable<EducationWhereInput>
    OR?: Enumerable<EducationWhereInput>
    NOT?: Enumerable<EducationWhereInput>
    instansi?: StringFilter | string
    level?: EnumLevelEduFilter | LevelEdu
    major?: StringNullableFilter | string | null
    year?: IntFilter | number
    attachment?: StringNullableFilter | string | null
  }

  export type TrainingWhereInput = {
    AND?: Enumerable<TrainingWhereInput>
    OR?: Enumerable<TrainingWhereInput>
    NOT?: Enumerable<TrainingWhereInput>
    name?: StringFilter | string
    instansi?: StringFilter | string
    long?: IntFilter | number
    year?: IntFilter | number
    place?: StringFilter | string
    attachment?: StringNullableFilter | string | null
  }

  export type EmploymentWhereInput = {
    AND?: Enumerable<EmploymentWhereInput>
    OR?: Enumerable<EmploymentWhereInput>
    NOT?: Enumerable<EmploymentWhereInput>
    position?: StringFilter | string
    year?: IntFilter | number
    place?: StringFilter | string
    note?: StringNullableFilter | string | null
  }

  export type ProfessionWhereInput = {
    AND?: Enumerable<ProfessionWhereInput>
    OR?: Enumerable<ProfessionWhereInput>
    NOT?: Enumerable<ProfessionWhereInput>
    name?: StringFilter | string
    instansi?: StringFilter | string
    year?: IntFilter | number
    attachment?: StringNullableFilter | string | null
  }

  export type OverseasWhereInput = {
    AND?: Enumerable<OverseasWhereInput>
    OR?: Enumerable<OverseasWhereInput>
    NOT?: Enumerable<OverseasWhereInput>
    country?: StringFilter | string
    instansi?: StringFilter | string
    objective?: StringFilter | string
    long?: IntFilter | number
    year?: IntFilter | number
    attachment?: StringNullableFilter | string | null
  }

  export type ScientificWhereInput = {
    AND?: Enumerable<ScientificWhereInput>
    OR?: Enumerable<ScientificWhereInput>
    NOT?: Enumerable<ScientificWhereInput>
    name?: StringFilter | string
    instansi?: StringFilter | string
    position?: StringFilter | string
    place?: StringFilter | string
    period?: StringFilter | string
    attachment?: StringNullableFilter | string | null
  }

  export type OrganizationWhereInput = {
    AND?: Enumerable<OrganizationWhereInput>
    OR?: Enumerable<OrganizationWhereInput>
    NOT?: Enumerable<OrganizationWhereInput>
    name?: StringFilter | string
    position?: StringFilter | string
    period?: StringFilter | string
    leader?: StringFilter | string
    place?: StringFilter | string
  }

  export type PapersWhereInput = {
    AND?: Enumerable<PapersWhereInput>
    OR?: Enumerable<PapersWhereInput>
    NOT?: Enumerable<PapersWhereInput>
    name?: StringFilter | string
    year?: IntFilter | number
    published?: StringFilter | string
  }

  export type InnovationWhereInput = {
    AND?: Enumerable<InnovationWhereInput>
    OR?: Enumerable<InnovationWhereInput>
    NOT?: Enumerable<InnovationWhereInput>
    name?: StringFilter | string
    year?: IntFilter | number
    patent?: BoolFilter | boolean
  }

  export type AwardWhereInput = {
    AND?: Enumerable<AwardWhereInput>
    OR?: Enumerable<AwardWhereInput>
    NOT?: Enumerable<AwardWhereInput>
    name?: StringFilter | string
    year?: IntFilter | number
    instansi?: StringFilter | string
    attachment?: StringNullableFilter | string | null
  }

  export type SourcePersonWhereInput = {
    AND?: Enumerable<SourcePersonWhereInput>
    OR?: Enumerable<SourcePersonWhereInput>
    NOT?: Enumerable<SourcePersonWhereInput>
    name?: StringFilter | string
    date?: StringFilter | string
    instansi?: StringFilter | string
    note?: StringNullableFilter | string | null
    attachment?: StringNullableFilter | string | null
  }

  export type ContestWhereInput = {
    AND?: Enumerable<ContestWhereInput>
    OR?: Enumerable<ContestWhereInput>
    NOT?: Enumerable<ContestWhereInput>
    name?: StringFilter | string
    date?: StringFilter | string
    instansi?: StringFilter | string
    level?: StringFilter | string
    attachment?: StringNullableFilter | string | null
  }

  export type DocumentsWhereInput = {
    AND?: Enumerable<DocumentsWhereInput>
    OR?: Enumerable<DocumentsWhereInput>
    NOT?: Enumerable<DocumentsWhereInput>
    name?: StringFilter | string
    date?: StringFilter | string
    instansi?: StringFilter | string
    note?: StringNullableFilter | string | null
    attachment?: StringNullableFilter | string | null
  }

  export type AdditionalWhereInput = {
    AND?: Enumerable<AdditionalWhereInput>
    OR?: Enumerable<AdditionalWhereInput>
    NOT?: Enumerable<AdditionalWhereInput>
    position?: StringFilter | string
    date?: StringFilter | string
    instansi?: StringFilter | string
    note?: StringNullableFilter | string | null
    attachment?: StringNullableFilter | string | null
  }

  export type NestedEnumTypePersonalWithAggregatesFilter = {
    equals?: TypePersonal
    in?: Enumerable<TypePersonal>
    notIn?: Enumerable<TypePersonal>
    not?: NestedEnumTypePersonalWithAggregatesFilter | TypePersonal
    _count?: NestedIntFilter
    _min?: NestedEnumTypePersonalFilter
    _max?: NestedEnumTypePersonalFilter
  }

  export type NestedEnumGenderWithAggregatesFilter = {
    equals?: Gender
    in?: Enumerable<Gender>
    notIn?: Enumerable<Gender>
    not?: NestedEnumGenderWithAggregatesFilter | Gender
    _count?: NestedIntFilter
    _min?: NestedEnumGenderFilter
    _max?: NestedEnumGenderFilter
  }

  export type NestedEnumReligionWithAggregatesFilter = {
    equals?: Religion
    in?: Enumerable<Religion>
    notIn?: Enumerable<Religion>
    not?: NestedEnumReligionWithAggregatesFilter | Religion
    _count?: NestedIntFilter
    _min?: NestedEnumReligionFilter
    _max?: NestedEnumReligionFilter
  }

  export type NestedEnumChildTypeFilter = {
    equals?: ChildType
    in?: Enumerable<ChildType>
    notIn?: Enumerable<ChildType>
    not?: NestedEnumChildTypeFilter | ChildType
  }

  export type NestedEnumChildTypeWithAggregatesFilter = {
    equals?: ChildType
    in?: Enumerable<ChildType>
    notIn?: Enumerable<ChildType>
    not?: NestedEnumChildTypeWithAggregatesFilter | ChildType
    _count?: NestedIntFilter
    _min?: NestedEnumChildTypeFilter
    _max?: NestedEnumChildTypeFilter
  }

  export type OrganizationalWhereInput = {
    AND?: Enumerable<OrganizationalWhereInput>
    OR?: Enumerable<OrganizationalWhereInput>
    NOT?: Enumerable<OrganizationalWhereInput>
    kepsek?: StringFilter | string
    wakasek?: StringFilter | string
    wakakur?: StringFilter | string
    wakasiw?: StringFilter | string
    wakapra?: StringFilter | string
    wakahum?: StringNullableFilter | string | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    isSet?: boolean
  }

  export type RoomPropertyWhereInput = {
    AND?: Enumerable<RoomPropertyWhereInput>
    OR?: Enumerable<RoomPropertyWhereInput>
    NOT?: Enumerable<RoomPropertyWhereInput>
    pkl?: BoolNullableFilter | boolean | null
  }

  export type NestedEnumSemesterFilter = {
    equals?: Semester
    in?: Enumerable<Semester>
    notIn?: Enumerable<Semester>
    not?: NestedEnumSemesterFilter | Semester
  }

  export type NestedEnumSemesterWithAggregatesFilter = {
    equals?: Semester
    in?: Enumerable<Semester>
    notIn?: Enumerable<Semester>
    not?: NestedEnumSemesterWithAggregatesFilter | Semester
    _count?: NestedIntFilter
    _min?: NestedEnumSemesterFilter
    _max?: NestedEnumSemesterFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    isSet?: boolean
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
    isSet?: boolean
  }

  export type NestedEnumOMaterialModelFilter = {
    equals?: OMaterialModel
    in?: Enumerable<OMaterialModel>
    notIn?: Enumerable<OMaterialModel>
    not?: NestedEnumOMaterialModelFilter | OMaterialModel
  }

  export type NestedEnumOMaterialModelWithAggregatesFilter = {
    equals?: OMaterialModel
    in?: Enumerable<OMaterialModel>
    notIn?: Enumerable<OMaterialModel>
    not?: NestedEnumOMaterialModelWithAggregatesFilter | OMaterialModel
    _count?: NestedIntFilter
    _min?: NestedEnumOMaterialModelFilter
    _max?: NestedEnumOMaterialModelFilter
  }

  export type NestedEnumTaksonomiFilter = {
    equals?: Taksonomi
    in?: Enumerable<Taksonomi>
    notIn?: Enumerable<Taksonomi>
    not?: NestedEnumTaksonomiFilter | Taksonomi
  }

  export type NestedEnumTaksonomiWithAggregatesFilter = {
    equals?: Taksonomi
    in?: Enumerable<Taksonomi>
    notIn?: Enumerable<Taksonomi>
    not?: NestedEnumTaksonomiWithAggregatesFilter | Taksonomi
    _count?: NestedIntFilter
    _min?: NestedEnumTaksonomiFilter
    _max?: NestedEnumTaksonomiFilter
  }

  export type NestedEnumOhelperTypeFilter = {
    equals?: OhelperType
    in?: Enumerable<OhelperType>
    notIn?: Enumerable<OhelperType>
    not?: NestedEnumOhelperTypeFilter | OhelperType
  }

  export type NestedEnumOhelperTypeWithAggregatesFilter = {
    equals?: OhelperType
    in?: Enumerable<OhelperType>
    notIn?: Enumerable<OhelperType>
    not?: NestedEnumOhelperTypeWithAggregatesFilter | OhelperType
    _count?: NestedIntFilter
    _min?: NestedEnumOhelperTypeFilter
    _max?: NestedEnumOhelperTypeFilter
  }

  export type NestedEnumOresourceTypeFilter = {
    equals?: OresourceType
    in?: Enumerable<OresourceType>
    notIn?: Enumerable<OresourceType>
    not?: NestedEnumOresourceTypeFilter | OresourceType
  }

  export type NestedEnumOresourceTypeWithAggregatesFilter = {
    equals?: OresourceType
    in?: Enumerable<OresourceType>
    notIn?: Enumerable<OresourceType>
    not?: NestedEnumOresourceTypeWithAggregatesFilter | OresourceType
    _count?: NestedIntFilter
    _min?: NestedEnumOresourceTypeFilter
    _max?: NestedEnumOresourceTypeFilter
  }

  export type TDevicePropsWhereInput = {
    AND?: Enumerable<TDevicePropsWhereInput>
    OR?: Enumerable<TDevicePropsWhereInput>
    NOT?: Enumerable<TDevicePropsWhereInput>
    docDate?: DateTimeFilter | Date | string
    docAddr?: StringFilter | string
    kepText?: StringFilter | string
    kepUser?: StringFilter | string
    ke3Text?: StringFilter | string
    jabText?: StringFilter | string
    ke3User?: StringFilter | string
  }

  export type TDevicePosWhereInput = {
    AND?: Enumerable<TDevicePosWhereInput>
    OR?: Enumerable<TDevicePosWhereInput>
    NOT?: Enumerable<TDevicePosWhereInput>
    mouth?: IntFilter | number
    week?: IntFilter | number
    active?: BoolFilter | boolean
  }

  export type ContactDudiWhereInput = {
    AND?: Enumerable<ContactDudiWhereInput>
    OR?: Enumerable<ContactDudiWhereInput>
    NOT?: Enumerable<ContactDudiWhereInput>
    name?: StringFilter | string
    position?: StringFilter | string
    email?: StringFilter | string
    phone?: StringFilter | string
  }

  export type DudiTimeWorkWhereInput = {
    AND?: Enumerable<DudiTimeWorkWhereInput>
    OR?: Enumerable<DudiTimeWorkWhereInput>
    NOT?: Enumerable<DudiTimeWorkWhereInput>
    holidays?: StringNullableListFilter
    timeIn?: StringFilter | string
    timeOut?: StringFilter | string
    actifity?: BoolFilter | boolean
  }

  export type DudiIndicatorWhereInput = {
    AND?: Enumerable<DudiIndicatorWhereInput>
    OR?: Enumerable<DudiIndicatorWhereInput>
    NOT?: Enumerable<DudiIndicatorWhereInput>
    no?: IntFilter | number
    code?: StringFilter | string
    name?: StringFilter | string
  }

  export type UserCreateWithoutTrackerInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    disable?: boolean
    google?: XOR<GoogleNullableCreateEnvelopeInput, GoogleCreateInput> | null
    role?: RoleCreateNestedOneWithoutUsersInput
    auth?: AuthCreateNestedOneWithoutUserInput
    objective?: ObjectiveCreateNestedManyWithoutUserInput
    link?: LinkCreateNestedManyWithoutUserInput
    tDevice?: TDeviceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTrackerInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    roleId?: string | null
    disable?: boolean
    google?: XOR<GoogleNullableCreateEnvelopeInput, GoogleCreateInput> | null
    auth?: AuthUncheckedCreateNestedOneWithoutUserInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutUserInput
    link?: LinkUncheckedCreateNestedManyWithoutUserInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTrackerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTrackerInput, UserUncheckedCreateWithoutTrackerInput>
  }

  export type InstansiCreateWithoutHistoryInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    disable?: boolean
    majors?: KonsentrasiKeahlianCreateNestedManyWithoutInstansiInput
    role?: RoleCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearCreateNestedManyWithoutInstansiInput
    teacher?: TeacherCreateNestedManyWithoutInstansiInput
    student?: StudentCreateNestedManyWithoutInstansiInput
    tracker?: TrackerCreateNestedManyWithoutInstansiInput
    unikMapels?: MataPelajaranCreateNestedManyWithoutInstansiInput
    tDevice?: TDeviceCreateNestedManyWithoutInstansiInput
    objective?: ObjectiveCreateNestedManyWithoutInstansiInput
    dudi?: DudiCreateNestedManyWithoutInstansiInput
  }

  export type InstansiUncheckedCreateWithoutHistoryInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    majorIds?: InstansiCreatemajorIdsInput | Enumerable<string>
    disable?: boolean
    majors?: KonsentrasiKeahlianUncheckedCreateNestedManyWithoutInstansiInput
    role?: RoleUncheckedCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearUncheckedCreateNestedManyWithoutInstansiInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutInstansiInput
    student?: StudentUncheckedCreateNestedManyWithoutInstansiInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutInstansiInput
    unikMapels?: MataPelajaranUncheckedCreateNestedManyWithoutInstansiInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutInstansiInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutInstansiInput
    dudi?: DudiUncheckedCreateNestedManyWithoutInstansiInput
  }

  export type InstansiCreateOrConnectWithoutHistoryInput = {
    where: InstansiWhereUniqueInput
    create: XOR<InstansiCreateWithoutHistoryInput, InstansiUncheckedCreateWithoutHistoryInput>
  }

  export type InstansiCreateWithoutTrackerInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    disable?: boolean
    majors?: KonsentrasiKeahlianCreateNestedManyWithoutInstansiInput
    role?: RoleCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearCreateNestedManyWithoutInstansiInput
    teacher?: TeacherCreateNestedManyWithoutInstansiInput
    student?: StudentCreateNestedManyWithoutInstansiInput
    history?: TrackerCreateNestedManyWithoutRefInput
    unikMapels?: MataPelajaranCreateNestedManyWithoutInstansiInput
    tDevice?: TDeviceCreateNestedManyWithoutInstansiInput
    objective?: ObjectiveCreateNestedManyWithoutInstansiInput
    dudi?: DudiCreateNestedManyWithoutInstansiInput
  }

  export type InstansiUncheckedCreateWithoutTrackerInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    majorIds?: InstansiCreatemajorIdsInput | Enumerable<string>
    disable?: boolean
    majors?: KonsentrasiKeahlianUncheckedCreateNestedManyWithoutInstansiInput
    role?: RoleUncheckedCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearUncheckedCreateNestedManyWithoutInstansiInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutInstansiInput
    student?: StudentUncheckedCreateNestedManyWithoutInstansiInput
    history?: TrackerUncheckedCreateNestedManyWithoutRefInput
    unikMapels?: MataPelajaranUncheckedCreateNestedManyWithoutInstansiInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutInstansiInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutInstansiInput
    dudi?: DudiUncheckedCreateNestedManyWithoutInstansiInput
  }

  export type InstansiCreateOrConnectWithoutTrackerInput = {
    where: InstansiWhereUniqueInput
    create: XOR<InstansiCreateWithoutTrackerInput, InstansiUncheckedCreateWithoutTrackerInput>
  }

  export type MataPelajaranCreateWithoutTrackerInput = {
    id?: string
    level?: Level | null
    type?: MataPelajaranType
    no: string
    code: string
    name: string
    religion?: Religion | null
    disable?: boolean
    program?: ProgramKeahlianCreateNestedOneWithoutMapelInput
    keahlian?: KonsentrasiKeahlianCreateNestedOneWithoutMapelInput
    instansi?: InstansiCreateNestedOneWithoutUnikMapelsInput
    element?: ElementCreateNestedManyWithoutMapelInput
    schedule?: ScheduleCreateNestedManyWithoutMapelInput
    objective?: ObjectiveCreateNestedManyWithoutMapelInput
    device?: TDeviceCreateNestedManyWithoutMapelInput
  }

  export type MataPelajaranUncheckedCreateWithoutTrackerInput = {
    id?: string
    level?: Level | null
    type?: MataPelajaranType
    no: string
    code: string
    name: string
    religion?: Religion | null
    programId?: string | null
    keahlianid?: string | null
    instansiId?: string | null
    disable?: boolean
    element?: ElementUncheckedCreateNestedManyWithoutMapelInput
    schedule?: ScheduleUncheckedCreateNestedManyWithoutMapelInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutMapelInput
    device?: TDeviceUncheckedCreateNestedManyWithoutMapelInput
  }

  export type MataPelajaranCreateOrConnectWithoutTrackerInput = {
    where: MataPelajaranWhereUniqueInput
    create: XOR<MataPelajaranCreateWithoutTrackerInput, MataPelajaranUncheckedCreateWithoutTrackerInput>
  }

  export type ElementCreateWithoutTrackerInput = {
    id?: string
    no: number
    name: string
    description: string
    disable?: boolean
    achievement?: AchievementCreateNestedManyWithoutElementInput
    mapel: MataPelajaranCreateNestedOneWithoutElementInput
    scheduleClass?: TeachingCreateNestedManyWithoutElemenInput
    objective?: ObjectiveCreateNestedManyWithoutElemenInput
  }

  export type ElementUncheckedCreateWithoutTrackerInput = {
    id?: string
    no: number
    name: string
    description: string
    mapelId: string
    disable?: boolean
    scheduleClassIds?: ElementCreatescheduleClassIdsInput | Enumerable<string>
    achievement?: AchievementUncheckedCreateNestedManyWithoutElementInput
    scheduleClass?: TeachingUncheckedCreateNestedManyWithoutElemenInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutElemenInput
  }

  export type ElementCreateOrConnectWithoutTrackerInput = {
    where: ElementWhereUniqueInput
    create: XOR<ElementCreateWithoutTrackerInput, ElementUncheckedCreateWithoutTrackerInput>
  }

  export type AchievementCreateWithoutTrackerInput = {
    id?: string
    no: number
    fase?: Fase
    description: string
    disable?: boolean
    element: ElementCreateNestedOneWithoutAchievementInput
    objective?: ObjectiveCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUncheckedCreateWithoutTrackerInput = {
    id?: string
    no: number
    fase?: Fase
    description: string
    elementId: string
    disable?: boolean
    objective?: ObjectiveUncheckedCreateNestedManyWithoutAchievementInput
  }

  export type AchievementCreateOrConnectWithoutTrackerInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutTrackerInput, AchievementUncheckedCreateWithoutTrackerInput>
  }

  export type BidangKeahlianCreateWithoutTrackerInput = {
    id?: string
    code: string
    name: string
    disable?: boolean
    program?: ProgramKeahlianCreateNestedManyWithoutBidangInput
  }

  export type BidangKeahlianUncheckedCreateWithoutTrackerInput = {
    id?: string
    code: string
    name: string
    disable?: boolean
    program?: ProgramKeahlianUncheckedCreateNestedManyWithoutBidangInput
  }

  export type BidangKeahlianCreateOrConnectWithoutTrackerInput = {
    where: BidangKeahlianWhereUniqueInput
    create: XOR<BidangKeahlianCreateWithoutTrackerInput, BidangKeahlianUncheckedCreateWithoutTrackerInput>
  }

  export type ProgramKeahlianCreateWithoutTrackerInput = {
    id?: string
    code: string
    name: string
    disable?: boolean
    bidang: BidangKeahlianCreateNestedOneWithoutProgramInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedManyWithoutProgramInput
    mapel?: MataPelajaranCreateNestedManyWithoutProgramInput
  }

  export type ProgramKeahlianUncheckedCreateWithoutTrackerInput = {
    id?: string
    code: string
    name: string
    bidangId: string
    disable?: boolean
    konsentrasi?: KonsentrasiKeahlianUncheckedCreateNestedManyWithoutProgramInput
    mapel?: MataPelajaranUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramKeahlianCreateOrConnectWithoutTrackerInput = {
    where: ProgramKeahlianWhereUniqueInput
    create: XOR<ProgramKeahlianCreateWithoutTrackerInput, ProgramKeahlianUncheckedCreateWithoutTrackerInput>
  }

  export type KonsentrasiKeahlianCreateWithoutTrackerInput = {
    id?: string
    code: string
    name: string
    tahun: number
    disable?: boolean
    program: ProgramKeahlianCreateNestedOneWithoutKonsentrasiInput
    student?: StudentCreateNestedManyWithoutMajorInput
    instansi?: InstansiCreateNestedManyWithoutMajorsInput
    classRoom?: ClassRoomCreateNestedManyWithoutMajorInput
    mapel?: MataPelajaranCreateNestedManyWithoutKeahlianInput
    dudi?: DudiCreateNestedManyWithoutMajorInput
    kkni?: KkniCreateNestedManyWithoutKonsentrasiInput
  }

  export type KonsentrasiKeahlianUncheckedCreateWithoutTrackerInput = {
    id?: string
    code: string
    name: string
    programId: string
    tahun: number
    instansiIds?: KonsentrasiKeahlianCreateinstansiIdsInput | Enumerable<string>
    disable?: boolean
    student?: StudentUncheckedCreateNestedManyWithoutMajorInput
    instansi?: InstansiUncheckedCreateNestedManyWithoutMajorsInput
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutMajorInput
    mapel?: MataPelajaranUncheckedCreateNestedManyWithoutKeahlianInput
    dudi?: DudiUncheckedCreateNestedManyWithoutMajorInput
    kkni?: KkniUncheckedCreateNestedManyWithoutKonsentrasiInput
  }

  export type KonsentrasiKeahlianCreateOrConnectWithoutTrackerInput = {
    where: KonsentrasiKeahlianWhereUniqueInput
    create: XOR<KonsentrasiKeahlianCreateWithoutTrackerInput, KonsentrasiKeahlianUncheckedCreateWithoutTrackerInput>
  }

  export type SchoolYearCreateWithoutTrackerInput = {
    id?: string
    year: number
    departments?: SchoolYearCreatedepartmentsInput | Enumerable<string>
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    disable?: boolean
    instansi: InstansiCreateNestedOneWithoutSchoolYearInput
    classRoom?: ClassRoomCreateNestedManyWithoutYearInput
    students?: StudentCreateNestedManyWithoutStartYearInput
    calendar?: CalendarCreateNestedManyWithoutRefInput
    schedule?: ScheduleCreateNestedManyWithoutYearInput
    objective?: ObjectiveCreateNestedManyWithoutYearInput
    TDevice?: TDeviceCreateNestedManyWithoutYearInput
  }

  export type SchoolYearUncheckedCreateWithoutTrackerInput = {
    id?: string
    year: number
    instansiId: string
    departments?: SchoolYearCreatedepartmentsInput | Enumerable<string>
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutYearInput
    students?: StudentUncheckedCreateNestedManyWithoutStartYearInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutRefInput
    schedule?: ScheduleUncheckedCreateNestedManyWithoutYearInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutYearInput
    TDevice?: TDeviceUncheckedCreateNestedManyWithoutYearInput
  }

  export type SchoolYearCreateOrConnectWithoutTrackerInput = {
    where: SchoolYearWhereUniqueInput
    create: XOR<SchoolYearCreateWithoutTrackerInput, SchoolYearUncheckedCreateWithoutTrackerInput>
  }

  export type TeacherCreateWithoutTrackerInput = {
    id?: string
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: Date | string | null
    tmtGol?: Date | string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    disable?: boolean
    personal: PersonalCreateNestedOneWithoutTeacherInput
    classRoom?: ClassRoomCreateNestedManyWithoutWaliInput
    instansi: InstansiCreateNestedOneWithoutTeacherInput
    event?: CalendarCreateNestedManyWithoutTeacherInput
    teaching?: TeachingCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutTrackerInput = {
    id?: string
    personalId: string
    instansiId: string
    eventIds?: TeacherCreateeventIdsInput | Enumerable<string>
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: Date | string | null
    tmtGol?: Date | string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutWaliInput
    event?: CalendarUncheckedCreateNestedManyWithoutTeacherInput
    teaching?: TeachingUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutTrackerInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutTrackerInput, TeacherUncheckedCreateWithoutTrackerInput>
  }

  export type ClassRoomCreateWithoutTrackerInput = {
    id?: string
    name: string
    level: number
    property?: XOR<RoomPropertyNullableCreateEnvelopeInput, RoomPropertyCreateInput> | null
    disable?: boolean
    year: SchoolYearCreateNestedOneWithoutClassRoomInput
    wali: TeacherCreateNestedOneWithoutClassRoomInput
    major?: KonsentrasiKeahlianCreateNestedOneWithoutClassRoomInput
    students?: StudentCreateNestedManyWithoutClassRoomInput
    event?: CalendarCreateNestedManyWithoutClassRoomInput
    teaching?: TeachingCreateNestedManyWithoutClassRoomInput
    tDevice?: TDeviceCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomUncheckedCreateWithoutTrackerInput = {
    id?: string
    name: string
    yearId: string
    waliId: string
    level: number
    property?: XOR<RoomPropertyNullableCreateEnvelopeInput, RoomPropertyCreateInput> | null
    majorId?: string | null
    studentIds?: ClassRoomCreatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomCreateeventIdsInput | Enumerable<string>
    disable?: boolean
    teachingIds?: ClassRoomCreateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomCreatetDeviceIdsInput | Enumerable<string>
    students?: StudentUncheckedCreateNestedManyWithoutClassRoomInput
    event?: CalendarUncheckedCreateNestedManyWithoutClassRoomInput
    teaching?: TeachingUncheckedCreateNestedManyWithoutClassRoomInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomCreateOrConnectWithoutTrackerInput = {
    where: ClassRoomWhereUniqueInput
    create: XOR<ClassRoomCreateWithoutTrackerInput, ClassRoomUncheckedCreateWithoutTrackerInput>
  }

  export type StudentCreateWithoutTrackerInput = {
    id?: string
    nis: string
    lastSchool: string
    disable?: boolean
    personal: PersonalCreateNestedOneWithoutStudentInput
    major?: KonsentrasiKeahlianCreateNestedOneWithoutStudentInput
    classRoom?: ClassRoomCreateNestedManyWithoutStudentsInput
    startYear: SchoolYearCreateNestedOneWithoutStudentsInput
    instansi: InstansiCreateNestedOneWithoutStudentInput
    event?: CalendarCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutTrackerInput = {
    id?: string
    nis: string
    lastSchool: string
    personalId: string
    majorId?: string | null
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    startYearId: string
    instansiId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutStudentsInput
    event?: CalendarUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutTrackerInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutTrackerInput, StudentUncheckedCreateWithoutTrackerInput>
  }

  export type ScheduleCreateWithoutTrackerInput = {
    id?: string
    disable?: boolean
    year: SchoolYearCreateNestedOneWithoutScheduleInput
    mapel: MataPelajaranCreateNestedOneWithoutScheduleInput
    teaching?: TeachingCreateNestedManyWithoutRefInput
  }

  export type ScheduleUncheckedCreateWithoutTrackerInput = {
    id?: string
    yearId: string
    mapelId: string
    disable?: boolean
    teaching?: TeachingUncheckedCreateNestedManyWithoutRefInput
  }

  export type ScheduleCreateOrConnectWithoutTrackerInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutTrackerInput, ScheduleUncheckedCreateWithoutTrackerInput>
  }

  export type TeachingCreateWithoutTrackerInput = {
    id?: string
    level: number
    hours: number
    semester: Semester
    disable?: boolean
    ref: ScheduleCreateNestedOneWithoutTeachingInput
    teacher: TeacherCreateNestedOneWithoutTeachingInput
    classRoom?: ClassRoomCreateNestedManyWithoutTeachingInput
    elemen?: ElementCreateNestedManyWithoutScheduleClassInput
    tDevice?: TDeviceCreateNestedManyWithoutTeachingInput
  }

  export type TeachingUncheckedCreateWithoutTrackerInput = {
    id?: string
    refId: string
    level: number
    hours: number
    semester: Semester
    teacherId: string
    classRoomIds?: TeachingCreateclassRoomIdsInput | Enumerable<string>
    elemenIds?: TeachingCreateelemenIdsInput | Enumerable<string>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutTeachingInput
    elemen?: ElementUncheckedCreateNestedManyWithoutScheduleClassInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutTeachingInput
  }

  export type TeachingCreateOrConnectWithoutTrackerInput = {
    where: TeachingWhereUniqueInput
    create: XOR<TeachingCreateWithoutTrackerInput, TeachingUncheckedCreateWithoutTrackerInput>
  }

  export type ObjectiveCreateWithoutTrackerInput = {
    id?: string
    level: number
    fase: Fase
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    user: UserCreateNestedOneWithoutObjectiveInput
    instansi: InstansiCreateNestedOneWithoutObjectiveInput
    year: SchoolYearCreateNestedOneWithoutObjectiveInput
    mapel: MataPelajaranCreateNestedOneWithoutObjectiveInput
    elemen: ElementCreateNestedOneWithoutObjectiveInput
    achievement: AchievementCreateNestedOneWithoutObjectiveInput
    material?: OMaterialCreateNestedManyWithoutRefInput
    resourse?: OresourceCreateNestedManyWithoutRefInput
    ppp?: OpppCreateNestedManyWithoutRefInput
    tool?: OhelperCreateNestedManyWithoutToolInput
    mate?: OhelperCreateNestedManyWithoutMateInput
    meth?: OhelperCreateNestedManyWithoutMethInput
    media?: OhelperCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentCreateNestedManyWithoutRefInput
    devices?: TDeviceDataCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveUncheckedCreateWithoutTrackerInput = {
    id?: string
    level: number
    fase: Fase
    userId: string
    instansiId: string
    yearId: string
    mapelId: string
    elementId: string
    achievementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedCreateNestedManyWithoutRefInput
    resourse?: OresourceUncheckedCreateNestedManyWithoutRefInput
    ppp?: OpppUncheckedCreateNestedManyWithoutRefInput
    tool?: OhelperUncheckedCreateNestedManyWithoutToolInput
    mate?: OhelperUncheckedCreateNestedManyWithoutMateInput
    meth?: OhelperUncheckedCreateNestedManyWithoutMethInput
    media?: OhelperUncheckedCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentUncheckedCreateNestedManyWithoutRefInput
    devices?: TDeviceDataUncheckedCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveCreateOrConnectWithoutTrackerInput = {
    where: ObjectiveWhereUniqueInput
    create: XOR<ObjectiveCreateWithoutTrackerInput, ObjectiveUncheckedCreateWithoutTrackerInput>
  }

  export type TDeviceCreateWithoutTrackerInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    teaching: TeachingCreateNestedOneWithoutTDeviceInput
    year: SchoolYearCreateNestedOneWithoutTDeviceInput
    user: UserCreateNestedOneWithoutTDeviceInput
    instansi: InstansiCreateNestedOneWithoutTDeviceInput
    mapel: MataPelajaranCreateNestedOneWithoutDeviceInput
    classRoom?: ClassRoomCreateNestedManyWithoutTDeviceInput
    data?: TDeviceDataCreateNestedManyWithoutRefInput
    children?: TDeviceCreateNestedManyWithoutParentInput
    parent?: TDeviceCreateNestedOneWithoutChildrenInput
  }

  export type TDeviceUncheckedCreateWithoutTrackerInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    teachingId: string
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    yearId: string
    userId: string
    instansiId: string
    mapelId: string
    classRoomIds?: TDeviceCreateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    parentId?: string | null
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutTDeviceInput
    data?: TDeviceDataUncheckedCreateNestedManyWithoutRefInput
    children?: TDeviceUncheckedCreateNestedManyWithoutParentInput
  }

  export type TDeviceCreateOrConnectWithoutTrackerInput = {
    where: TDeviceWhereUniqueInput
    create: XOR<TDeviceCreateWithoutTrackerInput, TDeviceUncheckedCreateWithoutTrackerInput>
  }

  export type CalendarCreateWithoutTrackerInput = {
    id?: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    disable?: boolean
    ref: SchoolYearCreateNestedOneWithoutCalendarInput
    classRoom?: ClassRoomCreateNestedManyWithoutEventInput
    student?: StudentCreateNestedManyWithoutEventInput
    teacher?: TeacherCreateNestedManyWithoutEventInput
  }

  export type CalendarUncheckedCreateWithoutTrackerInput = {
    id?: string
    refId: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    classRoomIds?: CalendarCreateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarCreatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarCreateteacherIdsInput | Enumerable<string>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutEventInput
    student?: StudentUncheckedCreateNestedManyWithoutEventInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutEventInput
  }

  export type CalendarCreateOrConnectWithoutTrackerInput = {
    where: CalendarWhereUniqueInput
    create: XOR<CalendarCreateWithoutTrackerInput, CalendarUncheckedCreateWithoutTrackerInput>
  }

  export type DudiCreateWithoutTrackerInput = {
    id?: string
    name: string
    street: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    contact: XOR<ContactDudiCreateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiCreatecollabsInput | Enumerable<string>
    timework: XOR<DudiTimeWorkCreateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: boolean
    instansi: InstansiCreateNestedOneWithoutDudiInput
    major: KonsentrasiKeahlianCreateNestedOneWithoutDudiInput
    learning?: DudiLearningCreateNestedManyWithoutRefInput
    kkni?: KkniCreateNestedOneWithoutDudiInput
  }

  export type DudiUncheckedCreateWithoutTrackerInput = {
    id?: string
    name: string
    street: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    instansiId: string
    majorId: string
    contact: XOR<ContactDudiCreateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiCreatecollabsInput | Enumerable<string>
    timework: XOR<DudiTimeWorkCreateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: boolean
    kkniId?: string | null
    learning?: DudiLearningUncheckedCreateNestedManyWithoutRefInput
  }

  export type DudiCreateOrConnectWithoutTrackerInput = {
    where: DudiWhereUniqueInput
    create: XOR<DudiCreateWithoutTrackerInput, DudiUncheckedCreateWithoutTrackerInput>
  }

  export type KkniCreateWithoutTrackerInput = {
    id?: string
    no: number
    code: string
    name: string
    description?: string | null
    disable?: boolean
    konsentrasi: KonsentrasiKeahlianCreateNestedOneWithoutKkniInput
    dudi?: DudiCreateNestedManyWithoutKkniInput
  }

  export type KkniUncheckedCreateWithoutTrackerInput = {
    id?: string
    konsentrasiId: string
    no: number
    code: string
    name: string
    description?: string | null
    disable?: boolean
    dudi?: DudiUncheckedCreateNestedManyWithoutKkniInput
  }

  export type KkniCreateOrConnectWithoutTrackerInput = {
    where: KkniWhereUniqueInput
    create: XOR<KkniCreateWithoutTrackerInput, KkniUncheckedCreateWithoutTrackerInput>
  }

  export type UserUpsertWithoutTrackerInput = {
    update: XOR<UserUpdateWithoutTrackerInput, UserUncheckedUpdateWithoutTrackerInput>
    create: XOR<UserCreateWithoutTrackerInput, UserUncheckedCreateWithoutTrackerInput>
  }

  export type UserUpdateWithoutTrackerInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    google?: XOR<GoogleNullableUpdateEnvelopeInput, GoogleCreateInput> | null
    role?: RoleUpdateOneWithoutUsersNestedInput
    auth?: AuthUpdateOneWithoutUserNestedInput
    objective?: ObjectiveUpdateManyWithoutUserNestedInput
    link?: LinkUpdateManyWithoutUserNestedInput
    tDevice?: TDeviceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTrackerInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    google?: XOR<GoogleNullableUpdateEnvelopeInput, GoogleCreateInput> | null
    auth?: AuthUncheckedUpdateOneWithoutUserNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutUserNestedInput
    link?: LinkUncheckedUpdateManyWithoutUserNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InstansiUpsertWithoutHistoryInput = {
    update: XOR<InstansiUpdateWithoutHistoryInput, InstansiUncheckedUpdateWithoutHistoryInput>
    create: XOR<InstansiCreateWithoutHistoryInput, InstansiUncheckedCreateWithoutHistoryInput>
  }

  export type InstansiUpdateWithoutHistoryInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    majors?: KonsentrasiKeahlianUpdateManyWithoutInstansiNestedInput
    role?: RoleUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUpdateManyWithoutInstansiNestedInput
    student?: StudentUpdateManyWithoutInstansiNestedInput
    tracker?: TrackerUpdateManyWithoutInstansiNestedInput
    unikMapels?: MataPelajaranUpdateManyWithoutInstansiNestedInput
    tDevice?: TDeviceUpdateManyWithoutInstansiNestedInput
    objective?: ObjectiveUpdateManyWithoutInstansiNestedInput
    dudi?: DudiUpdateManyWithoutInstansiNestedInput
  }

  export type InstansiUncheckedUpdateWithoutHistoryInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    majorIds?: InstansiUpdatemajorIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    majors?: KonsentrasiKeahlianUncheckedUpdateManyWithoutInstansiNestedInput
    role?: RoleUncheckedUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUncheckedUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutInstansiNestedInput
    student?: StudentUncheckedUpdateManyWithoutInstansiNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutInstansiNestedInput
    unikMapels?: MataPelajaranUncheckedUpdateManyWithoutInstansiNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutInstansiNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutInstansiNestedInput
    dudi?: DudiUncheckedUpdateManyWithoutInstansiNestedInput
  }

  export type InstansiUpsertWithoutTrackerInput = {
    update: XOR<InstansiUpdateWithoutTrackerInput, InstansiUncheckedUpdateWithoutTrackerInput>
    create: XOR<InstansiCreateWithoutTrackerInput, InstansiUncheckedCreateWithoutTrackerInput>
  }

  export type InstansiUpdateWithoutTrackerInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    majors?: KonsentrasiKeahlianUpdateManyWithoutInstansiNestedInput
    role?: RoleUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUpdateManyWithoutInstansiNestedInput
    student?: StudentUpdateManyWithoutInstansiNestedInput
    history?: TrackerUpdateManyWithoutRefNestedInput
    unikMapels?: MataPelajaranUpdateManyWithoutInstansiNestedInput
    tDevice?: TDeviceUpdateManyWithoutInstansiNestedInput
    objective?: ObjectiveUpdateManyWithoutInstansiNestedInput
    dudi?: DudiUpdateManyWithoutInstansiNestedInput
  }

  export type InstansiUncheckedUpdateWithoutTrackerInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    majorIds?: InstansiUpdatemajorIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    majors?: KonsentrasiKeahlianUncheckedUpdateManyWithoutInstansiNestedInput
    role?: RoleUncheckedUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUncheckedUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutInstansiNestedInput
    student?: StudentUncheckedUpdateManyWithoutInstansiNestedInput
    history?: TrackerUncheckedUpdateManyWithoutRefNestedInput
    unikMapels?: MataPelajaranUncheckedUpdateManyWithoutInstansiNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutInstansiNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutInstansiNestedInput
    dudi?: DudiUncheckedUpdateManyWithoutInstansiNestedInput
  }

  export type MataPelajaranUpsertWithoutTrackerInput = {
    update: XOR<MataPelajaranUpdateWithoutTrackerInput, MataPelajaranUncheckedUpdateWithoutTrackerInput>
    create: XOR<MataPelajaranCreateWithoutTrackerInput, MataPelajaranUncheckedCreateWithoutTrackerInput>
  }

  export type MataPelajaranUpdateWithoutTrackerInput = {
    level?: NullableEnumLevelFieldUpdateOperationsInput | Level | null
    type?: EnumMataPelajaranTypeFieldUpdateOperationsInput | MataPelajaranType
    no?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    program?: ProgramKeahlianUpdateOneWithoutMapelNestedInput
    keahlian?: KonsentrasiKeahlianUpdateOneWithoutMapelNestedInput
    instansi?: InstansiUpdateOneWithoutUnikMapelsNestedInput
    element?: ElementUpdateManyWithoutMapelNestedInput
    schedule?: ScheduleUpdateManyWithoutMapelNestedInput
    objective?: ObjectiveUpdateManyWithoutMapelNestedInput
    device?: TDeviceUpdateManyWithoutMapelNestedInput
  }

  export type MataPelajaranUncheckedUpdateWithoutTrackerInput = {
    level?: NullableEnumLevelFieldUpdateOperationsInput | Level | null
    type?: EnumMataPelajaranTypeFieldUpdateOperationsInput | MataPelajaranType
    no?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    keahlianid?: NullableStringFieldUpdateOperationsInput | string | null
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    element?: ElementUncheckedUpdateManyWithoutMapelNestedInput
    schedule?: ScheduleUncheckedUpdateManyWithoutMapelNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutMapelNestedInput
    device?: TDeviceUncheckedUpdateManyWithoutMapelNestedInput
  }

  export type ElementUpsertWithoutTrackerInput = {
    update: XOR<ElementUpdateWithoutTrackerInput, ElementUncheckedUpdateWithoutTrackerInput>
    create: XOR<ElementCreateWithoutTrackerInput, ElementUncheckedCreateWithoutTrackerInput>
  }

  export type ElementUpdateWithoutTrackerInput = {
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    achievement?: AchievementUpdateManyWithoutElementNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutElementNestedInput
    scheduleClass?: TeachingUpdateManyWithoutElemenNestedInput
    objective?: ObjectiveUpdateManyWithoutElemenNestedInput
  }

  export type ElementUncheckedUpdateWithoutTrackerInput = {
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    scheduleClassIds?: ElementUpdatescheduleClassIdsInput | Enumerable<string>
    achievement?: AchievementUncheckedUpdateManyWithoutElementNestedInput
    scheduleClass?: TeachingUncheckedUpdateManyWithoutElemenNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutElemenNestedInput
  }

  export type AchievementUpsertWithoutTrackerInput = {
    update: XOR<AchievementUpdateWithoutTrackerInput, AchievementUncheckedUpdateWithoutTrackerInput>
    create: XOR<AchievementCreateWithoutTrackerInput, AchievementUncheckedCreateWithoutTrackerInput>
  }

  export type AchievementUpdateWithoutTrackerInput = {
    no?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    description?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    element?: ElementUpdateOneRequiredWithoutAchievementNestedInput
    objective?: ObjectiveUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementUncheckedUpdateWithoutTrackerInput = {
    no?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    description?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    objective?: ObjectiveUncheckedUpdateManyWithoutAchievementNestedInput
  }

  export type BidangKeahlianUpsertWithoutTrackerInput = {
    update: XOR<BidangKeahlianUpdateWithoutTrackerInput, BidangKeahlianUncheckedUpdateWithoutTrackerInput>
    create: XOR<BidangKeahlianCreateWithoutTrackerInput, BidangKeahlianUncheckedCreateWithoutTrackerInput>
  }

  export type BidangKeahlianUpdateWithoutTrackerInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    program?: ProgramKeahlianUpdateManyWithoutBidangNestedInput
  }

  export type BidangKeahlianUncheckedUpdateWithoutTrackerInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    program?: ProgramKeahlianUncheckedUpdateManyWithoutBidangNestedInput
  }

  export type ProgramKeahlianUpsertWithoutTrackerInput = {
    update: XOR<ProgramKeahlianUpdateWithoutTrackerInput, ProgramKeahlianUncheckedUpdateWithoutTrackerInput>
    create: XOR<ProgramKeahlianCreateWithoutTrackerInput, ProgramKeahlianUncheckedCreateWithoutTrackerInput>
  }

  export type ProgramKeahlianUpdateWithoutTrackerInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    bidang?: BidangKeahlianUpdateOneRequiredWithoutProgramNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateManyWithoutProgramNestedInput
    mapel?: MataPelajaranUpdateManyWithoutProgramNestedInput
  }

  export type ProgramKeahlianUncheckedUpdateWithoutTrackerInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bidangId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    konsentrasi?: KonsentrasiKeahlianUncheckedUpdateManyWithoutProgramNestedInput
    mapel?: MataPelajaranUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type KonsentrasiKeahlianUpsertWithoutTrackerInput = {
    update: XOR<KonsentrasiKeahlianUpdateWithoutTrackerInput, KonsentrasiKeahlianUncheckedUpdateWithoutTrackerInput>
    create: XOR<KonsentrasiKeahlianCreateWithoutTrackerInput, KonsentrasiKeahlianUncheckedCreateWithoutTrackerInput>
  }

  export type KonsentrasiKeahlianUpdateWithoutTrackerInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    disable?: BoolFieldUpdateOperationsInput | boolean
    program?: ProgramKeahlianUpdateOneRequiredWithoutKonsentrasiNestedInput
    student?: StudentUpdateManyWithoutMajorNestedInput
    instansi?: InstansiUpdateManyWithoutMajorsNestedInput
    classRoom?: ClassRoomUpdateManyWithoutMajorNestedInput
    mapel?: MataPelajaranUpdateManyWithoutKeahlianNestedInput
    dudi?: DudiUpdateManyWithoutMajorNestedInput
    kkni?: KkniUpdateManyWithoutKonsentrasiNestedInput
  }

  export type KonsentrasiKeahlianUncheckedUpdateWithoutTrackerInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    instansiIds?: KonsentrasiKeahlianUpdateinstansiIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUncheckedUpdateManyWithoutMajorNestedInput
    instansi?: InstansiUncheckedUpdateManyWithoutMajorsNestedInput
    classRoom?: ClassRoomUncheckedUpdateManyWithoutMajorNestedInput
    mapel?: MataPelajaranUncheckedUpdateManyWithoutKeahlianNestedInput
    dudi?: DudiUncheckedUpdateManyWithoutMajorNestedInput
    kkni?: KkniUncheckedUpdateManyWithoutKonsentrasiNestedInput
  }

  export type SchoolYearUpsertWithoutTrackerInput = {
    update: XOR<SchoolYearUpdateWithoutTrackerInput, SchoolYearUncheckedUpdateWithoutTrackerInput>
    create: XOR<SchoolYearCreateWithoutTrackerInput, SchoolYearUncheckedCreateWithoutTrackerInput>
  }

  export type SchoolYearUpdateWithoutTrackerInput = {
    year?: IntFieldUpdateOperationsInput | number
    departments?: SchoolYearUpdatedepartmentsInput | Enumerable<string>
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    instansi?: InstansiUpdateOneRequiredWithoutSchoolYearNestedInput
    classRoom?: ClassRoomUpdateManyWithoutYearNestedInput
    students?: StudentUpdateManyWithoutStartYearNestedInput
    calendar?: CalendarUpdateManyWithoutRefNestedInput
    schedule?: ScheduleUpdateManyWithoutYearNestedInput
    objective?: ObjectiveUpdateManyWithoutYearNestedInput
    TDevice?: TDeviceUpdateManyWithoutYearNestedInput
  }

  export type SchoolYearUncheckedUpdateWithoutTrackerInput = {
    year?: IntFieldUpdateOperationsInput | number
    instansiId?: StringFieldUpdateOperationsInput | string
    departments?: SchoolYearUpdatedepartmentsInput | Enumerable<string>
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutYearNestedInput
    students?: StudentUncheckedUpdateManyWithoutStartYearNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutRefNestedInput
    schedule?: ScheduleUncheckedUpdateManyWithoutYearNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutYearNestedInput
    TDevice?: TDeviceUncheckedUpdateManyWithoutYearNestedInput
  }

  export type TeacherUpsertWithoutTrackerInput = {
    update: XOR<TeacherUpdateWithoutTrackerInput, TeacherUncheckedUpdateWithoutTrackerInput>
    create: XOR<TeacherCreateWithoutTrackerInput, TeacherUncheckedCreateWithoutTrackerInput>
  }

  export type TeacherUpdateWithoutTrackerInput = {
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tmtGol?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    personal?: PersonalUpdateOneRequiredWithoutTeacherNestedInput
    classRoom?: ClassRoomUpdateManyWithoutWaliNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutTeacherNestedInput
    event?: CalendarUpdateManyWithoutTeacherNestedInput
    teaching?: TeachingUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutTrackerInput = {
    personalId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: TeacherUpdateeventIdsInput | Enumerable<string>
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tmtGol?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutWaliNestedInput
    event?: CalendarUncheckedUpdateManyWithoutTeacherNestedInput
    teaching?: TeachingUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type ClassRoomUpsertWithoutTrackerInput = {
    update: XOR<ClassRoomUpdateWithoutTrackerInput, ClassRoomUncheckedUpdateWithoutTrackerInput>
    create: XOR<ClassRoomCreateWithoutTrackerInput, ClassRoomUncheckedCreateWithoutTrackerInput>
  }

  export type ClassRoomUpdateWithoutTrackerInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    property?: XOR<RoomPropertyNullableUpdateEnvelopeInput, RoomPropertyCreateInput> | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    year?: SchoolYearUpdateOneRequiredWithoutClassRoomNestedInput
    wali?: TeacherUpdateOneRequiredWithoutClassRoomNestedInput
    major?: KonsentrasiKeahlianUpdateOneWithoutClassRoomNestedInput
    students?: StudentUpdateManyWithoutClassRoomNestedInput
    event?: CalendarUpdateManyWithoutClassRoomNestedInput
    teaching?: TeachingUpdateManyWithoutClassRoomNestedInput
    tDevice?: TDeviceUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomUncheckedUpdateWithoutTrackerInput = {
    name?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    waliId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    property?: XOR<RoomPropertyNullableUpdateEnvelopeInput, RoomPropertyCreateInput> | null
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    studentIds?: ClassRoomUpdatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomUpdateeventIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    teachingIds?: ClassRoomUpdateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomUpdatetDeviceIdsInput | Enumerable<string>
    students?: StudentUncheckedUpdateManyWithoutClassRoomNestedInput
    event?: CalendarUncheckedUpdateManyWithoutClassRoomNestedInput
    teaching?: TeachingUncheckedUpdateManyWithoutClassRoomNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutClassRoomNestedInput
  }

  export type StudentUpsertWithoutTrackerInput = {
    update: XOR<StudentUpdateWithoutTrackerInput, StudentUncheckedUpdateWithoutTrackerInput>
    create: XOR<StudentCreateWithoutTrackerInput, StudentUncheckedCreateWithoutTrackerInput>
  }

  export type StudentUpdateWithoutTrackerInput = {
    nis?: StringFieldUpdateOperationsInput | string
    lastSchool?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    personal?: PersonalUpdateOneRequiredWithoutStudentNestedInput
    major?: KonsentrasiKeahlianUpdateOneWithoutStudentNestedInput
    classRoom?: ClassRoomUpdateManyWithoutStudentsNestedInput
    startYear?: SchoolYearUpdateOneRequiredWithoutStudentsNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutStudentNestedInput
    event?: CalendarUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutTrackerInput = {
    nis?: StringFieldUpdateOperationsInput | string
    lastSchool?: StringFieldUpdateOperationsInput | string
    personalId?: StringFieldUpdateOperationsInput | string
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomIds?: StudentUpdateclassRoomIdsInput | Enumerable<string>
    startYearId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: StudentUpdateeventIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutStudentsNestedInput
    event?: CalendarUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ScheduleUpsertWithoutTrackerInput = {
    update: XOR<ScheduleUpdateWithoutTrackerInput, ScheduleUncheckedUpdateWithoutTrackerInput>
    create: XOR<ScheduleCreateWithoutTrackerInput, ScheduleUncheckedCreateWithoutTrackerInput>
  }

  export type ScheduleUpdateWithoutTrackerInput = {
    disable?: BoolFieldUpdateOperationsInput | boolean
    year?: SchoolYearUpdateOneRequiredWithoutScheduleNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutScheduleNestedInput
    teaching?: TeachingUpdateManyWithoutRefNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutTrackerInput = {
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    teaching?: TeachingUncheckedUpdateManyWithoutRefNestedInput
  }

  export type TeachingUpsertWithoutTrackerInput = {
    update: XOR<TeachingUpdateWithoutTrackerInput, TeachingUncheckedUpdateWithoutTrackerInput>
    create: XOR<TeachingCreateWithoutTrackerInput, TeachingUncheckedCreateWithoutTrackerInput>
  }

  export type TeachingUpdateWithoutTrackerInput = {
    level?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    semester?: EnumSemesterFieldUpdateOperationsInput | Semester
    disable?: BoolFieldUpdateOperationsInput | boolean
    ref?: ScheduleUpdateOneRequiredWithoutTeachingNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutTeachingNestedInput
    classRoom?: ClassRoomUpdateManyWithoutTeachingNestedInput
    elemen?: ElementUpdateManyWithoutScheduleClassNestedInput
    tDevice?: TDeviceUpdateManyWithoutTeachingNestedInput
  }

  export type TeachingUncheckedUpdateWithoutTrackerInput = {
    refId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    semester?: EnumSemesterFieldUpdateOperationsInput | Semester
    teacherId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: TeachingUpdateclassRoomIdsInput | Enumerable<string>
    elemenIds?: TeachingUpdateelemenIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutTeachingNestedInput
    elemen?: ElementUncheckedUpdateManyWithoutScheduleClassNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutTeachingNestedInput
  }

  export type ObjectiveUpsertWithoutTrackerInput = {
    update: XOR<ObjectiveUpdateWithoutTrackerInput, ObjectiveUncheckedUpdateWithoutTrackerInput>
    create: XOR<ObjectiveCreateWithoutTrackerInput, ObjectiveUncheckedCreateWithoutTrackerInput>
  }

  export type ObjectiveUpdateWithoutTrackerInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutObjectiveNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutObjectiveNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutObjectiveNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutObjectiveNestedInput
    elemen?: ElementUpdateOneRequiredWithoutObjectiveNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutObjectiveNestedInput
    material?: OMaterialUpdateManyWithoutRefNestedInput
    resourse?: OresourceUpdateManyWithoutRefNestedInput
    ppp?: OpppUpdateManyWithoutRefNestedInput
    tool?: OhelperUpdateManyWithoutToolNestedInput
    mate?: OhelperUpdateManyWithoutMateNestedInput
    meth?: OhelperUpdateManyWithoutMethNestedInput
    media?: OhelperUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateWithoutTrackerInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    toolIds?: ObjectiveUpdatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveUpdatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveUpdatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveUpdatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedUpdateManyWithoutRefNestedInput
    resourse?: OresourceUncheckedUpdateManyWithoutRefNestedInput
    ppp?: OpppUncheckedUpdateManyWithoutRefNestedInput
    tool?: OhelperUncheckedUpdateManyWithoutToolNestedInput
    mate?: OhelperUncheckedUpdateManyWithoutMateNestedInput
    meth?: OhelperUncheckedUpdateManyWithoutMethNestedInput
    media?: OhelperUncheckedUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUncheckedUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUncheckedUpdateManyWithoutObjectiveNestedInput
  }

  export type TDeviceUpsertWithoutTrackerInput = {
    update: XOR<TDeviceUpdateWithoutTrackerInput, TDeviceUncheckedUpdateWithoutTrackerInput>
    create: XOR<TDeviceCreateWithoutTrackerInput, TDeviceUncheckedCreateWithoutTrackerInput>
  }

  export type TDeviceUpdateWithoutTrackerInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    teaching?: TeachingUpdateOneRequiredWithoutTDeviceNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutTDeviceNestedInput
    user?: UserUpdateOneRequiredWithoutTDeviceNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutTDeviceNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutDeviceNestedInput
    classRoom?: ClassRoomUpdateManyWithoutTDeviceNestedInput
    data?: TDeviceDataUpdateManyWithoutRefNestedInput
    children?: TDeviceUpdateManyWithoutParentNestedInput
    parent?: TDeviceUpdateOneWithoutChildrenNestedInput
  }

  export type TDeviceUncheckedUpdateWithoutTrackerInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    teachingId?: StringFieldUpdateOperationsInput | string
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    yearId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: TDeviceUpdateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutTDeviceNestedInput
    data?: TDeviceDataUncheckedUpdateManyWithoutRefNestedInput
    children?: TDeviceUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CalendarUpsertWithoutTrackerInput = {
    update: XOR<CalendarUpdateWithoutTrackerInput, CalendarUncheckedUpdateWithoutTrackerInput>
    create: XOR<CalendarCreateWithoutTrackerInput, CalendarUncheckedCreateWithoutTrackerInput>
  }

  export type CalendarUpdateWithoutTrackerInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    ref?: SchoolYearUpdateOneRequiredWithoutCalendarNestedInput
    classRoom?: ClassRoomUpdateManyWithoutEventNestedInput
    student?: StudentUpdateManyWithoutEventNestedInput
    teacher?: TeacherUpdateManyWithoutEventNestedInput
  }

  export type CalendarUncheckedUpdateWithoutTrackerInput = {
    refId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    classRoomIds?: CalendarUpdateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarUpdatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarUpdateteacherIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutEventNestedInput
    student?: StudentUncheckedUpdateManyWithoutEventNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutEventNestedInput
  }

  export type DudiUpsertWithoutTrackerInput = {
    update: XOR<DudiUpdateWithoutTrackerInput, DudiUncheckedUpdateWithoutTrackerInput>
    create: XOR<DudiCreateWithoutTrackerInput, DudiUncheckedCreateWithoutTrackerInput>
  }

  export type DudiUpdateWithoutTrackerInput = {
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    contact?: XOR<ContactDudiUpdateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiUpdatecollabsInput | Enumerable<string>
    timework?: XOR<DudiTimeWorkUpdateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    instansi?: InstansiUpdateOneRequiredWithoutDudiNestedInput
    major?: KonsentrasiKeahlianUpdateOneRequiredWithoutDudiNestedInput
    learning?: DudiLearningUpdateManyWithoutRefNestedInput
    kkni?: KkniUpdateOneWithoutDudiNestedInput
  }

  export type DudiUncheckedUpdateWithoutTrackerInput = {
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    instansiId?: StringFieldUpdateOperationsInput | string
    majorId?: StringFieldUpdateOperationsInput | string
    contact?: XOR<ContactDudiUpdateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiUpdatecollabsInput | Enumerable<string>
    timework?: XOR<DudiTimeWorkUpdateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
    learning?: DudiLearningUncheckedUpdateManyWithoutRefNestedInput
  }

  export type KkniUpsertWithoutTrackerInput = {
    update: XOR<KkniUpdateWithoutTrackerInput, KkniUncheckedUpdateWithoutTrackerInput>
    create: XOR<KkniCreateWithoutTrackerInput, KkniUncheckedCreateWithoutTrackerInput>
  }

  export type KkniUpdateWithoutTrackerInput = {
    no?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    konsentrasi?: KonsentrasiKeahlianUpdateOneRequiredWithoutKkniNestedInput
    dudi?: DudiUpdateManyWithoutKkniNestedInput
  }

  export type KkniUncheckedUpdateWithoutTrackerInput = {
    konsentrasiId?: StringFieldUpdateOperationsInput | string
    no?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    dudi?: DudiUncheckedUpdateManyWithoutKkniNestedInput
  }

  export type CoordinateCreateInput = {
    longitude: number
    latitude: number
  }

  export type KonsentrasiKeahlianCreateWithoutInstansiInput = {
    id?: string
    code: string
    name: string
    tahun: number
    disable?: boolean
    program: ProgramKeahlianCreateNestedOneWithoutKonsentrasiInput
    student?: StudentCreateNestedManyWithoutMajorInput
    classRoom?: ClassRoomCreateNestedManyWithoutMajorInput
    tracker?: TrackerCreateNestedManyWithoutKonsentrasiInput
    mapel?: MataPelajaranCreateNestedManyWithoutKeahlianInput
    dudi?: DudiCreateNestedManyWithoutMajorInput
    kkni?: KkniCreateNestedManyWithoutKonsentrasiInput
  }

  export type KonsentrasiKeahlianUncheckedCreateWithoutInstansiInput = {
    id?: string
    code: string
    name: string
    programId: string
    tahun: number
    instansiIds?: KonsentrasiKeahlianCreateinstansiIdsInput | Enumerable<string>
    disable?: boolean
    student?: StudentUncheckedCreateNestedManyWithoutMajorInput
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutMajorInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutKonsentrasiInput
    mapel?: MataPelajaranUncheckedCreateNestedManyWithoutKeahlianInput
    dudi?: DudiUncheckedCreateNestedManyWithoutMajorInput
    kkni?: KkniUncheckedCreateNestedManyWithoutKonsentrasiInput
  }

  export type KonsentrasiKeahlianCreateOrConnectWithoutInstansiInput = {
    where: KonsentrasiKeahlianWhereUniqueInput
    create: XOR<KonsentrasiKeahlianCreateWithoutInstansiInput, KonsentrasiKeahlianUncheckedCreateWithoutInstansiInput>
  }

  export type RoleCreateWithoutInstansiInput = {
    id?: string
    key: Roles
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutInstansiInput = {
    id?: string
    key: Roles
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutInstansiInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutInstansiInput, RoleUncheckedCreateWithoutInstansiInput>
  }

  export type RoleCreateManyInstansiInputEnvelope = {
    data: Enumerable<RoleCreateManyInstansiInput>
  }

  export type SchoolYearCreateWithoutInstansiInput = {
    id?: string
    year: number
    departments?: SchoolYearCreatedepartmentsInput | Enumerable<string>
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    disable?: boolean
    classRoom?: ClassRoomCreateNestedManyWithoutYearInput
    students?: StudentCreateNestedManyWithoutStartYearInput
    calendar?: CalendarCreateNestedManyWithoutRefInput
    schedule?: ScheduleCreateNestedManyWithoutYearInput
    objective?: ObjectiveCreateNestedManyWithoutYearInput
    tracker?: TrackerCreateNestedManyWithoutTpInput
    TDevice?: TDeviceCreateNestedManyWithoutYearInput
  }

  export type SchoolYearUncheckedCreateWithoutInstansiInput = {
    id?: string
    year: number
    departments?: SchoolYearCreatedepartmentsInput | Enumerable<string>
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutYearInput
    students?: StudentUncheckedCreateNestedManyWithoutStartYearInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutRefInput
    schedule?: ScheduleUncheckedCreateNestedManyWithoutYearInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutYearInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTpInput
    TDevice?: TDeviceUncheckedCreateNestedManyWithoutYearInput
  }

  export type SchoolYearCreateOrConnectWithoutInstansiInput = {
    where: SchoolYearWhereUniqueInput
    create: XOR<SchoolYearCreateWithoutInstansiInput, SchoolYearUncheckedCreateWithoutInstansiInput>
  }

  export type SchoolYearCreateManyInstansiInputEnvelope = {
    data: Enumerable<SchoolYearCreateManyInstansiInput>
  }

  export type TeacherCreateWithoutInstansiInput = {
    id?: string
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: Date | string | null
    tmtGol?: Date | string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    disable?: boolean
    personal: PersonalCreateNestedOneWithoutTeacherInput
    classRoom?: ClassRoomCreateNestedManyWithoutWaliInput
    event?: CalendarCreateNestedManyWithoutTeacherInput
    tracker?: TrackerCreateNestedManyWithoutTeacherInput
    teaching?: TeachingCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutInstansiInput = {
    id?: string
    personalId: string
    eventIds?: TeacherCreateeventIdsInput | Enumerable<string>
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: Date | string | null
    tmtGol?: Date | string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutWaliInput
    event?: CalendarUncheckedCreateNestedManyWithoutTeacherInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTeacherInput
    teaching?: TeachingUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutInstansiInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutInstansiInput, TeacherUncheckedCreateWithoutInstansiInput>
  }

  export type TeacherCreateManyInstansiInputEnvelope = {
    data: Enumerable<TeacherCreateManyInstansiInput>
  }

  export type StudentCreateWithoutInstansiInput = {
    id?: string
    nis: string
    lastSchool: string
    disable?: boolean
    personal: PersonalCreateNestedOneWithoutStudentInput
    major?: KonsentrasiKeahlianCreateNestedOneWithoutStudentInput
    classRoom?: ClassRoomCreateNestedManyWithoutStudentsInput
    startYear: SchoolYearCreateNestedOneWithoutStudentsInput
    event?: CalendarCreateNestedManyWithoutStudentInput
    tracker?: TrackerCreateNestedManyWithoutMuridInput
  }

  export type StudentUncheckedCreateWithoutInstansiInput = {
    id?: string
    nis: string
    lastSchool: string
    personalId: string
    majorId?: string | null
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    startYearId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutStudentsInput
    event?: CalendarUncheckedCreateNestedManyWithoutStudentInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutMuridInput
  }

  export type StudentCreateOrConnectWithoutInstansiInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutInstansiInput, StudentUncheckedCreateWithoutInstansiInput>
  }

  export type StudentCreateManyInstansiInputEnvelope = {
    data: Enumerable<StudentCreateManyInstansiInput>
  }

  export type TrackerCreateWithoutInstansiInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrackerInput
    ref: InstansiCreateNestedOneWithoutHistoryInput
    mapel?: MataPelajaranCreateNestedOneWithoutTrackerInput
    elemen?: ElementCreateNestedOneWithoutTrackerInput
    cp?: AchievementCreateNestedOneWithoutTrackerInput
    bidang?: BidangKeahlianCreateNestedOneWithoutTrackerInput
    program?: ProgramKeahlianCreateNestedOneWithoutTrackerInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedOneWithoutTrackerInput
    tp?: SchoolYearCreateNestedOneWithoutTrackerInput
    teacher?: TeacherCreateNestedOneWithoutTrackerInput
    kelas?: ClassRoomCreateNestedOneWithoutTrackerInput
    murid?: StudentCreateNestedOneWithoutTrackerInput
    jadwal?: ScheduleCreateNestedOneWithoutTrackerInput
    mengajar?: TeachingCreateNestedOneWithoutTrackerInput
    tujuan?: ObjectiveCreateNestedOneWithoutTrackerInput
    perangkat?: TDeviceCreateNestedOneWithoutTrackerInput
    kalender?: CalendarCreateNestedOneWithoutTrackerInput
    dudi?: DudiCreateNestedOneWithoutTrackerInput
    kkni?: KkniCreateNestedOneWithoutTrackerInput
  }

  export type TrackerUncheckedCreateWithoutInstansiInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TrackerCreateOrConnectWithoutInstansiInput = {
    where: TrackerWhereUniqueInput
    create: XOR<TrackerCreateWithoutInstansiInput, TrackerUncheckedCreateWithoutInstansiInput>
  }

  export type TrackerCreateManyInstansiInputEnvelope = {
    data: Enumerable<TrackerCreateManyInstansiInput>
  }

  export type TrackerCreateWithoutRefInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrackerInput
    instansi?: InstansiCreateNestedOneWithoutTrackerInput
    mapel?: MataPelajaranCreateNestedOneWithoutTrackerInput
    elemen?: ElementCreateNestedOneWithoutTrackerInput
    cp?: AchievementCreateNestedOneWithoutTrackerInput
    bidang?: BidangKeahlianCreateNestedOneWithoutTrackerInput
    program?: ProgramKeahlianCreateNestedOneWithoutTrackerInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedOneWithoutTrackerInput
    tp?: SchoolYearCreateNestedOneWithoutTrackerInput
    teacher?: TeacherCreateNestedOneWithoutTrackerInput
    kelas?: ClassRoomCreateNestedOneWithoutTrackerInput
    murid?: StudentCreateNestedOneWithoutTrackerInput
    jadwal?: ScheduleCreateNestedOneWithoutTrackerInput
    mengajar?: TeachingCreateNestedOneWithoutTrackerInput
    tujuan?: ObjectiveCreateNestedOneWithoutTrackerInput
    perangkat?: TDeviceCreateNestedOneWithoutTrackerInput
    kalender?: CalendarCreateNestedOneWithoutTrackerInput
    dudi?: DudiCreateNestedOneWithoutTrackerInput
    kkni?: KkniCreateNestedOneWithoutTrackerInput
  }

  export type TrackerUncheckedCreateWithoutRefInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TrackerCreateOrConnectWithoutRefInput = {
    where: TrackerWhereUniqueInput
    create: XOR<TrackerCreateWithoutRefInput, TrackerUncheckedCreateWithoutRefInput>
  }

  export type TrackerCreateManyRefInputEnvelope = {
    data: Enumerable<TrackerCreateManyRefInput>
  }

  export type MataPelajaranCreateWithoutInstansiInput = {
    id?: string
    level?: Level | null
    type?: MataPelajaranType
    no: string
    code: string
    name: string
    religion?: Religion | null
    disable?: boolean
    program?: ProgramKeahlianCreateNestedOneWithoutMapelInput
    keahlian?: KonsentrasiKeahlianCreateNestedOneWithoutMapelInput
    element?: ElementCreateNestedManyWithoutMapelInput
    schedule?: ScheduleCreateNestedManyWithoutMapelInput
    tracker?: TrackerCreateNestedManyWithoutMapelInput
    objective?: ObjectiveCreateNestedManyWithoutMapelInput
    device?: TDeviceCreateNestedManyWithoutMapelInput
  }

  export type MataPelajaranUncheckedCreateWithoutInstansiInput = {
    id?: string
    level?: Level | null
    type?: MataPelajaranType
    no: string
    code: string
    name: string
    religion?: Religion | null
    programId?: string | null
    keahlianid?: string | null
    disable?: boolean
    element?: ElementUncheckedCreateNestedManyWithoutMapelInput
    schedule?: ScheduleUncheckedCreateNestedManyWithoutMapelInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutMapelInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutMapelInput
    device?: TDeviceUncheckedCreateNestedManyWithoutMapelInput
  }

  export type MataPelajaranCreateOrConnectWithoutInstansiInput = {
    where: MataPelajaranWhereUniqueInput
    create: XOR<MataPelajaranCreateWithoutInstansiInput, MataPelajaranUncheckedCreateWithoutInstansiInput>
  }

  export type MataPelajaranCreateManyInstansiInputEnvelope = {
    data: Enumerable<MataPelajaranCreateManyInstansiInput>
  }

  export type TDeviceCreateWithoutInstansiInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    teaching: TeachingCreateNestedOneWithoutTDeviceInput
    year: SchoolYearCreateNestedOneWithoutTDeviceInput
    user: UserCreateNestedOneWithoutTDeviceInput
    mapel: MataPelajaranCreateNestedOneWithoutDeviceInput
    classRoom?: ClassRoomCreateNestedManyWithoutTDeviceInput
    tracker?: TrackerCreateNestedManyWithoutPerangkatInput
    data?: TDeviceDataCreateNestedManyWithoutRefInput
    children?: TDeviceCreateNestedManyWithoutParentInput
    parent?: TDeviceCreateNestedOneWithoutChildrenInput
  }

  export type TDeviceUncheckedCreateWithoutInstansiInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    teachingId: string
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    yearId: string
    userId: string
    mapelId: string
    classRoomIds?: TDeviceCreateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    parentId?: string | null
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutTDeviceInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutPerangkatInput
    data?: TDeviceDataUncheckedCreateNestedManyWithoutRefInput
    children?: TDeviceUncheckedCreateNestedManyWithoutParentInput
  }

  export type TDeviceCreateOrConnectWithoutInstansiInput = {
    where: TDeviceWhereUniqueInput
    create: XOR<TDeviceCreateWithoutInstansiInput, TDeviceUncheckedCreateWithoutInstansiInput>
  }

  export type TDeviceCreateManyInstansiInputEnvelope = {
    data: Enumerable<TDeviceCreateManyInstansiInput>
  }

  export type ObjectiveCreateWithoutInstansiInput = {
    id?: string
    level: number
    fase: Fase
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    user: UserCreateNestedOneWithoutObjectiveInput
    year: SchoolYearCreateNestedOneWithoutObjectiveInput
    mapel: MataPelajaranCreateNestedOneWithoutObjectiveInput
    elemen: ElementCreateNestedOneWithoutObjectiveInput
    achievement: AchievementCreateNestedOneWithoutObjectiveInput
    material?: OMaterialCreateNestedManyWithoutRefInput
    tracker?: TrackerCreateNestedManyWithoutTujuanInput
    resourse?: OresourceCreateNestedManyWithoutRefInput
    ppp?: OpppCreateNestedManyWithoutRefInput
    tool?: OhelperCreateNestedManyWithoutToolInput
    mate?: OhelperCreateNestedManyWithoutMateInput
    meth?: OhelperCreateNestedManyWithoutMethInput
    media?: OhelperCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentCreateNestedManyWithoutRefInput
    devices?: TDeviceDataCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveUncheckedCreateWithoutInstansiInput = {
    id?: string
    level: number
    fase: Fase
    userId: string
    yearId: string
    mapelId: string
    elementId: string
    achievementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedCreateNestedManyWithoutRefInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTujuanInput
    resourse?: OresourceUncheckedCreateNestedManyWithoutRefInput
    ppp?: OpppUncheckedCreateNestedManyWithoutRefInput
    tool?: OhelperUncheckedCreateNestedManyWithoutToolInput
    mate?: OhelperUncheckedCreateNestedManyWithoutMateInput
    meth?: OhelperUncheckedCreateNestedManyWithoutMethInput
    media?: OhelperUncheckedCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentUncheckedCreateNestedManyWithoutRefInput
    devices?: TDeviceDataUncheckedCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveCreateOrConnectWithoutInstansiInput = {
    where: ObjectiveWhereUniqueInput
    create: XOR<ObjectiveCreateWithoutInstansiInput, ObjectiveUncheckedCreateWithoutInstansiInput>
  }

  export type ObjectiveCreateManyInstansiInputEnvelope = {
    data: Enumerable<ObjectiveCreateManyInstansiInput>
  }

  export type DudiCreateWithoutInstansiInput = {
    id?: string
    name: string
    street: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    contact: XOR<ContactDudiCreateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiCreatecollabsInput | Enumerable<string>
    timework: XOR<DudiTimeWorkCreateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: boolean
    major: KonsentrasiKeahlianCreateNestedOneWithoutDudiInput
    learning?: DudiLearningCreateNestedManyWithoutRefInput
    tracker?: TrackerCreateNestedManyWithoutDudiInput
    kkni?: KkniCreateNestedOneWithoutDudiInput
  }

  export type DudiUncheckedCreateWithoutInstansiInput = {
    id?: string
    name: string
    street: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    majorId: string
    contact: XOR<ContactDudiCreateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiCreatecollabsInput | Enumerable<string>
    timework: XOR<DudiTimeWorkCreateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: boolean
    kkniId?: string | null
    learning?: DudiLearningUncheckedCreateNestedManyWithoutRefInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutDudiInput
  }

  export type DudiCreateOrConnectWithoutInstansiInput = {
    where: DudiWhereUniqueInput
    create: XOR<DudiCreateWithoutInstansiInput, DudiUncheckedCreateWithoutInstansiInput>
  }

  export type DudiCreateManyInstansiInputEnvelope = {
    data: Enumerable<DudiCreateManyInstansiInput>
  }

  export type AddressUpdateInput = {
    provinsi?: StringFieldUpdateOperationsInput | string
    kabupaten?: StringFieldUpdateOperationsInput | string
    kecamatan?: StringFieldUpdateOperationsInput | string
    kelurahan?: StringFieldUpdateOperationsInput | string
    kodepos?: StringFieldUpdateOperationsInput | string
    coordinate?: XOR<CoordinateUpdateEnvelopeInput, CoordinateCreateInput>
  }

  export type KonsentrasiKeahlianUpsertWithWhereUniqueWithoutInstansiInput = {
    where: KonsentrasiKeahlianWhereUniqueInput
    update: XOR<KonsentrasiKeahlianUpdateWithoutInstansiInput, KonsentrasiKeahlianUncheckedUpdateWithoutInstansiInput>
    create: XOR<KonsentrasiKeahlianCreateWithoutInstansiInput, KonsentrasiKeahlianUncheckedCreateWithoutInstansiInput>
  }

  export type KonsentrasiKeahlianUpdateWithWhereUniqueWithoutInstansiInput = {
    where: KonsentrasiKeahlianWhereUniqueInput
    data: XOR<KonsentrasiKeahlianUpdateWithoutInstansiInput, KonsentrasiKeahlianUncheckedUpdateWithoutInstansiInput>
  }

  export type KonsentrasiKeahlianUpdateManyWithWhereWithoutInstansiInput = {
    where: KonsentrasiKeahlianScalarWhereInput
    data: XOR<KonsentrasiKeahlianUpdateManyMutationInput, KonsentrasiKeahlianUncheckedUpdateManyWithoutMajorsInput>
  }

  export type KonsentrasiKeahlianScalarWhereInput = {
    AND?: Enumerable<KonsentrasiKeahlianScalarWhereInput>
    OR?: Enumerable<KonsentrasiKeahlianScalarWhereInput>
    NOT?: Enumerable<KonsentrasiKeahlianScalarWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    name?: StringFilter | string
    programId?: StringFilter | string
    tahun?: IntFilter | number
    instansiIds?: StringNullableListFilter
    disable?: BoolFilter | boolean
  }

  export type RoleUpsertWithWhereUniqueWithoutInstansiInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutInstansiInput, RoleUncheckedUpdateWithoutInstansiInput>
    create: XOR<RoleCreateWithoutInstansiInput, RoleUncheckedCreateWithoutInstansiInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutInstansiInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutInstansiInput, RoleUncheckedUpdateWithoutInstansiInput>
  }

  export type RoleUpdateManyWithWhereWithoutInstansiInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type RoleScalarWhereInput = {
    AND?: Enumerable<RoleScalarWhereInput>
    OR?: Enumerable<RoleScalarWhereInput>
    NOT?: Enumerable<RoleScalarWhereInput>
    id?: StringFilter | string
    key?: EnumRolesFilter | Roles
    instansiId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SchoolYearUpsertWithWhereUniqueWithoutInstansiInput = {
    where: SchoolYearWhereUniqueInput
    update: XOR<SchoolYearUpdateWithoutInstansiInput, SchoolYearUncheckedUpdateWithoutInstansiInput>
    create: XOR<SchoolYearCreateWithoutInstansiInput, SchoolYearUncheckedCreateWithoutInstansiInput>
  }

  export type SchoolYearUpdateWithWhereUniqueWithoutInstansiInput = {
    where: SchoolYearWhereUniqueInput
    data: XOR<SchoolYearUpdateWithoutInstansiInput, SchoolYearUncheckedUpdateWithoutInstansiInput>
  }

  export type SchoolYearUpdateManyWithWhereWithoutInstansiInput = {
    where: SchoolYearScalarWhereInput
    data: XOR<SchoolYearUpdateManyMutationInput, SchoolYearUncheckedUpdateManyWithoutSchoolYearInput>
  }

  export type SchoolYearScalarWhereInput = {
    AND?: Enumerable<SchoolYearScalarWhereInput>
    OR?: Enumerable<SchoolYearScalarWhereInput>
    NOT?: Enumerable<SchoolYearScalarWhereInput>
    id?: StringFilter | string
    year?: IntFilter | number
    instansiId?: StringFilter | string
    departments?: StringNullableListFilter
    disable?: BoolFilter | boolean
  }

  export type TeacherUpsertWithWhereUniqueWithoutInstansiInput = {
    where: TeacherWhereUniqueInput
    update: XOR<TeacherUpdateWithoutInstansiInput, TeacherUncheckedUpdateWithoutInstansiInput>
    create: XOR<TeacherCreateWithoutInstansiInput, TeacherUncheckedCreateWithoutInstansiInput>
  }

  export type TeacherUpdateWithWhereUniqueWithoutInstansiInput = {
    where: TeacherWhereUniqueInput
    data: XOR<TeacherUpdateWithoutInstansiInput, TeacherUncheckedUpdateWithoutInstansiInput>
  }

  export type TeacherUpdateManyWithWhereWithoutInstansiInput = {
    where: TeacherScalarWhereInput
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TeacherScalarWhereInput = {
    AND?: Enumerable<TeacherScalarWhereInput>
    OR?: Enumerable<TeacherScalarWhereInput>
    NOT?: Enumerable<TeacherScalarWhereInput>
    id?: StringFilter | string
    personalId?: StringFilter | string
    instansiId?: StringFilter | string
    eventIds?: StringNullableListFilter
    nip?: StringNullableFilter | string | null
    nrg?: StringNullableFilter | string | null
    noKarpeg?: StringNullableFilter | string | null
    tmtTugas?: DateTimeNullableFilter | Date | string | null
    tmtGol?: DateTimeNullableFilter | Date | string | null
    position?: StringNullableFilter | string | null
    rank?: StringNullableFilter | string | null
    period?: StringNullableFilter | string | null
    certificate?: StringNullableFilter | string | null
    disable?: BoolFilter | boolean
  }

  export type StudentUpsertWithWhereUniqueWithoutInstansiInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutInstansiInput, StudentUncheckedUpdateWithoutInstansiInput>
    create: XOR<StudentCreateWithoutInstansiInput, StudentUncheckedCreateWithoutInstansiInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutInstansiInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutInstansiInput, StudentUncheckedUpdateWithoutInstansiInput>
  }

  export type StudentUpdateManyWithWhereWithoutInstansiInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentScalarWhereInput = {
    AND?: Enumerable<StudentScalarWhereInput>
    OR?: Enumerable<StudentScalarWhereInput>
    NOT?: Enumerable<StudentScalarWhereInput>
    id?: StringFilter | string
    nis?: StringFilter | string
    lastSchool?: StringFilter | string
    personalId?: StringFilter | string
    majorId?: StringNullableFilter | string | null
    classRoomIds?: StringNullableListFilter
    startYearId?: StringFilter | string
    instansiId?: StringFilter | string
    eventIds?: StringNullableListFilter
    disable?: BoolFilter | boolean
  }

  export type TrackerUpsertWithWhereUniqueWithoutInstansiInput = {
    where: TrackerWhereUniqueInput
    update: XOR<TrackerUpdateWithoutInstansiInput, TrackerUncheckedUpdateWithoutInstansiInput>
    create: XOR<TrackerCreateWithoutInstansiInput, TrackerUncheckedCreateWithoutInstansiInput>
  }

  export type TrackerUpdateWithWhereUniqueWithoutInstansiInput = {
    where: TrackerWhereUniqueInput
    data: XOR<TrackerUpdateWithoutInstansiInput, TrackerUncheckedUpdateWithoutInstansiInput>
  }

  export type TrackerUpdateManyWithWhereWithoutInstansiInput = {
    where: TrackerScalarWhereInput
    data: XOR<TrackerUpdateManyMutationInput, TrackerUncheckedUpdateManyWithoutTrackerInput>
  }

  export type TrackerScalarWhereInput = {
    AND?: Enumerable<TrackerScalarWhereInput>
    OR?: Enumerable<TrackerScalarWhereInput>
    NOT?: Enumerable<TrackerScalarWhereInput>
    id?: StringFilter | string
    point?: EnumPointTrackerFilter | PointTracker
    type?: EnumTypeTrackerFilter | TypeTracker
    userId?: StringFilter | string
    refId?: StringFilter | string
    instansiId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    mapelId?: StringNullableFilter | string | null
    elementId?: StringNullableFilter | string | null
    cpId?: StringNullableFilter | string | null
    bidangId?: StringNullableFilter | string | null
    programId?: StringNullableFilter | string | null
    konsentrasiId?: StringNullableFilter | string | null
    tpId?: StringNullableFilter | string | null
    teacherId?: StringNullableFilter | string | null
    kelasId?: StringNullableFilter | string | null
    muridId?: StringNullableFilter | string | null
    jadwalId?: StringNullableFilter | string | null
    mengajarId?: StringNullableFilter | string | null
    tujuanId?: StringNullableFilter | string | null
    perangkatId?: StringNullableFilter | string | null
    kalenderId?: StringNullableFilter | string | null
    dudiId?: StringNullableFilter | string | null
    kkniId?: StringNullableFilter | string | null
  }

  export type TrackerUpsertWithWhereUniqueWithoutRefInput = {
    where: TrackerWhereUniqueInput
    update: XOR<TrackerUpdateWithoutRefInput, TrackerUncheckedUpdateWithoutRefInput>
    create: XOR<TrackerCreateWithoutRefInput, TrackerUncheckedCreateWithoutRefInput>
  }

  export type TrackerUpdateWithWhereUniqueWithoutRefInput = {
    where: TrackerWhereUniqueInput
    data: XOR<TrackerUpdateWithoutRefInput, TrackerUncheckedUpdateWithoutRefInput>
  }

  export type TrackerUpdateManyWithWhereWithoutRefInput = {
    where: TrackerScalarWhereInput
    data: XOR<TrackerUpdateManyMutationInput, TrackerUncheckedUpdateManyWithoutHistoryInput>
  }

  export type MataPelajaranUpsertWithWhereUniqueWithoutInstansiInput = {
    where: MataPelajaranWhereUniqueInput
    update: XOR<MataPelajaranUpdateWithoutInstansiInput, MataPelajaranUncheckedUpdateWithoutInstansiInput>
    create: XOR<MataPelajaranCreateWithoutInstansiInput, MataPelajaranUncheckedCreateWithoutInstansiInput>
  }

  export type MataPelajaranUpdateWithWhereUniqueWithoutInstansiInput = {
    where: MataPelajaranWhereUniqueInput
    data: XOR<MataPelajaranUpdateWithoutInstansiInput, MataPelajaranUncheckedUpdateWithoutInstansiInput>
  }

  export type MataPelajaranUpdateManyWithWhereWithoutInstansiInput = {
    where: MataPelajaranScalarWhereInput
    data: XOR<MataPelajaranUpdateManyMutationInput, MataPelajaranUncheckedUpdateManyWithoutUnikMapelsInput>
  }

  export type MataPelajaranScalarWhereInput = {
    AND?: Enumerable<MataPelajaranScalarWhereInput>
    OR?: Enumerable<MataPelajaranScalarWhereInput>
    NOT?: Enumerable<MataPelajaranScalarWhereInput>
    id?: StringFilter | string
    level?: EnumLevelNullableFilter | Level | null
    type?: EnumMataPelajaranTypeFilter | MataPelajaranType
    no?: StringFilter | string
    code?: StringFilter | string
    name?: StringFilter | string
    religion?: EnumReligionNullableFilter | Religion | null
    programId?: StringNullableFilter | string | null
    keahlianid?: StringNullableFilter | string | null
    instansiId?: StringNullableFilter | string | null
    disable?: BoolFilter | boolean
  }

  export type TDeviceUpsertWithWhereUniqueWithoutInstansiInput = {
    where: TDeviceWhereUniqueInput
    update: XOR<TDeviceUpdateWithoutInstansiInput, TDeviceUncheckedUpdateWithoutInstansiInput>
    create: XOR<TDeviceCreateWithoutInstansiInput, TDeviceUncheckedCreateWithoutInstansiInput>
  }

  export type TDeviceUpdateWithWhereUniqueWithoutInstansiInput = {
    where: TDeviceWhereUniqueInput
    data: XOR<TDeviceUpdateWithoutInstansiInput, TDeviceUncheckedUpdateWithoutInstansiInput>
  }

  export type TDeviceUpdateManyWithWhereWithoutInstansiInput = {
    where: TDeviceScalarWhereInput
    data: XOR<TDeviceUpdateManyMutationInput, TDeviceUncheckedUpdateManyWithoutTDeviceInput>
  }

  export type TDeviceScalarWhereInput = {
    AND?: Enumerable<TDeviceScalarWhereInput>
    OR?: Enumerable<TDeviceScalarWhereInput>
    NOT?: Enumerable<TDeviceScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    level?: IntFilter | number
    fase?: EnumFaseFilter | Fase
    teachingId?: StringFilter | string
    yearId?: StringFilter | string
    userId?: StringFilter | string
    instansiId?: StringFilter | string
    mapelId?: StringFilter | string
    classRoomIds?: StringNullableListFilter
    elemen?: StringNullableListFilter
    disable?: BoolFilter | boolean
    parentId?: StringNullableFilter | string | null
  }

  export type ObjectiveUpsertWithWhereUniqueWithoutInstansiInput = {
    where: ObjectiveWhereUniqueInput
    update: XOR<ObjectiveUpdateWithoutInstansiInput, ObjectiveUncheckedUpdateWithoutInstansiInput>
    create: XOR<ObjectiveCreateWithoutInstansiInput, ObjectiveUncheckedCreateWithoutInstansiInput>
  }

  export type ObjectiveUpdateWithWhereUniqueWithoutInstansiInput = {
    where: ObjectiveWhereUniqueInput
    data: XOR<ObjectiveUpdateWithoutInstansiInput, ObjectiveUncheckedUpdateWithoutInstansiInput>
  }

  export type ObjectiveUpdateManyWithWhereWithoutInstansiInput = {
    where: ObjectiveScalarWhereInput
    data: XOR<ObjectiveUpdateManyMutationInput, ObjectiveUncheckedUpdateManyWithoutObjectiveInput>
  }

  export type ObjectiveScalarWhereInput = {
    AND?: Enumerable<ObjectiveScalarWhereInput>
    OR?: Enumerable<ObjectiveScalarWhereInput>
    NOT?: Enumerable<ObjectiveScalarWhereInput>
    id?: StringFilter | string
    level?: IntFilter | number
    fase?: EnumFaseFilter | Fase
    userId?: StringFilter | string
    instansiId?: StringFilter | string
    yearId?: StringFilter | string
    mapelId?: StringFilter | string
    elementId?: StringFilter | string
    achievementId?: StringFilter | string
    code?: StringFilter | string
    kkm?: IntFilter | number
    steps?: IntFilter | number
    subjectMatter?: StringFilter | string
    competencie?: StringNullableListFilter
    firstSkill?: StringNullableListFilter
    triggerQuest?: StringNullableListFilter
    disable?: BoolFilter | boolean
    toolIds?: StringNullableListFilter
    mateIds?: StringNullableListFilter
    methIds?: StringNullableListFilter
    mediaIds?: StringNullableListFilter
  }

  export type DudiUpsertWithWhereUniqueWithoutInstansiInput = {
    where: DudiWhereUniqueInput
    update: XOR<DudiUpdateWithoutInstansiInput, DudiUncheckedUpdateWithoutInstansiInput>
    create: XOR<DudiCreateWithoutInstansiInput, DudiUncheckedCreateWithoutInstansiInput>
  }

  export type DudiUpdateWithWhereUniqueWithoutInstansiInput = {
    where: DudiWhereUniqueInput
    data: XOR<DudiUpdateWithoutInstansiInput, DudiUncheckedUpdateWithoutInstansiInput>
  }

  export type DudiUpdateManyWithWhereWithoutInstansiInput = {
    where: DudiScalarWhereInput
    data: XOR<DudiUpdateManyMutationInput, DudiUncheckedUpdateManyWithoutDudiInput>
  }

  export type DudiScalarWhereInput = {
    AND?: Enumerable<DudiScalarWhereInput>
    OR?: Enumerable<DudiScalarWhereInput>
    NOT?: Enumerable<DudiScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    street?: StringFilter | string
    instansiId?: StringFilter | string
    majorId?: StringFilter | string
    collabs?: StringNullableListFilter
    disable?: BoolFilter | boolean
    kkniId?: StringNullableFilter | string | null
  }

  export type ProgramKeahlianCreateWithoutMapelInput = {
    id?: string
    code: string
    name: string
    disable?: boolean
    bidang: BidangKeahlianCreateNestedOneWithoutProgramInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedManyWithoutProgramInput
    tracker?: TrackerCreateNestedManyWithoutProgramInput
  }

  export type ProgramKeahlianUncheckedCreateWithoutMapelInput = {
    id?: string
    code: string
    name: string
    bidangId: string
    disable?: boolean
    konsentrasi?: KonsentrasiKeahlianUncheckedCreateNestedManyWithoutProgramInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramKeahlianCreateOrConnectWithoutMapelInput = {
    where: ProgramKeahlianWhereUniqueInput
    create: XOR<ProgramKeahlianCreateWithoutMapelInput, ProgramKeahlianUncheckedCreateWithoutMapelInput>
  }

  export type KonsentrasiKeahlianCreateWithoutMapelInput = {
    id?: string
    code: string
    name: string
    tahun: number
    disable?: boolean
    program: ProgramKeahlianCreateNestedOneWithoutKonsentrasiInput
    student?: StudentCreateNestedManyWithoutMajorInput
    instansi?: InstansiCreateNestedManyWithoutMajorsInput
    classRoom?: ClassRoomCreateNestedManyWithoutMajorInput
    tracker?: TrackerCreateNestedManyWithoutKonsentrasiInput
    dudi?: DudiCreateNestedManyWithoutMajorInput
    kkni?: KkniCreateNestedManyWithoutKonsentrasiInput
  }

  export type KonsentrasiKeahlianUncheckedCreateWithoutMapelInput = {
    id?: string
    code: string
    name: string
    programId: string
    tahun: number
    instansiIds?: KonsentrasiKeahlianCreateinstansiIdsInput | Enumerable<string>
    disable?: boolean
    student?: StudentUncheckedCreateNestedManyWithoutMajorInput
    instansi?: InstansiUncheckedCreateNestedManyWithoutMajorsInput
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutMajorInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutKonsentrasiInput
    dudi?: DudiUncheckedCreateNestedManyWithoutMajorInput
    kkni?: KkniUncheckedCreateNestedManyWithoutKonsentrasiInput
  }

  export type KonsentrasiKeahlianCreateOrConnectWithoutMapelInput = {
    where: KonsentrasiKeahlianWhereUniqueInput
    create: XOR<KonsentrasiKeahlianCreateWithoutMapelInput, KonsentrasiKeahlianUncheckedCreateWithoutMapelInput>
  }

  export type InstansiCreateWithoutUnikMapelsInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    disable?: boolean
    majors?: KonsentrasiKeahlianCreateNestedManyWithoutInstansiInput
    role?: RoleCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearCreateNestedManyWithoutInstansiInput
    teacher?: TeacherCreateNestedManyWithoutInstansiInput
    student?: StudentCreateNestedManyWithoutInstansiInput
    tracker?: TrackerCreateNestedManyWithoutInstansiInput
    history?: TrackerCreateNestedManyWithoutRefInput
    tDevice?: TDeviceCreateNestedManyWithoutInstansiInput
    objective?: ObjectiveCreateNestedManyWithoutInstansiInput
    dudi?: DudiCreateNestedManyWithoutInstansiInput
  }

  export type InstansiUncheckedCreateWithoutUnikMapelsInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    majorIds?: InstansiCreatemajorIdsInput | Enumerable<string>
    disable?: boolean
    majors?: KonsentrasiKeahlianUncheckedCreateNestedManyWithoutInstansiInput
    role?: RoleUncheckedCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearUncheckedCreateNestedManyWithoutInstansiInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutInstansiInput
    student?: StudentUncheckedCreateNestedManyWithoutInstansiInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutInstansiInput
    history?: TrackerUncheckedCreateNestedManyWithoutRefInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutInstansiInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutInstansiInput
    dudi?: DudiUncheckedCreateNestedManyWithoutInstansiInput
  }

  export type InstansiCreateOrConnectWithoutUnikMapelsInput = {
    where: InstansiWhereUniqueInput
    create: XOR<InstansiCreateWithoutUnikMapelsInput, InstansiUncheckedCreateWithoutUnikMapelsInput>
  }

  export type ElementCreateWithoutMapelInput = {
    id?: string
    no: number
    name: string
    description: string
    disable?: boolean
    achievement?: AchievementCreateNestedManyWithoutElementInput
    tracker?: TrackerCreateNestedManyWithoutElemenInput
    scheduleClass?: TeachingCreateNestedManyWithoutElemenInput
    objective?: ObjectiveCreateNestedManyWithoutElemenInput
  }

  export type ElementUncheckedCreateWithoutMapelInput = {
    id?: string
    no: number
    name: string
    description: string
    disable?: boolean
    scheduleClassIds?: ElementCreatescheduleClassIdsInput | Enumerable<string>
    achievement?: AchievementUncheckedCreateNestedManyWithoutElementInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutElemenInput
    scheduleClass?: TeachingUncheckedCreateNestedManyWithoutElemenInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutElemenInput
  }

  export type ElementCreateOrConnectWithoutMapelInput = {
    where: ElementWhereUniqueInput
    create: XOR<ElementCreateWithoutMapelInput, ElementUncheckedCreateWithoutMapelInput>
  }

  export type ElementCreateManyMapelInputEnvelope = {
    data: Enumerable<ElementCreateManyMapelInput>
  }

  export type ScheduleCreateWithoutMapelInput = {
    id?: string
    disable?: boolean
    year: SchoolYearCreateNestedOneWithoutScheduleInput
    tracker?: TrackerCreateNestedManyWithoutJadwalInput
    teaching?: TeachingCreateNestedManyWithoutRefInput
  }

  export type ScheduleUncheckedCreateWithoutMapelInput = {
    id?: string
    yearId: string
    disable?: boolean
    tracker?: TrackerUncheckedCreateNestedManyWithoutJadwalInput
    teaching?: TeachingUncheckedCreateNestedManyWithoutRefInput
  }

  export type ScheduleCreateOrConnectWithoutMapelInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutMapelInput, ScheduleUncheckedCreateWithoutMapelInput>
  }

  export type ScheduleCreateManyMapelInputEnvelope = {
    data: Enumerable<ScheduleCreateManyMapelInput>
  }

  export type TrackerCreateWithoutMapelInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrackerInput
    ref: InstansiCreateNestedOneWithoutHistoryInput
    instansi?: InstansiCreateNestedOneWithoutTrackerInput
    elemen?: ElementCreateNestedOneWithoutTrackerInput
    cp?: AchievementCreateNestedOneWithoutTrackerInput
    bidang?: BidangKeahlianCreateNestedOneWithoutTrackerInput
    program?: ProgramKeahlianCreateNestedOneWithoutTrackerInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedOneWithoutTrackerInput
    tp?: SchoolYearCreateNestedOneWithoutTrackerInput
    teacher?: TeacherCreateNestedOneWithoutTrackerInput
    kelas?: ClassRoomCreateNestedOneWithoutTrackerInput
    murid?: StudentCreateNestedOneWithoutTrackerInput
    jadwal?: ScheduleCreateNestedOneWithoutTrackerInput
    mengajar?: TeachingCreateNestedOneWithoutTrackerInput
    tujuan?: ObjectiveCreateNestedOneWithoutTrackerInput
    perangkat?: TDeviceCreateNestedOneWithoutTrackerInput
    kalender?: CalendarCreateNestedOneWithoutTrackerInput
    dudi?: DudiCreateNestedOneWithoutTrackerInput
    kkni?: KkniCreateNestedOneWithoutTrackerInput
  }

  export type TrackerUncheckedCreateWithoutMapelInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TrackerCreateOrConnectWithoutMapelInput = {
    where: TrackerWhereUniqueInput
    create: XOR<TrackerCreateWithoutMapelInput, TrackerUncheckedCreateWithoutMapelInput>
  }

  export type TrackerCreateManyMapelInputEnvelope = {
    data: Enumerable<TrackerCreateManyMapelInput>
  }

  export type ObjectiveCreateWithoutMapelInput = {
    id?: string
    level: number
    fase: Fase
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    user: UserCreateNestedOneWithoutObjectiveInput
    instansi: InstansiCreateNestedOneWithoutObjectiveInput
    year: SchoolYearCreateNestedOneWithoutObjectiveInput
    elemen: ElementCreateNestedOneWithoutObjectiveInput
    achievement: AchievementCreateNestedOneWithoutObjectiveInput
    material?: OMaterialCreateNestedManyWithoutRefInput
    tracker?: TrackerCreateNestedManyWithoutTujuanInput
    resourse?: OresourceCreateNestedManyWithoutRefInput
    ppp?: OpppCreateNestedManyWithoutRefInput
    tool?: OhelperCreateNestedManyWithoutToolInput
    mate?: OhelperCreateNestedManyWithoutMateInput
    meth?: OhelperCreateNestedManyWithoutMethInput
    media?: OhelperCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentCreateNestedManyWithoutRefInput
    devices?: TDeviceDataCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveUncheckedCreateWithoutMapelInput = {
    id?: string
    level: number
    fase: Fase
    userId: string
    instansiId: string
    yearId: string
    elementId: string
    achievementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedCreateNestedManyWithoutRefInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTujuanInput
    resourse?: OresourceUncheckedCreateNestedManyWithoutRefInput
    ppp?: OpppUncheckedCreateNestedManyWithoutRefInput
    tool?: OhelperUncheckedCreateNestedManyWithoutToolInput
    mate?: OhelperUncheckedCreateNestedManyWithoutMateInput
    meth?: OhelperUncheckedCreateNestedManyWithoutMethInput
    media?: OhelperUncheckedCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentUncheckedCreateNestedManyWithoutRefInput
    devices?: TDeviceDataUncheckedCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveCreateOrConnectWithoutMapelInput = {
    where: ObjectiveWhereUniqueInput
    create: XOR<ObjectiveCreateWithoutMapelInput, ObjectiveUncheckedCreateWithoutMapelInput>
  }

  export type ObjectiveCreateManyMapelInputEnvelope = {
    data: Enumerable<ObjectiveCreateManyMapelInput>
  }

  export type TDeviceCreateWithoutMapelInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    teaching: TeachingCreateNestedOneWithoutTDeviceInput
    year: SchoolYearCreateNestedOneWithoutTDeviceInput
    user: UserCreateNestedOneWithoutTDeviceInput
    instansi: InstansiCreateNestedOneWithoutTDeviceInput
    classRoom?: ClassRoomCreateNestedManyWithoutTDeviceInput
    tracker?: TrackerCreateNestedManyWithoutPerangkatInput
    data?: TDeviceDataCreateNestedManyWithoutRefInput
    children?: TDeviceCreateNestedManyWithoutParentInput
    parent?: TDeviceCreateNestedOneWithoutChildrenInput
  }

  export type TDeviceUncheckedCreateWithoutMapelInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    teachingId: string
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    yearId: string
    userId: string
    instansiId: string
    classRoomIds?: TDeviceCreateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    parentId?: string | null
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutTDeviceInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutPerangkatInput
    data?: TDeviceDataUncheckedCreateNestedManyWithoutRefInput
    children?: TDeviceUncheckedCreateNestedManyWithoutParentInput
  }

  export type TDeviceCreateOrConnectWithoutMapelInput = {
    where: TDeviceWhereUniqueInput
    create: XOR<TDeviceCreateWithoutMapelInput, TDeviceUncheckedCreateWithoutMapelInput>
  }

  export type TDeviceCreateManyMapelInputEnvelope = {
    data: Enumerable<TDeviceCreateManyMapelInput>
  }

  export type ProgramKeahlianUpsertWithoutMapelInput = {
    update: XOR<ProgramKeahlianUpdateWithoutMapelInput, ProgramKeahlianUncheckedUpdateWithoutMapelInput>
    create: XOR<ProgramKeahlianCreateWithoutMapelInput, ProgramKeahlianUncheckedCreateWithoutMapelInput>
  }

  export type ProgramKeahlianUpdateWithoutMapelInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    bidang?: BidangKeahlianUpdateOneRequiredWithoutProgramNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateManyWithoutProgramNestedInput
    tracker?: TrackerUpdateManyWithoutProgramNestedInput
  }

  export type ProgramKeahlianUncheckedUpdateWithoutMapelInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bidangId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    konsentrasi?: KonsentrasiKeahlianUncheckedUpdateManyWithoutProgramNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type KonsentrasiKeahlianUpsertWithoutMapelInput = {
    update: XOR<KonsentrasiKeahlianUpdateWithoutMapelInput, KonsentrasiKeahlianUncheckedUpdateWithoutMapelInput>
    create: XOR<KonsentrasiKeahlianCreateWithoutMapelInput, KonsentrasiKeahlianUncheckedCreateWithoutMapelInput>
  }

  export type KonsentrasiKeahlianUpdateWithoutMapelInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    disable?: BoolFieldUpdateOperationsInput | boolean
    program?: ProgramKeahlianUpdateOneRequiredWithoutKonsentrasiNestedInput
    student?: StudentUpdateManyWithoutMajorNestedInput
    instansi?: InstansiUpdateManyWithoutMajorsNestedInput
    classRoom?: ClassRoomUpdateManyWithoutMajorNestedInput
    tracker?: TrackerUpdateManyWithoutKonsentrasiNestedInput
    dudi?: DudiUpdateManyWithoutMajorNestedInput
    kkni?: KkniUpdateManyWithoutKonsentrasiNestedInput
  }

  export type KonsentrasiKeahlianUncheckedUpdateWithoutMapelInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    instansiIds?: KonsentrasiKeahlianUpdateinstansiIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUncheckedUpdateManyWithoutMajorNestedInput
    instansi?: InstansiUncheckedUpdateManyWithoutMajorsNestedInput
    classRoom?: ClassRoomUncheckedUpdateManyWithoutMajorNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutKonsentrasiNestedInput
    dudi?: DudiUncheckedUpdateManyWithoutMajorNestedInput
    kkni?: KkniUncheckedUpdateManyWithoutKonsentrasiNestedInput
  }

  export type InstansiUpsertWithoutUnikMapelsInput = {
    update: XOR<InstansiUpdateWithoutUnikMapelsInput, InstansiUncheckedUpdateWithoutUnikMapelsInput>
    create: XOR<InstansiCreateWithoutUnikMapelsInput, InstansiUncheckedCreateWithoutUnikMapelsInput>
  }

  export type InstansiUpdateWithoutUnikMapelsInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    majors?: KonsentrasiKeahlianUpdateManyWithoutInstansiNestedInput
    role?: RoleUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUpdateManyWithoutInstansiNestedInput
    student?: StudentUpdateManyWithoutInstansiNestedInput
    tracker?: TrackerUpdateManyWithoutInstansiNestedInput
    history?: TrackerUpdateManyWithoutRefNestedInput
    tDevice?: TDeviceUpdateManyWithoutInstansiNestedInput
    objective?: ObjectiveUpdateManyWithoutInstansiNestedInput
    dudi?: DudiUpdateManyWithoutInstansiNestedInput
  }

  export type InstansiUncheckedUpdateWithoutUnikMapelsInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    majorIds?: InstansiUpdatemajorIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    majors?: KonsentrasiKeahlianUncheckedUpdateManyWithoutInstansiNestedInput
    role?: RoleUncheckedUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUncheckedUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutInstansiNestedInput
    student?: StudentUncheckedUpdateManyWithoutInstansiNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutInstansiNestedInput
    history?: TrackerUncheckedUpdateManyWithoutRefNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutInstansiNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutInstansiNestedInput
    dudi?: DudiUncheckedUpdateManyWithoutInstansiNestedInput
  }

  export type ElementUpsertWithWhereUniqueWithoutMapelInput = {
    where: ElementWhereUniqueInput
    update: XOR<ElementUpdateWithoutMapelInput, ElementUncheckedUpdateWithoutMapelInput>
    create: XOR<ElementCreateWithoutMapelInput, ElementUncheckedCreateWithoutMapelInput>
  }

  export type ElementUpdateWithWhereUniqueWithoutMapelInput = {
    where: ElementWhereUniqueInput
    data: XOR<ElementUpdateWithoutMapelInput, ElementUncheckedUpdateWithoutMapelInput>
  }

  export type ElementUpdateManyWithWhereWithoutMapelInput = {
    where: ElementScalarWhereInput
    data: XOR<ElementUpdateManyMutationInput, ElementUncheckedUpdateManyWithoutElementInput>
  }

  export type ElementScalarWhereInput = {
    AND?: Enumerable<ElementScalarWhereInput>
    OR?: Enumerable<ElementScalarWhereInput>
    NOT?: Enumerable<ElementScalarWhereInput>
    id?: StringFilter | string
    no?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    mapelId?: StringFilter | string
    disable?: BoolFilter | boolean
    scheduleClassIds?: StringNullableListFilter
  }

  export type ScheduleUpsertWithWhereUniqueWithoutMapelInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutMapelInput, ScheduleUncheckedUpdateWithoutMapelInput>
    create: XOR<ScheduleCreateWithoutMapelInput, ScheduleUncheckedCreateWithoutMapelInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutMapelInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutMapelInput, ScheduleUncheckedUpdateWithoutMapelInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutMapelInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutScheduleInput>
  }

  export type ScheduleScalarWhereInput = {
    AND?: Enumerable<ScheduleScalarWhereInput>
    OR?: Enumerable<ScheduleScalarWhereInput>
    NOT?: Enumerable<ScheduleScalarWhereInput>
    id?: StringFilter | string
    yearId?: StringFilter | string
    mapelId?: StringFilter | string
    disable?: BoolFilter | boolean
  }

  export type TrackerUpsertWithWhereUniqueWithoutMapelInput = {
    where: TrackerWhereUniqueInput
    update: XOR<TrackerUpdateWithoutMapelInput, TrackerUncheckedUpdateWithoutMapelInput>
    create: XOR<TrackerCreateWithoutMapelInput, TrackerUncheckedCreateWithoutMapelInput>
  }

  export type TrackerUpdateWithWhereUniqueWithoutMapelInput = {
    where: TrackerWhereUniqueInput
    data: XOR<TrackerUpdateWithoutMapelInput, TrackerUncheckedUpdateWithoutMapelInput>
  }

  export type TrackerUpdateManyWithWhereWithoutMapelInput = {
    where: TrackerScalarWhereInput
    data: XOR<TrackerUpdateManyMutationInput, TrackerUncheckedUpdateManyWithoutTrackerInput>
  }

  export type ObjectiveUpsertWithWhereUniqueWithoutMapelInput = {
    where: ObjectiveWhereUniqueInput
    update: XOR<ObjectiveUpdateWithoutMapelInput, ObjectiveUncheckedUpdateWithoutMapelInput>
    create: XOR<ObjectiveCreateWithoutMapelInput, ObjectiveUncheckedCreateWithoutMapelInput>
  }

  export type ObjectiveUpdateWithWhereUniqueWithoutMapelInput = {
    where: ObjectiveWhereUniqueInput
    data: XOR<ObjectiveUpdateWithoutMapelInput, ObjectiveUncheckedUpdateWithoutMapelInput>
  }

  export type ObjectiveUpdateManyWithWhereWithoutMapelInput = {
    where: ObjectiveScalarWhereInput
    data: XOR<ObjectiveUpdateManyMutationInput, ObjectiveUncheckedUpdateManyWithoutObjectiveInput>
  }

  export type TDeviceUpsertWithWhereUniqueWithoutMapelInput = {
    where: TDeviceWhereUniqueInput
    update: XOR<TDeviceUpdateWithoutMapelInput, TDeviceUncheckedUpdateWithoutMapelInput>
    create: XOR<TDeviceCreateWithoutMapelInput, TDeviceUncheckedCreateWithoutMapelInput>
  }

  export type TDeviceUpdateWithWhereUniqueWithoutMapelInput = {
    where: TDeviceWhereUniqueInput
    data: XOR<TDeviceUpdateWithoutMapelInput, TDeviceUncheckedUpdateWithoutMapelInput>
  }

  export type TDeviceUpdateManyWithWhereWithoutMapelInput = {
    where: TDeviceScalarWhereInput
    data: XOR<TDeviceUpdateManyMutationInput, TDeviceUncheckedUpdateManyWithoutDeviceInput>
  }

  export type AchievementCreateWithoutElementInput = {
    id?: string
    no: number
    fase?: Fase
    description: string
    disable?: boolean
    objective?: ObjectiveCreateNestedManyWithoutAchievementInput
    tracker?: TrackerCreateNestedManyWithoutCpInput
  }

  export type AchievementUncheckedCreateWithoutElementInput = {
    id?: string
    no: number
    fase?: Fase
    description: string
    disable?: boolean
    objective?: ObjectiveUncheckedCreateNestedManyWithoutAchievementInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutCpInput
  }

  export type AchievementCreateOrConnectWithoutElementInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutElementInput, AchievementUncheckedCreateWithoutElementInput>
  }

  export type AchievementCreateManyElementInputEnvelope = {
    data: Enumerable<AchievementCreateManyElementInput>
  }

  export type MataPelajaranCreateWithoutElementInput = {
    id?: string
    level?: Level | null
    type?: MataPelajaranType
    no: string
    code: string
    name: string
    religion?: Religion | null
    disable?: boolean
    program?: ProgramKeahlianCreateNestedOneWithoutMapelInput
    keahlian?: KonsentrasiKeahlianCreateNestedOneWithoutMapelInput
    instansi?: InstansiCreateNestedOneWithoutUnikMapelsInput
    schedule?: ScheduleCreateNestedManyWithoutMapelInput
    tracker?: TrackerCreateNestedManyWithoutMapelInput
    objective?: ObjectiveCreateNestedManyWithoutMapelInput
    device?: TDeviceCreateNestedManyWithoutMapelInput
  }

  export type MataPelajaranUncheckedCreateWithoutElementInput = {
    id?: string
    level?: Level | null
    type?: MataPelajaranType
    no: string
    code: string
    name: string
    religion?: Religion | null
    programId?: string | null
    keahlianid?: string | null
    instansiId?: string | null
    disable?: boolean
    schedule?: ScheduleUncheckedCreateNestedManyWithoutMapelInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutMapelInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutMapelInput
    device?: TDeviceUncheckedCreateNestedManyWithoutMapelInput
  }

  export type MataPelajaranCreateOrConnectWithoutElementInput = {
    where: MataPelajaranWhereUniqueInput
    create: XOR<MataPelajaranCreateWithoutElementInput, MataPelajaranUncheckedCreateWithoutElementInput>
  }

  export type TrackerCreateWithoutElemenInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrackerInput
    ref: InstansiCreateNestedOneWithoutHistoryInput
    instansi?: InstansiCreateNestedOneWithoutTrackerInput
    mapel?: MataPelajaranCreateNestedOneWithoutTrackerInput
    cp?: AchievementCreateNestedOneWithoutTrackerInput
    bidang?: BidangKeahlianCreateNestedOneWithoutTrackerInput
    program?: ProgramKeahlianCreateNestedOneWithoutTrackerInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedOneWithoutTrackerInput
    tp?: SchoolYearCreateNestedOneWithoutTrackerInput
    teacher?: TeacherCreateNestedOneWithoutTrackerInput
    kelas?: ClassRoomCreateNestedOneWithoutTrackerInput
    murid?: StudentCreateNestedOneWithoutTrackerInput
    jadwal?: ScheduleCreateNestedOneWithoutTrackerInput
    mengajar?: TeachingCreateNestedOneWithoutTrackerInput
    tujuan?: ObjectiveCreateNestedOneWithoutTrackerInput
    perangkat?: TDeviceCreateNestedOneWithoutTrackerInput
    kalender?: CalendarCreateNestedOneWithoutTrackerInput
    dudi?: DudiCreateNestedOneWithoutTrackerInput
    kkni?: KkniCreateNestedOneWithoutTrackerInput
  }

  export type TrackerUncheckedCreateWithoutElemenInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TrackerCreateOrConnectWithoutElemenInput = {
    where: TrackerWhereUniqueInput
    create: XOR<TrackerCreateWithoutElemenInput, TrackerUncheckedCreateWithoutElemenInput>
  }

  export type TrackerCreateManyElemenInputEnvelope = {
    data: Enumerable<TrackerCreateManyElemenInput>
  }

  export type TeachingCreateWithoutElemenInput = {
    id?: string
    level: number
    hours: number
    semester: Semester
    disable?: boolean
    ref: ScheduleCreateNestedOneWithoutTeachingInput
    teacher: TeacherCreateNestedOneWithoutTeachingInput
    classRoom?: ClassRoomCreateNestedManyWithoutTeachingInput
    tracker?: TrackerCreateNestedManyWithoutMengajarInput
    tDevice?: TDeviceCreateNestedManyWithoutTeachingInput
  }

  export type TeachingUncheckedCreateWithoutElemenInput = {
    id?: string
    refId: string
    level: number
    hours: number
    semester: Semester
    teacherId: string
    classRoomIds?: TeachingCreateclassRoomIdsInput | Enumerable<string>
    elemenIds?: TeachingCreateelemenIdsInput | Enumerable<string>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutTeachingInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutMengajarInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutTeachingInput
  }

  export type TeachingCreateOrConnectWithoutElemenInput = {
    where: TeachingWhereUniqueInput
    create: XOR<TeachingCreateWithoutElemenInput, TeachingUncheckedCreateWithoutElemenInput>
  }

  export type ObjectiveCreateWithoutElemenInput = {
    id?: string
    level: number
    fase: Fase
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    user: UserCreateNestedOneWithoutObjectiveInput
    instansi: InstansiCreateNestedOneWithoutObjectiveInput
    year: SchoolYearCreateNestedOneWithoutObjectiveInput
    mapel: MataPelajaranCreateNestedOneWithoutObjectiveInput
    achievement: AchievementCreateNestedOneWithoutObjectiveInput
    material?: OMaterialCreateNestedManyWithoutRefInput
    tracker?: TrackerCreateNestedManyWithoutTujuanInput
    resourse?: OresourceCreateNestedManyWithoutRefInput
    ppp?: OpppCreateNestedManyWithoutRefInput
    tool?: OhelperCreateNestedManyWithoutToolInput
    mate?: OhelperCreateNestedManyWithoutMateInput
    meth?: OhelperCreateNestedManyWithoutMethInput
    media?: OhelperCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentCreateNestedManyWithoutRefInput
    devices?: TDeviceDataCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveUncheckedCreateWithoutElemenInput = {
    id?: string
    level: number
    fase: Fase
    userId: string
    instansiId: string
    yearId: string
    mapelId: string
    achievementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedCreateNestedManyWithoutRefInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTujuanInput
    resourse?: OresourceUncheckedCreateNestedManyWithoutRefInput
    ppp?: OpppUncheckedCreateNestedManyWithoutRefInput
    tool?: OhelperUncheckedCreateNestedManyWithoutToolInput
    mate?: OhelperUncheckedCreateNestedManyWithoutMateInput
    meth?: OhelperUncheckedCreateNestedManyWithoutMethInput
    media?: OhelperUncheckedCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentUncheckedCreateNestedManyWithoutRefInput
    devices?: TDeviceDataUncheckedCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveCreateOrConnectWithoutElemenInput = {
    where: ObjectiveWhereUniqueInput
    create: XOR<ObjectiveCreateWithoutElemenInput, ObjectiveUncheckedCreateWithoutElemenInput>
  }

  export type ObjectiveCreateManyElemenInputEnvelope = {
    data: Enumerable<ObjectiveCreateManyElemenInput>
  }

  export type AchievementUpsertWithWhereUniqueWithoutElementInput = {
    where: AchievementWhereUniqueInput
    update: XOR<AchievementUpdateWithoutElementInput, AchievementUncheckedUpdateWithoutElementInput>
    create: XOR<AchievementCreateWithoutElementInput, AchievementUncheckedCreateWithoutElementInput>
  }

  export type AchievementUpdateWithWhereUniqueWithoutElementInput = {
    where: AchievementWhereUniqueInput
    data: XOR<AchievementUpdateWithoutElementInput, AchievementUncheckedUpdateWithoutElementInput>
  }

  export type AchievementUpdateManyWithWhereWithoutElementInput = {
    where: AchievementScalarWhereInput
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyWithoutAchievementInput>
  }

  export type AchievementScalarWhereInput = {
    AND?: Enumerable<AchievementScalarWhereInput>
    OR?: Enumerable<AchievementScalarWhereInput>
    NOT?: Enumerable<AchievementScalarWhereInput>
    id?: StringFilter | string
    no?: IntFilter | number
    fase?: EnumFaseFilter | Fase
    description?: StringFilter | string
    elementId?: StringFilter | string
    disable?: BoolFilter | boolean
  }

  export type MataPelajaranUpsertWithoutElementInput = {
    update: XOR<MataPelajaranUpdateWithoutElementInput, MataPelajaranUncheckedUpdateWithoutElementInput>
    create: XOR<MataPelajaranCreateWithoutElementInput, MataPelajaranUncheckedCreateWithoutElementInput>
  }

  export type MataPelajaranUpdateWithoutElementInput = {
    level?: NullableEnumLevelFieldUpdateOperationsInput | Level | null
    type?: EnumMataPelajaranTypeFieldUpdateOperationsInput | MataPelajaranType
    no?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    program?: ProgramKeahlianUpdateOneWithoutMapelNestedInput
    keahlian?: KonsentrasiKeahlianUpdateOneWithoutMapelNestedInput
    instansi?: InstansiUpdateOneWithoutUnikMapelsNestedInput
    schedule?: ScheduleUpdateManyWithoutMapelNestedInput
    tracker?: TrackerUpdateManyWithoutMapelNestedInput
    objective?: ObjectiveUpdateManyWithoutMapelNestedInput
    device?: TDeviceUpdateManyWithoutMapelNestedInput
  }

  export type MataPelajaranUncheckedUpdateWithoutElementInput = {
    level?: NullableEnumLevelFieldUpdateOperationsInput | Level | null
    type?: EnumMataPelajaranTypeFieldUpdateOperationsInput | MataPelajaranType
    no?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    keahlianid?: NullableStringFieldUpdateOperationsInput | string | null
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    schedule?: ScheduleUncheckedUpdateManyWithoutMapelNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutMapelNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutMapelNestedInput
    device?: TDeviceUncheckedUpdateManyWithoutMapelNestedInput
  }

  export type TrackerUpsertWithWhereUniqueWithoutElemenInput = {
    where: TrackerWhereUniqueInput
    update: XOR<TrackerUpdateWithoutElemenInput, TrackerUncheckedUpdateWithoutElemenInput>
    create: XOR<TrackerCreateWithoutElemenInput, TrackerUncheckedCreateWithoutElemenInput>
  }

  export type TrackerUpdateWithWhereUniqueWithoutElemenInput = {
    where: TrackerWhereUniqueInput
    data: XOR<TrackerUpdateWithoutElemenInput, TrackerUncheckedUpdateWithoutElemenInput>
  }

  export type TrackerUpdateManyWithWhereWithoutElemenInput = {
    where: TrackerScalarWhereInput
    data: XOR<TrackerUpdateManyMutationInput, TrackerUncheckedUpdateManyWithoutTrackerInput>
  }

  export type TeachingUpsertWithWhereUniqueWithoutElemenInput = {
    where: TeachingWhereUniqueInput
    update: XOR<TeachingUpdateWithoutElemenInput, TeachingUncheckedUpdateWithoutElemenInput>
    create: XOR<TeachingCreateWithoutElemenInput, TeachingUncheckedCreateWithoutElemenInput>
  }

  export type TeachingUpdateWithWhereUniqueWithoutElemenInput = {
    where: TeachingWhereUniqueInput
    data: XOR<TeachingUpdateWithoutElemenInput, TeachingUncheckedUpdateWithoutElemenInput>
  }

  export type TeachingUpdateManyWithWhereWithoutElemenInput = {
    where: TeachingScalarWhereInput
    data: XOR<TeachingUpdateManyMutationInput, TeachingUncheckedUpdateManyWithoutScheduleClassInput>
  }

  export type TeachingScalarWhereInput = {
    AND?: Enumerable<TeachingScalarWhereInput>
    OR?: Enumerable<TeachingScalarWhereInput>
    NOT?: Enumerable<TeachingScalarWhereInput>
    id?: StringFilter | string
    refId?: StringFilter | string
    level?: IntFilter | number
    hours?: IntFilter | number
    semester?: EnumSemesterFilter | Semester
    teacherId?: StringFilter | string
    classRoomIds?: StringNullableListFilter
    elemenIds?: StringNullableListFilter
    disable?: BoolFilter | boolean
  }

  export type ObjectiveUpsertWithWhereUniqueWithoutElemenInput = {
    where: ObjectiveWhereUniqueInput
    update: XOR<ObjectiveUpdateWithoutElemenInput, ObjectiveUncheckedUpdateWithoutElemenInput>
    create: XOR<ObjectiveCreateWithoutElemenInput, ObjectiveUncheckedCreateWithoutElemenInput>
  }

  export type ObjectiveUpdateWithWhereUniqueWithoutElemenInput = {
    where: ObjectiveWhereUniqueInput
    data: XOR<ObjectiveUpdateWithoutElemenInput, ObjectiveUncheckedUpdateWithoutElemenInput>
  }

  export type ObjectiveUpdateManyWithWhereWithoutElemenInput = {
    where: ObjectiveScalarWhereInput
    data: XOR<ObjectiveUpdateManyMutationInput, ObjectiveUncheckedUpdateManyWithoutObjectiveInput>
  }

  export type ElementCreateWithoutAchievementInput = {
    id?: string
    no: number
    name: string
    description: string
    disable?: boolean
    mapel: MataPelajaranCreateNestedOneWithoutElementInput
    tracker?: TrackerCreateNestedManyWithoutElemenInput
    scheduleClass?: TeachingCreateNestedManyWithoutElemenInput
    objective?: ObjectiveCreateNestedManyWithoutElemenInput
  }

  export type ElementUncheckedCreateWithoutAchievementInput = {
    id?: string
    no: number
    name: string
    description: string
    mapelId: string
    disable?: boolean
    scheduleClassIds?: ElementCreatescheduleClassIdsInput | Enumerable<string>
    tracker?: TrackerUncheckedCreateNestedManyWithoutElemenInput
    scheduleClass?: TeachingUncheckedCreateNestedManyWithoutElemenInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutElemenInput
  }

  export type ElementCreateOrConnectWithoutAchievementInput = {
    where: ElementWhereUniqueInput
    create: XOR<ElementCreateWithoutAchievementInput, ElementUncheckedCreateWithoutAchievementInput>
  }

  export type ObjectiveCreateWithoutAchievementInput = {
    id?: string
    level: number
    fase: Fase
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    user: UserCreateNestedOneWithoutObjectiveInput
    instansi: InstansiCreateNestedOneWithoutObjectiveInput
    year: SchoolYearCreateNestedOneWithoutObjectiveInput
    mapel: MataPelajaranCreateNestedOneWithoutObjectiveInput
    elemen: ElementCreateNestedOneWithoutObjectiveInput
    material?: OMaterialCreateNestedManyWithoutRefInput
    tracker?: TrackerCreateNestedManyWithoutTujuanInput
    resourse?: OresourceCreateNestedManyWithoutRefInput
    ppp?: OpppCreateNestedManyWithoutRefInput
    tool?: OhelperCreateNestedManyWithoutToolInput
    mate?: OhelperCreateNestedManyWithoutMateInput
    meth?: OhelperCreateNestedManyWithoutMethInput
    media?: OhelperCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentCreateNestedManyWithoutRefInput
    devices?: TDeviceDataCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveUncheckedCreateWithoutAchievementInput = {
    id?: string
    level: number
    fase: Fase
    userId: string
    instansiId: string
    yearId: string
    mapelId: string
    elementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedCreateNestedManyWithoutRefInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTujuanInput
    resourse?: OresourceUncheckedCreateNestedManyWithoutRefInput
    ppp?: OpppUncheckedCreateNestedManyWithoutRefInput
    tool?: OhelperUncheckedCreateNestedManyWithoutToolInput
    mate?: OhelperUncheckedCreateNestedManyWithoutMateInput
    meth?: OhelperUncheckedCreateNestedManyWithoutMethInput
    media?: OhelperUncheckedCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentUncheckedCreateNestedManyWithoutRefInput
    devices?: TDeviceDataUncheckedCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveCreateOrConnectWithoutAchievementInput = {
    where: ObjectiveWhereUniqueInput
    create: XOR<ObjectiveCreateWithoutAchievementInput, ObjectiveUncheckedCreateWithoutAchievementInput>
  }

  export type ObjectiveCreateManyAchievementInputEnvelope = {
    data: Enumerable<ObjectiveCreateManyAchievementInput>
  }

  export type TrackerCreateWithoutCpInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrackerInput
    ref: InstansiCreateNestedOneWithoutHistoryInput
    instansi?: InstansiCreateNestedOneWithoutTrackerInput
    mapel?: MataPelajaranCreateNestedOneWithoutTrackerInput
    elemen?: ElementCreateNestedOneWithoutTrackerInput
    bidang?: BidangKeahlianCreateNestedOneWithoutTrackerInput
    program?: ProgramKeahlianCreateNestedOneWithoutTrackerInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedOneWithoutTrackerInput
    tp?: SchoolYearCreateNestedOneWithoutTrackerInput
    teacher?: TeacherCreateNestedOneWithoutTrackerInput
    kelas?: ClassRoomCreateNestedOneWithoutTrackerInput
    murid?: StudentCreateNestedOneWithoutTrackerInput
    jadwal?: ScheduleCreateNestedOneWithoutTrackerInput
    mengajar?: TeachingCreateNestedOneWithoutTrackerInput
    tujuan?: ObjectiveCreateNestedOneWithoutTrackerInput
    perangkat?: TDeviceCreateNestedOneWithoutTrackerInput
    kalender?: CalendarCreateNestedOneWithoutTrackerInput
    dudi?: DudiCreateNestedOneWithoutTrackerInput
    kkni?: KkniCreateNestedOneWithoutTrackerInput
  }

  export type TrackerUncheckedCreateWithoutCpInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TrackerCreateOrConnectWithoutCpInput = {
    where: TrackerWhereUniqueInput
    create: XOR<TrackerCreateWithoutCpInput, TrackerUncheckedCreateWithoutCpInput>
  }

  export type TrackerCreateManyCpInputEnvelope = {
    data: Enumerable<TrackerCreateManyCpInput>
  }

  export type ElementUpsertWithoutAchievementInput = {
    update: XOR<ElementUpdateWithoutAchievementInput, ElementUncheckedUpdateWithoutAchievementInput>
    create: XOR<ElementCreateWithoutAchievementInput, ElementUncheckedCreateWithoutAchievementInput>
  }

  export type ElementUpdateWithoutAchievementInput = {
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    mapel?: MataPelajaranUpdateOneRequiredWithoutElementNestedInput
    tracker?: TrackerUpdateManyWithoutElemenNestedInput
    scheduleClass?: TeachingUpdateManyWithoutElemenNestedInput
    objective?: ObjectiveUpdateManyWithoutElemenNestedInput
  }

  export type ElementUncheckedUpdateWithoutAchievementInput = {
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    scheduleClassIds?: ElementUpdatescheduleClassIdsInput | Enumerable<string>
    tracker?: TrackerUncheckedUpdateManyWithoutElemenNestedInput
    scheduleClass?: TeachingUncheckedUpdateManyWithoutElemenNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutElemenNestedInput
  }

  export type ObjectiveUpsertWithWhereUniqueWithoutAchievementInput = {
    where: ObjectiveWhereUniqueInput
    update: XOR<ObjectiveUpdateWithoutAchievementInput, ObjectiveUncheckedUpdateWithoutAchievementInput>
    create: XOR<ObjectiveCreateWithoutAchievementInput, ObjectiveUncheckedCreateWithoutAchievementInput>
  }

  export type ObjectiveUpdateWithWhereUniqueWithoutAchievementInput = {
    where: ObjectiveWhereUniqueInput
    data: XOR<ObjectiveUpdateWithoutAchievementInput, ObjectiveUncheckedUpdateWithoutAchievementInput>
  }

  export type ObjectiveUpdateManyWithWhereWithoutAchievementInput = {
    where: ObjectiveScalarWhereInput
    data: XOR<ObjectiveUpdateManyMutationInput, ObjectiveUncheckedUpdateManyWithoutObjectiveInput>
  }

  export type TrackerUpsertWithWhereUniqueWithoutCpInput = {
    where: TrackerWhereUniqueInput
    update: XOR<TrackerUpdateWithoutCpInput, TrackerUncheckedUpdateWithoutCpInput>
    create: XOR<TrackerCreateWithoutCpInput, TrackerUncheckedCreateWithoutCpInput>
  }

  export type TrackerUpdateWithWhereUniqueWithoutCpInput = {
    where: TrackerWhereUniqueInput
    data: XOR<TrackerUpdateWithoutCpInput, TrackerUncheckedUpdateWithoutCpInput>
  }

  export type TrackerUpdateManyWithWhereWithoutCpInput = {
    where: TrackerScalarWhereInput
    data: XOR<TrackerUpdateManyMutationInput, TrackerUncheckedUpdateManyWithoutTrackerInput>
  }

  export type ProgramKeahlianCreateWithoutBidangInput = {
    id?: string
    code: string
    name: string
    disable?: boolean
    konsentrasi?: KonsentrasiKeahlianCreateNestedManyWithoutProgramInput
    tracker?: TrackerCreateNestedManyWithoutProgramInput
    mapel?: MataPelajaranCreateNestedManyWithoutProgramInput
  }

  export type ProgramKeahlianUncheckedCreateWithoutBidangInput = {
    id?: string
    code: string
    name: string
    disable?: boolean
    konsentrasi?: KonsentrasiKeahlianUncheckedCreateNestedManyWithoutProgramInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutProgramInput
    mapel?: MataPelajaranUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramKeahlianCreateOrConnectWithoutBidangInput = {
    where: ProgramKeahlianWhereUniqueInput
    create: XOR<ProgramKeahlianCreateWithoutBidangInput, ProgramKeahlianUncheckedCreateWithoutBidangInput>
  }

  export type ProgramKeahlianCreateManyBidangInputEnvelope = {
    data: Enumerable<ProgramKeahlianCreateManyBidangInput>
  }

  export type TrackerCreateWithoutBidangInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrackerInput
    ref: InstansiCreateNestedOneWithoutHistoryInput
    instansi?: InstansiCreateNestedOneWithoutTrackerInput
    mapel?: MataPelajaranCreateNestedOneWithoutTrackerInput
    elemen?: ElementCreateNestedOneWithoutTrackerInput
    cp?: AchievementCreateNestedOneWithoutTrackerInput
    program?: ProgramKeahlianCreateNestedOneWithoutTrackerInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedOneWithoutTrackerInput
    tp?: SchoolYearCreateNestedOneWithoutTrackerInput
    teacher?: TeacherCreateNestedOneWithoutTrackerInput
    kelas?: ClassRoomCreateNestedOneWithoutTrackerInput
    murid?: StudentCreateNestedOneWithoutTrackerInput
    jadwal?: ScheduleCreateNestedOneWithoutTrackerInput
    mengajar?: TeachingCreateNestedOneWithoutTrackerInput
    tujuan?: ObjectiveCreateNestedOneWithoutTrackerInput
    perangkat?: TDeviceCreateNestedOneWithoutTrackerInput
    kalender?: CalendarCreateNestedOneWithoutTrackerInput
    dudi?: DudiCreateNestedOneWithoutTrackerInput
    kkni?: KkniCreateNestedOneWithoutTrackerInput
  }

  export type TrackerUncheckedCreateWithoutBidangInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TrackerCreateOrConnectWithoutBidangInput = {
    where: TrackerWhereUniqueInput
    create: XOR<TrackerCreateWithoutBidangInput, TrackerUncheckedCreateWithoutBidangInput>
  }

  export type TrackerCreateManyBidangInputEnvelope = {
    data: Enumerable<TrackerCreateManyBidangInput>
  }

  export type ProgramKeahlianUpsertWithWhereUniqueWithoutBidangInput = {
    where: ProgramKeahlianWhereUniqueInput
    update: XOR<ProgramKeahlianUpdateWithoutBidangInput, ProgramKeahlianUncheckedUpdateWithoutBidangInput>
    create: XOR<ProgramKeahlianCreateWithoutBidangInput, ProgramKeahlianUncheckedCreateWithoutBidangInput>
  }

  export type ProgramKeahlianUpdateWithWhereUniqueWithoutBidangInput = {
    where: ProgramKeahlianWhereUniqueInput
    data: XOR<ProgramKeahlianUpdateWithoutBidangInput, ProgramKeahlianUncheckedUpdateWithoutBidangInput>
  }

  export type ProgramKeahlianUpdateManyWithWhereWithoutBidangInput = {
    where: ProgramKeahlianScalarWhereInput
    data: XOR<ProgramKeahlianUpdateManyMutationInput, ProgramKeahlianUncheckedUpdateManyWithoutProgramInput>
  }

  export type ProgramKeahlianScalarWhereInput = {
    AND?: Enumerable<ProgramKeahlianScalarWhereInput>
    OR?: Enumerable<ProgramKeahlianScalarWhereInput>
    NOT?: Enumerable<ProgramKeahlianScalarWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    name?: StringFilter | string
    bidangId?: StringFilter | string
    disable?: BoolFilter | boolean
  }

  export type TrackerUpsertWithWhereUniqueWithoutBidangInput = {
    where: TrackerWhereUniqueInput
    update: XOR<TrackerUpdateWithoutBidangInput, TrackerUncheckedUpdateWithoutBidangInput>
    create: XOR<TrackerCreateWithoutBidangInput, TrackerUncheckedCreateWithoutBidangInput>
  }

  export type TrackerUpdateWithWhereUniqueWithoutBidangInput = {
    where: TrackerWhereUniqueInput
    data: XOR<TrackerUpdateWithoutBidangInput, TrackerUncheckedUpdateWithoutBidangInput>
  }

  export type TrackerUpdateManyWithWhereWithoutBidangInput = {
    where: TrackerScalarWhereInput
    data: XOR<TrackerUpdateManyMutationInput, TrackerUncheckedUpdateManyWithoutTrackerInput>
  }

  export type BidangKeahlianCreateWithoutProgramInput = {
    id?: string
    code: string
    name: string
    disable?: boolean
    tracker?: TrackerCreateNestedManyWithoutBidangInput
  }

  export type BidangKeahlianUncheckedCreateWithoutProgramInput = {
    id?: string
    code: string
    name: string
    disable?: boolean
    tracker?: TrackerUncheckedCreateNestedManyWithoutBidangInput
  }

  export type BidangKeahlianCreateOrConnectWithoutProgramInput = {
    where: BidangKeahlianWhereUniqueInput
    create: XOR<BidangKeahlianCreateWithoutProgramInput, BidangKeahlianUncheckedCreateWithoutProgramInput>
  }

  export type KonsentrasiKeahlianCreateWithoutProgramInput = {
    id?: string
    code: string
    name: string
    tahun: number
    disable?: boolean
    student?: StudentCreateNestedManyWithoutMajorInput
    instansi?: InstansiCreateNestedManyWithoutMajorsInput
    classRoom?: ClassRoomCreateNestedManyWithoutMajorInput
    tracker?: TrackerCreateNestedManyWithoutKonsentrasiInput
    mapel?: MataPelajaranCreateNestedManyWithoutKeahlianInput
    dudi?: DudiCreateNestedManyWithoutMajorInput
    kkni?: KkniCreateNestedManyWithoutKonsentrasiInput
  }

  export type KonsentrasiKeahlianUncheckedCreateWithoutProgramInput = {
    id?: string
    code: string
    name: string
    tahun: number
    instansiIds?: KonsentrasiKeahlianCreateinstansiIdsInput | Enumerable<string>
    disable?: boolean
    student?: StudentUncheckedCreateNestedManyWithoutMajorInput
    instansi?: InstansiUncheckedCreateNestedManyWithoutMajorsInput
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutMajorInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutKonsentrasiInput
    mapel?: MataPelajaranUncheckedCreateNestedManyWithoutKeahlianInput
    dudi?: DudiUncheckedCreateNestedManyWithoutMajorInput
    kkni?: KkniUncheckedCreateNestedManyWithoutKonsentrasiInput
  }

  export type KonsentrasiKeahlianCreateOrConnectWithoutProgramInput = {
    where: KonsentrasiKeahlianWhereUniqueInput
    create: XOR<KonsentrasiKeahlianCreateWithoutProgramInput, KonsentrasiKeahlianUncheckedCreateWithoutProgramInput>
  }

  export type KonsentrasiKeahlianCreateManyProgramInputEnvelope = {
    data: Enumerable<KonsentrasiKeahlianCreateManyProgramInput>
  }

  export type TrackerCreateWithoutProgramInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrackerInput
    ref: InstansiCreateNestedOneWithoutHistoryInput
    instansi?: InstansiCreateNestedOneWithoutTrackerInput
    mapel?: MataPelajaranCreateNestedOneWithoutTrackerInput
    elemen?: ElementCreateNestedOneWithoutTrackerInput
    cp?: AchievementCreateNestedOneWithoutTrackerInput
    bidang?: BidangKeahlianCreateNestedOneWithoutTrackerInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedOneWithoutTrackerInput
    tp?: SchoolYearCreateNestedOneWithoutTrackerInput
    teacher?: TeacherCreateNestedOneWithoutTrackerInput
    kelas?: ClassRoomCreateNestedOneWithoutTrackerInput
    murid?: StudentCreateNestedOneWithoutTrackerInput
    jadwal?: ScheduleCreateNestedOneWithoutTrackerInput
    mengajar?: TeachingCreateNestedOneWithoutTrackerInput
    tujuan?: ObjectiveCreateNestedOneWithoutTrackerInput
    perangkat?: TDeviceCreateNestedOneWithoutTrackerInput
    kalender?: CalendarCreateNestedOneWithoutTrackerInput
    dudi?: DudiCreateNestedOneWithoutTrackerInput
    kkni?: KkniCreateNestedOneWithoutTrackerInput
  }

  export type TrackerUncheckedCreateWithoutProgramInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TrackerCreateOrConnectWithoutProgramInput = {
    where: TrackerWhereUniqueInput
    create: XOR<TrackerCreateWithoutProgramInput, TrackerUncheckedCreateWithoutProgramInput>
  }

  export type TrackerCreateManyProgramInputEnvelope = {
    data: Enumerable<TrackerCreateManyProgramInput>
  }

  export type MataPelajaranCreateWithoutProgramInput = {
    id?: string
    level?: Level | null
    type?: MataPelajaranType
    no: string
    code: string
    name: string
    religion?: Religion | null
    disable?: boolean
    keahlian?: KonsentrasiKeahlianCreateNestedOneWithoutMapelInput
    instansi?: InstansiCreateNestedOneWithoutUnikMapelsInput
    element?: ElementCreateNestedManyWithoutMapelInput
    schedule?: ScheduleCreateNestedManyWithoutMapelInput
    tracker?: TrackerCreateNestedManyWithoutMapelInput
    objective?: ObjectiveCreateNestedManyWithoutMapelInput
    device?: TDeviceCreateNestedManyWithoutMapelInput
  }

  export type MataPelajaranUncheckedCreateWithoutProgramInput = {
    id?: string
    level?: Level | null
    type?: MataPelajaranType
    no: string
    code: string
    name: string
    religion?: Religion | null
    keahlianid?: string | null
    instansiId?: string | null
    disable?: boolean
    element?: ElementUncheckedCreateNestedManyWithoutMapelInput
    schedule?: ScheduleUncheckedCreateNestedManyWithoutMapelInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutMapelInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutMapelInput
    device?: TDeviceUncheckedCreateNestedManyWithoutMapelInput
  }

  export type MataPelajaranCreateOrConnectWithoutProgramInput = {
    where: MataPelajaranWhereUniqueInput
    create: XOR<MataPelajaranCreateWithoutProgramInput, MataPelajaranUncheckedCreateWithoutProgramInput>
  }

  export type MataPelajaranCreateManyProgramInputEnvelope = {
    data: Enumerable<MataPelajaranCreateManyProgramInput>
  }

  export type BidangKeahlianUpsertWithoutProgramInput = {
    update: XOR<BidangKeahlianUpdateWithoutProgramInput, BidangKeahlianUncheckedUpdateWithoutProgramInput>
    create: XOR<BidangKeahlianCreateWithoutProgramInput, BidangKeahlianUncheckedCreateWithoutProgramInput>
  }

  export type BidangKeahlianUpdateWithoutProgramInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    tracker?: TrackerUpdateManyWithoutBidangNestedInput
  }

  export type BidangKeahlianUncheckedUpdateWithoutProgramInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    tracker?: TrackerUncheckedUpdateManyWithoutBidangNestedInput
  }

  export type KonsentrasiKeahlianUpsertWithWhereUniqueWithoutProgramInput = {
    where: KonsentrasiKeahlianWhereUniqueInput
    update: XOR<KonsentrasiKeahlianUpdateWithoutProgramInput, KonsentrasiKeahlianUncheckedUpdateWithoutProgramInput>
    create: XOR<KonsentrasiKeahlianCreateWithoutProgramInput, KonsentrasiKeahlianUncheckedCreateWithoutProgramInput>
  }

  export type KonsentrasiKeahlianUpdateWithWhereUniqueWithoutProgramInput = {
    where: KonsentrasiKeahlianWhereUniqueInput
    data: XOR<KonsentrasiKeahlianUpdateWithoutProgramInput, KonsentrasiKeahlianUncheckedUpdateWithoutProgramInput>
  }

  export type KonsentrasiKeahlianUpdateManyWithWhereWithoutProgramInput = {
    where: KonsentrasiKeahlianScalarWhereInput
    data: XOR<KonsentrasiKeahlianUpdateManyMutationInput, KonsentrasiKeahlianUncheckedUpdateManyWithoutKonsentrasiInput>
  }

  export type TrackerUpsertWithWhereUniqueWithoutProgramInput = {
    where: TrackerWhereUniqueInput
    update: XOR<TrackerUpdateWithoutProgramInput, TrackerUncheckedUpdateWithoutProgramInput>
    create: XOR<TrackerCreateWithoutProgramInput, TrackerUncheckedCreateWithoutProgramInput>
  }

  export type TrackerUpdateWithWhereUniqueWithoutProgramInput = {
    where: TrackerWhereUniqueInput
    data: XOR<TrackerUpdateWithoutProgramInput, TrackerUncheckedUpdateWithoutProgramInput>
  }

  export type TrackerUpdateManyWithWhereWithoutProgramInput = {
    where: TrackerScalarWhereInput
    data: XOR<TrackerUpdateManyMutationInput, TrackerUncheckedUpdateManyWithoutTrackerInput>
  }

  export type MataPelajaranUpsertWithWhereUniqueWithoutProgramInput = {
    where: MataPelajaranWhereUniqueInput
    update: XOR<MataPelajaranUpdateWithoutProgramInput, MataPelajaranUncheckedUpdateWithoutProgramInput>
    create: XOR<MataPelajaranCreateWithoutProgramInput, MataPelajaranUncheckedCreateWithoutProgramInput>
  }

  export type MataPelajaranUpdateWithWhereUniqueWithoutProgramInput = {
    where: MataPelajaranWhereUniqueInput
    data: XOR<MataPelajaranUpdateWithoutProgramInput, MataPelajaranUncheckedUpdateWithoutProgramInput>
  }

  export type MataPelajaranUpdateManyWithWhereWithoutProgramInput = {
    where: MataPelajaranScalarWhereInput
    data: XOR<MataPelajaranUpdateManyMutationInput, MataPelajaranUncheckedUpdateManyWithoutMapelInput>
  }

  export type ProgramKeahlianCreateWithoutKonsentrasiInput = {
    id?: string
    code: string
    name: string
    disable?: boolean
    bidang: BidangKeahlianCreateNestedOneWithoutProgramInput
    tracker?: TrackerCreateNestedManyWithoutProgramInput
    mapel?: MataPelajaranCreateNestedManyWithoutProgramInput
  }

  export type ProgramKeahlianUncheckedCreateWithoutKonsentrasiInput = {
    id?: string
    code: string
    name: string
    bidangId: string
    disable?: boolean
    tracker?: TrackerUncheckedCreateNestedManyWithoutProgramInput
    mapel?: MataPelajaranUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramKeahlianCreateOrConnectWithoutKonsentrasiInput = {
    where: ProgramKeahlianWhereUniqueInput
    create: XOR<ProgramKeahlianCreateWithoutKonsentrasiInput, ProgramKeahlianUncheckedCreateWithoutKonsentrasiInput>
  }

  export type StudentCreateWithoutMajorInput = {
    id?: string
    nis: string
    lastSchool: string
    disable?: boolean
    personal: PersonalCreateNestedOneWithoutStudentInput
    classRoom?: ClassRoomCreateNestedManyWithoutStudentsInput
    startYear: SchoolYearCreateNestedOneWithoutStudentsInput
    instansi: InstansiCreateNestedOneWithoutStudentInput
    event?: CalendarCreateNestedManyWithoutStudentInput
    tracker?: TrackerCreateNestedManyWithoutMuridInput
  }

  export type StudentUncheckedCreateWithoutMajorInput = {
    id?: string
    nis: string
    lastSchool: string
    personalId: string
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    startYearId: string
    instansiId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutStudentsInput
    event?: CalendarUncheckedCreateNestedManyWithoutStudentInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutMuridInput
  }

  export type StudentCreateOrConnectWithoutMajorInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutMajorInput, StudentUncheckedCreateWithoutMajorInput>
  }

  export type StudentCreateManyMajorInputEnvelope = {
    data: Enumerable<StudentCreateManyMajorInput>
  }

  export type InstansiCreateWithoutMajorsInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    disable?: boolean
    role?: RoleCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearCreateNestedManyWithoutInstansiInput
    teacher?: TeacherCreateNestedManyWithoutInstansiInput
    student?: StudentCreateNestedManyWithoutInstansiInput
    tracker?: TrackerCreateNestedManyWithoutInstansiInput
    history?: TrackerCreateNestedManyWithoutRefInput
    unikMapels?: MataPelajaranCreateNestedManyWithoutInstansiInput
    tDevice?: TDeviceCreateNestedManyWithoutInstansiInput
    objective?: ObjectiveCreateNestedManyWithoutInstansiInput
    dudi?: DudiCreateNestedManyWithoutInstansiInput
  }

  export type InstansiUncheckedCreateWithoutMajorsInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    majorIds?: InstansiCreatemajorIdsInput | Enumerable<string>
    disable?: boolean
    role?: RoleUncheckedCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearUncheckedCreateNestedManyWithoutInstansiInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutInstansiInput
    student?: StudentUncheckedCreateNestedManyWithoutInstansiInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutInstansiInput
    history?: TrackerUncheckedCreateNestedManyWithoutRefInput
    unikMapels?: MataPelajaranUncheckedCreateNestedManyWithoutInstansiInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutInstansiInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutInstansiInput
    dudi?: DudiUncheckedCreateNestedManyWithoutInstansiInput
  }

  export type InstansiCreateOrConnectWithoutMajorsInput = {
    where: InstansiWhereUniqueInput
    create: XOR<InstansiCreateWithoutMajorsInput, InstansiUncheckedCreateWithoutMajorsInput>
  }

  export type ClassRoomCreateWithoutMajorInput = {
    id?: string
    name: string
    level: number
    property?: XOR<RoomPropertyNullableCreateEnvelopeInput, RoomPropertyCreateInput> | null
    disable?: boolean
    year: SchoolYearCreateNestedOneWithoutClassRoomInput
    wali: TeacherCreateNestedOneWithoutClassRoomInput
    students?: StudentCreateNestedManyWithoutClassRoomInput
    event?: CalendarCreateNestedManyWithoutClassRoomInput
    tracker?: TrackerCreateNestedManyWithoutKelasInput
    teaching?: TeachingCreateNestedManyWithoutClassRoomInput
    tDevice?: TDeviceCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomUncheckedCreateWithoutMajorInput = {
    id?: string
    name: string
    yearId: string
    waliId: string
    level: number
    property?: XOR<RoomPropertyNullableCreateEnvelopeInput, RoomPropertyCreateInput> | null
    studentIds?: ClassRoomCreatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomCreateeventIdsInput | Enumerable<string>
    disable?: boolean
    teachingIds?: ClassRoomCreateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomCreatetDeviceIdsInput | Enumerable<string>
    students?: StudentUncheckedCreateNestedManyWithoutClassRoomInput
    event?: CalendarUncheckedCreateNestedManyWithoutClassRoomInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutKelasInput
    teaching?: TeachingUncheckedCreateNestedManyWithoutClassRoomInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomCreateOrConnectWithoutMajorInput = {
    where: ClassRoomWhereUniqueInput
    create: XOR<ClassRoomCreateWithoutMajorInput, ClassRoomUncheckedCreateWithoutMajorInput>
  }

  export type ClassRoomCreateManyMajorInputEnvelope = {
    data: Enumerable<ClassRoomCreateManyMajorInput>
  }

  export type TrackerCreateWithoutKonsentrasiInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrackerInput
    ref: InstansiCreateNestedOneWithoutHistoryInput
    instansi?: InstansiCreateNestedOneWithoutTrackerInput
    mapel?: MataPelajaranCreateNestedOneWithoutTrackerInput
    elemen?: ElementCreateNestedOneWithoutTrackerInput
    cp?: AchievementCreateNestedOneWithoutTrackerInput
    bidang?: BidangKeahlianCreateNestedOneWithoutTrackerInput
    program?: ProgramKeahlianCreateNestedOneWithoutTrackerInput
    tp?: SchoolYearCreateNestedOneWithoutTrackerInput
    teacher?: TeacherCreateNestedOneWithoutTrackerInput
    kelas?: ClassRoomCreateNestedOneWithoutTrackerInput
    murid?: StudentCreateNestedOneWithoutTrackerInput
    jadwal?: ScheduleCreateNestedOneWithoutTrackerInput
    mengajar?: TeachingCreateNestedOneWithoutTrackerInput
    tujuan?: ObjectiveCreateNestedOneWithoutTrackerInput
    perangkat?: TDeviceCreateNestedOneWithoutTrackerInput
    kalender?: CalendarCreateNestedOneWithoutTrackerInput
    dudi?: DudiCreateNestedOneWithoutTrackerInput
    kkni?: KkniCreateNestedOneWithoutTrackerInput
  }

  export type TrackerUncheckedCreateWithoutKonsentrasiInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TrackerCreateOrConnectWithoutKonsentrasiInput = {
    where: TrackerWhereUniqueInput
    create: XOR<TrackerCreateWithoutKonsentrasiInput, TrackerUncheckedCreateWithoutKonsentrasiInput>
  }

  export type TrackerCreateManyKonsentrasiInputEnvelope = {
    data: Enumerable<TrackerCreateManyKonsentrasiInput>
  }

  export type MataPelajaranCreateWithoutKeahlianInput = {
    id?: string
    level?: Level | null
    type?: MataPelajaranType
    no: string
    code: string
    name: string
    religion?: Religion | null
    disable?: boolean
    program?: ProgramKeahlianCreateNestedOneWithoutMapelInput
    instansi?: InstansiCreateNestedOneWithoutUnikMapelsInput
    element?: ElementCreateNestedManyWithoutMapelInput
    schedule?: ScheduleCreateNestedManyWithoutMapelInput
    tracker?: TrackerCreateNestedManyWithoutMapelInput
    objective?: ObjectiveCreateNestedManyWithoutMapelInput
    device?: TDeviceCreateNestedManyWithoutMapelInput
  }

  export type MataPelajaranUncheckedCreateWithoutKeahlianInput = {
    id?: string
    level?: Level | null
    type?: MataPelajaranType
    no: string
    code: string
    name: string
    religion?: Religion | null
    programId?: string | null
    instansiId?: string | null
    disable?: boolean
    element?: ElementUncheckedCreateNestedManyWithoutMapelInput
    schedule?: ScheduleUncheckedCreateNestedManyWithoutMapelInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutMapelInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutMapelInput
    device?: TDeviceUncheckedCreateNestedManyWithoutMapelInput
  }

  export type MataPelajaranCreateOrConnectWithoutKeahlianInput = {
    where: MataPelajaranWhereUniqueInput
    create: XOR<MataPelajaranCreateWithoutKeahlianInput, MataPelajaranUncheckedCreateWithoutKeahlianInput>
  }

  export type MataPelajaranCreateManyKeahlianInputEnvelope = {
    data: Enumerable<MataPelajaranCreateManyKeahlianInput>
  }

  export type DudiCreateWithoutMajorInput = {
    id?: string
    name: string
    street: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    contact: XOR<ContactDudiCreateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiCreatecollabsInput | Enumerable<string>
    timework: XOR<DudiTimeWorkCreateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: boolean
    instansi: InstansiCreateNestedOneWithoutDudiInput
    learning?: DudiLearningCreateNestedManyWithoutRefInput
    tracker?: TrackerCreateNestedManyWithoutDudiInput
    kkni?: KkniCreateNestedOneWithoutDudiInput
  }

  export type DudiUncheckedCreateWithoutMajorInput = {
    id?: string
    name: string
    street: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    instansiId: string
    contact: XOR<ContactDudiCreateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiCreatecollabsInput | Enumerable<string>
    timework: XOR<DudiTimeWorkCreateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: boolean
    kkniId?: string | null
    learning?: DudiLearningUncheckedCreateNestedManyWithoutRefInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutDudiInput
  }

  export type DudiCreateOrConnectWithoutMajorInput = {
    where: DudiWhereUniqueInput
    create: XOR<DudiCreateWithoutMajorInput, DudiUncheckedCreateWithoutMajorInput>
  }

  export type DudiCreateManyMajorInputEnvelope = {
    data: Enumerable<DudiCreateManyMajorInput>
  }

  export type KkniCreateWithoutKonsentrasiInput = {
    id?: string
    no: number
    code: string
    name: string
    description?: string | null
    disable?: boolean
    dudi?: DudiCreateNestedManyWithoutKkniInput
    tracker?: TrackerCreateNestedManyWithoutKkniInput
  }

  export type KkniUncheckedCreateWithoutKonsentrasiInput = {
    id?: string
    no: number
    code: string
    name: string
    description?: string | null
    disable?: boolean
    dudi?: DudiUncheckedCreateNestedManyWithoutKkniInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutKkniInput
  }

  export type KkniCreateOrConnectWithoutKonsentrasiInput = {
    where: KkniWhereUniqueInput
    create: XOR<KkniCreateWithoutKonsentrasiInput, KkniUncheckedCreateWithoutKonsentrasiInput>
  }

  export type KkniCreateManyKonsentrasiInputEnvelope = {
    data: Enumerable<KkniCreateManyKonsentrasiInput>
  }

  export type ProgramKeahlianUpsertWithoutKonsentrasiInput = {
    update: XOR<ProgramKeahlianUpdateWithoutKonsentrasiInput, ProgramKeahlianUncheckedUpdateWithoutKonsentrasiInput>
    create: XOR<ProgramKeahlianCreateWithoutKonsentrasiInput, ProgramKeahlianUncheckedCreateWithoutKonsentrasiInput>
  }

  export type ProgramKeahlianUpdateWithoutKonsentrasiInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    bidang?: BidangKeahlianUpdateOneRequiredWithoutProgramNestedInput
    tracker?: TrackerUpdateManyWithoutProgramNestedInput
    mapel?: MataPelajaranUpdateManyWithoutProgramNestedInput
  }

  export type ProgramKeahlianUncheckedUpdateWithoutKonsentrasiInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bidangId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    tracker?: TrackerUncheckedUpdateManyWithoutProgramNestedInput
    mapel?: MataPelajaranUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type StudentUpsertWithWhereUniqueWithoutMajorInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutMajorInput, StudentUncheckedUpdateWithoutMajorInput>
    create: XOR<StudentCreateWithoutMajorInput, StudentUncheckedCreateWithoutMajorInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutMajorInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutMajorInput, StudentUncheckedUpdateWithoutMajorInput>
  }

  export type StudentUpdateManyWithWhereWithoutMajorInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutStudentInput>
  }

  export type InstansiUpsertWithWhereUniqueWithoutMajorsInput = {
    where: InstansiWhereUniqueInput
    update: XOR<InstansiUpdateWithoutMajorsInput, InstansiUncheckedUpdateWithoutMajorsInput>
    create: XOR<InstansiCreateWithoutMajorsInput, InstansiUncheckedCreateWithoutMajorsInput>
  }

  export type InstansiUpdateWithWhereUniqueWithoutMajorsInput = {
    where: InstansiWhereUniqueInput
    data: XOR<InstansiUpdateWithoutMajorsInput, InstansiUncheckedUpdateWithoutMajorsInput>
  }

  export type InstansiUpdateManyWithWhereWithoutMajorsInput = {
    where: InstansiScalarWhereInput
    data: XOR<InstansiUpdateManyMutationInput, InstansiUncheckedUpdateManyWithoutInstansiInput>
  }

  export type InstansiScalarWhereInput = {
    AND?: Enumerable<InstansiScalarWhereInput>
    OR?: Enumerable<InstansiScalarWhereInput>
    NOT?: Enumerable<InstansiScalarWhereInput>
    id?: StringFilter | string
    npsn?: StringFilter | string
    name?: StringFilter | string
    isPrivate?: BoolFilter | boolean
    level?: EnumLevelFilter | Level
    religion?: EnumReligionNullableFilter | Religion | null
    major?: BoolNullableFilter | boolean | null
    majorIds?: StringNullableListFilter
    disable?: BoolFilter | boolean
  }

  export type ClassRoomUpsertWithWhereUniqueWithoutMajorInput = {
    where: ClassRoomWhereUniqueInput
    update: XOR<ClassRoomUpdateWithoutMajorInput, ClassRoomUncheckedUpdateWithoutMajorInput>
    create: XOR<ClassRoomCreateWithoutMajorInput, ClassRoomUncheckedCreateWithoutMajorInput>
  }

  export type ClassRoomUpdateWithWhereUniqueWithoutMajorInput = {
    where: ClassRoomWhereUniqueInput
    data: XOR<ClassRoomUpdateWithoutMajorInput, ClassRoomUncheckedUpdateWithoutMajorInput>
  }

  export type ClassRoomUpdateManyWithWhereWithoutMajorInput = {
    where: ClassRoomScalarWhereInput
    data: XOR<ClassRoomUpdateManyMutationInput, ClassRoomUncheckedUpdateManyWithoutClassRoomInput>
  }

  export type ClassRoomScalarWhereInput = {
    AND?: Enumerable<ClassRoomScalarWhereInput>
    OR?: Enumerable<ClassRoomScalarWhereInput>
    NOT?: Enumerable<ClassRoomScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    yearId?: StringFilter | string
    waliId?: StringFilter | string
    level?: IntFilter | number
    majorId?: StringNullableFilter | string | null
    studentIds?: StringNullableListFilter
    eventIds?: StringNullableListFilter
    disable?: BoolFilter | boolean
    teachingIds?: StringNullableListFilter
    tDeviceIds?: StringNullableListFilter
  }

  export type TrackerUpsertWithWhereUniqueWithoutKonsentrasiInput = {
    where: TrackerWhereUniqueInput
    update: XOR<TrackerUpdateWithoutKonsentrasiInput, TrackerUncheckedUpdateWithoutKonsentrasiInput>
    create: XOR<TrackerCreateWithoutKonsentrasiInput, TrackerUncheckedCreateWithoutKonsentrasiInput>
  }

  export type TrackerUpdateWithWhereUniqueWithoutKonsentrasiInput = {
    where: TrackerWhereUniqueInput
    data: XOR<TrackerUpdateWithoutKonsentrasiInput, TrackerUncheckedUpdateWithoutKonsentrasiInput>
  }

  export type TrackerUpdateManyWithWhereWithoutKonsentrasiInput = {
    where: TrackerScalarWhereInput
    data: XOR<TrackerUpdateManyMutationInput, TrackerUncheckedUpdateManyWithoutTrackerInput>
  }

  export type MataPelajaranUpsertWithWhereUniqueWithoutKeahlianInput = {
    where: MataPelajaranWhereUniqueInput
    update: XOR<MataPelajaranUpdateWithoutKeahlianInput, MataPelajaranUncheckedUpdateWithoutKeahlianInput>
    create: XOR<MataPelajaranCreateWithoutKeahlianInput, MataPelajaranUncheckedCreateWithoutKeahlianInput>
  }

  export type MataPelajaranUpdateWithWhereUniqueWithoutKeahlianInput = {
    where: MataPelajaranWhereUniqueInput
    data: XOR<MataPelajaranUpdateWithoutKeahlianInput, MataPelajaranUncheckedUpdateWithoutKeahlianInput>
  }

  export type MataPelajaranUpdateManyWithWhereWithoutKeahlianInput = {
    where: MataPelajaranScalarWhereInput
    data: XOR<MataPelajaranUpdateManyMutationInput, MataPelajaranUncheckedUpdateManyWithoutMapelInput>
  }

  export type DudiUpsertWithWhereUniqueWithoutMajorInput = {
    where: DudiWhereUniqueInput
    update: XOR<DudiUpdateWithoutMajorInput, DudiUncheckedUpdateWithoutMajorInput>
    create: XOR<DudiCreateWithoutMajorInput, DudiUncheckedCreateWithoutMajorInput>
  }

  export type DudiUpdateWithWhereUniqueWithoutMajorInput = {
    where: DudiWhereUniqueInput
    data: XOR<DudiUpdateWithoutMajorInput, DudiUncheckedUpdateWithoutMajorInput>
  }

  export type DudiUpdateManyWithWhereWithoutMajorInput = {
    where: DudiScalarWhereInput
    data: XOR<DudiUpdateManyMutationInput, DudiUncheckedUpdateManyWithoutDudiInput>
  }

  export type KkniUpsertWithWhereUniqueWithoutKonsentrasiInput = {
    where: KkniWhereUniqueInput
    update: XOR<KkniUpdateWithoutKonsentrasiInput, KkniUncheckedUpdateWithoutKonsentrasiInput>
    create: XOR<KkniCreateWithoutKonsentrasiInput, KkniUncheckedCreateWithoutKonsentrasiInput>
  }

  export type KkniUpdateWithWhereUniqueWithoutKonsentrasiInput = {
    where: KkniWhereUniqueInput
    data: XOR<KkniUpdateWithoutKonsentrasiInput, KkniUncheckedUpdateWithoutKonsentrasiInput>
  }

  export type KkniUpdateManyWithWhereWithoutKonsentrasiInput = {
    where: KkniScalarWhereInput
    data: XOR<KkniUpdateManyMutationInput, KkniUncheckedUpdateManyWithoutKkniInput>
  }

  export type KkniScalarWhereInput = {
    AND?: Enumerable<KkniScalarWhereInput>
    OR?: Enumerable<KkniScalarWhereInput>
    NOT?: Enumerable<KkniScalarWhereInput>
    id?: StringFilter | string
    konsentrasiId?: StringFilter | string
    no?: IntFilter | number
    code?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    disable?: BoolFilter | boolean
  }

  export type InstansiCreateWithoutRoleInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    disable?: boolean
    majors?: KonsentrasiKeahlianCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearCreateNestedManyWithoutInstansiInput
    teacher?: TeacherCreateNestedManyWithoutInstansiInput
    student?: StudentCreateNestedManyWithoutInstansiInput
    tracker?: TrackerCreateNestedManyWithoutInstansiInput
    history?: TrackerCreateNestedManyWithoutRefInput
    unikMapels?: MataPelajaranCreateNestedManyWithoutInstansiInput
    tDevice?: TDeviceCreateNestedManyWithoutInstansiInput
    objective?: ObjectiveCreateNestedManyWithoutInstansiInput
    dudi?: DudiCreateNestedManyWithoutInstansiInput
  }

  export type InstansiUncheckedCreateWithoutRoleInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    majorIds?: InstansiCreatemajorIdsInput | Enumerable<string>
    disable?: boolean
    majors?: KonsentrasiKeahlianUncheckedCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearUncheckedCreateNestedManyWithoutInstansiInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutInstansiInput
    student?: StudentUncheckedCreateNestedManyWithoutInstansiInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutInstansiInput
    history?: TrackerUncheckedCreateNestedManyWithoutRefInput
    unikMapels?: MataPelajaranUncheckedCreateNestedManyWithoutInstansiInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutInstansiInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutInstansiInput
    dudi?: DudiUncheckedCreateNestedManyWithoutInstansiInput
  }

  export type InstansiCreateOrConnectWithoutRoleInput = {
    where: InstansiWhereUniqueInput
    create: XOR<InstansiCreateWithoutRoleInput, InstansiUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateWithoutRoleInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    disable?: boolean
    google?: XOR<GoogleNullableCreateEnvelopeInput, GoogleCreateInput> | null
    auth?: AuthCreateNestedOneWithoutUserInput
    tracker?: TrackerCreateNestedManyWithoutUserInput
    objective?: ObjectiveCreateNestedManyWithoutUserInput
    link?: LinkCreateNestedManyWithoutUserInput
    tDevice?: TDeviceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    disable?: boolean
    google?: XOR<GoogleNullableCreateEnvelopeInput, GoogleCreateInput> | null
    auth?: AuthUncheckedCreateNestedOneWithoutUserInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutUserInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutUserInput
    link?: LinkUncheckedCreateNestedManyWithoutUserInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: Enumerable<UserCreateManyRoleInput>
  }

  export type InstansiUpsertWithoutRoleInput = {
    update: XOR<InstansiUpdateWithoutRoleInput, InstansiUncheckedUpdateWithoutRoleInput>
    create: XOR<InstansiCreateWithoutRoleInput, InstansiUncheckedCreateWithoutRoleInput>
  }

  export type InstansiUpdateWithoutRoleInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    majors?: KonsentrasiKeahlianUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUpdateManyWithoutInstansiNestedInput
    student?: StudentUpdateManyWithoutInstansiNestedInput
    tracker?: TrackerUpdateManyWithoutInstansiNestedInput
    history?: TrackerUpdateManyWithoutRefNestedInput
    unikMapels?: MataPelajaranUpdateManyWithoutInstansiNestedInput
    tDevice?: TDeviceUpdateManyWithoutInstansiNestedInput
    objective?: ObjectiveUpdateManyWithoutInstansiNestedInput
    dudi?: DudiUpdateManyWithoutInstansiNestedInput
  }

  export type InstansiUncheckedUpdateWithoutRoleInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    majorIds?: InstansiUpdatemajorIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    majors?: KonsentrasiKeahlianUncheckedUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUncheckedUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutInstansiNestedInput
    student?: StudentUncheckedUpdateManyWithoutInstansiNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutInstansiNestedInput
    history?: TrackerUncheckedUpdateManyWithoutRefNestedInput
    unikMapels?: MataPelajaranUncheckedUpdateManyWithoutInstansiNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutInstansiNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutInstansiNestedInput
    dudi?: DudiUncheckedUpdateManyWithoutInstansiNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    picture?: StringNullableFilter | string | null
    username?: StringFilter | string
    active?: BoolFilter | boolean
    verify?: BoolFilter | boolean
    password?: StringFilter | string
    passhash?: StringFilter | string
    roleId?: StringNullableFilter | string | null
    disable?: BoolFilter | boolean
  }

  export type GoogleCreatescopesInput = {
    set: Enumerable<string>
  }

  export type RoleCreateWithoutUsersInput = {
    id?: string
    key: Roles
    createdAt?: Date | string
    updatedAt?: Date | string
    instansi: InstansiCreateNestedOneWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: string
    key: Roles
    instansiId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type AuthCreateWithoutUserInput = {
    id?: string
    personal: PersonalCreateNestedOneWithoutAuthInput
  }

  export type AuthUncheckedCreateWithoutUserInput = {
    id?: string
    personalId: string
  }

  export type AuthCreateOrConnectWithoutUserInput = {
    where: AuthWhereUniqueInput
    create: XOR<AuthCreateWithoutUserInput, AuthUncheckedCreateWithoutUserInput>
  }

  export type TrackerCreateWithoutUserInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    createdAt?: Date | string
    ref: InstansiCreateNestedOneWithoutHistoryInput
    instansi?: InstansiCreateNestedOneWithoutTrackerInput
    mapel?: MataPelajaranCreateNestedOneWithoutTrackerInput
    elemen?: ElementCreateNestedOneWithoutTrackerInput
    cp?: AchievementCreateNestedOneWithoutTrackerInput
    bidang?: BidangKeahlianCreateNestedOneWithoutTrackerInput
    program?: ProgramKeahlianCreateNestedOneWithoutTrackerInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedOneWithoutTrackerInput
    tp?: SchoolYearCreateNestedOneWithoutTrackerInput
    teacher?: TeacherCreateNestedOneWithoutTrackerInput
    kelas?: ClassRoomCreateNestedOneWithoutTrackerInput
    murid?: StudentCreateNestedOneWithoutTrackerInput
    jadwal?: ScheduleCreateNestedOneWithoutTrackerInput
    mengajar?: TeachingCreateNestedOneWithoutTrackerInput
    tujuan?: ObjectiveCreateNestedOneWithoutTrackerInput
    perangkat?: TDeviceCreateNestedOneWithoutTrackerInput
    kalender?: CalendarCreateNestedOneWithoutTrackerInput
    dudi?: DudiCreateNestedOneWithoutTrackerInput
    kkni?: KkniCreateNestedOneWithoutTrackerInput
  }

  export type TrackerUncheckedCreateWithoutUserInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TrackerCreateOrConnectWithoutUserInput = {
    where: TrackerWhereUniqueInput
    create: XOR<TrackerCreateWithoutUserInput, TrackerUncheckedCreateWithoutUserInput>
  }

  export type TrackerCreateManyUserInputEnvelope = {
    data: Enumerable<TrackerCreateManyUserInput>
  }

  export type ObjectiveCreateWithoutUserInput = {
    id?: string
    level: number
    fase: Fase
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    instansi: InstansiCreateNestedOneWithoutObjectiveInput
    year: SchoolYearCreateNestedOneWithoutObjectiveInput
    mapel: MataPelajaranCreateNestedOneWithoutObjectiveInput
    elemen: ElementCreateNestedOneWithoutObjectiveInput
    achievement: AchievementCreateNestedOneWithoutObjectiveInput
    material?: OMaterialCreateNestedManyWithoutRefInput
    tracker?: TrackerCreateNestedManyWithoutTujuanInput
    resourse?: OresourceCreateNestedManyWithoutRefInput
    ppp?: OpppCreateNestedManyWithoutRefInput
    tool?: OhelperCreateNestedManyWithoutToolInput
    mate?: OhelperCreateNestedManyWithoutMateInput
    meth?: OhelperCreateNestedManyWithoutMethInput
    media?: OhelperCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentCreateNestedManyWithoutRefInput
    devices?: TDeviceDataCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveUncheckedCreateWithoutUserInput = {
    id?: string
    level: number
    fase: Fase
    instansiId: string
    yearId: string
    mapelId: string
    elementId: string
    achievementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedCreateNestedManyWithoutRefInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTujuanInput
    resourse?: OresourceUncheckedCreateNestedManyWithoutRefInput
    ppp?: OpppUncheckedCreateNestedManyWithoutRefInput
    tool?: OhelperUncheckedCreateNestedManyWithoutToolInput
    mate?: OhelperUncheckedCreateNestedManyWithoutMateInput
    meth?: OhelperUncheckedCreateNestedManyWithoutMethInput
    media?: OhelperUncheckedCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentUncheckedCreateNestedManyWithoutRefInput
    devices?: TDeviceDataUncheckedCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveCreateOrConnectWithoutUserInput = {
    where: ObjectiveWhereUniqueInput
    create: XOR<ObjectiveCreateWithoutUserInput, ObjectiveUncheckedCreateWithoutUserInput>
  }

  export type ObjectiveCreateManyUserInputEnvelope = {
    data: Enumerable<ObjectiveCreateManyUserInput>
  }

  export type LinkCreateWithoutUserInput = {
    id?: string
    url?: string | null
    title: string
    description?: string | null
    image?: string | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    objResource?: OresourceCreateNestedManyWithoutLinkInput
  }

  export type LinkUncheckedCreateWithoutUserInput = {
    id?: string
    url?: string | null
    title: string
    description?: string | null
    image?: string | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    objResource?: OresourceUncheckedCreateNestedManyWithoutLinkInput
  }

  export type LinkCreateOrConnectWithoutUserInput = {
    where: LinkWhereUniqueInput
    create: XOR<LinkCreateWithoutUserInput, LinkUncheckedCreateWithoutUserInput>
  }

  export type LinkCreateManyUserInputEnvelope = {
    data: Enumerable<LinkCreateManyUserInput>
  }

  export type TDeviceCreateWithoutUserInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    teaching: TeachingCreateNestedOneWithoutTDeviceInput
    year: SchoolYearCreateNestedOneWithoutTDeviceInput
    instansi: InstansiCreateNestedOneWithoutTDeviceInput
    mapel: MataPelajaranCreateNestedOneWithoutDeviceInput
    classRoom?: ClassRoomCreateNestedManyWithoutTDeviceInput
    tracker?: TrackerCreateNestedManyWithoutPerangkatInput
    data?: TDeviceDataCreateNestedManyWithoutRefInput
    children?: TDeviceCreateNestedManyWithoutParentInput
    parent?: TDeviceCreateNestedOneWithoutChildrenInput
  }

  export type TDeviceUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    teachingId: string
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    yearId: string
    instansiId: string
    mapelId: string
    classRoomIds?: TDeviceCreateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    parentId?: string | null
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutTDeviceInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutPerangkatInput
    data?: TDeviceDataUncheckedCreateNestedManyWithoutRefInput
    children?: TDeviceUncheckedCreateNestedManyWithoutParentInput
  }

  export type TDeviceCreateOrConnectWithoutUserInput = {
    where: TDeviceWhereUniqueInput
    create: XOR<TDeviceCreateWithoutUserInput, TDeviceUncheckedCreateWithoutUserInput>
  }

  export type TDeviceCreateManyUserInputEnvelope = {
    data: Enumerable<TDeviceCreateManyUserInput>
  }

  export type GoogleUpsertInput = {
    set: GoogleCreateInput | null
    update: GoogleUpdateInput
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    key?: EnumRolesFieldUpdateOperationsInput | Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instansi?: InstansiUpdateOneRequiredWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    key?: EnumRolesFieldUpdateOperationsInput | Roles
    instansiId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthUpsertWithoutUserInput = {
    update: XOR<AuthUpdateWithoutUserInput, AuthUncheckedUpdateWithoutUserInput>
    create: XOR<AuthCreateWithoutUserInput, AuthUncheckedCreateWithoutUserInput>
  }

  export type AuthUpdateWithoutUserInput = {
    personal?: PersonalUpdateOneRequiredWithoutAuthNestedInput
  }

  export type AuthUncheckedUpdateWithoutUserInput = {
    personalId?: StringFieldUpdateOperationsInput | string
  }

  export type TrackerUpsertWithWhereUniqueWithoutUserInput = {
    where: TrackerWhereUniqueInput
    update: XOR<TrackerUpdateWithoutUserInput, TrackerUncheckedUpdateWithoutUserInput>
    create: XOR<TrackerCreateWithoutUserInput, TrackerUncheckedCreateWithoutUserInput>
  }

  export type TrackerUpdateWithWhereUniqueWithoutUserInput = {
    where: TrackerWhereUniqueInput
    data: XOR<TrackerUpdateWithoutUserInput, TrackerUncheckedUpdateWithoutUserInput>
  }

  export type TrackerUpdateManyWithWhereWithoutUserInput = {
    where: TrackerScalarWhereInput
    data: XOR<TrackerUpdateManyMutationInput, TrackerUncheckedUpdateManyWithoutTrackerInput>
  }

  export type ObjectiveUpsertWithWhereUniqueWithoutUserInput = {
    where: ObjectiveWhereUniqueInput
    update: XOR<ObjectiveUpdateWithoutUserInput, ObjectiveUncheckedUpdateWithoutUserInput>
    create: XOR<ObjectiveCreateWithoutUserInput, ObjectiveUncheckedCreateWithoutUserInput>
  }

  export type ObjectiveUpdateWithWhereUniqueWithoutUserInput = {
    where: ObjectiveWhereUniqueInput
    data: XOR<ObjectiveUpdateWithoutUserInput, ObjectiveUncheckedUpdateWithoutUserInput>
  }

  export type ObjectiveUpdateManyWithWhereWithoutUserInput = {
    where: ObjectiveScalarWhereInput
    data: XOR<ObjectiveUpdateManyMutationInput, ObjectiveUncheckedUpdateManyWithoutObjectiveInput>
  }

  export type LinkUpsertWithWhereUniqueWithoutUserInput = {
    where: LinkWhereUniqueInput
    update: XOR<LinkUpdateWithoutUserInput, LinkUncheckedUpdateWithoutUserInput>
    create: XOR<LinkCreateWithoutUserInput, LinkUncheckedCreateWithoutUserInput>
  }

  export type LinkUpdateWithWhereUniqueWithoutUserInput = {
    where: LinkWhereUniqueInput
    data: XOR<LinkUpdateWithoutUserInput, LinkUncheckedUpdateWithoutUserInput>
  }

  export type LinkUpdateManyWithWhereWithoutUserInput = {
    where: LinkScalarWhereInput
    data: XOR<LinkUpdateManyMutationInput, LinkUncheckedUpdateManyWithoutLinkInput>
  }

  export type LinkScalarWhereInput = {
    AND?: Enumerable<LinkScalarWhereInput>
    OR?: Enumerable<LinkScalarWhereInput>
    NOT?: Enumerable<LinkScalarWhereInput>
    id?: StringFilter | string
    url?: StringNullableFilter | string | null
    title?: StringFilter | string
    description?: StringNullableFilter | string | null
    image?: StringNullableFilter | string | null
    width?: IntNullableFilter | number | null
    height?: IntNullableFilter | number | null
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TDeviceUpsertWithWhereUniqueWithoutUserInput = {
    where: TDeviceWhereUniqueInput
    update: XOR<TDeviceUpdateWithoutUserInput, TDeviceUncheckedUpdateWithoutUserInput>
    create: XOR<TDeviceCreateWithoutUserInput, TDeviceUncheckedCreateWithoutUserInput>
  }

  export type TDeviceUpdateWithWhereUniqueWithoutUserInput = {
    where: TDeviceWhereUniqueInput
    data: XOR<TDeviceUpdateWithoutUserInput, TDeviceUncheckedUpdateWithoutUserInput>
  }

  export type TDeviceUpdateManyWithWhereWithoutUserInput = {
    where: TDeviceScalarWhereInput
    data: XOR<TDeviceUpdateManyMutationInput, TDeviceUncheckedUpdateManyWithoutTDeviceInput>
  }

  export type AuthCreateWithoutPersonalInput = {
    id?: string
    user: UserCreateNestedOneWithoutAuthInput
  }

  export type AuthUncheckedCreateWithoutPersonalInput = {
    id?: string
    userId: string
  }

  export type AuthCreateOrConnectWithoutPersonalInput = {
    where: AuthWhereUniqueInput
    create: XOR<AuthCreateWithoutPersonalInput, AuthUncheckedCreateWithoutPersonalInput>
  }

  export type FamilyTreeCreateWithoutFatherInput = {
    id?: string
    nokk: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    mother?: PersonalCreateNestedOneWithoutMotherInput
    wali?: PersonalCreateNestedOneWithoutWaliInput
    couple?: PersonalCreateNestedOneWithoutCoupleInput
    childs?: FamilyTreeChildCreateNestedManyWithoutKkInput
  }

  export type FamilyTreeUncheckedCreateWithoutFatherInput = {
    id?: string
    nokk: string
    motherId?: string | null
    waliId?: string | null
    coupleId?: string | null
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    childs?: FamilyTreeChildUncheckedCreateNestedManyWithoutKkInput
  }

  export type FamilyTreeCreateOrConnectWithoutFatherInput = {
    where: FamilyTreeWhereUniqueInput
    create: XOR<FamilyTreeCreateWithoutFatherInput, FamilyTreeUncheckedCreateWithoutFatherInput>
  }

  export type FamilyTreeCreateManyFatherInputEnvelope = {
    data: Enumerable<FamilyTreeCreateManyFatherInput>
  }

  export type FamilyTreeCreateWithoutMotherInput = {
    id?: string
    nokk: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    father?: PersonalCreateNestedOneWithoutFatherInput
    wali?: PersonalCreateNestedOneWithoutWaliInput
    couple?: PersonalCreateNestedOneWithoutCoupleInput
    childs?: FamilyTreeChildCreateNestedManyWithoutKkInput
  }

  export type FamilyTreeUncheckedCreateWithoutMotherInput = {
    id?: string
    nokk: string
    fatherId?: string | null
    waliId?: string | null
    coupleId?: string | null
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    childs?: FamilyTreeChildUncheckedCreateNestedManyWithoutKkInput
  }

  export type FamilyTreeCreateOrConnectWithoutMotherInput = {
    where: FamilyTreeWhereUniqueInput
    create: XOR<FamilyTreeCreateWithoutMotherInput, FamilyTreeUncheckedCreateWithoutMotherInput>
  }

  export type FamilyTreeCreateManyMotherInputEnvelope = {
    data: Enumerable<FamilyTreeCreateManyMotherInput>
  }

  export type FamilyTreeCreateWithoutWaliInput = {
    id?: string
    nokk: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    father?: PersonalCreateNestedOneWithoutFatherInput
    mother?: PersonalCreateNestedOneWithoutMotherInput
    couple?: PersonalCreateNestedOneWithoutCoupleInput
    childs?: FamilyTreeChildCreateNestedManyWithoutKkInput
  }

  export type FamilyTreeUncheckedCreateWithoutWaliInput = {
    id?: string
    nokk: string
    fatherId?: string | null
    motherId?: string | null
    coupleId?: string | null
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    childs?: FamilyTreeChildUncheckedCreateNestedManyWithoutKkInput
  }

  export type FamilyTreeCreateOrConnectWithoutWaliInput = {
    where: FamilyTreeWhereUniqueInput
    create: XOR<FamilyTreeCreateWithoutWaliInput, FamilyTreeUncheckedCreateWithoutWaliInput>
  }

  export type FamilyTreeCreateManyWaliInputEnvelope = {
    data: Enumerable<FamilyTreeCreateManyWaliInput>
  }

  export type FamilyTreeCreateWithoutCoupleInput = {
    id?: string
    nokk: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    father?: PersonalCreateNestedOneWithoutFatherInput
    mother?: PersonalCreateNestedOneWithoutMotherInput
    wali?: PersonalCreateNestedOneWithoutWaliInput
    childs?: FamilyTreeChildCreateNestedManyWithoutKkInput
  }

  export type FamilyTreeUncheckedCreateWithoutCoupleInput = {
    id?: string
    nokk: string
    fatherId?: string | null
    motherId?: string | null
    waliId?: string | null
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    childs?: FamilyTreeChildUncheckedCreateNestedManyWithoutKkInput
  }

  export type FamilyTreeCreateOrConnectWithoutCoupleInput = {
    where: FamilyTreeWhereUniqueInput
    create: XOR<FamilyTreeCreateWithoutCoupleInput, FamilyTreeUncheckedCreateWithoutCoupleInput>
  }

  export type FamilyTreeCreateManyCoupleInputEnvelope = {
    data: Enumerable<FamilyTreeCreateManyCoupleInput>
  }

  export type FamilyTreeChildCreateWithoutPersonalInput = {
    id?: string
    no: number
    type: ChildType
    kk: FamilyTreeCreateNestedOneWithoutChildsInput
  }

  export type FamilyTreeChildUncheckedCreateWithoutPersonalInput = {
    id?: string
    no: number
    type: ChildType
    kkId: string
  }

  export type FamilyTreeChildCreateOrConnectWithoutPersonalInput = {
    where: FamilyTreeChildWhereUniqueInput
    create: XOR<FamilyTreeChildCreateWithoutPersonalInput, FamilyTreeChildUncheckedCreateWithoutPersonalInput>
  }

  export type StudentCreateWithoutPersonalInput = {
    id?: string
    nis: string
    lastSchool: string
    disable?: boolean
    major?: KonsentrasiKeahlianCreateNestedOneWithoutStudentInput
    classRoom?: ClassRoomCreateNestedManyWithoutStudentsInput
    startYear: SchoolYearCreateNestedOneWithoutStudentsInput
    instansi: InstansiCreateNestedOneWithoutStudentInput
    event?: CalendarCreateNestedManyWithoutStudentInput
    tracker?: TrackerCreateNestedManyWithoutMuridInput
  }

  export type StudentUncheckedCreateWithoutPersonalInput = {
    id?: string
    nis: string
    lastSchool: string
    majorId?: string | null
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    startYearId: string
    instansiId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutStudentsInput
    event?: CalendarUncheckedCreateNestedManyWithoutStudentInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutMuridInput
  }

  export type StudentCreateOrConnectWithoutPersonalInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutPersonalInput, StudentUncheckedCreateWithoutPersonalInput>
  }

  export type StudentCreateManyPersonalInputEnvelope = {
    data: Enumerable<StudentCreateManyPersonalInput>
  }

  export type TeacherCreateWithoutPersonalInput = {
    id?: string
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: Date | string | null
    tmtGol?: Date | string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    disable?: boolean
    classRoom?: ClassRoomCreateNestedManyWithoutWaliInput
    instansi: InstansiCreateNestedOneWithoutTeacherInput
    event?: CalendarCreateNestedManyWithoutTeacherInput
    tracker?: TrackerCreateNestedManyWithoutTeacherInput
    teaching?: TeachingCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutPersonalInput = {
    id?: string
    instansiId: string
    eventIds?: TeacherCreateeventIdsInput | Enumerable<string>
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: Date | string | null
    tmtGol?: Date | string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutWaliInput
    event?: CalendarUncheckedCreateNestedManyWithoutTeacherInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTeacherInput
    teaching?: TeachingUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutPersonalInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutPersonalInput, TeacherUncheckedCreateWithoutPersonalInput>
  }

  export type TeacherCreateManyPersonalInputEnvelope = {
    data: Enumerable<TeacherCreateManyPersonalInput>
  }

  export type BornUpdateInput = {
    place?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUpsertInput = {
    set: AddressCreateInput | null
    update: AddressUpdateInput
  }

  export type EducationUpdateManyInput = {
    where: EducationWhereInput
    data: EducationUpdateInput
  }

  export type EducationDeleteManyInput = {
    where: EducationWhereInput
  }

  export type TrainingUpdateManyInput = {
    where: TrainingWhereInput
    data: TrainingUpdateInput
  }

  export type TrainingDeleteManyInput = {
    where: TrainingWhereInput
  }

  export type EmploymentUpdateManyInput = {
    where: EmploymentWhereInput
    data: EmploymentUpdateInput
  }

  export type EmploymentDeleteManyInput = {
    where: EmploymentWhereInput
  }

  export type ProfessionUpdateManyInput = {
    where: ProfessionWhereInput
    data: ProfessionUpdateInput
  }

  export type ProfessionDeleteManyInput = {
    where: ProfessionWhereInput
  }

  export type OverseasUpdateManyInput = {
    where: OverseasWhereInput
    data: OverseasUpdateInput
  }

  export type OverseasDeleteManyInput = {
    where: OverseasWhereInput
  }

  export type ScientificUpdateManyInput = {
    where: ScientificWhereInput
    data: ScientificUpdateInput
  }

  export type ScientificDeleteManyInput = {
    where: ScientificWhereInput
  }

  export type OrganizationUpdateManyInput = {
    where: OrganizationWhereInput
    data: OrganizationUpdateInput
  }

  export type OrganizationDeleteManyInput = {
    where: OrganizationWhereInput
  }

  export type PapersUpdateManyInput = {
    where: PapersWhereInput
    data: PapersUpdateInput
  }

  export type PapersDeleteManyInput = {
    where: PapersWhereInput
  }

  export type InnovationUpdateManyInput = {
    where: InnovationWhereInput
    data: InnovationUpdateInput
  }

  export type InnovationDeleteManyInput = {
    where: InnovationWhereInput
  }

  export type AwardUpdateManyInput = {
    where: AwardWhereInput
    data: AwardUpdateInput
  }

  export type AwardDeleteManyInput = {
    where: AwardWhereInput
  }

  export type SourcePersonUpdateManyInput = {
    where: SourcePersonWhereInput
    data: SourcePersonUpdateInput
  }

  export type SourcePersonDeleteManyInput = {
    where: SourcePersonWhereInput
  }

  export type ContestUpdateManyInput = {
    where: ContestWhereInput
    data: ContestUpdateInput
  }

  export type ContestDeleteManyInput = {
    where: ContestWhereInput
  }

  export type DocumentsUpdateManyInput = {
    where: DocumentsWhereInput
    data: DocumentsUpdateInput
  }

  export type DocumentsDeleteManyInput = {
    where: DocumentsWhereInput
  }

  export type AdditionalUpdateManyInput = {
    where: AdditionalWhereInput
    data: AdditionalUpdateInput
  }

  export type AdditionalDeleteManyInput = {
    where: AdditionalWhereInput
  }

  export type AuthUpsertWithoutPersonalInput = {
    update: XOR<AuthUpdateWithoutPersonalInput, AuthUncheckedUpdateWithoutPersonalInput>
    create: XOR<AuthCreateWithoutPersonalInput, AuthUncheckedCreateWithoutPersonalInput>
  }

  export type AuthUpdateWithoutPersonalInput = {
    user?: UserUpdateOneRequiredWithoutAuthNestedInput
  }

  export type AuthUncheckedUpdateWithoutPersonalInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type FamilyTreeUpsertWithWhereUniqueWithoutFatherInput = {
    where: FamilyTreeWhereUniqueInput
    update: XOR<FamilyTreeUpdateWithoutFatherInput, FamilyTreeUncheckedUpdateWithoutFatherInput>
    create: XOR<FamilyTreeCreateWithoutFatherInput, FamilyTreeUncheckedCreateWithoutFatherInput>
  }

  export type FamilyTreeUpdateWithWhereUniqueWithoutFatherInput = {
    where: FamilyTreeWhereUniqueInput
    data: XOR<FamilyTreeUpdateWithoutFatherInput, FamilyTreeUncheckedUpdateWithoutFatherInput>
  }

  export type FamilyTreeUpdateManyWithWhereWithoutFatherInput = {
    where: FamilyTreeScalarWhereInput
    data: XOR<FamilyTreeUpdateManyMutationInput, FamilyTreeUncheckedUpdateManyWithoutFatherInput>
  }

  export type FamilyTreeScalarWhereInput = {
    AND?: Enumerable<FamilyTreeScalarWhereInput>
    OR?: Enumerable<FamilyTreeScalarWhereInput>
    NOT?: Enumerable<FamilyTreeScalarWhereInput>
    id?: StringFilter | string
    nokk?: StringFilter | string
    fatherId?: StringNullableFilter | string | null
    motherId?: StringNullableFilter | string | null
    waliId?: StringNullableFilter | string | null
    coupleId?: StringNullableFilter | string | null
  }

  export type FamilyTreeUpsertWithWhereUniqueWithoutMotherInput = {
    where: FamilyTreeWhereUniqueInput
    update: XOR<FamilyTreeUpdateWithoutMotherInput, FamilyTreeUncheckedUpdateWithoutMotherInput>
    create: XOR<FamilyTreeCreateWithoutMotherInput, FamilyTreeUncheckedCreateWithoutMotherInput>
  }

  export type FamilyTreeUpdateWithWhereUniqueWithoutMotherInput = {
    where: FamilyTreeWhereUniqueInput
    data: XOR<FamilyTreeUpdateWithoutMotherInput, FamilyTreeUncheckedUpdateWithoutMotherInput>
  }

  export type FamilyTreeUpdateManyWithWhereWithoutMotherInput = {
    where: FamilyTreeScalarWhereInput
    data: XOR<FamilyTreeUpdateManyMutationInput, FamilyTreeUncheckedUpdateManyWithoutMotherInput>
  }

  export type FamilyTreeUpsertWithWhereUniqueWithoutWaliInput = {
    where: FamilyTreeWhereUniqueInput
    update: XOR<FamilyTreeUpdateWithoutWaliInput, FamilyTreeUncheckedUpdateWithoutWaliInput>
    create: XOR<FamilyTreeCreateWithoutWaliInput, FamilyTreeUncheckedCreateWithoutWaliInput>
  }

  export type FamilyTreeUpdateWithWhereUniqueWithoutWaliInput = {
    where: FamilyTreeWhereUniqueInput
    data: XOR<FamilyTreeUpdateWithoutWaliInput, FamilyTreeUncheckedUpdateWithoutWaliInput>
  }

  export type FamilyTreeUpdateManyWithWhereWithoutWaliInput = {
    where: FamilyTreeScalarWhereInput
    data: XOR<FamilyTreeUpdateManyMutationInput, FamilyTreeUncheckedUpdateManyWithoutWaliInput>
  }

  export type FamilyTreeUpsertWithWhereUniqueWithoutCoupleInput = {
    where: FamilyTreeWhereUniqueInput
    update: XOR<FamilyTreeUpdateWithoutCoupleInput, FamilyTreeUncheckedUpdateWithoutCoupleInput>
    create: XOR<FamilyTreeCreateWithoutCoupleInput, FamilyTreeUncheckedCreateWithoutCoupleInput>
  }

  export type FamilyTreeUpdateWithWhereUniqueWithoutCoupleInput = {
    where: FamilyTreeWhereUniqueInput
    data: XOR<FamilyTreeUpdateWithoutCoupleInput, FamilyTreeUncheckedUpdateWithoutCoupleInput>
  }

  export type FamilyTreeUpdateManyWithWhereWithoutCoupleInput = {
    where: FamilyTreeScalarWhereInput
    data: XOR<FamilyTreeUpdateManyMutationInput, FamilyTreeUncheckedUpdateManyWithoutCoupleInput>
  }

  export type FamilyTreeChildUpsertWithoutPersonalInput = {
    update: XOR<FamilyTreeChildUpdateWithoutPersonalInput, FamilyTreeChildUncheckedUpdateWithoutPersonalInput>
    create: XOR<FamilyTreeChildCreateWithoutPersonalInput, FamilyTreeChildUncheckedCreateWithoutPersonalInput>
  }

  export type FamilyTreeChildUpdateWithoutPersonalInput = {
    no?: IntFieldUpdateOperationsInput | number
    type?: EnumChildTypeFieldUpdateOperationsInput | ChildType
    kk?: FamilyTreeUpdateOneRequiredWithoutChildsNestedInput
  }

  export type FamilyTreeChildUncheckedUpdateWithoutPersonalInput = {
    no?: IntFieldUpdateOperationsInput | number
    type?: EnumChildTypeFieldUpdateOperationsInput | ChildType
    kkId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentUpsertWithWhereUniqueWithoutPersonalInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutPersonalInput, StudentUncheckedUpdateWithoutPersonalInput>
    create: XOR<StudentCreateWithoutPersonalInput, StudentUncheckedCreateWithoutPersonalInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutPersonalInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutPersonalInput, StudentUncheckedUpdateWithoutPersonalInput>
  }

  export type StudentUpdateManyWithWhereWithoutPersonalInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutStudentInput>
  }

  export type TeacherUpsertWithWhereUniqueWithoutPersonalInput = {
    where: TeacherWhereUniqueInput
    update: XOR<TeacherUpdateWithoutPersonalInput, TeacherUncheckedUpdateWithoutPersonalInput>
    create: XOR<TeacherCreateWithoutPersonalInput, TeacherUncheckedCreateWithoutPersonalInput>
  }

  export type TeacherUpdateWithWhereUniqueWithoutPersonalInput = {
    where: TeacherWhereUniqueInput
    data: XOR<TeacherUpdateWithoutPersonalInput, TeacherUncheckedUpdateWithoutPersonalInput>
  }

  export type TeacherUpdateManyWithWhereWithoutPersonalInput = {
    where: TeacherScalarWhereInput
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyWithoutTeacherInput>
  }

  export type UserCreateWithoutAuthInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    disable?: boolean
    google?: XOR<GoogleNullableCreateEnvelopeInput, GoogleCreateInput> | null
    role?: RoleCreateNestedOneWithoutUsersInput
    tracker?: TrackerCreateNestedManyWithoutUserInput
    objective?: ObjectiveCreateNestedManyWithoutUserInput
    link?: LinkCreateNestedManyWithoutUserInput
    tDevice?: TDeviceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuthInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    roleId?: string | null
    disable?: boolean
    google?: XOR<GoogleNullableCreateEnvelopeInput, GoogleCreateInput> | null
    tracker?: TrackerUncheckedCreateNestedManyWithoutUserInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutUserInput
    link?: LinkUncheckedCreateNestedManyWithoutUserInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuthInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthInput, UserUncheckedCreateWithoutAuthInput>
  }

  export type PersonalCreateWithoutAuthInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign?: boolean | null
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email?: string | null
    belajarId?: string | null
    nophone?: string | null
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: boolean
    father?: FamilyTreeCreateNestedManyWithoutFatherInput
    mother?: FamilyTreeCreateNestedManyWithoutMotherInput
    wali?: FamilyTreeCreateNestedManyWithoutWaliInput
    couple?: FamilyTreeCreateNestedManyWithoutCoupleInput
    child?: FamilyTreeChildCreateNestedOneWithoutPersonalInput
    student?: StudentCreateNestedManyWithoutPersonalInput
    teacher?: TeacherCreateNestedManyWithoutPersonalInput
  }

  export type PersonalUncheckedCreateWithoutAuthInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign?: boolean | null
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email?: string | null
    belajarId?: string | null
    nophone?: string | null
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: boolean
    father?: FamilyTreeUncheckedCreateNestedManyWithoutFatherInput
    mother?: FamilyTreeUncheckedCreateNestedManyWithoutMotherInput
    wali?: FamilyTreeUncheckedCreateNestedManyWithoutWaliInput
    couple?: FamilyTreeUncheckedCreateNestedManyWithoutCoupleInput
    child?: FamilyTreeChildUncheckedCreateNestedOneWithoutPersonalInput
    student?: StudentUncheckedCreateNestedManyWithoutPersonalInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutPersonalInput
  }

  export type PersonalCreateOrConnectWithoutAuthInput = {
    where: PersonalWhereUniqueInput
    create: XOR<PersonalCreateWithoutAuthInput, PersonalUncheckedCreateWithoutAuthInput>
  }

  export type UserUpsertWithoutAuthInput = {
    update: XOR<UserUpdateWithoutAuthInput, UserUncheckedUpdateWithoutAuthInput>
    create: XOR<UserCreateWithoutAuthInput, UserUncheckedCreateWithoutAuthInput>
  }

  export type UserUpdateWithoutAuthInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    google?: XOR<GoogleNullableUpdateEnvelopeInput, GoogleCreateInput> | null
    role?: RoleUpdateOneWithoutUsersNestedInput
    tracker?: TrackerUpdateManyWithoutUserNestedInput
    objective?: ObjectiveUpdateManyWithoutUserNestedInput
    link?: LinkUpdateManyWithoutUserNestedInput
    tDevice?: TDeviceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    google?: XOR<GoogleNullableUpdateEnvelopeInput, GoogleCreateInput> | null
    tracker?: TrackerUncheckedUpdateManyWithoutUserNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutUserNestedInput
    link?: LinkUncheckedUpdateManyWithoutUserNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PersonalUpsertWithoutAuthInput = {
    update: XOR<PersonalUpdateWithoutAuthInput, PersonalUncheckedUpdateWithoutAuthInput>
    create: XOR<PersonalCreateWithoutAuthInput, PersonalUncheckedCreateWithoutAuthInput>
  }

  export type PersonalUpdateWithoutAuthInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: NullableStringFieldUpdateOperationsInput | string | null
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: NullableStringFieldUpdateOperationsInput | string | null
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: BoolFieldUpdateOperationsInput | boolean
    father?: FamilyTreeUpdateManyWithoutFatherNestedInput
    mother?: FamilyTreeUpdateManyWithoutMotherNestedInput
    wali?: FamilyTreeUpdateManyWithoutWaliNestedInput
    couple?: FamilyTreeUpdateManyWithoutCoupleNestedInput
    child?: FamilyTreeChildUpdateOneWithoutPersonalNestedInput
    student?: StudentUpdateManyWithoutPersonalNestedInput
    teacher?: TeacherUpdateManyWithoutPersonalNestedInput
  }

  export type PersonalUncheckedUpdateWithoutAuthInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: NullableStringFieldUpdateOperationsInput | string | null
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: NullableStringFieldUpdateOperationsInput | string | null
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: BoolFieldUpdateOperationsInput | boolean
    father?: FamilyTreeUncheckedUpdateManyWithoutFatherNestedInput
    mother?: FamilyTreeUncheckedUpdateManyWithoutMotherNestedInput
    wali?: FamilyTreeUncheckedUpdateManyWithoutWaliNestedInput
    couple?: FamilyTreeUncheckedUpdateManyWithoutCoupleNestedInput
    child?: FamilyTreeChildUncheckedUpdateOneWithoutPersonalNestedInput
    student?: StudentUncheckedUpdateManyWithoutPersonalNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutPersonalNestedInput
  }

  export type PersonalCreateWithoutFatherInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign?: boolean | null
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email?: string | null
    belajarId?: string | null
    nophone?: string | null
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: boolean
    auth?: AuthCreateNestedOneWithoutPersonalInput
    mother?: FamilyTreeCreateNestedManyWithoutMotherInput
    wali?: FamilyTreeCreateNestedManyWithoutWaliInput
    couple?: FamilyTreeCreateNestedManyWithoutCoupleInput
    child?: FamilyTreeChildCreateNestedOneWithoutPersonalInput
    student?: StudentCreateNestedManyWithoutPersonalInput
    teacher?: TeacherCreateNestedManyWithoutPersonalInput
  }

  export type PersonalUncheckedCreateWithoutFatherInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign?: boolean | null
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email?: string | null
    belajarId?: string | null
    nophone?: string | null
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: boolean
    auth?: AuthUncheckedCreateNestedOneWithoutPersonalInput
    mother?: FamilyTreeUncheckedCreateNestedManyWithoutMotherInput
    wali?: FamilyTreeUncheckedCreateNestedManyWithoutWaliInput
    couple?: FamilyTreeUncheckedCreateNestedManyWithoutCoupleInput
    child?: FamilyTreeChildUncheckedCreateNestedOneWithoutPersonalInput
    student?: StudentUncheckedCreateNestedManyWithoutPersonalInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutPersonalInput
  }

  export type PersonalCreateOrConnectWithoutFatherInput = {
    where: PersonalWhereUniqueInput
    create: XOR<PersonalCreateWithoutFatherInput, PersonalUncheckedCreateWithoutFatherInput>
  }

  export type PersonalCreateWithoutMotherInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign?: boolean | null
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email?: string | null
    belajarId?: string | null
    nophone?: string | null
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: boolean
    auth?: AuthCreateNestedOneWithoutPersonalInput
    father?: FamilyTreeCreateNestedManyWithoutFatherInput
    wali?: FamilyTreeCreateNestedManyWithoutWaliInput
    couple?: FamilyTreeCreateNestedManyWithoutCoupleInput
    child?: FamilyTreeChildCreateNestedOneWithoutPersonalInput
    student?: StudentCreateNestedManyWithoutPersonalInput
    teacher?: TeacherCreateNestedManyWithoutPersonalInput
  }

  export type PersonalUncheckedCreateWithoutMotherInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign?: boolean | null
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email?: string | null
    belajarId?: string | null
    nophone?: string | null
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: boolean
    auth?: AuthUncheckedCreateNestedOneWithoutPersonalInput
    father?: FamilyTreeUncheckedCreateNestedManyWithoutFatherInput
    wali?: FamilyTreeUncheckedCreateNestedManyWithoutWaliInput
    couple?: FamilyTreeUncheckedCreateNestedManyWithoutCoupleInput
    child?: FamilyTreeChildUncheckedCreateNestedOneWithoutPersonalInput
    student?: StudentUncheckedCreateNestedManyWithoutPersonalInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutPersonalInput
  }

  export type PersonalCreateOrConnectWithoutMotherInput = {
    where: PersonalWhereUniqueInput
    create: XOR<PersonalCreateWithoutMotherInput, PersonalUncheckedCreateWithoutMotherInput>
  }

  export type PersonalCreateWithoutWaliInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign?: boolean | null
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email?: string | null
    belajarId?: string | null
    nophone?: string | null
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: boolean
    auth?: AuthCreateNestedOneWithoutPersonalInput
    father?: FamilyTreeCreateNestedManyWithoutFatherInput
    mother?: FamilyTreeCreateNestedManyWithoutMotherInput
    couple?: FamilyTreeCreateNestedManyWithoutCoupleInput
    child?: FamilyTreeChildCreateNestedOneWithoutPersonalInput
    student?: StudentCreateNestedManyWithoutPersonalInput
    teacher?: TeacherCreateNestedManyWithoutPersonalInput
  }

  export type PersonalUncheckedCreateWithoutWaliInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign?: boolean | null
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email?: string | null
    belajarId?: string | null
    nophone?: string | null
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: boolean
    auth?: AuthUncheckedCreateNestedOneWithoutPersonalInput
    father?: FamilyTreeUncheckedCreateNestedManyWithoutFatherInput
    mother?: FamilyTreeUncheckedCreateNestedManyWithoutMotherInput
    couple?: FamilyTreeUncheckedCreateNestedManyWithoutCoupleInput
    child?: FamilyTreeChildUncheckedCreateNestedOneWithoutPersonalInput
    student?: StudentUncheckedCreateNestedManyWithoutPersonalInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutPersonalInput
  }

  export type PersonalCreateOrConnectWithoutWaliInput = {
    where: PersonalWhereUniqueInput
    create: XOR<PersonalCreateWithoutWaliInput, PersonalUncheckedCreateWithoutWaliInput>
  }

  export type PersonalCreateWithoutCoupleInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign?: boolean | null
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email?: string | null
    belajarId?: string | null
    nophone?: string | null
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: boolean
    auth?: AuthCreateNestedOneWithoutPersonalInput
    father?: FamilyTreeCreateNestedManyWithoutFatherInput
    mother?: FamilyTreeCreateNestedManyWithoutMotherInput
    wali?: FamilyTreeCreateNestedManyWithoutWaliInput
    child?: FamilyTreeChildCreateNestedOneWithoutPersonalInput
    student?: StudentCreateNestedManyWithoutPersonalInput
    teacher?: TeacherCreateNestedManyWithoutPersonalInput
  }

  export type PersonalUncheckedCreateWithoutCoupleInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign?: boolean | null
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email?: string | null
    belajarId?: string | null
    nophone?: string | null
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: boolean
    auth?: AuthUncheckedCreateNestedOneWithoutPersonalInput
    father?: FamilyTreeUncheckedCreateNestedManyWithoutFatherInput
    mother?: FamilyTreeUncheckedCreateNestedManyWithoutMotherInput
    wali?: FamilyTreeUncheckedCreateNestedManyWithoutWaliInput
    child?: FamilyTreeChildUncheckedCreateNestedOneWithoutPersonalInput
    student?: StudentUncheckedCreateNestedManyWithoutPersonalInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutPersonalInput
  }

  export type PersonalCreateOrConnectWithoutCoupleInput = {
    where: PersonalWhereUniqueInput
    create: XOR<PersonalCreateWithoutCoupleInput, PersonalUncheckedCreateWithoutCoupleInput>
  }

  export type FamilyTreeChildCreateWithoutKkInput = {
    id?: string
    no: number
    type: ChildType
    personal: PersonalCreateNestedOneWithoutChildInput
  }

  export type FamilyTreeChildUncheckedCreateWithoutKkInput = {
    id?: string
    no: number
    type: ChildType
    personalId: string
  }

  export type FamilyTreeChildCreateOrConnectWithoutKkInput = {
    where: FamilyTreeChildWhereUniqueInput
    create: XOR<FamilyTreeChildCreateWithoutKkInput, FamilyTreeChildUncheckedCreateWithoutKkInput>
  }

  export type FamilyTreeChildCreateManyKkInputEnvelope = {
    data: Enumerable<FamilyTreeChildCreateManyKkInput>
  }

  export type PersonalUpsertWithoutFatherInput = {
    update: XOR<PersonalUpdateWithoutFatherInput, PersonalUncheckedUpdateWithoutFatherInput>
    create: XOR<PersonalCreateWithoutFatherInput, PersonalUncheckedCreateWithoutFatherInput>
  }

  export type PersonalUpdateWithoutFatherInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: NullableStringFieldUpdateOperationsInput | string | null
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: NullableStringFieldUpdateOperationsInput | string | null
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: BoolFieldUpdateOperationsInput | boolean
    auth?: AuthUpdateOneWithoutPersonalNestedInput
    mother?: FamilyTreeUpdateManyWithoutMotherNestedInput
    wali?: FamilyTreeUpdateManyWithoutWaliNestedInput
    couple?: FamilyTreeUpdateManyWithoutCoupleNestedInput
    child?: FamilyTreeChildUpdateOneWithoutPersonalNestedInput
    student?: StudentUpdateManyWithoutPersonalNestedInput
    teacher?: TeacherUpdateManyWithoutPersonalNestedInput
  }

  export type PersonalUncheckedUpdateWithoutFatherInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: NullableStringFieldUpdateOperationsInput | string | null
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: NullableStringFieldUpdateOperationsInput | string | null
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: BoolFieldUpdateOperationsInput | boolean
    auth?: AuthUncheckedUpdateOneWithoutPersonalNestedInput
    mother?: FamilyTreeUncheckedUpdateManyWithoutMotherNestedInput
    wali?: FamilyTreeUncheckedUpdateManyWithoutWaliNestedInput
    couple?: FamilyTreeUncheckedUpdateManyWithoutCoupleNestedInput
    child?: FamilyTreeChildUncheckedUpdateOneWithoutPersonalNestedInput
    student?: StudentUncheckedUpdateManyWithoutPersonalNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutPersonalNestedInput
  }

  export type PersonalUpsertWithoutMotherInput = {
    update: XOR<PersonalUpdateWithoutMotherInput, PersonalUncheckedUpdateWithoutMotherInput>
    create: XOR<PersonalCreateWithoutMotherInput, PersonalUncheckedCreateWithoutMotherInput>
  }

  export type PersonalUpdateWithoutMotherInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: NullableStringFieldUpdateOperationsInput | string | null
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: NullableStringFieldUpdateOperationsInput | string | null
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: BoolFieldUpdateOperationsInput | boolean
    auth?: AuthUpdateOneWithoutPersonalNestedInput
    father?: FamilyTreeUpdateManyWithoutFatherNestedInput
    wali?: FamilyTreeUpdateManyWithoutWaliNestedInput
    couple?: FamilyTreeUpdateManyWithoutCoupleNestedInput
    child?: FamilyTreeChildUpdateOneWithoutPersonalNestedInput
    student?: StudentUpdateManyWithoutPersonalNestedInput
    teacher?: TeacherUpdateManyWithoutPersonalNestedInput
  }

  export type PersonalUncheckedUpdateWithoutMotherInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: NullableStringFieldUpdateOperationsInput | string | null
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: NullableStringFieldUpdateOperationsInput | string | null
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: BoolFieldUpdateOperationsInput | boolean
    auth?: AuthUncheckedUpdateOneWithoutPersonalNestedInput
    father?: FamilyTreeUncheckedUpdateManyWithoutFatherNestedInput
    wali?: FamilyTreeUncheckedUpdateManyWithoutWaliNestedInput
    couple?: FamilyTreeUncheckedUpdateManyWithoutCoupleNestedInput
    child?: FamilyTreeChildUncheckedUpdateOneWithoutPersonalNestedInput
    student?: StudentUncheckedUpdateManyWithoutPersonalNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutPersonalNestedInput
  }

  export type PersonalUpsertWithoutWaliInput = {
    update: XOR<PersonalUpdateWithoutWaliInput, PersonalUncheckedUpdateWithoutWaliInput>
    create: XOR<PersonalCreateWithoutWaliInput, PersonalUncheckedCreateWithoutWaliInput>
  }

  export type PersonalUpdateWithoutWaliInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: NullableStringFieldUpdateOperationsInput | string | null
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: NullableStringFieldUpdateOperationsInput | string | null
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: BoolFieldUpdateOperationsInput | boolean
    auth?: AuthUpdateOneWithoutPersonalNestedInput
    father?: FamilyTreeUpdateManyWithoutFatherNestedInput
    mother?: FamilyTreeUpdateManyWithoutMotherNestedInput
    couple?: FamilyTreeUpdateManyWithoutCoupleNestedInput
    child?: FamilyTreeChildUpdateOneWithoutPersonalNestedInput
    student?: StudentUpdateManyWithoutPersonalNestedInput
    teacher?: TeacherUpdateManyWithoutPersonalNestedInput
  }

  export type PersonalUncheckedUpdateWithoutWaliInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: NullableStringFieldUpdateOperationsInput | string | null
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: NullableStringFieldUpdateOperationsInput | string | null
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: BoolFieldUpdateOperationsInput | boolean
    auth?: AuthUncheckedUpdateOneWithoutPersonalNestedInput
    father?: FamilyTreeUncheckedUpdateManyWithoutFatherNestedInput
    mother?: FamilyTreeUncheckedUpdateManyWithoutMotherNestedInput
    couple?: FamilyTreeUncheckedUpdateManyWithoutCoupleNestedInput
    child?: FamilyTreeChildUncheckedUpdateOneWithoutPersonalNestedInput
    student?: StudentUncheckedUpdateManyWithoutPersonalNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutPersonalNestedInput
  }

  export type PersonalUpsertWithoutCoupleInput = {
    update: XOR<PersonalUpdateWithoutCoupleInput, PersonalUncheckedUpdateWithoutCoupleInput>
    create: XOR<PersonalCreateWithoutCoupleInput, PersonalUncheckedCreateWithoutCoupleInput>
  }

  export type PersonalUpdateWithoutCoupleInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: NullableStringFieldUpdateOperationsInput | string | null
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: NullableStringFieldUpdateOperationsInput | string | null
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: BoolFieldUpdateOperationsInput | boolean
    auth?: AuthUpdateOneWithoutPersonalNestedInput
    father?: FamilyTreeUpdateManyWithoutFatherNestedInput
    mother?: FamilyTreeUpdateManyWithoutMotherNestedInput
    wali?: FamilyTreeUpdateManyWithoutWaliNestedInput
    child?: FamilyTreeChildUpdateOneWithoutPersonalNestedInput
    student?: StudentUpdateManyWithoutPersonalNestedInput
    teacher?: TeacherUpdateManyWithoutPersonalNestedInput
  }

  export type PersonalUncheckedUpdateWithoutCoupleInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: NullableStringFieldUpdateOperationsInput | string | null
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: NullableStringFieldUpdateOperationsInput | string | null
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: BoolFieldUpdateOperationsInput | boolean
    auth?: AuthUncheckedUpdateOneWithoutPersonalNestedInput
    father?: FamilyTreeUncheckedUpdateManyWithoutFatherNestedInput
    mother?: FamilyTreeUncheckedUpdateManyWithoutMotherNestedInput
    wali?: FamilyTreeUncheckedUpdateManyWithoutWaliNestedInput
    child?: FamilyTreeChildUncheckedUpdateOneWithoutPersonalNestedInput
    student?: StudentUncheckedUpdateManyWithoutPersonalNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutPersonalNestedInput
  }

  export type FamilyTreeChildUpsertWithWhereUniqueWithoutKkInput = {
    where: FamilyTreeChildWhereUniqueInput
    update: XOR<FamilyTreeChildUpdateWithoutKkInput, FamilyTreeChildUncheckedUpdateWithoutKkInput>
    create: XOR<FamilyTreeChildCreateWithoutKkInput, FamilyTreeChildUncheckedCreateWithoutKkInput>
  }

  export type FamilyTreeChildUpdateWithWhereUniqueWithoutKkInput = {
    where: FamilyTreeChildWhereUniqueInput
    data: XOR<FamilyTreeChildUpdateWithoutKkInput, FamilyTreeChildUncheckedUpdateWithoutKkInput>
  }

  export type FamilyTreeChildUpdateManyWithWhereWithoutKkInput = {
    where: FamilyTreeChildScalarWhereInput
    data: XOR<FamilyTreeChildUpdateManyMutationInput, FamilyTreeChildUncheckedUpdateManyWithoutChildsInput>
  }

  export type FamilyTreeChildScalarWhereInput = {
    AND?: Enumerable<FamilyTreeChildScalarWhereInput>
    OR?: Enumerable<FamilyTreeChildScalarWhereInput>
    NOT?: Enumerable<FamilyTreeChildScalarWhereInput>
    id?: StringFilter | string
    no?: IntFilter | number
    type?: EnumChildTypeFilter | ChildType
    kkId?: StringFilter | string
    personalId?: StringFilter | string
  }

  export type FamilyTreeCreateWithoutChildsInput = {
    id?: string
    nokk: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    father?: PersonalCreateNestedOneWithoutFatherInput
    mother?: PersonalCreateNestedOneWithoutMotherInput
    wali?: PersonalCreateNestedOneWithoutWaliInput
    couple?: PersonalCreateNestedOneWithoutCoupleInput
  }

  export type FamilyTreeUncheckedCreateWithoutChildsInput = {
    id?: string
    nokk: string
    fatherId?: string | null
    motherId?: string | null
    waliId?: string | null
    coupleId?: string | null
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
  }

  export type FamilyTreeCreateOrConnectWithoutChildsInput = {
    where: FamilyTreeWhereUniqueInput
    create: XOR<FamilyTreeCreateWithoutChildsInput, FamilyTreeUncheckedCreateWithoutChildsInput>
  }

  export type PersonalCreateWithoutChildInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign?: boolean | null
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email?: string | null
    belajarId?: string | null
    nophone?: string | null
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: boolean
    auth?: AuthCreateNestedOneWithoutPersonalInput
    father?: FamilyTreeCreateNestedManyWithoutFatherInput
    mother?: FamilyTreeCreateNestedManyWithoutMotherInput
    wali?: FamilyTreeCreateNestedManyWithoutWaliInput
    couple?: FamilyTreeCreateNestedManyWithoutCoupleInput
    student?: StudentCreateNestedManyWithoutPersonalInput
    teacher?: TeacherCreateNestedManyWithoutPersonalInput
  }

  export type PersonalUncheckedCreateWithoutChildInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign?: boolean | null
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email?: string | null
    belajarId?: string | null
    nophone?: string | null
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: boolean
    auth?: AuthUncheckedCreateNestedOneWithoutPersonalInput
    father?: FamilyTreeUncheckedCreateNestedManyWithoutFatherInput
    mother?: FamilyTreeUncheckedCreateNestedManyWithoutMotherInput
    wali?: FamilyTreeUncheckedCreateNestedManyWithoutWaliInput
    couple?: FamilyTreeUncheckedCreateNestedManyWithoutCoupleInput
    student?: StudentUncheckedCreateNestedManyWithoutPersonalInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutPersonalInput
  }

  export type PersonalCreateOrConnectWithoutChildInput = {
    where: PersonalWhereUniqueInput
    create: XOR<PersonalCreateWithoutChildInput, PersonalUncheckedCreateWithoutChildInput>
  }

  export type FamilyTreeUpsertWithoutChildsInput = {
    update: XOR<FamilyTreeUpdateWithoutChildsInput, FamilyTreeUncheckedUpdateWithoutChildsInput>
    create: XOR<FamilyTreeCreateWithoutChildsInput, FamilyTreeUncheckedCreateWithoutChildsInput>
  }

  export type FamilyTreeUpdateWithoutChildsInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    father?: PersonalUpdateOneWithoutFatherNestedInput
    mother?: PersonalUpdateOneWithoutMotherNestedInput
    wali?: PersonalUpdateOneWithoutWaliNestedInput
    couple?: PersonalUpdateOneWithoutCoupleNestedInput
  }

  export type FamilyTreeUncheckedUpdateWithoutChildsInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    fatherId?: NullableStringFieldUpdateOperationsInput | string | null
    motherId?: NullableStringFieldUpdateOperationsInput | string | null
    waliId?: NullableStringFieldUpdateOperationsInput | string | null
    coupleId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
  }

  export type PersonalUpsertWithoutChildInput = {
    update: XOR<PersonalUpdateWithoutChildInput, PersonalUncheckedUpdateWithoutChildInput>
    create: XOR<PersonalCreateWithoutChildInput, PersonalUncheckedCreateWithoutChildInput>
  }

  export type PersonalUpdateWithoutChildInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: NullableStringFieldUpdateOperationsInput | string | null
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: NullableStringFieldUpdateOperationsInput | string | null
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: BoolFieldUpdateOperationsInput | boolean
    auth?: AuthUpdateOneWithoutPersonalNestedInput
    father?: FamilyTreeUpdateManyWithoutFatherNestedInput
    mother?: FamilyTreeUpdateManyWithoutMotherNestedInput
    wali?: FamilyTreeUpdateManyWithoutWaliNestedInput
    couple?: FamilyTreeUpdateManyWithoutCoupleNestedInput
    student?: StudentUpdateManyWithoutPersonalNestedInput
    teacher?: TeacherUpdateManyWithoutPersonalNestedInput
  }

  export type PersonalUncheckedUpdateWithoutChildInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: NullableStringFieldUpdateOperationsInput | string | null
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: NullableStringFieldUpdateOperationsInput | string | null
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: BoolFieldUpdateOperationsInput | boolean
    auth?: AuthUncheckedUpdateOneWithoutPersonalNestedInput
    father?: FamilyTreeUncheckedUpdateManyWithoutFatherNestedInput
    mother?: FamilyTreeUncheckedUpdateManyWithoutMotherNestedInput
    wali?: FamilyTreeUncheckedUpdateManyWithoutWaliNestedInput
    couple?: FamilyTreeUncheckedUpdateManyWithoutCoupleNestedInput
    student?: StudentUncheckedUpdateManyWithoutPersonalNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutPersonalNestedInput
  }

  export type InstansiCreateWithoutSchoolYearInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    disable?: boolean
    majors?: KonsentrasiKeahlianCreateNestedManyWithoutInstansiInput
    role?: RoleCreateNestedManyWithoutInstansiInput
    teacher?: TeacherCreateNestedManyWithoutInstansiInput
    student?: StudentCreateNestedManyWithoutInstansiInput
    tracker?: TrackerCreateNestedManyWithoutInstansiInput
    history?: TrackerCreateNestedManyWithoutRefInput
    unikMapels?: MataPelajaranCreateNestedManyWithoutInstansiInput
    tDevice?: TDeviceCreateNestedManyWithoutInstansiInput
    objective?: ObjectiveCreateNestedManyWithoutInstansiInput
    dudi?: DudiCreateNestedManyWithoutInstansiInput
  }

  export type InstansiUncheckedCreateWithoutSchoolYearInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    majorIds?: InstansiCreatemajorIdsInput | Enumerable<string>
    disable?: boolean
    majors?: KonsentrasiKeahlianUncheckedCreateNestedManyWithoutInstansiInput
    role?: RoleUncheckedCreateNestedManyWithoutInstansiInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutInstansiInput
    student?: StudentUncheckedCreateNestedManyWithoutInstansiInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutInstansiInput
    history?: TrackerUncheckedCreateNestedManyWithoutRefInput
    unikMapels?: MataPelajaranUncheckedCreateNestedManyWithoutInstansiInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutInstansiInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutInstansiInput
    dudi?: DudiUncheckedCreateNestedManyWithoutInstansiInput
  }

  export type InstansiCreateOrConnectWithoutSchoolYearInput = {
    where: InstansiWhereUniqueInput
    create: XOR<InstansiCreateWithoutSchoolYearInput, InstansiUncheckedCreateWithoutSchoolYearInput>
  }

  export type ClassRoomCreateWithoutYearInput = {
    id?: string
    name: string
    level: number
    property?: XOR<RoomPropertyNullableCreateEnvelopeInput, RoomPropertyCreateInput> | null
    disable?: boolean
    wali: TeacherCreateNestedOneWithoutClassRoomInput
    major?: KonsentrasiKeahlianCreateNestedOneWithoutClassRoomInput
    students?: StudentCreateNestedManyWithoutClassRoomInput
    event?: CalendarCreateNestedManyWithoutClassRoomInput
    tracker?: TrackerCreateNestedManyWithoutKelasInput
    teaching?: TeachingCreateNestedManyWithoutClassRoomInput
    tDevice?: TDeviceCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomUncheckedCreateWithoutYearInput = {
    id?: string
    name: string
    waliId: string
    level: number
    property?: XOR<RoomPropertyNullableCreateEnvelopeInput, RoomPropertyCreateInput> | null
    majorId?: string | null
    studentIds?: ClassRoomCreatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomCreateeventIdsInput | Enumerable<string>
    disable?: boolean
    teachingIds?: ClassRoomCreateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomCreatetDeviceIdsInput | Enumerable<string>
    students?: StudentUncheckedCreateNestedManyWithoutClassRoomInput
    event?: CalendarUncheckedCreateNestedManyWithoutClassRoomInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutKelasInput
    teaching?: TeachingUncheckedCreateNestedManyWithoutClassRoomInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomCreateOrConnectWithoutYearInput = {
    where: ClassRoomWhereUniqueInput
    create: XOR<ClassRoomCreateWithoutYearInput, ClassRoomUncheckedCreateWithoutYearInput>
  }

  export type ClassRoomCreateManyYearInputEnvelope = {
    data: Enumerable<ClassRoomCreateManyYearInput>
  }

  export type StudentCreateWithoutStartYearInput = {
    id?: string
    nis: string
    lastSchool: string
    disable?: boolean
    personal: PersonalCreateNestedOneWithoutStudentInput
    major?: KonsentrasiKeahlianCreateNestedOneWithoutStudentInput
    classRoom?: ClassRoomCreateNestedManyWithoutStudentsInput
    instansi: InstansiCreateNestedOneWithoutStudentInput
    event?: CalendarCreateNestedManyWithoutStudentInput
    tracker?: TrackerCreateNestedManyWithoutMuridInput
  }

  export type StudentUncheckedCreateWithoutStartYearInput = {
    id?: string
    nis: string
    lastSchool: string
    personalId: string
    majorId?: string | null
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    instansiId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutStudentsInput
    event?: CalendarUncheckedCreateNestedManyWithoutStudentInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutMuridInput
  }

  export type StudentCreateOrConnectWithoutStartYearInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStartYearInput, StudentUncheckedCreateWithoutStartYearInput>
  }

  export type StudentCreateManyStartYearInputEnvelope = {
    data: Enumerable<StudentCreateManyStartYearInput>
  }

  export type CalendarCreateWithoutRefInput = {
    id?: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    disable?: boolean
    classRoom?: ClassRoomCreateNestedManyWithoutEventInput
    student?: StudentCreateNestedManyWithoutEventInput
    teacher?: TeacherCreateNestedManyWithoutEventInput
    tracker?: TrackerCreateNestedManyWithoutKalenderInput
  }

  export type CalendarUncheckedCreateWithoutRefInput = {
    id?: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    classRoomIds?: CalendarCreateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarCreatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarCreateteacherIdsInput | Enumerable<string>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutEventInput
    student?: StudentUncheckedCreateNestedManyWithoutEventInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutEventInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutKalenderInput
  }

  export type CalendarCreateOrConnectWithoutRefInput = {
    where: CalendarWhereUniqueInput
    create: XOR<CalendarCreateWithoutRefInput, CalendarUncheckedCreateWithoutRefInput>
  }

  export type CalendarCreateManyRefInputEnvelope = {
    data: Enumerable<CalendarCreateManyRefInput>
  }

  export type ScheduleCreateWithoutYearInput = {
    id?: string
    disable?: boolean
    mapel: MataPelajaranCreateNestedOneWithoutScheduleInput
    tracker?: TrackerCreateNestedManyWithoutJadwalInput
    teaching?: TeachingCreateNestedManyWithoutRefInput
  }

  export type ScheduleUncheckedCreateWithoutYearInput = {
    id?: string
    mapelId: string
    disable?: boolean
    tracker?: TrackerUncheckedCreateNestedManyWithoutJadwalInput
    teaching?: TeachingUncheckedCreateNestedManyWithoutRefInput
  }

  export type ScheduleCreateOrConnectWithoutYearInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutYearInput, ScheduleUncheckedCreateWithoutYearInput>
  }

  export type ScheduleCreateManyYearInputEnvelope = {
    data: Enumerable<ScheduleCreateManyYearInput>
  }

  export type ObjectiveCreateWithoutYearInput = {
    id?: string
    level: number
    fase: Fase
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    user: UserCreateNestedOneWithoutObjectiveInput
    instansi: InstansiCreateNestedOneWithoutObjectiveInput
    mapel: MataPelajaranCreateNestedOneWithoutObjectiveInput
    elemen: ElementCreateNestedOneWithoutObjectiveInput
    achievement: AchievementCreateNestedOneWithoutObjectiveInput
    material?: OMaterialCreateNestedManyWithoutRefInput
    tracker?: TrackerCreateNestedManyWithoutTujuanInput
    resourse?: OresourceCreateNestedManyWithoutRefInput
    ppp?: OpppCreateNestedManyWithoutRefInput
    tool?: OhelperCreateNestedManyWithoutToolInput
    mate?: OhelperCreateNestedManyWithoutMateInput
    meth?: OhelperCreateNestedManyWithoutMethInput
    media?: OhelperCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentCreateNestedManyWithoutRefInput
    devices?: TDeviceDataCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveUncheckedCreateWithoutYearInput = {
    id?: string
    level: number
    fase: Fase
    userId: string
    instansiId: string
    mapelId: string
    elementId: string
    achievementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedCreateNestedManyWithoutRefInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTujuanInput
    resourse?: OresourceUncheckedCreateNestedManyWithoutRefInput
    ppp?: OpppUncheckedCreateNestedManyWithoutRefInput
    tool?: OhelperUncheckedCreateNestedManyWithoutToolInput
    mate?: OhelperUncheckedCreateNestedManyWithoutMateInput
    meth?: OhelperUncheckedCreateNestedManyWithoutMethInput
    media?: OhelperUncheckedCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentUncheckedCreateNestedManyWithoutRefInput
    devices?: TDeviceDataUncheckedCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveCreateOrConnectWithoutYearInput = {
    where: ObjectiveWhereUniqueInput
    create: XOR<ObjectiveCreateWithoutYearInput, ObjectiveUncheckedCreateWithoutYearInput>
  }

  export type ObjectiveCreateManyYearInputEnvelope = {
    data: Enumerable<ObjectiveCreateManyYearInput>
  }

  export type TrackerCreateWithoutTpInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrackerInput
    ref: InstansiCreateNestedOneWithoutHistoryInput
    instansi?: InstansiCreateNestedOneWithoutTrackerInput
    mapel?: MataPelajaranCreateNestedOneWithoutTrackerInput
    elemen?: ElementCreateNestedOneWithoutTrackerInput
    cp?: AchievementCreateNestedOneWithoutTrackerInput
    bidang?: BidangKeahlianCreateNestedOneWithoutTrackerInput
    program?: ProgramKeahlianCreateNestedOneWithoutTrackerInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedOneWithoutTrackerInput
    teacher?: TeacherCreateNestedOneWithoutTrackerInput
    kelas?: ClassRoomCreateNestedOneWithoutTrackerInput
    murid?: StudentCreateNestedOneWithoutTrackerInput
    jadwal?: ScheduleCreateNestedOneWithoutTrackerInput
    mengajar?: TeachingCreateNestedOneWithoutTrackerInput
    tujuan?: ObjectiveCreateNestedOneWithoutTrackerInput
    perangkat?: TDeviceCreateNestedOneWithoutTrackerInput
    kalender?: CalendarCreateNestedOneWithoutTrackerInput
    dudi?: DudiCreateNestedOneWithoutTrackerInput
    kkni?: KkniCreateNestedOneWithoutTrackerInput
  }

  export type TrackerUncheckedCreateWithoutTpInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TrackerCreateOrConnectWithoutTpInput = {
    where: TrackerWhereUniqueInput
    create: XOR<TrackerCreateWithoutTpInput, TrackerUncheckedCreateWithoutTpInput>
  }

  export type TrackerCreateManyTpInputEnvelope = {
    data: Enumerable<TrackerCreateManyTpInput>
  }

  export type TDeviceCreateWithoutYearInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    teaching: TeachingCreateNestedOneWithoutTDeviceInput
    user: UserCreateNestedOneWithoutTDeviceInput
    instansi: InstansiCreateNestedOneWithoutTDeviceInput
    mapel: MataPelajaranCreateNestedOneWithoutDeviceInput
    classRoom?: ClassRoomCreateNestedManyWithoutTDeviceInput
    tracker?: TrackerCreateNestedManyWithoutPerangkatInput
    data?: TDeviceDataCreateNestedManyWithoutRefInput
    children?: TDeviceCreateNestedManyWithoutParentInput
    parent?: TDeviceCreateNestedOneWithoutChildrenInput
  }

  export type TDeviceUncheckedCreateWithoutYearInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    teachingId: string
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    userId: string
    instansiId: string
    mapelId: string
    classRoomIds?: TDeviceCreateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    parentId?: string | null
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutTDeviceInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutPerangkatInput
    data?: TDeviceDataUncheckedCreateNestedManyWithoutRefInput
    children?: TDeviceUncheckedCreateNestedManyWithoutParentInput
  }

  export type TDeviceCreateOrConnectWithoutYearInput = {
    where: TDeviceWhereUniqueInput
    create: XOR<TDeviceCreateWithoutYearInput, TDeviceUncheckedCreateWithoutYearInput>
  }

  export type TDeviceCreateManyYearInputEnvelope = {
    data: Enumerable<TDeviceCreateManyYearInput>
  }

  export type OrganizationalUpdateInput = {
    kepsek?: StringFieldUpdateOperationsInput | string
    wakasek?: StringFieldUpdateOperationsInput | string
    wakakur?: StringFieldUpdateOperationsInput | string
    wakasiw?: StringFieldUpdateOperationsInput | string
    wakapra?: StringFieldUpdateOperationsInput | string
    wakahum?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InstansiUpsertWithoutSchoolYearInput = {
    update: XOR<InstansiUpdateWithoutSchoolYearInput, InstansiUncheckedUpdateWithoutSchoolYearInput>
    create: XOR<InstansiCreateWithoutSchoolYearInput, InstansiUncheckedCreateWithoutSchoolYearInput>
  }

  export type InstansiUpdateWithoutSchoolYearInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    majors?: KonsentrasiKeahlianUpdateManyWithoutInstansiNestedInput
    role?: RoleUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUpdateManyWithoutInstansiNestedInput
    student?: StudentUpdateManyWithoutInstansiNestedInput
    tracker?: TrackerUpdateManyWithoutInstansiNestedInput
    history?: TrackerUpdateManyWithoutRefNestedInput
    unikMapels?: MataPelajaranUpdateManyWithoutInstansiNestedInput
    tDevice?: TDeviceUpdateManyWithoutInstansiNestedInput
    objective?: ObjectiveUpdateManyWithoutInstansiNestedInput
    dudi?: DudiUpdateManyWithoutInstansiNestedInput
  }

  export type InstansiUncheckedUpdateWithoutSchoolYearInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    majorIds?: InstansiUpdatemajorIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    majors?: KonsentrasiKeahlianUncheckedUpdateManyWithoutInstansiNestedInput
    role?: RoleUncheckedUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutInstansiNestedInput
    student?: StudentUncheckedUpdateManyWithoutInstansiNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutInstansiNestedInput
    history?: TrackerUncheckedUpdateManyWithoutRefNestedInput
    unikMapels?: MataPelajaranUncheckedUpdateManyWithoutInstansiNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutInstansiNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutInstansiNestedInput
    dudi?: DudiUncheckedUpdateManyWithoutInstansiNestedInput
  }

  export type ClassRoomUpsertWithWhereUniqueWithoutYearInput = {
    where: ClassRoomWhereUniqueInput
    update: XOR<ClassRoomUpdateWithoutYearInput, ClassRoomUncheckedUpdateWithoutYearInput>
    create: XOR<ClassRoomCreateWithoutYearInput, ClassRoomUncheckedCreateWithoutYearInput>
  }

  export type ClassRoomUpdateWithWhereUniqueWithoutYearInput = {
    where: ClassRoomWhereUniqueInput
    data: XOR<ClassRoomUpdateWithoutYearInput, ClassRoomUncheckedUpdateWithoutYearInput>
  }

  export type ClassRoomUpdateManyWithWhereWithoutYearInput = {
    where: ClassRoomScalarWhereInput
    data: XOR<ClassRoomUpdateManyMutationInput, ClassRoomUncheckedUpdateManyWithoutClassRoomInput>
  }

  export type StudentUpsertWithWhereUniqueWithoutStartYearInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutStartYearInput, StudentUncheckedUpdateWithoutStartYearInput>
    create: XOR<StudentCreateWithoutStartYearInput, StudentUncheckedCreateWithoutStartYearInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutStartYearInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutStartYearInput, StudentUncheckedUpdateWithoutStartYearInput>
  }

  export type StudentUpdateManyWithWhereWithoutStartYearInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutStudentsInput>
  }

  export type CalendarUpsertWithWhereUniqueWithoutRefInput = {
    where: CalendarWhereUniqueInput
    update: XOR<CalendarUpdateWithoutRefInput, CalendarUncheckedUpdateWithoutRefInput>
    create: XOR<CalendarCreateWithoutRefInput, CalendarUncheckedCreateWithoutRefInput>
  }

  export type CalendarUpdateWithWhereUniqueWithoutRefInput = {
    where: CalendarWhereUniqueInput
    data: XOR<CalendarUpdateWithoutRefInput, CalendarUncheckedUpdateWithoutRefInput>
  }

  export type CalendarUpdateManyWithWhereWithoutRefInput = {
    where: CalendarScalarWhereInput
    data: XOR<CalendarUpdateManyMutationInput, CalendarUncheckedUpdateManyWithoutCalendarInput>
  }

  export type CalendarScalarWhereInput = {
    AND?: Enumerable<CalendarScalarWhereInput>
    OR?: Enumerable<CalendarScalarWhereInput>
    NOT?: Enumerable<CalendarScalarWhereInput>
    id?: StringFilter | string
    refId?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    start?: DateTimeFilter | Date | string
    end?: DateTimeNullableFilter | Date | string | null
    color?: StringFilter | string
    classRoomIds?: StringNullableListFilter
    studentIds?: StringNullableListFilter
    teacherIds?: StringNullableListFilter
    disable?: BoolFilter | boolean
  }

  export type ScheduleUpsertWithWhereUniqueWithoutYearInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutYearInput, ScheduleUncheckedUpdateWithoutYearInput>
    create: XOR<ScheduleCreateWithoutYearInput, ScheduleUncheckedCreateWithoutYearInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutYearInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutYearInput, ScheduleUncheckedUpdateWithoutYearInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutYearInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutScheduleInput>
  }

  export type ObjectiveUpsertWithWhereUniqueWithoutYearInput = {
    where: ObjectiveWhereUniqueInput
    update: XOR<ObjectiveUpdateWithoutYearInput, ObjectiveUncheckedUpdateWithoutYearInput>
    create: XOR<ObjectiveCreateWithoutYearInput, ObjectiveUncheckedCreateWithoutYearInput>
  }

  export type ObjectiveUpdateWithWhereUniqueWithoutYearInput = {
    where: ObjectiveWhereUniqueInput
    data: XOR<ObjectiveUpdateWithoutYearInput, ObjectiveUncheckedUpdateWithoutYearInput>
  }

  export type ObjectiveUpdateManyWithWhereWithoutYearInput = {
    where: ObjectiveScalarWhereInput
    data: XOR<ObjectiveUpdateManyMutationInput, ObjectiveUncheckedUpdateManyWithoutObjectiveInput>
  }

  export type TrackerUpsertWithWhereUniqueWithoutTpInput = {
    where: TrackerWhereUniqueInput
    update: XOR<TrackerUpdateWithoutTpInput, TrackerUncheckedUpdateWithoutTpInput>
    create: XOR<TrackerCreateWithoutTpInput, TrackerUncheckedCreateWithoutTpInput>
  }

  export type TrackerUpdateWithWhereUniqueWithoutTpInput = {
    where: TrackerWhereUniqueInput
    data: XOR<TrackerUpdateWithoutTpInput, TrackerUncheckedUpdateWithoutTpInput>
  }

  export type TrackerUpdateManyWithWhereWithoutTpInput = {
    where: TrackerScalarWhereInput
    data: XOR<TrackerUpdateManyMutationInput, TrackerUncheckedUpdateManyWithoutTrackerInput>
  }

  export type TDeviceUpsertWithWhereUniqueWithoutYearInput = {
    where: TDeviceWhereUniqueInput
    update: XOR<TDeviceUpdateWithoutYearInput, TDeviceUncheckedUpdateWithoutYearInput>
    create: XOR<TDeviceCreateWithoutYearInput, TDeviceUncheckedCreateWithoutYearInput>
  }

  export type TDeviceUpdateWithWhereUniqueWithoutYearInput = {
    where: TDeviceWhereUniqueInput
    data: XOR<TDeviceUpdateWithoutYearInput, TDeviceUncheckedUpdateWithoutYearInput>
  }

  export type TDeviceUpdateManyWithWhereWithoutYearInput = {
    where: TDeviceScalarWhereInput
    data: XOR<TDeviceUpdateManyMutationInput, TDeviceUncheckedUpdateManyWithoutTDeviceInput>
  }

  export type PersonalCreateWithoutTeacherInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign?: boolean | null
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email?: string | null
    belajarId?: string | null
    nophone?: string | null
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: boolean
    auth?: AuthCreateNestedOneWithoutPersonalInput
    father?: FamilyTreeCreateNestedManyWithoutFatherInput
    mother?: FamilyTreeCreateNestedManyWithoutMotherInput
    wali?: FamilyTreeCreateNestedManyWithoutWaliInput
    couple?: FamilyTreeCreateNestedManyWithoutCoupleInput
    child?: FamilyTreeChildCreateNestedOneWithoutPersonalInput
    student?: StudentCreateNestedManyWithoutPersonalInput
  }

  export type PersonalUncheckedCreateWithoutTeacherInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign?: boolean | null
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email?: string | null
    belajarId?: string | null
    nophone?: string | null
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: boolean
    auth?: AuthUncheckedCreateNestedOneWithoutPersonalInput
    father?: FamilyTreeUncheckedCreateNestedManyWithoutFatherInput
    mother?: FamilyTreeUncheckedCreateNestedManyWithoutMotherInput
    wali?: FamilyTreeUncheckedCreateNestedManyWithoutWaliInput
    couple?: FamilyTreeUncheckedCreateNestedManyWithoutCoupleInput
    child?: FamilyTreeChildUncheckedCreateNestedOneWithoutPersonalInput
    student?: StudentUncheckedCreateNestedManyWithoutPersonalInput
  }

  export type PersonalCreateOrConnectWithoutTeacherInput = {
    where: PersonalWhereUniqueInput
    create: XOR<PersonalCreateWithoutTeacherInput, PersonalUncheckedCreateWithoutTeacherInput>
  }

  export type ClassRoomCreateWithoutWaliInput = {
    id?: string
    name: string
    level: number
    property?: XOR<RoomPropertyNullableCreateEnvelopeInput, RoomPropertyCreateInput> | null
    disable?: boolean
    year: SchoolYearCreateNestedOneWithoutClassRoomInput
    major?: KonsentrasiKeahlianCreateNestedOneWithoutClassRoomInput
    students?: StudentCreateNestedManyWithoutClassRoomInput
    event?: CalendarCreateNestedManyWithoutClassRoomInput
    tracker?: TrackerCreateNestedManyWithoutKelasInput
    teaching?: TeachingCreateNestedManyWithoutClassRoomInput
    tDevice?: TDeviceCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomUncheckedCreateWithoutWaliInput = {
    id?: string
    name: string
    yearId: string
    level: number
    property?: XOR<RoomPropertyNullableCreateEnvelopeInput, RoomPropertyCreateInput> | null
    majorId?: string | null
    studentIds?: ClassRoomCreatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomCreateeventIdsInput | Enumerable<string>
    disable?: boolean
    teachingIds?: ClassRoomCreateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomCreatetDeviceIdsInput | Enumerable<string>
    students?: StudentUncheckedCreateNestedManyWithoutClassRoomInput
    event?: CalendarUncheckedCreateNestedManyWithoutClassRoomInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutKelasInput
    teaching?: TeachingUncheckedCreateNestedManyWithoutClassRoomInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomCreateOrConnectWithoutWaliInput = {
    where: ClassRoomWhereUniqueInput
    create: XOR<ClassRoomCreateWithoutWaliInput, ClassRoomUncheckedCreateWithoutWaliInput>
  }

  export type ClassRoomCreateManyWaliInputEnvelope = {
    data: Enumerable<ClassRoomCreateManyWaliInput>
  }

  export type InstansiCreateWithoutTeacherInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    disable?: boolean
    majors?: KonsentrasiKeahlianCreateNestedManyWithoutInstansiInput
    role?: RoleCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearCreateNestedManyWithoutInstansiInput
    student?: StudentCreateNestedManyWithoutInstansiInput
    tracker?: TrackerCreateNestedManyWithoutInstansiInput
    history?: TrackerCreateNestedManyWithoutRefInput
    unikMapels?: MataPelajaranCreateNestedManyWithoutInstansiInput
    tDevice?: TDeviceCreateNestedManyWithoutInstansiInput
    objective?: ObjectiveCreateNestedManyWithoutInstansiInput
    dudi?: DudiCreateNestedManyWithoutInstansiInput
  }

  export type InstansiUncheckedCreateWithoutTeacherInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    majorIds?: InstansiCreatemajorIdsInput | Enumerable<string>
    disable?: boolean
    majors?: KonsentrasiKeahlianUncheckedCreateNestedManyWithoutInstansiInput
    role?: RoleUncheckedCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearUncheckedCreateNestedManyWithoutInstansiInput
    student?: StudentUncheckedCreateNestedManyWithoutInstansiInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutInstansiInput
    history?: TrackerUncheckedCreateNestedManyWithoutRefInput
    unikMapels?: MataPelajaranUncheckedCreateNestedManyWithoutInstansiInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutInstansiInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutInstansiInput
    dudi?: DudiUncheckedCreateNestedManyWithoutInstansiInput
  }

  export type InstansiCreateOrConnectWithoutTeacherInput = {
    where: InstansiWhereUniqueInput
    create: XOR<InstansiCreateWithoutTeacherInput, InstansiUncheckedCreateWithoutTeacherInput>
  }

  export type CalendarCreateWithoutTeacherInput = {
    id?: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    disable?: boolean
    ref: SchoolYearCreateNestedOneWithoutCalendarInput
    classRoom?: ClassRoomCreateNestedManyWithoutEventInput
    student?: StudentCreateNestedManyWithoutEventInput
    tracker?: TrackerCreateNestedManyWithoutKalenderInput
  }

  export type CalendarUncheckedCreateWithoutTeacherInput = {
    id?: string
    refId: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    classRoomIds?: CalendarCreateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarCreatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarCreateteacherIdsInput | Enumerable<string>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutEventInput
    student?: StudentUncheckedCreateNestedManyWithoutEventInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutKalenderInput
  }

  export type CalendarCreateOrConnectWithoutTeacherInput = {
    where: CalendarWhereUniqueInput
    create: XOR<CalendarCreateWithoutTeacherInput, CalendarUncheckedCreateWithoutTeacherInput>
  }

  export type TrackerCreateWithoutTeacherInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrackerInput
    ref: InstansiCreateNestedOneWithoutHistoryInput
    instansi?: InstansiCreateNestedOneWithoutTrackerInput
    mapel?: MataPelajaranCreateNestedOneWithoutTrackerInput
    elemen?: ElementCreateNestedOneWithoutTrackerInput
    cp?: AchievementCreateNestedOneWithoutTrackerInput
    bidang?: BidangKeahlianCreateNestedOneWithoutTrackerInput
    program?: ProgramKeahlianCreateNestedOneWithoutTrackerInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedOneWithoutTrackerInput
    tp?: SchoolYearCreateNestedOneWithoutTrackerInput
    kelas?: ClassRoomCreateNestedOneWithoutTrackerInput
    murid?: StudentCreateNestedOneWithoutTrackerInput
    jadwal?: ScheduleCreateNestedOneWithoutTrackerInput
    mengajar?: TeachingCreateNestedOneWithoutTrackerInput
    tujuan?: ObjectiveCreateNestedOneWithoutTrackerInput
    perangkat?: TDeviceCreateNestedOneWithoutTrackerInput
    kalender?: CalendarCreateNestedOneWithoutTrackerInput
    dudi?: DudiCreateNestedOneWithoutTrackerInput
    kkni?: KkniCreateNestedOneWithoutTrackerInput
  }

  export type TrackerUncheckedCreateWithoutTeacherInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TrackerCreateOrConnectWithoutTeacherInput = {
    where: TrackerWhereUniqueInput
    create: XOR<TrackerCreateWithoutTeacherInput, TrackerUncheckedCreateWithoutTeacherInput>
  }

  export type TrackerCreateManyTeacherInputEnvelope = {
    data: Enumerable<TrackerCreateManyTeacherInput>
  }

  export type TeachingCreateWithoutTeacherInput = {
    id?: string
    level: number
    hours: number
    semester: Semester
    disable?: boolean
    ref: ScheduleCreateNestedOneWithoutTeachingInput
    classRoom?: ClassRoomCreateNestedManyWithoutTeachingInput
    elemen?: ElementCreateNestedManyWithoutScheduleClassInput
    tracker?: TrackerCreateNestedManyWithoutMengajarInput
    tDevice?: TDeviceCreateNestedManyWithoutTeachingInput
  }

  export type TeachingUncheckedCreateWithoutTeacherInput = {
    id?: string
    refId: string
    level: number
    hours: number
    semester: Semester
    classRoomIds?: TeachingCreateclassRoomIdsInput | Enumerable<string>
    elemenIds?: TeachingCreateelemenIdsInput | Enumerable<string>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutTeachingInput
    elemen?: ElementUncheckedCreateNestedManyWithoutScheduleClassInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutMengajarInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutTeachingInput
  }

  export type TeachingCreateOrConnectWithoutTeacherInput = {
    where: TeachingWhereUniqueInput
    create: XOR<TeachingCreateWithoutTeacherInput, TeachingUncheckedCreateWithoutTeacherInput>
  }

  export type TeachingCreateManyTeacherInputEnvelope = {
    data: Enumerable<TeachingCreateManyTeacherInput>
  }

  export type PersonalUpsertWithoutTeacherInput = {
    update: XOR<PersonalUpdateWithoutTeacherInput, PersonalUncheckedUpdateWithoutTeacherInput>
    create: XOR<PersonalCreateWithoutTeacherInput, PersonalUncheckedCreateWithoutTeacherInput>
  }

  export type PersonalUpdateWithoutTeacherInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: NullableStringFieldUpdateOperationsInput | string | null
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: NullableStringFieldUpdateOperationsInput | string | null
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: BoolFieldUpdateOperationsInput | boolean
    auth?: AuthUpdateOneWithoutPersonalNestedInput
    father?: FamilyTreeUpdateManyWithoutFatherNestedInput
    mother?: FamilyTreeUpdateManyWithoutMotherNestedInput
    wali?: FamilyTreeUpdateManyWithoutWaliNestedInput
    couple?: FamilyTreeUpdateManyWithoutCoupleNestedInput
    child?: FamilyTreeChildUpdateOneWithoutPersonalNestedInput
    student?: StudentUpdateManyWithoutPersonalNestedInput
  }

  export type PersonalUncheckedUpdateWithoutTeacherInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: NullableStringFieldUpdateOperationsInput | string | null
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: NullableStringFieldUpdateOperationsInput | string | null
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: BoolFieldUpdateOperationsInput | boolean
    auth?: AuthUncheckedUpdateOneWithoutPersonalNestedInput
    father?: FamilyTreeUncheckedUpdateManyWithoutFatherNestedInput
    mother?: FamilyTreeUncheckedUpdateManyWithoutMotherNestedInput
    wali?: FamilyTreeUncheckedUpdateManyWithoutWaliNestedInput
    couple?: FamilyTreeUncheckedUpdateManyWithoutCoupleNestedInput
    child?: FamilyTreeChildUncheckedUpdateOneWithoutPersonalNestedInput
    student?: StudentUncheckedUpdateManyWithoutPersonalNestedInput
  }

  export type ClassRoomUpsertWithWhereUniqueWithoutWaliInput = {
    where: ClassRoomWhereUniqueInput
    update: XOR<ClassRoomUpdateWithoutWaliInput, ClassRoomUncheckedUpdateWithoutWaliInput>
    create: XOR<ClassRoomCreateWithoutWaliInput, ClassRoomUncheckedCreateWithoutWaliInput>
  }

  export type ClassRoomUpdateWithWhereUniqueWithoutWaliInput = {
    where: ClassRoomWhereUniqueInput
    data: XOR<ClassRoomUpdateWithoutWaliInput, ClassRoomUncheckedUpdateWithoutWaliInput>
  }

  export type ClassRoomUpdateManyWithWhereWithoutWaliInput = {
    where: ClassRoomScalarWhereInput
    data: XOR<ClassRoomUpdateManyMutationInput, ClassRoomUncheckedUpdateManyWithoutClassRoomInput>
  }

  export type InstansiUpsertWithoutTeacherInput = {
    update: XOR<InstansiUpdateWithoutTeacherInput, InstansiUncheckedUpdateWithoutTeacherInput>
    create: XOR<InstansiCreateWithoutTeacherInput, InstansiUncheckedCreateWithoutTeacherInput>
  }

  export type InstansiUpdateWithoutTeacherInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    majors?: KonsentrasiKeahlianUpdateManyWithoutInstansiNestedInput
    role?: RoleUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUpdateManyWithoutInstansiNestedInput
    student?: StudentUpdateManyWithoutInstansiNestedInput
    tracker?: TrackerUpdateManyWithoutInstansiNestedInput
    history?: TrackerUpdateManyWithoutRefNestedInput
    unikMapels?: MataPelajaranUpdateManyWithoutInstansiNestedInput
    tDevice?: TDeviceUpdateManyWithoutInstansiNestedInput
    objective?: ObjectiveUpdateManyWithoutInstansiNestedInput
    dudi?: DudiUpdateManyWithoutInstansiNestedInput
  }

  export type InstansiUncheckedUpdateWithoutTeacherInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    majorIds?: InstansiUpdatemajorIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    majors?: KonsentrasiKeahlianUncheckedUpdateManyWithoutInstansiNestedInput
    role?: RoleUncheckedUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUncheckedUpdateManyWithoutInstansiNestedInput
    student?: StudentUncheckedUpdateManyWithoutInstansiNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutInstansiNestedInput
    history?: TrackerUncheckedUpdateManyWithoutRefNestedInput
    unikMapels?: MataPelajaranUncheckedUpdateManyWithoutInstansiNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutInstansiNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutInstansiNestedInput
    dudi?: DudiUncheckedUpdateManyWithoutInstansiNestedInput
  }

  export type CalendarUpsertWithWhereUniqueWithoutTeacherInput = {
    where: CalendarWhereUniqueInput
    update: XOR<CalendarUpdateWithoutTeacherInput, CalendarUncheckedUpdateWithoutTeacherInput>
    create: XOR<CalendarCreateWithoutTeacherInput, CalendarUncheckedCreateWithoutTeacherInput>
  }

  export type CalendarUpdateWithWhereUniqueWithoutTeacherInput = {
    where: CalendarWhereUniqueInput
    data: XOR<CalendarUpdateWithoutTeacherInput, CalendarUncheckedUpdateWithoutTeacherInput>
  }

  export type CalendarUpdateManyWithWhereWithoutTeacherInput = {
    where: CalendarScalarWhereInput
    data: XOR<CalendarUpdateManyMutationInput, CalendarUncheckedUpdateManyWithoutEventInput>
  }

  export type TrackerUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TrackerWhereUniqueInput
    update: XOR<TrackerUpdateWithoutTeacherInput, TrackerUncheckedUpdateWithoutTeacherInput>
    create: XOR<TrackerCreateWithoutTeacherInput, TrackerUncheckedCreateWithoutTeacherInput>
  }

  export type TrackerUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TrackerWhereUniqueInput
    data: XOR<TrackerUpdateWithoutTeacherInput, TrackerUncheckedUpdateWithoutTeacherInput>
  }

  export type TrackerUpdateManyWithWhereWithoutTeacherInput = {
    where: TrackerScalarWhereInput
    data: XOR<TrackerUpdateManyMutationInput, TrackerUncheckedUpdateManyWithoutTrackerInput>
  }

  export type TeachingUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TeachingWhereUniqueInput
    update: XOR<TeachingUpdateWithoutTeacherInput, TeachingUncheckedUpdateWithoutTeacherInput>
    create: XOR<TeachingCreateWithoutTeacherInput, TeachingUncheckedCreateWithoutTeacherInput>
  }

  export type TeachingUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TeachingWhereUniqueInput
    data: XOR<TeachingUpdateWithoutTeacherInput, TeachingUncheckedUpdateWithoutTeacherInput>
  }

  export type TeachingUpdateManyWithWhereWithoutTeacherInput = {
    where: TeachingScalarWhereInput
    data: XOR<TeachingUpdateManyMutationInput, TeachingUncheckedUpdateManyWithoutTeachingInput>
  }

  export type SchoolYearCreateWithoutClassRoomInput = {
    id?: string
    year: number
    departments?: SchoolYearCreatedepartmentsInput | Enumerable<string>
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    disable?: boolean
    instansi: InstansiCreateNestedOneWithoutSchoolYearInput
    students?: StudentCreateNestedManyWithoutStartYearInput
    calendar?: CalendarCreateNestedManyWithoutRefInput
    schedule?: ScheduleCreateNestedManyWithoutYearInput
    objective?: ObjectiveCreateNestedManyWithoutYearInput
    tracker?: TrackerCreateNestedManyWithoutTpInput
    TDevice?: TDeviceCreateNestedManyWithoutYearInput
  }

  export type SchoolYearUncheckedCreateWithoutClassRoomInput = {
    id?: string
    year: number
    instansiId: string
    departments?: SchoolYearCreatedepartmentsInput | Enumerable<string>
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    disable?: boolean
    students?: StudentUncheckedCreateNestedManyWithoutStartYearInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutRefInput
    schedule?: ScheduleUncheckedCreateNestedManyWithoutYearInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutYearInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTpInput
    TDevice?: TDeviceUncheckedCreateNestedManyWithoutYearInput
  }

  export type SchoolYearCreateOrConnectWithoutClassRoomInput = {
    where: SchoolYearWhereUniqueInput
    create: XOR<SchoolYearCreateWithoutClassRoomInput, SchoolYearUncheckedCreateWithoutClassRoomInput>
  }

  export type TeacherCreateWithoutClassRoomInput = {
    id?: string
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: Date | string | null
    tmtGol?: Date | string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    disable?: boolean
    personal: PersonalCreateNestedOneWithoutTeacherInput
    instansi: InstansiCreateNestedOneWithoutTeacherInput
    event?: CalendarCreateNestedManyWithoutTeacherInput
    tracker?: TrackerCreateNestedManyWithoutTeacherInput
    teaching?: TeachingCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutClassRoomInput = {
    id?: string
    personalId: string
    instansiId: string
    eventIds?: TeacherCreateeventIdsInput | Enumerable<string>
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: Date | string | null
    tmtGol?: Date | string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    disable?: boolean
    event?: CalendarUncheckedCreateNestedManyWithoutTeacherInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTeacherInput
    teaching?: TeachingUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutClassRoomInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutClassRoomInput, TeacherUncheckedCreateWithoutClassRoomInput>
  }

  export type KonsentrasiKeahlianCreateWithoutClassRoomInput = {
    id?: string
    code: string
    name: string
    tahun: number
    disable?: boolean
    program: ProgramKeahlianCreateNestedOneWithoutKonsentrasiInput
    student?: StudentCreateNestedManyWithoutMajorInput
    instansi?: InstansiCreateNestedManyWithoutMajorsInput
    tracker?: TrackerCreateNestedManyWithoutKonsentrasiInput
    mapel?: MataPelajaranCreateNestedManyWithoutKeahlianInput
    dudi?: DudiCreateNestedManyWithoutMajorInput
    kkni?: KkniCreateNestedManyWithoutKonsentrasiInput
  }

  export type KonsentrasiKeahlianUncheckedCreateWithoutClassRoomInput = {
    id?: string
    code: string
    name: string
    programId: string
    tahun: number
    instansiIds?: KonsentrasiKeahlianCreateinstansiIdsInput | Enumerable<string>
    disable?: boolean
    student?: StudentUncheckedCreateNestedManyWithoutMajorInput
    instansi?: InstansiUncheckedCreateNestedManyWithoutMajorsInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutKonsentrasiInput
    mapel?: MataPelajaranUncheckedCreateNestedManyWithoutKeahlianInput
    dudi?: DudiUncheckedCreateNestedManyWithoutMajorInput
    kkni?: KkniUncheckedCreateNestedManyWithoutKonsentrasiInput
  }

  export type KonsentrasiKeahlianCreateOrConnectWithoutClassRoomInput = {
    where: KonsentrasiKeahlianWhereUniqueInput
    create: XOR<KonsentrasiKeahlianCreateWithoutClassRoomInput, KonsentrasiKeahlianUncheckedCreateWithoutClassRoomInput>
  }

  export type StudentCreateWithoutClassRoomInput = {
    id?: string
    nis: string
    lastSchool: string
    disable?: boolean
    personal: PersonalCreateNestedOneWithoutStudentInput
    major?: KonsentrasiKeahlianCreateNestedOneWithoutStudentInput
    startYear: SchoolYearCreateNestedOneWithoutStudentsInput
    instansi: InstansiCreateNestedOneWithoutStudentInput
    event?: CalendarCreateNestedManyWithoutStudentInput
    tracker?: TrackerCreateNestedManyWithoutMuridInput
  }

  export type StudentUncheckedCreateWithoutClassRoomInput = {
    id?: string
    nis: string
    lastSchool: string
    personalId: string
    majorId?: string | null
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    startYearId: string
    instansiId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
    disable?: boolean
    event?: CalendarUncheckedCreateNestedManyWithoutStudentInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutMuridInput
  }

  export type StudentCreateOrConnectWithoutClassRoomInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutClassRoomInput, StudentUncheckedCreateWithoutClassRoomInput>
  }

  export type CalendarCreateWithoutClassRoomInput = {
    id?: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    disable?: boolean
    ref: SchoolYearCreateNestedOneWithoutCalendarInput
    student?: StudentCreateNestedManyWithoutEventInput
    teacher?: TeacherCreateNestedManyWithoutEventInput
    tracker?: TrackerCreateNestedManyWithoutKalenderInput
  }

  export type CalendarUncheckedCreateWithoutClassRoomInput = {
    id?: string
    refId: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    classRoomIds?: CalendarCreateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarCreatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarCreateteacherIdsInput | Enumerable<string>
    disable?: boolean
    student?: StudentUncheckedCreateNestedManyWithoutEventInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutEventInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutKalenderInput
  }

  export type CalendarCreateOrConnectWithoutClassRoomInput = {
    where: CalendarWhereUniqueInput
    create: XOR<CalendarCreateWithoutClassRoomInput, CalendarUncheckedCreateWithoutClassRoomInput>
  }

  export type TrackerCreateWithoutKelasInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrackerInput
    ref: InstansiCreateNestedOneWithoutHistoryInput
    instansi?: InstansiCreateNestedOneWithoutTrackerInput
    mapel?: MataPelajaranCreateNestedOneWithoutTrackerInput
    elemen?: ElementCreateNestedOneWithoutTrackerInput
    cp?: AchievementCreateNestedOneWithoutTrackerInput
    bidang?: BidangKeahlianCreateNestedOneWithoutTrackerInput
    program?: ProgramKeahlianCreateNestedOneWithoutTrackerInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedOneWithoutTrackerInput
    tp?: SchoolYearCreateNestedOneWithoutTrackerInput
    teacher?: TeacherCreateNestedOneWithoutTrackerInput
    murid?: StudentCreateNestedOneWithoutTrackerInput
    jadwal?: ScheduleCreateNestedOneWithoutTrackerInput
    mengajar?: TeachingCreateNestedOneWithoutTrackerInput
    tujuan?: ObjectiveCreateNestedOneWithoutTrackerInput
    perangkat?: TDeviceCreateNestedOneWithoutTrackerInput
    kalender?: CalendarCreateNestedOneWithoutTrackerInput
    dudi?: DudiCreateNestedOneWithoutTrackerInput
    kkni?: KkniCreateNestedOneWithoutTrackerInput
  }

  export type TrackerUncheckedCreateWithoutKelasInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TrackerCreateOrConnectWithoutKelasInput = {
    where: TrackerWhereUniqueInput
    create: XOR<TrackerCreateWithoutKelasInput, TrackerUncheckedCreateWithoutKelasInput>
  }

  export type TrackerCreateManyKelasInputEnvelope = {
    data: Enumerable<TrackerCreateManyKelasInput>
  }

  export type TeachingCreateWithoutClassRoomInput = {
    id?: string
    level: number
    hours: number
    semester: Semester
    disable?: boolean
    ref: ScheduleCreateNestedOneWithoutTeachingInput
    teacher: TeacherCreateNestedOneWithoutTeachingInput
    elemen?: ElementCreateNestedManyWithoutScheduleClassInput
    tracker?: TrackerCreateNestedManyWithoutMengajarInput
    tDevice?: TDeviceCreateNestedManyWithoutTeachingInput
  }

  export type TeachingUncheckedCreateWithoutClassRoomInput = {
    id?: string
    refId: string
    level: number
    hours: number
    semester: Semester
    teacherId: string
    classRoomIds?: TeachingCreateclassRoomIdsInput | Enumerable<string>
    elemenIds?: TeachingCreateelemenIdsInput | Enumerable<string>
    disable?: boolean
    elemen?: ElementUncheckedCreateNestedManyWithoutScheduleClassInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutMengajarInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutTeachingInput
  }

  export type TeachingCreateOrConnectWithoutClassRoomInput = {
    where: TeachingWhereUniqueInput
    create: XOR<TeachingCreateWithoutClassRoomInput, TeachingUncheckedCreateWithoutClassRoomInput>
  }

  export type TDeviceCreateWithoutClassRoomInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    teaching: TeachingCreateNestedOneWithoutTDeviceInput
    year: SchoolYearCreateNestedOneWithoutTDeviceInput
    user: UserCreateNestedOneWithoutTDeviceInput
    instansi: InstansiCreateNestedOneWithoutTDeviceInput
    mapel: MataPelajaranCreateNestedOneWithoutDeviceInput
    tracker?: TrackerCreateNestedManyWithoutPerangkatInput
    data?: TDeviceDataCreateNestedManyWithoutRefInput
    children?: TDeviceCreateNestedManyWithoutParentInput
    parent?: TDeviceCreateNestedOneWithoutChildrenInput
  }

  export type TDeviceUncheckedCreateWithoutClassRoomInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    teachingId: string
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    yearId: string
    userId: string
    instansiId: string
    mapelId: string
    classRoomIds?: TDeviceCreateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    parentId?: string | null
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    tracker?: TrackerUncheckedCreateNestedManyWithoutPerangkatInput
    data?: TDeviceDataUncheckedCreateNestedManyWithoutRefInput
    children?: TDeviceUncheckedCreateNestedManyWithoutParentInput
  }

  export type TDeviceCreateOrConnectWithoutClassRoomInput = {
    where: TDeviceWhereUniqueInput
    create: XOR<TDeviceCreateWithoutClassRoomInput, TDeviceUncheckedCreateWithoutClassRoomInput>
  }

  export type RoomPropertyUpsertInput = {
    set: RoomPropertyCreateInput | null
    update: RoomPropertyUpdateInput
  }

  export type SchoolYearUpsertWithoutClassRoomInput = {
    update: XOR<SchoolYearUpdateWithoutClassRoomInput, SchoolYearUncheckedUpdateWithoutClassRoomInput>
    create: XOR<SchoolYearCreateWithoutClassRoomInput, SchoolYearUncheckedCreateWithoutClassRoomInput>
  }

  export type SchoolYearUpdateWithoutClassRoomInput = {
    year?: IntFieldUpdateOperationsInput | number
    departments?: SchoolYearUpdatedepartmentsInput | Enumerable<string>
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    instansi?: InstansiUpdateOneRequiredWithoutSchoolYearNestedInput
    students?: StudentUpdateManyWithoutStartYearNestedInput
    calendar?: CalendarUpdateManyWithoutRefNestedInput
    schedule?: ScheduleUpdateManyWithoutYearNestedInput
    objective?: ObjectiveUpdateManyWithoutYearNestedInput
    tracker?: TrackerUpdateManyWithoutTpNestedInput
    TDevice?: TDeviceUpdateManyWithoutYearNestedInput
  }

  export type SchoolYearUncheckedUpdateWithoutClassRoomInput = {
    year?: IntFieldUpdateOperationsInput | number
    instansiId?: StringFieldUpdateOperationsInput | string
    departments?: SchoolYearUpdatedepartmentsInput | Enumerable<string>
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    students?: StudentUncheckedUpdateManyWithoutStartYearNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutRefNestedInput
    schedule?: ScheduleUncheckedUpdateManyWithoutYearNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutYearNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTpNestedInput
    TDevice?: TDeviceUncheckedUpdateManyWithoutYearNestedInput
  }

  export type TeacherUpsertWithoutClassRoomInput = {
    update: XOR<TeacherUpdateWithoutClassRoomInput, TeacherUncheckedUpdateWithoutClassRoomInput>
    create: XOR<TeacherCreateWithoutClassRoomInput, TeacherUncheckedCreateWithoutClassRoomInput>
  }

  export type TeacherUpdateWithoutClassRoomInput = {
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tmtGol?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    personal?: PersonalUpdateOneRequiredWithoutTeacherNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutTeacherNestedInput
    event?: CalendarUpdateManyWithoutTeacherNestedInput
    tracker?: TrackerUpdateManyWithoutTeacherNestedInput
    teaching?: TeachingUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutClassRoomInput = {
    personalId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: TeacherUpdateeventIdsInput | Enumerable<string>
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tmtGol?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    event?: CalendarUncheckedUpdateManyWithoutTeacherNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTeacherNestedInput
    teaching?: TeachingUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type KonsentrasiKeahlianUpsertWithoutClassRoomInput = {
    update: XOR<KonsentrasiKeahlianUpdateWithoutClassRoomInput, KonsentrasiKeahlianUncheckedUpdateWithoutClassRoomInput>
    create: XOR<KonsentrasiKeahlianCreateWithoutClassRoomInput, KonsentrasiKeahlianUncheckedCreateWithoutClassRoomInput>
  }

  export type KonsentrasiKeahlianUpdateWithoutClassRoomInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    disable?: BoolFieldUpdateOperationsInput | boolean
    program?: ProgramKeahlianUpdateOneRequiredWithoutKonsentrasiNestedInput
    student?: StudentUpdateManyWithoutMajorNestedInput
    instansi?: InstansiUpdateManyWithoutMajorsNestedInput
    tracker?: TrackerUpdateManyWithoutKonsentrasiNestedInput
    mapel?: MataPelajaranUpdateManyWithoutKeahlianNestedInput
    dudi?: DudiUpdateManyWithoutMajorNestedInput
    kkni?: KkniUpdateManyWithoutKonsentrasiNestedInput
  }

  export type KonsentrasiKeahlianUncheckedUpdateWithoutClassRoomInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    instansiIds?: KonsentrasiKeahlianUpdateinstansiIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUncheckedUpdateManyWithoutMajorNestedInput
    instansi?: InstansiUncheckedUpdateManyWithoutMajorsNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutKonsentrasiNestedInput
    mapel?: MataPelajaranUncheckedUpdateManyWithoutKeahlianNestedInput
    dudi?: DudiUncheckedUpdateManyWithoutMajorNestedInput
    kkni?: KkniUncheckedUpdateManyWithoutKonsentrasiNestedInput
  }

  export type StudentUpsertWithWhereUniqueWithoutClassRoomInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutClassRoomInput, StudentUncheckedUpdateWithoutClassRoomInput>
    create: XOR<StudentCreateWithoutClassRoomInput, StudentUncheckedCreateWithoutClassRoomInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutClassRoomInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutClassRoomInput, StudentUncheckedUpdateWithoutClassRoomInput>
  }

  export type StudentUpdateManyWithWhereWithoutClassRoomInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutStudentsInput>
  }

  export type CalendarUpsertWithWhereUniqueWithoutClassRoomInput = {
    where: CalendarWhereUniqueInput
    update: XOR<CalendarUpdateWithoutClassRoomInput, CalendarUncheckedUpdateWithoutClassRoomInput>
    create: XOR<CalendarCreateWithoutClassRoomInput, CalendarUncheckedCreateWithoutClassRoomInput>
  }

  export type CalendarUpdateWithWhereUniqueWithoutClassRoomInput = {
    where: CalendarWhereUniqueInput
    data: XOR<CalendarUpdateWithoutClassRoomInput, CalendarUncheckedUpdateWithoutClassRoomInput>
  }

  export type CalendarUpdateManyWithWhereWithoutClassRoomInput = {
    where: CalendarScalarWhereInput
    data: XOR<CalendarUpdateManyMutationInput, CalendarUncheckedUpdateManyWithoutEventInput>
  }

  export type TrackerUpsertWithWhereUniqueWithoutKelasInput = {
    where: TrackerWhereUniqueInput
    update: XOR<TrackerUpdateWithoutKelasInput, TrackerUncheckedUpdateWithoutKelasInput>
    create: XOR<TrackerCreateWithoutKelasInput, TrackerUncheckedCreateWithoutKelasInput>
  }

  export type TrackerUpdateWithWhereUniqueWithoutKelasInput = {
    where: TrackerWhereUniqueInput
    data: XOR<TrackerUpdateWithoutKelasInput, TrackerUncheckedUpdateWithoutKelasInput>
  }

  export type TrackerUpdateManyWithWhereWithoutKelasInput = {
    where: TrackerScalarWhereInput
    data: XOR<TrackerUpdateManyMutationInput, TrackerUncheckedUpdateManyWithoutTrackerInput>
  }

  export type TeachingUpsertWithWhereUniqueWithoutClassRoomInput = {
    where: TeachingWhereUniqueInput
    update: XOR<TeachingUpdateWithoutClassRoomInput, TeachingUncheckedUpdateWithoutClassRoomInput>
    create: XOR<TeachingCreateWithoutClassRoomInput, TeachingUncheckedCreateWithoutClassRoomInput>
  }

  export type TeachingUpdateWithWhereUniqueWithoutClassRoomInput = {
    where: TeachingWhereUniqueInput
    data: XOR<TeachingUpdateWithoutClassRoomInput, TeachingUncheckedUpdateWithoutClassRoomInput>
  }

  export type TeachingUpdateManyWithWhereWithoutClassRoomInput = {
    where: TeachingScalarWhereInput
    data: XOR<TeachingUpdateManyMutationInput, TeachingUncheckedUpdateManyWithoutTeachingInput>
  }

  export type TDeviceUpsertWithWhereUniqueWithoutClassRoomInput = {
    where: TDeviceWhereUniqueInput
    update: XOR<TDeviceUpdateWithoutClassRoomInput, TDeviceUncheckedUpdateWithoutClassRoomInput>
    create: XOR<TDeviceCreateWithoutClassRoomInput, TDeviceUncheckedCreateWithoutClassRoomInput>
  }

  export type TDeviceUpdateWithWhereUniqueWithoutClassRoomInput = {
    where: TDeviceWhereUniqueInput
    data: XOR<TDeviceUpdateWithoutClassRoomInput, TDeviceUncheckedUpdateWithoutClassRoomInput>
  }

  export type TDeviceUpdateManyWithWhereWithoutClassRoomInput = {
    where: TDeviceScalarWhereInput
    data: XOR<TDeviceUpdateManyMutationInput, TDeviceUncheckedUpdateManyWithoutTDeviceInput>
  }

  export type PersonalCreateWithoutStudentInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign?: boolean | null
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email?: string | null
    belajarId?: string | null
    nophone?: string | null
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: boolean
    auth?: AuthCreateNestedOneWithoutPersonalInput
    father?: FamilyTreeCreateNestedManyWithoutFatherInput
    mother?: FamilyTreeCreateNestedManyWithoutMotherInput
    wali?: FamilyTreeCreateNestedManyWithoutWaliInput
    couple?: FamilyTreeCreateNestedManyWithoutCoupleInput
    child?: FamilyTreeChildCreateNestedOneWithoutPersonalInput
    teacher?: TeacherCreateNestedManyWithoutPersonalInput
  }

  export type PersonalUncheckedCreateWithoutStudentInput = {
    id?: string
    nik?: string | null
    nisn?: string | null
    type: TypePersonal
    fullname: string
    gender: Gender
    foreign?: boolean | null
    country?: string | null
    religion: Religion
    born: XOR<BornCreateEnvelopeInput, BornCreateInput>
    email?: string | null
    belajarId?: string | null
    nophone?: string | null
    isLife?: boolean | null
    address?: XOR<AddressNullableCreateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListCreateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListCreateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListCreateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListCreateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListCreateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListCreateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListCreateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListCreateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListCreateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListCreateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListCreateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListCreateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListCreateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListCreateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: boolean
    auth?: AuthUncheckedCreateNestedOneWithoutPersonalInput
    father?: FamilyTreeUncheckedCreateNestedManyWithoutFatherInput
    mother?: FamilyTreeUncheckedCreateNestedManyWithoutMotherInput
    wali?: FamilyTreeUncheckedCreateNestedManyWithoutWaliInput
    couple?: FamilyTreeUncheckedCreateNestedManyWithoutCoupleInput
    child?: FamilyTreeChildUncheckedCreateNestedOneWithoutPersonalInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutPersonalInput
  }

  export type PersonalCreateOrConnectWithoutStudentInput = {
    where: PersonalWhereUniqueInput
    create: XOR<PersonalCreateWithoutStudentInput, PersonalUncheckedCreateWithoutStudentInput>
  }

  export type KonsentrasiKeahlianCreateWithoutStudentInput = {
    id?: string
    code: string
    name: string
    tahun: number
    disable?: boolean
    program: ProgramKeahlianCreateNestedOneWithoutKonsentrasiInput
    instansi?: InstansiCreateNestedManyWithoutMajorsInput
    classRoom?: ClassRoomCreateNestedManyWithoutMajorInput
    tracker?: TrackerCreateNestedManyWithoutKonsentrasiInput
    mapel?: MataPelajaranCreateNestedManyWithoutKeahlianInput
    dudi?: DudiCreateNestedManyWithoutMajorInput
    kkni?: KkniCreateNestedManyWithoutKonsentrasiInput
  }

  export type KonsentrasiKeahlianUncheckedCreateWithoutStudentInput = {
    id?: string
    code: string
    name: string
    programId: string
    tahun: number
    instansiIds?: KonsentrasiKeahlianCreateinstansiIdsInput | Enumerable<string>
    disable?: boolean
    instansi?: InstansiUncheckedCreateNestedManyWithoutMajorsInput
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutMajorInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutKonsentrasiInput
    mapel?: MataPelajaranUncheckedCreateNestedManyWithoutKeahlianInput
    dudi?: DudiUncheckedCreateNestedManyWithoutMajorInput
    kkni?: KkniUncheckedCreateNestedManyWithoutKonsentrasiInput
  }

  export type KonsentrasiKeahlianCreateOrConnectWithoutStudentInput = {
    where: KonsentrasiKeahlianWhereUniqueInput
    create: XOR<KonsentrasiKeahlianCreateWithoutStudentInput, KonsentrasiKeahlianUncheckedCreateWithoutStudentInput>
  }

  export type ClassRoomCreateWithoutStudentsInput = {
    id?: string
    name: string
    level: number
    property?: XOR<RoomPropertyNullableCreateEnvelopeInput, RoomPropertyCreateInput> | null
    disable?: boolean
    year: SchoolYearCreateNestedOneWithoutClassRoomInput
    wali: TeacherCreateNestedOneWithoutClassRoomInput
    major?: KonsentrasiKeahlianCreateNestedOneWithoutClassRoomInput
    event?: CalendarCreateNestedManyWithoutClassRoomInput
    tracker?: TrackerCreateNestedManyWithoutKelasInput
    teaching?: TeachingCreateNestedManyWithoutClassRoomInput
    tDevice?: TDeviceCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    yearId: string
    waliId: string
    level: number
    property?: XOR<RoomPropertyNullableCreateEnvelopeInput, RoomPropertyCreateInput> | null
    majorId?: string | null
    studentIds?: ClassRoomCreatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomCreateeventIdsInput | Enumerable<string>
    disable?: boolean
    teachingIds?: ClassRoomCreateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomCreatetDeviceIdsInput | Enumerable<string>
    event?: CalendarUncheckedCreateNestedManyWithoutClassRoomInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutKelasInput
    teaching?: TeachingUncheckedCreateNestedManyWithoutClassRoomInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomCreateOrConnectWithoutStudentsInput = {
    where: ClassRoomWhereUniqueInput
    create: XOR<ClassRoomCreateWithoutStudentsInput, ClassRoomUncheckedCreateWithoutStudentsInput>
  }

  export type SchoolYearCreateWithoutStudentsInput = {
    id?: string
    year: number
    departments?: SchoolYearCreatedepartmentsInput | Enumerable<string>
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    disable?: boolean
    instansi: InstansiCreateNestedOneWithoutSchoolYearInput
    classRoom?: ClassRoomCreateNestedManyWithoutYearInput
    calendar?: CalendarCreateNestedManyWithoutRefInput
    schedule?: ScheduleCreateNestedManyWithoutYearInput
    objective?: ObjectiveCreateNestedManyWithoutYearInput
    tracker?: TrackerCreateNestedManyWithoutTpInput
    TDevice?: TDeviceCreateNestedManyWithoutYearInput
  }

  export type SchoolYearUncheckedCreateWithoutStudentsInput = {
    id?: string
    year: number
    instansiId: string
    departments?: SchoolYearCreatedepartmentsInput | Enumerable<string>
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutYearInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutRefInput
    schedule?: ScheduleUncheckedCreateNestedManyWithoutYearInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutYearInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTpInput
    TDevice?: TDeviceUncheckedCreateNestedManyWithoutYearInput
  }

  export type SchoolYearCreateOrConnectWithoutStudentsInput = {
    where: SchoolYearWhereUniqueInput
    create: XOR<SchoolYearCreateWithoutStudentsInput, SchoolYearUncheckedCreateWithoutStudentsInput>
  }

  export type InstansiCreateWithoutStudentInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    disable?: boolean
    majors?: KonsentrasiKeahlianCreateNestedManyWithoutInstansiInput
    role?: RoleCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearCreateNestedManyWithoutInstansiInput
    teacher?: TeacherCreateNestedManyWithoutInstansiInput
    tracker?: TrackerCreateNestedManyWithoutInstansiInput
    history?: TrackerCreateNestedManyWithoutRefInput
    unikMapels?: MataPelajaranCreateNestedManyWithoutInstansiInput
    tDevice?: TDeviceCreateNestedManyWithoutInstansiInput
    objective?: ObjectiveCreateNestedManyWithoutInstansiInput
    dudi?: DudiCreateNestedManyWithoutInstansiInput
  }

  export type InstansiUncheckedCreateWithoutStudentInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    majorIds?: InstansiCreatemajorIdsInput | Enumerable<string>
    disable?: boolean
    majors?: KonsentrasiKeahlianUncheckedCreateNestedManyWithoutInstansiInput
    role?: RoleUncheckedCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearUncheckedCreateNestedManyWithoutInstansiInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutInstansiInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutInstansiInput
    history?: TrackerUncheckedCreateNestedManyWithoutRefInput
    unikMapels?: MataPelajaranUncheckedCreateNestedManyWithoutInstansiInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutInstansiInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutInstansiInput
    dudi?: DudiUncheckedCreateNestedManyWithoutInstansiInput
  }

  export type InstansiCreateOrConnectWithoutStudentInput = {
    where: InstansiWhereUniqueInput
    create: XOR<InstansiCreateWithoutStudentInput, InstansiUncheckedCreateWithoutStudentInput>
  }

  export type CalendarCreateWithoutStudentInput = {
    id?: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    disable?: boolean
    ref: SchoolYearCreateNestedOneWithoutCalendarInput
    classRoom?: ClassRoomCreateNestedManyWithoutEventInput
    teacher?: TeacherCreateNestedManyWithoutEventInput
    tracker?: TrackerCreateNestedManyWithoutKalenderInput
  }

  export type CalendarUncheckedCreateWithoutStudentInput = {
    id?: string
    refId: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    classRoomIds?: CalendarCreateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarCreatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarCreateteacherIdsInput | Enumerable<string>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutEventInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutEventInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutKalenderInput
  }

  export type CalendarCreateOrConnectWithoutStudentInput = {
    where: CalendarWhereUniqueInput
    create: XOR<CalendarCreateWithoutStudentInput, CalendarUncheckedCreateWithoutStudentInput>
  }

  export type TrackerCreateWithoutMuridInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrackerInput
    ref: InstansiCreateNestedOneWithoutHistoryInput
    instansi?: InstansiCreateNestedOneWithoutTrackerInput
    mapel?: MataPelajaranCreateNestedOneWithoutTrackerInput
    elemen?: ElementCreateNestedOneWithoutTrackerInput
    cp?: AchievementCreateNestedOneWithoutTrackerInput
    bidang?: BidangKeahlianCreateNestedOneWithoutTrackerInput
    program?: ProgramKeahlianCreateNestedOneWithoutTrackerInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedOneWithoutTrackerInput
    tp?: SchoolYearCreateNestedOneWithoutTrackerInput
    teacher?: TeacherCreateNestedOneWithoutTrackerInput
    kelas?: ClassRoomCreateNestedOneWithoutTrackerInput
    jadwal?: ScheduleCreateNestedOneWithoutTrackerInput
    mengajar?: TeachingCreateNestedOneWithoutTrackerInput
    tujuan?: ObjectiveCreateNestedOneWithoutTrackerInput
    perangkat?: TDeviceCreateNestedOneWithoutTrackerInput
    kalender?: CalendarCreateNestedOneWithoutTrackerInput
    dudi?: DudiCreateNestedOneWithoutTrackerInput
    kkni?: KkniCreateNestedOneWithoutTrackerInput
  }

  export type TrackerUncheckedCreateWithoutMuridInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TrackerCreateOrConnectWithoutMuridInput = {
    where: TrackerWhereUniqueInput
    create: XOR<TrackerCreateWithoutMuridInput, TrackerUncheckedCreateWithoutMuridInput>
  }

  export type TrackerCreateManyMuridInputEnvelope = {
    data: Enumerable<TrackerCreateManyMuridInput>
  }

  export type PersonalUpsertWithoutStudentInput = {
    update: XOR<PersonalUpdateWithoutStudentInput, PersonalUncheckedUpdateWithoutStudentInput>
    create: XOR<PersonalCreateWithoutStudentInput, PersonalUncheckedCreateWithoutStudentInput>
  }

  export type PersonalUpdateWithoutStudentInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: NullableStringFieldUpdateOperationsInput | string | null
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: NullableStringFieldUpdateOperationsInput | string | null
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: BoolFieldUpdateOperationsInput | boolean
    auth?: AuthUpdateOneWithoutPersonalNestedInput
    father?: FamilyTreeUpdateManyWithoutFatherNestedInput
    mother?: FamilyTreeUpdateManyWithoutMotherNestedInput
    wali?: FamilyTreeUpdateManyWithoutWaliNestedInput
    couple?: FamilyTreeUpdateManyWithoutCoupleNestedInput
    child?: FamilyTreeChildUpdateOneWithoutPersonalNestedInput
    teacher?: TeacherUpdateManyWithoutPersonalNestedInput
  }

  export type PersonalUncheckedUpdateWithoutStudentInput = {
    nik?: NullableStringFieldUpdateOperationsInput | string | null
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTypePersonalFieldUpdateOperationsInput | TypePersonal
    fullname?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | Gender
    foreign?: NullableBoolFieldUpdateOperationsInput | boolean | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: EnumReligionFieldUpdateOperationsInput | Religion
    born?: XOR<BornUpdateEnvelopeInput, BornCreateInput>
    email?: NullableStringFieldUpdateOperationsInput | string | null
    belajarId?: NullableStringFieldUpdateOperationsInput | string | null
    nophone?: NullableStringFieldUpdateOperationsInput | string | null
    isLife?: NullableBoolFieldUpdateOperationsInput | boolean | null
    address?: XOR<AddressNullableUpdateEnvelopeInput, AddressCreateInput> | null
    education?: XOR<EducationListUpdateEnvelopeInput, Enumerable<EducationCreateInput>>
    training?: XOR<TrainingListUpdateEnvelopeInput, Enumerable<TrainingCreateInput>>
    employment?: XOR<EmploymentListUpdateEnvelopeInput, Enumerable<EmploymentCreateInput>>
    profession?: XOR<ProfessionListUpdateEnvelopeInput, Enumerable<ProfessionCreateInput>>
    overseas?: XOR<OverseasListUpdateEnvelopeInput, Enumerable<OverseasCreateInput>>
    scientific?: XOR<ScientificListUpdateEnvelopeInput, Enumerable<ScientificCreateInput>>
    organization?: XOR<OrganizationListUpdateEnvelopeInput, Enumerable<OrganizationCreateInput>>
    papers?: XOR<PapersListUpdateEnvelopeInput, Enumerable<PapersCreateInput>>
    innovation?: XOR<InnovationListUpdateEnvelopeInput, Enumerable<InnovationCreateInput>>
    award?: XOR<AwardListUpdateEnvelopeInput, Enumerable<AwardCreateInput>>
    sourcePerson?: XOR<SourcePersonListUpdateEnvelopeInput, Enumerable<SourcePersonCreateInput>>
    contest?: XOR<ContestListUpdateEnvelopeInput, Enumerable<ContestCreateInput>>
    documents?: XOR<DocumentsListUpdateEnvelopeInput, Enumerable<DocumentsCreateInput>>
    additional?: XOR<AdditionalListUpdateEnvelopeInput, Enumerable<AdditionalCreateInput>>
    disable?: BoolFieldUpdateOperationsInput | boolean
    auth?: AuthUncheckedUpdateOneWithoutPersonalNestedInput
    father?: FamilyTreeUncheckedUpdateManyWithoutFatherNestedInput
    mother?: FamilyTreeUncheckedUpdateManyWithoutMotherNestedInput
    wali?: FamilyTreeUncheckedUpdateManyWithoutWaliNestedInput
    couple?: FamilyTreeUncheckedUpdateManyWithoutCoupleNestedInput
    child?: FamilyTreeChildUncheckedUpdateOneWithoutPersonalNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutPersonalNestedInput
  }

  export type KonsentrasiKeahlianUpsertWithoutStudentInput = {
    update: XOR<KonsentrasiKeahlianUpdateWithoutStudentInput, KonsentrasiKeahlianUncheckedUpdateWithoutStudentInput>
    create: XOR<KonsentrasiKeahlianCreateWithoutStudentInput, KonsentrasiKeahlianUncheckedCreateWithoutStudentInput>
  }

  export type KonsentrasiKeahlianUpdateWithoutStudentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    disable?: BoolFieldUpdateOperationsInput | boolean
    program?: ProgramKeahlianUpdateOneRequiredWithoutKonsentrasiNestedInput
    instansi?: InstansiUpdateManyWithoutMajorsNestedInput
    classRoom?: ClassRoomUpdateManyWithoutMajorNestedInput
    tracker?: TrackerUpdateManyWithoutKonsentrasiNestedInput
    mapel?: MataPelajaranUpdateManyWithoutKeahlianNestedInput
    dudi?: DudiUpdateManyWithoutMajorNestedInput
    kkni?: KkniUpdateManyWithoutKonsentrasiNestedInput
  }

  export type KonsentrasiKeahlianUncheckedUpdateWithoutStudentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    instansiIds?: KonsentrasiKeahlianUpdateinstansiIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    instansi?: InstansiUncheckedUpdateManyWithoutMajorsNestedInput
    classRoom?: ClassRoomUncheckedUpdateManyWithoutMajorNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutKonsentrasiNestedInput
    mapel?: MataPelajaranUncheckedUpdateManyWithoutKeahlianNestedInput
    dudi?: DudiUncheckedUpdateManyWithoutMajorNestedInput
    kkni?: KkniUncheckedUpdateManyWithoutKonsentrasiNestedInput
  }

  export type ClassRoomUpsertWithWhereUniqueWithoutStudentsInput = {
    where: ClassRoomWhereUniqueInput
    update: XOR<ClassRoomUpdateWithoutStudentsInput, ClassRoomUncheckedUpdateWithoutStudentsInput>
    create: XOR<ClassRoomCreateWithoutStudentsInput, ClassRoomUncheckedCreateWithoutStudentsInput>
  }

  export type ClassRoomUpdateWithWhereUniqueWithoutStudentsInput = {
    where: ClassRoomWhereUniqueInput
    data: XOR<ClassRoomUpdateWithoutStudentsInput, ClassRoomUncheckedUpdateWithoutStudentsInput>
  }

  export type ClassRoomUpdateManyWithWhereWithoutStudentsInput = {
    where: ClassRoomScalarWhereInput
    data: XOR<ClassRoomUpdateManyMutationInput, ClassRoomUncheckedUpdateManyWithoutClassRoomInput>
  }

  export type SchoolYearUpsertWithoutStudentsInput = {
    update: XOR<SchoolYearUpdateWithoutStudentsInput, SchoolYearUncheckedUpdateWithoutStudentsInput>
    create: XOR<SchoolYearCreateWithoutStudentsInput, SchoolYearUncheckedCreateWithoutStudentsInput>
  }

  export type SchoolYearUpdateWithoutStudentsInput = {
    year?: IntFieldUpdateOperationsInput | number
    departments?: SchoolYearUpdatedepartmentsInput | Enumerable<string>
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    instansi?: InstansiUpdateOneRequiredWithoutSchoolYearNestedInput
    classRoom?: ClassRoomUpdateManyWithoutYearNestedInput
    calendar?: CalendarUpdateManyWithoutRefNestedInput
    schedule?: ScheduleUpdateManyWithoutYearNestedInput
    objective?: ObjectiveUpdateManyWithoutYearNestedInput
    tracker?: TrackerUpdateManyWithoutTpNestedInput
    TDevice?: TDeviceUpdateManyWithoutYearNestedInput
  }

  export type SchoolYearUncheckedUpdateWithoutStudentsInput = {
    year?: IntFieldUpdateOperationsInput | number
    instansiId?: StringFieldUpdateOperationsInput | string
    departments?: SchoolYearUpdatedepartmentsInput | Enumerable<string>
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutYearNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutRefNestedInput
    schedule?: ScheduleUncheckedUpdateManyWithoutYearNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutYearNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTpNestedInput
    TDevice?: TDeviceUncheckedUpdateManyWithoutYearNestedInput
  }

  export type InstansiUpsertWithoutStudentInput = {
    update: XOR<InstansiUpdateWithoutStudentInput, InstansiUncheckedUpdateWithoutStudentInput>
    create: XOR<InstansiCreateWithoutStudentInput, InstansiUncheckedCreateWithoutStudentInput>
  }

  export type InstansiUpdateWithoutStudentInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    majors?: KonsentrasiKeahlianUpdateManyWithoutInstansiNestedInput
    role?: RoleUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUpdateManyWithoutInstansiNestedInput
    tracker?: TrackerUpdateManyWithoutInstansiNestedInput
    history?: TrackerUpdateManyWithoutRefNestedInput
    unikMapels?: MataPelajaranUpdateManyWithoutInstansiNestedInput
    tDevice?: TDeviceUpdateManyWithoutInstansiNestedInput
    objective?: ObjectiveUpdateManyWithoutInstansiNestedInput
    dudi?: DudiUpdateManyWithoutInstansiNestedInput
  }

  export type InstansiUncheckedUpdateWithoutStudentInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    majorIds?: InstansiUpdatemajorIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    majors?: KonsentrasiKeahlianUncheckedUpdateManyWithoutInstansiNestedInput
    role?: RoleUncheckedUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUncheckedUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutInstansiNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutInstansiNestedInput
    history?: TrackerUncheckedUpdateManyWithoutRefNestedInput
    unikMapels?: MataPelajaranUncheckedUpdateManyWithoutInstansiNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutInstansiNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutInstansiNestedInput
    dudi?: DudiUncheckedUpdateManyWithoutInstansiNestedInput
  }

  export type CalendarUpsertWithWhereUniqueWithoutStudentInput = {
    where: CalendarWhereUniqueInput
    update: XOR<CalendarUpdateWithoutStudentInput, CalendarUncheckedUpdateWithoutStudentInput>
    create: XOR<CalendarCreateWithoutStudentInput, CalendarUncheckedCreateWithoutStudentInput>
  }

  export type CalendarUpdateWithWhereUniqueWithoutStudentInput = {
    where: CalendarWhereUniqueInput
    data: XOR<CalendarUpdateWithoutStudentInput, CalendarUncheckedUpdateWithoutStudentInput>
  }

  export type CalendarUpdateManyWithWhereWithoutStudentInput = {
    where: CalendarScalarWhereInput
    data: XOR<CalendarUpdateManyMutationInput, CalendarUncheckedUpdateManyWithoutEventInput>
  }

  export type TrackerUpsertWithWhereUniqueWithoutMuridInput = {
    where: TrackerWhereUniqueInput
    update: XOR<TrackerUpdateWithoutMuridInput, TrackerUncheckedUpdateWithoutMuridInput>
    create: XOR<TrackerCreateWithoutMuridInput, TrackerUncheckedCreateWithoutMuridInput>
  }

  export type TrackerUpdateWithWhereUniqueWithoutMuridInput = {
    where: TrackerWhereUniqueInput
    data: XOR<TrackerUpdateWithoutMuridInput, TrackerUncheckedUpdateWithoutMuridInput>
  }

  export type TrackerUpdateManyWithWhereWithoutMuridInput = {
    where: TrackerScalarWhereInput
    data: XOR<TrackerUpdateManyMutationInput, TrackerUncheckedUpdateManyWithoutTrackerInput>
  }

  export type SchoolYearCreateWithoutScheduleInput = {
    id?: string
    year: number
    departments?: SchoolYearCreatedepartmentsInput | Enumerable<string>
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    disable?: boolean
    instansi: InstansiCreateNestedOneWithoutSchoolYearInput
    classRoom?: ClassRoomCreateNestedManyWithoutYearInput
    students?: StudentCreateNestedManyWithoutStartYearInput
    calendar?: CalendarCreateNestedManyWithoutRefInput
    objective?: ObjectiveCreateNestedManyWithoutYearInput
    tracker?: TrackerCreateNestedManyWithoutTpInput
    TDevice?: TDeviceCreateNestedManyWithoutYearInput
  }

  export type SchoolYearUncheckedCreateWithoutScheduleInput = {
    id?: string
    year: number
    instansiId: string
    departments?: SchoolYearCreatedepartmentsInput | Enumerable<string>
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutYearInput
    students?: StudentUncheckedCreateNestedManyWithoutStartYearInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutRefInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutYearInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTpInput
    TDevice?: TDeviceUncheckedCreateNestedManyWithoutYearInput
  }

  export type SchoolYearCreateOrConnectWithoutScheduleInput = {
    where: SchoolYearWhereUniqueInput
    create: XOR<SchoolYearCreateWithoutScheduleInput, SchoolYearUncheckedCreateWithoutScheduleInput>
  }

  export type MataPelajaranCreateWithoutScheduleInput = {
    id?: string
    level?: Level | null
    type?: MataPelajaranType
    no: string
    code: string
    name: string
    religion?: Religion | null
    disable?: boolean
    program?: ProgramKeahlianCreateNestedOneWithoutMapelInput
    keahlian?: KonsentrasiKeahlianCreateNestedOneWithoutMapelInput
    instansi?: InstansiCreateNestedOneWithoutUnikMapelsInput
    element?: ElementCreateNestedManyWithoutMapelInput
    tracker?: TrackerCreateNestedManyWithoutMapelInput
    objective?: ObjectiveCreateNestedManyWithoutMapelInput
    device?: TDeviceCreateNestedManyWithoutMapelInput
  }

  export type MataPelajaranUncheckedCreateWithoutScheduleInput = {
    id?: string
    level?: Level | null
    type?: MataPelajaranType
    no: string
    code: string
    name: string
    religion?: Religion | null
    programId?: string | null
    keahlianid?: string | null
    instansiId?: string | null
    disable?: boolean
    element?: ElementUncheckedCreateNestedManyWithoutMapelInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutMapelInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutMapelInput
    device?: TDeviceUncheckedCreateNestedManyWithoutMapelInput
  }

  export type MataPelajaranCreateOrConnectWithoutScheduleInput = {
    where: MataPelajaranWhereUniqueInput
    create: XOR<MataPelajaranCreateWithoutScheduleInput, MataPelajaranUncheckedCreateWithoutScheduleInput>
  }

  export type TrackerCreateWithoutJadwalInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrackerInput
    ref: InstansiCreateNestedOneWithoutHistoryInput
    instansi?: InstansiCreateNestedOneWithoutTrackerInput
    mapel?: MataPelajaranCreateNestedOneWithoutTrackerInput
    elemen?: ElementCreateNestedOneWithoutTrackerInput
    cp?: AchievementCreateNestedOneWithoutTrackerInput
    bidang?: BidangKeahlianCreateNestedOneWithoutTrackerInput
    program?: ProgramKeahlianCreateNestedOneWithoutTrackerInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedOneWithoutTrackerInput
    tp?: SchoolYearCreateNestedOneWithoutTrackerInput
    teacher?: TeacherCreateNestedOneWithoutTrackerInput
    kelas?: ClassRoomCreateNestedOneWithoutTrackerInput
    murid?: StudentCreateNestedOneWithoutTrackerInput
    mengajar?: TeachingCreateNestedOneWithoutTrackerInput
    tujuan?: ObjectiveCreateNestedOneWithoutTrackerInput
    perangkat?: TDeviceCreateNestedOneWithoutTrackerInput
    kalender?: CalendarCreateNestedOneWithoutTrackerInput
    dudi?: DudiCreateNestedOneWithoutTrackerInput
    kkni?: KkniCreateNestedOneWithoutTrackerInput
  }

  export type TrackerUncheckedCreateWithoutJadwalInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TrackerCreateOrConnectWithoutJadwalInput = {
    where: TrackerWhereUniqueInput
    create: XOR<TrackerCreateWithoutJadwalInput, TrackerUncheckedCreateWithoutJadwalInput>
  }

  export type TrackerCreateManyJadwalInputEnvelope = {
    data: Enumerable<TrackerCreateManyJadwalInput>
  }

  export type TeachingCreateWithoutRefInput = {
    id?: string
    level: number
    hours: number
    semester: Semester
    disable?: boolean
    teacher: TeacherCreateNestedOneWithoutTeachingInput
    classRoom?: ClassRoomCreateNestedManyWithoutTeachingInput
    elemen?: ElementCreateNestedManyWithoutScheduleClassInput
    tracker?: TrackerCreateNestedManyWithoutMengajarInput
    tDevice?: TDeviceCreateNestedManyWithoutTeachingInput
  }

  export type TeachingUncheckedCreateWithoutRefInput = {
    id?: string
    level: number
    hours: number
    semester: Semester
    teacherId: string
    classRoomIds?: TeachingCreateclassRoomIdsInput | Enumerable<string>
    elemenIds?: TeachingCreateelemenIdsInput | Enumerable<string>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutTeachingInput
    elemen?: ElementUncheckedCreateNestedManyWithoutScheduleClassInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutMengajarInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutTeachingInput
  }

  export type TeachingCreateOrConnectWithoutRefInput = {
    where: TeachingWhereUniqueInput
    create: XOR<TeachingCreateWithoutRefInput, TeachingUncheckedCreateWithoutRefInput>
  }

  export type TeachingCreateManyRefInputEnvelope = {
    data: Enumerable<TeachingCreateManyRefInput>
  }

  export type SchoolYearUpsertWithoutScheduleInput = {
    update: XOR<SchoolYearUpdateWithoutScheduleInput, SchoolYearUncheckedUpdateWithoutScheduleInput>
    create: XOR<SchoolYearCreateWithoutScheduleInput, SchoolYearUncheckedCreateWithoutScheduleInput>
  }

  export type SchoolYearUpdateWithoutScheduleInput = {
    year?: IntFieldUpdateOperationsInput | number
    departments?: SchoolYearUpdatedepartmentsInput | Enumerable<string>
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    instansi?: InstansiUpdateOneRequiredWithoutSchoolYearNestedInput
    classRoom?: ClassRoomUpdateManyWithoutYearNestedInput
    students?: StudentUpdateManyWithoutStartYearNestedInput
    calendar?: CalendarUpdateManyWithoutRefNestedInput
    objective?: ObjectiveUpdateManyWithoutYearNestedInput
    tracker?: TrackerUpdateManyWithoutTpNestedInput
    TDevice?: TDeviceUpdateManyWithoutYearNestedInput
  }

  export type SchoolYearUncheckedUpdateWithoutScheduleInput = {
    year?: IntFieldUpdateOperationsInput | number
    instansiId?: StringFieldUpdateOperationsInput | string
    departments?: SchoolYearUpdatedepartmentsInput | Enumerable<string>
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutYearNestedInput
    students?: StudentUncheckedUpdateManyWithoutStartYearNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutRefNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutYearNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTpNestedInput
    TDevice?: TDeviceUncheckedUpdateManyWithoutYearNestedInput
  }

  export type MataPelajaranUpsertWithoutScheduleInput = {
    update: XOR<MataPelajaranUpdateWithoutScheduleInput, MataPelajaranUncheckedUpdateWithoutScheduleInput>
    create: XOR<MataPelajaranCreateWithoutScheduleInput, MataPelajaranUncheckedCreateWithoutScheduleInput>
  }

  export type MataPelajaranUpdateWithoutScheduleInput = {
    level?: NullableEnumLevelFieldUpdateOperationsInput | Level | null
    type?: EnumMataPelajaranTypeFieldUpdateOperationsInput | MataPelajaranType
    no?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    program?: ProgramKeahlianUpdateOneWithoutMapelNestedInput
    keahlian?: KonsentrasiKeahlianUpdateOneWithoutMapelNestedInput
    instansi?: InstansiUpdateOneWithoutUnikMapelsNestedInput
    element?: ElementUpdateManyWithoutMapelNestedInput
    tracker?: TrackerUpdateManyWithoutMapelNestedInput
    objective?: ObjectiveUpdateManyWithoutMapelNestedInput
    device?: TDeviceUpdateManyWithoutMapelNestedInput
  }

  export type MataPelajaranUncheckedUpdateWithoutScheduleInput = {
    level?: NullableEnumLevelFieldUpdateOperationsInput | Level | null
    type?: EnumMataPelajaranTypeFieldUpdateOperationsInput | MataPelajaranType
    no?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    keahlianid?: NullableStringFieldUpdateOperationsInput | string | null
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    element?: ElementUncheckedUpdateManyWithoutMapelNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutMapelNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutMapelNestedInput
    device?: TDeviceUncheckedUpdateManyWithoutMapelNestedInput
  }

  export type TrackerUpsertWithWhereUniqueWithoutJadwalInput = {
    where: TrackerWhereUniqueInput
    update: XOR<TrackerUpdateWithoutJadwalInput, TrackerUncheckedUpdateWithoutJadwalInput>
    create: XOR<TrackerCreateWithoutJadwalInput, TrackerUncheckedCreateWithoutJadwalInput>
  }

  export type TrackerUpdateWithWhereUniqueWithoutJadwalInput = {
    where: TrackerWhereUniqueInput
    data: XOR<TrackerUpdateWithoutJadwalInput, TrackerUncheckedUpdateWithoutJadwalInput>
  }

  export type TrackerUpdateManyWithWhereWithoutJadwalInput = {
    where: TrackerScalarWhereInput
    data: XOR<TrackerUpdateManyMutationInput, TrackerUncheckedUpdateManyWithoutTrackerInput>
  }

  export type TeachingUpsertWithWhereUniqueWithoutRefInput = {
    where: TeachingWhereUniqueInput
    update: XOR<TeachingUpdateWithoutRefInput, TeachingUncheckedUpdateWithoutRefInput>
    create: XOR<TeachingCreateWithoutRefInput, TeachingUncheckedCreateWithoutRefInput>
  }

  export type TeachingUpdateWithWhereUniqueWithoutRefInput = {
    where: TeachingWhereUniqueInput
    data: XOR<TeachingUpdateWithoutRefInput, TeachingUncheckedUpdateWithoutRefInput>
  }

  export type TeachingUpdateManyWithWhereWithoutRefInput = {
    where: TeachingScalarWhereInput
    data: XOR<TeachingUpdateManyMutationInput, TeachingUncheckedUpdateManyWithoutTeachingInput>
  }

  export type ScheduleCreateWithoutTeachingInput = {
    id?: string
    disable?: boolean
    year: SchoolYearCreateNestedOneWithoutScheduleInput
    mapel: MataPelajaranCreateNestedOneWithoutScheduleInput
    tracker?: TrackerCreateNestedManyWithoutJadwalInput
  }

  export type ScheduleUncheckedCreateWithoutTeachingInput = {
    id?: string
    yearId: string
    mapelId: string
    disable?: boolean
    tracker?: TrackerUncheckedCreateNestedManyWithoutJadwalInput
  }

  export type ScheduleCreateOrConnectWithoutTeachingInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutTeachingInput, ScheduleUncheckedCreateWithoutTeachingInput>
  }

  export type TeacherCreateWithoutTeachingInput = {
    id?: string
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: Date | string | null
    tmtGol?: Date | string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    disable?: boolean
    personal: PersonalCreateNestedOneWithoutTeacherInput
    classRoom?: ClassRoomCreateNestedManyWithoutWaliInput
    instansi: InstansiCreateNestedOneWithoutTeacherInput
    event?: CalendarCreateNestedManyWithoutTeacherInput
    tracker?: TrackerCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutTeachingInput = {
    id?: string
    personalId: string
    instansiId: string
    eventIds?: TeacherCreateeventIdsInput | Enumerable<string>
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: Date | string | null
    tmtGol?: Date | string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutWaliInput
    event?: CalendarUncheckedCreateNestedManyWithoutTeacherInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutTeachingInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutTeachingInput, TeacherUncheckedCreateWithoutTeachingInput>
  }

  export type ClassRoomCreateWithoutTeachingInput = {
    id?: string
    name: string
    level: number
    property?: XOR<RoomPropertyNullableCreateEnvelopeInput, RoomPropertyCreateInput> | null
    disable?: boolean
    year: SchoolYearCreateNestedOneWithoutClassRoomInput
    wali: TeacherCreateNestedOneWithoutClassRoomInput
    major?: KonsentrasiKeahlianCreateNestedOneWithoutClassRoomInput
    students?: StudentCreateNestedManyWithoutClassRoomInput
    event?: CalendarCreateNestedManyWithoutClassRoomInput
    tracker?: TrackerCreateNestedManyWithoutKelasInput
    tDevice?: TDeviceCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomUncheckedCreateWithoutTeachingInput = {
    id?: string
    name: string
    yearId: string
    waliId: string
    level: number
    property?: XOR<RoomPropertyNullableCreateEnvelopeInput, RoomPropertyCreateInput> | null
    majorId?: string | null
    studentIds?: ClassRoomCreatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomCreateeventIdsInput | Enumerable<string>
    disable?: boolean
    teachingIds?: ClassRoomCreateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomCreatetDeviceIdsInput | Enumerable<string>
    students?: StudentUncheckedCreateNestedManyWithoutClassRoomInput
    event?: CalendarUncheckedCreateNestedManyWithoutClassRoomInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutKelasInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomCreateOrConnectWithoutTeachingInput = {
    where: ClassRoomWhereUniqueInput
    create: XOR<ClassRoomCreateWithoutTeachingInput, ClassRoomUncheckedCreateWithoutTeachingInput>
  }

  export type ElementCreateWithoutScheduleClassInput = {
    id?: string
    no: number
    name: string
    description: string
    disable?: boolean
    achievement?: AchievementCreateNestedManyWithoutElementInput
    mapel: MataPelajaranCreateNestedOneWithoutElementInput
    tracker?: TrackerCreateNestedManyWithoutElemenInput
    objective?: ObjectiveCreateNestedManyWithoutElemenInput
  }

  export type ElementUncheckedCreateWithoutScheduleClassInput = {
    id?: string
    no: number
    name: string
    description: string
    mapelId: string
    disable?: boolean
    scheduleClassIds?: ElementCreatescheduleClassIdsInput | Enumerable<string>
    achievement?: AchievementUncheckedCreateNestedManyWithoutElementInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutElemenInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutElemenInput
  }

  export type ElementCreateOrConnectWithoutScheduleClassInput = {
    where: ElementWhereUniqueInput
    create: XOR<ElementCreateWithoutScheduleClassInput, ElementUncheckedCreateWithoutScheduleClassInput>
  }

  export type TrackerCreateWithoutMengajarInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrackerInput
    ref: InstansiCreateNestedOneWithoutHistoryInput
    instansi?: InstansiCreateNestedOneWithoutTrackerInput
    mapel?: MataPelajaranCreateNestedOneWithoutTrackerInput
    elemen?: ElementCreateNestedOneWithoutTrackerInput
    cp?: AchievementCreateNestedOneWithoutTrackerInput
    bidang?: BidangKeahlianCreateNestedOneWithoutTrackerInput
    program?: ProgramKeahlianCreateNestedOneWithoutTrackerInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedOneWithoutTrackerInput
    tp?: SchoolYearCreateNestedOneWithoutTrackerInput
    teacher?: TeacherCreateNestedOneWithoutTrackerInput
    kelas?: ClassRoomCreateNestedOneWithoutTrackerInput
    murid?: StudentCreateNestedOneWithoutTrackerInput
    jadwal?: ScheduleCreateNestedOneWithoutTrackerInput
    tujuan?: ObjectiveCreateNestedOneWithoutTrackerInput
    perangkat?: TDeviceCreateNestedOneWithoutTrackerInput
    kalender?: CalendarCreateNestedOneWithoutTrackerInput
    dudi?: DudiCreateNestedOneWithoutTrackerInput
    kkni?: KkniCreateNestedOneWithoutTrackerInput
  }

  export type TrackerUncheckedCreateWithoutMengajarInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TrackerCreateOrConnectWithoutMengajarInput = {
    where: TrackerWhereUniqueInput
    create: XOR<TrackerCreateWithoutMengajarInput, TrackerUncheckedCreateWithoutMengajarInput>
  }

  export type TrackerCreateManyMengajarInputEnvelope = {
    data: Enumerable<TrackerCreateManyMengajarInput>
  }

  export type TDeviceCreateWithoutTeachingInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    year: SchoolYearCreateNestedOneWithoutTDeviceInput
    user: UserCreateNestedOneWithoutTDeviceInput
    instansi: InstansiCreateNestedOneWithoutTDeviceInput
    mapel: MataPelajaranCreateNestedOneWithoutDeviceInput
    classRoom?: ClassRoomCreateNestedManyWithoutTDeviceInput
    tracker?: TrackerCreateNestedManyWithoutPerangkatInput
    data?: TDeviceDataCreateNestedManyWithoutRefInput
    children?: TDeviceCreateNestedManyWithoutParentInput
    parent?: TDeviceCreateNestedOneWithoutChildrenInput
  }

  export type TDeviceUncheckedCreateWithoutTeachingInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    yearId: string
    userId: string
    instansiId: string
    mapelId: string
    classRoomIds?: TDeviceCreateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    parentId?: string | null
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutTDeviceInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutPerangkatInput
    data?: TDeviceDataUncheckedCreateNestedManyWithoutRefInput
    children?: TDeviceUncheckedCreateNestedManyWithoutParentInput
  }

  export type TDeviceCreateOrConnectWithoutTeachingInput = {
    where: TDeviceWhereUniqueInput
    create: XOR<TDeviceCreateWithoutTeachingInput, TDeviceUncheckedCreateWithoutTeachingInput>
  }

  export type TDeviceCreateManyTeachingInputEnvelope = {
    data: Enumerable<TDeviceCreateManyTeachingInput>
  }

  export type ScheduleUpsertWithoutTeachingInput = {
    update: XOR<ScheduleUpdateWithoutTeachingInput, ScheduleUncheckedUpdateWithoutTeachingInput>
    create: XOR<ScheduleCreateWithoutTeachingInput, ScheduleUncheckedCreateWithoutTeachingInput>
  }

  export type ScheduleUpdateWithoutTeachingInput = {
    disable?: BoolFieldUpdateOperationsInput | boolean
    year?: SchoolYearUpdateOneRequiredWithoutScheduleNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutScheduleNestedInput
    tracker?: TrackerUpdateManyWithoutJadwalNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutTeachingInput = {
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    tracker?: TrackerUncheckedUpdateManyWithoutJadwalNestedInput
  }

  export type TeacherUpsertWithoutTeachingInput = {
    update: XOR<TeacherUpdateWithoutTeachingInput, TeacherUncheckedUpdateWithoutTeachingInput>
    create: XOR<TeacherCreateWithoutTeachingInput, TeacherUncheckedCreateWithoutTeachingInput>
  }

  export type TeacherUpdateWithoutTeachingInput = {
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tmtGol?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    personal?: PersonalUpdateOneRequiredWithoutTeacherNestedInput
    classRoom?: ClassRoomUpdateManyWithoutWaliNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutTeacherNestedInput
    event?: CalendarUpdateManyWithoutTeacherNestedInput
    tracker?: TrackerUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutTeachingInput = {
    personalId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: TeacherUpdateeventIdsInput | Enumerable<string>
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tmtGol?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutWaliNestedInput
    event?: CalendarUncheckedUpdateManyWithoutTeacherNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type ClassRoomUpsertWithWhereUniqueWithoutTeachingInput = {
    where: ClassRoomWhereUniqueInput
    update: XOR<ClassRoomUpdateWithoutTeachingInput, ClassRoomUncheckedUpdateWithoutTeachingInput>
    create: XOR<ClassRoomCreateWithoutTeachingInput, ClassRoomUncheckedCreateWithoutTeachingInput>
  }

  export type ClassRoomUpdateWithWhereUniqueWithoutTeachingInput = {
    where: ClassRoomWhereUniqueInput
    data: XOR<ClassRoomUpdateWithoutTeachingInput, ClassRoomUncheckedUpdateWithoutTeachingInput>
  }

  export type ClassRoomUpdateManyWithWhereWithoutTeachingInput = {
    where: ClassRoomScalarWhereInput
    data: XOR<ClassRoomUpdateManyMutationInput, ClassRoomUncheckedUpdateManyWithoutClassRoomInput>
  }

  export type ElementUpsertWithWhereUniqueWithoutScheduleClassInput = {
    where: ElementWhereUniqueInput
    update: XOR<ElementUpdateWithoutScheduleClassInput, ElementUncheckedUpdateWithoutScheduleClassInput>
    create: XOR<ElementCreateWithoutScheduleClassInput, ElementUncheckedCreateWithoutScheduleClassInput>
  }

  export type ElementUpdateWithWhereUniqueWithoutScheduleClassInput = {
    where: ElementWhereUniqueInput
    data: XOR<ElementUpdateWithoutScheduleClassInput, ElementUncheckedUpdateWithoutScheduleClassInput>
  }

  export type ElementUpdateManyWithWhereWithoutScheduleClassInput = {
    where: ElementScalarWhereInput
    data: XOR<ElementUpdateManyMutationInput, ElementUncheckedUpdateManyWithoutElemenInput>
  }

  export type TrackerUpsertWithWhereUniqueWithoutMengajarInput = {
    where: TrackerWhereUniqueInput
    update: XOR<TrackerUpdateWithoutMengajarInput, TrackerUncheckedUpdateWithoutMengajarInput>
    create: XOR<TrackerCreateWithoutMengajarInput, TrackerUncheckedCreateWithoutMengajarInput>
  }

  export type TrackerUpdateWithWhereUniqueWithoutMengajarInput = {
    where: TrackerWhereUniqueInput
    data: XOR<TrackerUpdateWithoutMengajarInput, TrackerUncheckedUpdateWithoutMengajarInput>
  }

  export type TrackerUpdateManyWithWhereWithoutMengajarInput = {
    where: TrackerScalarWhereInput
    data: XOR<TrackerUpdateManyMutationInput, TrackerUncheckedUpdateManyWithoutTrackerInput>
  }

  export type TDeviceUpsertWithWhereUniqueWithoutTeachingInput = {
    where: TDeviceWhereUniqueInput
    update: XOR<TDeviceUpdateWithoutTeachingInput, TDeviceUncheckedUpdateWithoutTeachingInput>
    create: XOR<TDeviceCreateWithoutTeachingInput, TDeviceUncheckedCreateWithoutTeachingInput>
  }

  export type TDeviceUpdateWithWhereUniqueWithoutTeachingInput = {
    where: TDeviceWhereUniqueInput
    data: XOR<TDeviceUpdateWithoutTeachingInput, TDeviceUncheckedUpdateWithoutTeachingInput>
  }

  export type TDeviceUpdateManyWithWhereWithoutTeachingInput = {
    where: TDeviceScalarWhereInput
    data: XOR<TDeviceUpdateManyMutationInput, TDeviceUncheckedUpdateManyWithoutTDeviceInput>
  }

  export type UserCreateWithoutLinkInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    disable?: boolean
    google?: XOR<GoogleNullableCreateEnvelopeInput, GoogleCreateInput> | null
    role?: RoleCreateNestedOneWithoutUsersInput
    auth?: AuthCreateNestedOneWithoutUserInput
    tracker?: TrackerCreateNestedManyWithoutUserInput
    objective?: ObjectiveCreateNestedManyWithoutUserInput
    tDevice?: TDeviceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLinkInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    roleId?: string | null
    disable?: boolean
    google?: XOR<GoogleNullableCreateEnvelopeInput, GoogleCreateInput> | null
    auth?: AuthUncheckedCreateNestedOneWithoutUserInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutUserInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutUserInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLinkInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLinkInput, UserUncheckedCreateWithoutLinkInput>
  }

  export type OresourceCreateWithoutLinkInput = {
    id?: string
    name: string
    type: OresourceType
    ref: ObjectiveCreateNestedOneWithoutResourseInput
  }

  export type OresourceUncheckedCreateWithoutLinkInput = {
    id?: string
    name: string
    type: OresourceType
    refId: string
  }

  export type OresourceCreateOrConnectWithoutLinkInput = {
    where: OresourceWhereUniqueInput
    create: XOR<OresourceCreateWithoutLinkInput, OresourceUncheckedCreateWithoutLinkInput>
  }

  export type OresourceCreateManyLinkInputEnvelope = {
    data: Enumerable<OresourceCreateManyLinkInput>
  }

  export type UserUpsertWithoutLinkInput = {
    update: XOR<UserUpdateWithoutLinkInput, UserUncheckedUpdateWithoutLinkInput>
    create: XOR<UserCreateWithoutLinkInput, UserUncheckedCreateWithoutLinkInput>
  }

  export type UserUpdateWithoutLinkInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    google?: XOR<GoogleNullableUpdateEnvelopeInput, GoogleCreateInput> | null
    role?: RoleUpdateOneWithoutUsersNestedInput
    auth?: AuthUpdateOneWithoutUserNestedInput
    tracker?: TrackerUpdateManyWithoutUserNestedInput
    objective?: ObjectiveUpdateManyWithoutUserNestedInput
    tDevice?: TDeviceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLinkInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    google?: XOR<GoogleNullableUpdateEnvelopeInput, GoogleCreateInput> | null
    auth?: AuthUncheckedUpdateOneWithoutUserNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutUserNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutUserNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OresourceUpsertWithWhereUniqueWithoutLinkInput = {
    where: OresourceWhereUniqueInput
    update: XOR<OresourceUpdateWithoutLinkInput, OresourceUncheckedUpdateWithoutLinkInput>
    create: XOR<OresourceCreateWithoutLinkInput, OresourceUncheckedCreateWithoutLinkInput>
  }

  export type OresourceUpdateWithWhereUniqueWithoutLinkInput = {
    where: OresourceWhereUniqueInput
    data: XOR<OresourceUpdateWithoutLinkInput, OresourceUncheckedUpdateWithoutLinkInput>
  }

  export type OresourceUpdateManyWithWhereWithoutLinkInput = {
    where: OresourceScalarWhereInput
    data: XOR<OresourceUpdateManyMutationInput, OresourceUncheckedUpdateManyWithoutObjResourceInput>
  }

  export type OresourceScalarWhereInput = {
    AND?: Enumerable<OresourceScalarWhereInput>
    OR?: Enumerable<OresourceScalarWhereInput>
    NOT?: Enumerable<OresourceScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    type?: EnumOresourceTypeFilter | OresourceType
    refId?: StringFilter | string
    linkId?: StringNullableFilter | string | null
  }

  export type ObjectiveCreateWithoutAssessmentsInput = {
    id?: string
    level: number
    fase: Fase
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    user: UserCreateNestedOneWithoutObjectiveInput
    instansi: InstansiCreateNestedOneWithoutObjectiveInput
    year: SchoolYearCreateNestedOneWithoutObjectiveInput
    mapel: MataPelajaranCreateNestedOneWithoutObjectiveInput
    elemen: ElementCreateNestedOneWithoutObjectiveInput
    achievement: AchievementCreateNestedOneWithoutObjectiveInput
    material?: OMaterialCreateNestedManyWithoutRefInput
    tracker?: TrackerCreateNestedManyWithoutTujuanInput
    resourse?: OresourceCreateNestedManyWithoutRefInput
    ppp?: OpppCreateNestedManyWithoutRefInput
    tool?: OhelperCreateNestedManyWithoutToolInput
    mate?: OhelperCreateNestedManyWithoutMateInput
    meth?: OhelperCreateNestedManyWithoutMethInput
    media?: OhelperCreateNestedManyWithoutMediaInput
    devices?: TDeviceDataCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveUncheckedCreateWithoutAssessmentsInput = {
    id?: string
    level: number
    fase: Fase
    userId: string
    instansiId: string
    yearId: string
    mapelId: string
    elementId: string
    achievementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedCreateNestedManyWithoutRefInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTujuanInput
    resourse?: OresourceUncheckedCreateNestedManyWithoutRefInput
    ppp?: OpppUncheckedCreateNestedManyWithoutRefInput
    tool?: OhelperUncheckedCreateNestedManyWithoutToolInput
    mate?: OhelperUncheckedCreateNestedManyWithoutMateInput
    meth?: OhelperUncheckedCreateNestedManyWithoutMethInput
    media?: OhelperUncheckedCreateNestedManyWithoutMediaInput
    devices?: TDeviceDataUncheckedCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveCreateOrConnectWithoutAssessmentsInput = {
    where: ObjectiveWhereUniqueInput
    create: XOR<ObjectiveCreateWithoutAssessmentsInput, ObjectiveUncheckedCreateWithoutAssessmentsInput>
  }

  export type ObjectiveUpsertWithoutAssessmentsInput = {
    update: XOR<ObjectiveUpdateWithoutAssessmentsInput, ObjectiveUncheckedUpdateWithoutAssessmentsInput>
    create: XOR<ObjectiveCreateWithoutAssessmentsInput, ObjectiveUncheckedCreateWithoutAssessmentsInput>
  }

  export type ObjectiveUpdateWithoutAssessmentsInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutObjectiveNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutObjectiveNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutObjectiveNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutObjectiveNestedInput
    elemen?: ElementUpdateOneRequiredWithoutObjectiveNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutObjectiveNestedInput
    material?: OMaterialUpdateManyWithoutRefNestedInput
    tracker?: TrackerUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUpdateManyWithoutRefNestedInput
    ppp?: OpppUpdateManyWithoutRefNestedInput
    tool?: OhelperUpdateManyWithoutToolNestedInput
    mate?: OhelperUpdateManyWithoutMateNestedInput
    meth?: OhelperUpdateManyWithoutMethNestedInput
    media?: OhelperUpdateManyWithoutMediaNestedInput
    devices?: TDeviceDataUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateWithoutAssessmentsInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    toolIds?: ObjectiveUpdatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveUpdatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveUpdatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveUpdatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedUpdateManyWithoutRefNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUncheckedUpdateManyWithoutRefNestedInput
    ppp?: OpppUncheckedUpdateManyWithoutRefNestedInput
    tool?: OhelperUncheckedUpdateManyWithoutToolNestedInput
    mate?: OhelperUncheckedUpdateManyWithoutMateNestedInput
    meth?: OhelperUncheckedUpdateManyWithoutMethNestedInput
    media?: OhelperUncheckedUpdateManyWithoutMediaNestedInput
    devices?: TDeviceDataUncheckedUpdateManyWithoutObjectiveNestedInput
  }

  export type UserCreateWithoutObjectiveInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    disable?: boolean
    google?: XOR<GoogleNullableCreateEnvelopeInput, GoogleCreateInput> | null
    role?: RoleCreateNestedOneWithoutUsersInput
    auth?: AuthCreateNestedOneWithoutUserInput
    tracker?: TrackerCreateNestedManyWithoutUserInput
    link?: LinkCreateNestedManyWithoutUserInput
    tDevice?: TDeviceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutObjectiveInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    roleId?: string | null
    disable?: boolean
    google?: XOR<GoogleNullableCreateEnvelopeInput, GoogleCreateInput> | null
    auth?: AuthUncheckedCreateNestedOneWithoutUserInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutUserInput
    link?: LinkUncheckedCreateNestedManyWithoutUserInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutObjectiveInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutObjectiveInput, UserUncheckedCreateWithoutObjectiveInput>
  }

  export type InstansiCreateWithoutObjectiveInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    disable?: boolean
    majors?: KonsentrasiKeahlianCreateNestedManyWithoutInstansiInput
    role?: RoleCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearCreateNestedManyWithoutInstansiInput
    teacher?: TeacherCreateNestedManyWithoutInstansiInput
    student?: StudentCreateNestedManyWithoutInstansiInput
    tracker?: TrackerCreateNestedManyWithoutInstansiInput
    history?: TrackerCreateNestedManyWithoutRefInput
    unikMapels?: MataPelajaranCreateNestedManyWithoutInstansiInput
    tDevice?: TDeviceCreateNestedManyWithoutInstansiInput
    dudi?: DudiCreateNestedManyWithoutInstansiInput
  }

  export type InstansiUncheckedCreateWithoutObjectiveInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    majorIds?: InstansiCreatemajorIdsInput | Enumerable<string>
    disable?: boolean
    majors?: KonsentrasiKeahlianUncheckedCreateNestedManyWithoutInstansiInput
    role?: RoleUncheckedCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearUncheckedCreateNestedManyWithoutInstansiInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutInstansiInput
    student?: StudentUncheckedCreateNestedManyWithoutInstansiInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutInstansiInput
    history?: TrackerUncheckedCreateNestedManyWithoutRefInput
    unikMapels?: MataPelajaranUncheckedCreateNestedManyWithoutInstansiInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutInstansiInput
    dudi?: DudiUncheckedCreateNestedManyWithoutInstansiInput
  }

  export type InstansiCreateOrConnectWithoutObjectiveInput = {
    where: InstansiWhereUniqueInput
    create: XOR<InstansiCreateWithoutObjectiveInput, InstansiUncheckedCreateWithoutObjectiveInput>
  }

  export type SchoolYearCreateWithoutObjectiveInput = {
    id?: string
    year: number
    departments?: SchoolYearCreatedepartmentsInput | Enumerable<string>
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    disable?: boolean
    instansi: InstansiCreateNestedOneWithoutSchoolYearInput
    classRoom?: ClassRoomCreateNestedManyWithoutYearInput
    students?: StudentCreateNestedManyWithoutStartYearInput
    calendar?: CalendarCreateNestedManyWithoutRefInput
    schedule?: ScheduleCreateNestedManyWithoutYearInput
    tracker?: TrackerCreateNestedManyWithoutTpInput
    TDevice?: TDeviceCreateNestedManyWithoutYearInput
  }

  export type SchoolYearUncheckedCreateWithoutObjectiveInput = {
    id?: string
    year: number
    instansiId: string
    departments?: SchoolYearCreatedepartmentsInput | Enumerable<string>
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutYearInput
    students?: StudentUncheckedCreateNestedManyWithoutStartYearInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutRefInput
    schedule?: ScheduleUncheckedCreateNestedManyWithoutYearInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTpInput
    TDevice?: TDeviceUncheckedCreateNestedManyWithoutYearInput
  }

  export type SchoolYearCreateOrConnectWithoutObjectiveInput = {
    where: SchoolYearWhereUniqueInput
    create: XOR<SchoolYearCreateWithoutObjectiveInput, SchoolYearUncheckedCreateWithoutObjectiveInput>
  }

  export type MataPelajaranCreateWithoutObjectiveInput = {
    id?: string
    level?: Level | null
    type?: MataPelajaranType
    no: string
    code: string
    name: string
    religion?: Religion | null
    disable?: boolean
    program?: ProgramKeahlianCreateNestedOneWithoutMapelInput
    keahlian?: KonsentrasiKeahlianCreateNestedOneWithoutMapelInput
    instansi?: InstansiCreateNestedOneWithoutUnikMapelsInput
    element?: ElementCreateNestedManyWithoutMapelInput
    schedule?: ScheduleCreateNestedManyWithoutMapelInput
    tracker?: TrackerCreateNestedManyWithoutMapelInput
    device?: TDeviceCreateNestedManyWithoutMapelInput
  }

  export type MataPelajaranUncheckedCreateWithoutObjectiveInput = {
    id?: string
    level?: Level | null
    type?: MataPelajaranType
    no: string
    code: string
    name: string
    religion?: Religion | null
    programId?: string | null
    keahlianid?: string | null
    instansiId?: string | null
    disable?: boolean
    element?: ElementUncheckedCreateNestedManyWithoutMapelInput
    schedule?: ScheduleUncheckedCreateNestedManyWithoutMapelInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutMapelInput
    device?: TDeviceUncheckedCreateNestedManyWithoutMapelInput
  }

  export type MataPelajaranCreateOrConnectWithoutObjectiveInput = {
    where: MataPelajaranWhereUniqueInput
    create: XOR<MataPelajaranCreateWithoutObjectiveInput, MataPelajaranUncheckedCreateWithoutObjectiveInput>
  }

  export type ElementCreateWithoutObjectiveInput = {
    id?: string
    no: number
    name: string
    description: string
    disable?: boolean
    achievement?: AchievementCreateNestedManyWithoutElementInput
    mapel: MataPelajaranCreateNestedOneWithoutElementInput
    tracker?: TrackerCreateNestedManyWithoutElemenInput
    scheduleClass?: TeachingCreateNestedManyWithoutElemenInput
  }

  export type ElementUncheckedCreateWithoutObjectiveInput = {
    id?: string
    no: number
    name: string
    description: string
    mapelId: string
    disable?: boolean
    scheduleClassIds?: ElementCreatescheduleClassIdsInput | Enumerable<string>
    achievement?: AchievementUncheckedCreateNestedManyWithoutElementInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutElemenInput
    scheduleClass?: TeachingUncheckedCreateNestedManyWithoutElemenInput
  }

  export type ElementCreateOrConnectWithoutObjectiveInput = {
    where: ElementWhereUniqueInput
    create: XOR<ElementCreateWithoutObjectiveInput, ElementUncheckedCreateWithoutObjectiveInput>
  }

  export type AchievementCreateWithoutObjectiveInput = {
    id?: string
    no: number
    fase?: Fase
    description: string
    disable?: boolean
    element: ElementCreateNestedOneWithoutAchievementInput
    tracker?: TrackerCreateNestedManyWithoutCpInput
  }

  export type AchievementUncheckedCreateWithoutObjectiveInput = {
    id?: string
    no: number
    fase?: Fase
    description: string
    elementId: string
    disable?: boolean
    tracker?: TrackerUncheckedCreateNestedManyWithoutCpInput
  }

  export type AchievementCreateOrConnectWithoutObjectiveInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutObjectiveInput, AchievementUncheckedCreateWithoutObjectiveInput>
  }

  export type OMaterialCreateWithoutRefInput = {
    id?: string
    no: number
    content: string
    model: OMaterialModel
    learning?: OLearningCreateNestedManyWithoutRefInput
  }

  export type OMaterialUncheckedCreateWithoutRefInput = {
    id?: string
    no: number
    content: string
    model: OMaterialModel
    learning?: OLearningUncheckedCreateNestedManyWithoutRefInput
  }

  export type OMaterialCreateOrConnectWithoutRefInput = {
    where: OMaterialWhereUniqueInput
    create: XOR<OMaterialCreateWithoutRefInput, OMaterialUncheckedCreateWithoutRefInput>
  }

  export type OMaterialCreateManyRefInputEnvelope = {
    data: Enumerable<OMaterialCreateManyRefInput>
  }

  export type TrackerCreateWithoutTujuanInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrackerInput
    ref: InstansiCreateNestedOneWithoutHistoryInput
    instansi?: InstansiCreateNestedOneWithoutTrackerInput
    mapel?: MataPelajaranCreateNestedOneWithoutTrackerInput
    elemen?: ElementCreateNestedOneWithoutTrackerInput
    cp?: AchievementCreateNestedOneWithoutTrackerInput
    bidang?: BidangKeahlianCreateNestedOneWithoutTrackerInput
    program?: ProgramKeahlianCreateNestedOneWithoutTrackerInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedOneWithoutTrackerInput
    tp?: SchoolYearCreateNestedOneWithoutTrackerInput
    teacher?: TeacherCreateNestedOneWithoutTrackerInput
    kelas?: ClassRoomCreateNestedOneWithoutTrackerInput
    murid?: StudentCreateNestedOneWithoutTrackerInput
    jadwal?: ScheduleCreateNestedOneWithoutTrackerInput
    mengajar?: TeachingCreateNestedOneWithoutTrackerInput
    perangkat?: TDeviceCreateNestedOneWithoutTrackerInput
    kalender?: CalendarCreateNestedOneWithoutTrackerInput
    dudi?: DudiCreateNestedOneWithoutTrackerInput
    kkni?: KkniCreateNestedOneWithoutTrackerInput
  }

  export type TrackerUncheckedCreateWithoutTujuanInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TrackerCreateOrConnectWithoutTujuanInput = {
    where: TrackerWhereUniqueInput
    create: XOR<TrackerCreateWithoutTujuanInput, TrackerUncheckedCreateWithoutTujuanInput>
  }

  export type TrackerCreateManyTujuanInputEnvelope = {
    data: Enumerable<TrackerCreateManyTujuanInput>
  }

  export type OresourceCreateWithoutRefInput = {
    id?: string
    name: string
    type: OresourceType
    link?: LinkCreateNestedOneWithoutObjResourceInput
  }

  export type OresourceUncheckedCreateWithoutRefInput = {
    id?: string
    name: string
    type: OresourceType
    linkId?: string | null
  }

  export type OresourceCreateOrConnectWithoutRefInput = {
    where: OresourceWhereUniqueInput
    create: XOR<OresourceCreateWithoutRefInput, OresourceUncheckedCreateWithoutRefInput>
  }

  export type OresourceCreateManyRefInputEnvelope = {
    data: Enumerable<OresourceCreateManyRefInput>
  }

  export type OpppCreateWithoutRefInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type OpppUncheckedCreateWithoutRefInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type OpppCreateOrConnectWithoutRefInput = {
    where: OpppWhereUniqueInput
    create: XOR<OpppCreateWithoutRefInput, OpppUncheckedCreateWithoutRefInput>
  }

  export type OpppCreateManyRefInputEnvelope = {
    data: Enumerable<OpppCreateManyRefInput>
  }

  export type OhelperCreateWithoutToolInput = {
    id?: string
    type: OhelperType
    name: string
    mate?: ObjectiveCreateNestedManyWithoutMateInput
    meth?: ObjectiveCreateNestedManyWithoutMethInput
    media?: ObjectiveCreateNestedManyWithoutMediaInput
  }

  export type OhelperUncheckedCreateWithoutToolInput = {
    id?: string
    type: OhelperType
    name: string
    toolIds?: OhelperCreatetoolIdsInput | Enumerable<string>
    mateIds?: OhelperCreatemateIdsInput | Enumerable<string>
    methIds?: OhelperCreatemethIdsInput | Enumerable<string>
    mediaIds?: OhelperCreatemediaIdsInput | Enumerable<string>
    mate?: ObjectiveUncheckedCreateNestedManyWithoutMateInput
    meth?: ObjectiveUncheckedCreateNestedManyWithoutMethInput
    media?: ObjectiveUncheckedCreateNestedManyWithoutMediaInput
  }

  export type OhelperCreateOrConnectWithoutToolInput = {
    where: OhelperWhereUniqueInput
    create: XOR<OhelperCreateWithoutToolInput, OhelperUncheckedCreateWithoutToolInput>
  }

  export type OhelperCreateWithoutMateInput = {
    id?: string
    type: OhelperType
    name: string
    tool?: ObjectiveCreateNestedManyWithoutToolInput
    meth?: ObjectiveCreateNestedManyWithoutMethInput
    media?: ObjectiveCreateNestedManyWithoutMediaInput
  }

  export type OhelperUncheckedCreateWithoutMateInput = {
    id?: string
    type: OhelperType
    name: string
    toolIds?: OhelperCreatetoolIdsInput | Enumerable<string>
    mateIds?: OhelperCreatemateIdsInput | Enumerable<string>
    methIds?: OhelperCreatemethIdsInput | Enumerable<string>
    mediaIds?: OhelperCreatemediaIdsInput | Enumerable<string>
    tool?: ObjectiveUncheckedCreateNestedManyWithoutToolInput
    meth?: ObjectiveUncheckedCreateNestedManyWithoutMethInput
    media?: ObjectiveUncheckedCreateNestedManyWithoutMediaInput
  }

  export type OhelperCreateOrConnectWithoutMateInput = {
    where: OhelperWhereUniqueInput
    create: XOR<OhelperCreateWithoutMateInput, OhelperUncheckedCreateWithoutMateInput>
  }

  export type OhelperCreateWithoutMethInput = {
    id?: string
    type: OhelperType
    name: string
    tool?: ObjectiveCreateNestedManyWithoutToolInput
    mate?: ObjectiveCreateNestedManyWithoutMateInput
    media?: ObjectiveCreateNestedManyWithoutMediaInput
  }

  export type OhelperUncheckedCreateWithoutMethInput = {
    id?: string
    type: OhelperType
    name: string
    toolIds?: OhelperCreatetoolIdsInput | Enumerable<string>
    mateIds?: OhelperCreatemateIdsInput | Enumerable<string>
    methIds?: OhelperCreatemethIdsInput | Enumerable<string>
    mediaIds?: OhelperCreatemediaIdsInput | Enumerable<string>
    tool?: ObjectiveUncheckedCreateNestedManyWithoutToolInput
    mate?: ObjectiveUncheckedCreateNestedManyWithoutMateInput
    media?: ObjectiveUncheckedCreateNestedManyWithoutMediaInput
  }

  export type OhelperCreateOrConnectWithoutMethInput = {
    where: OhelperWhereUniqueInput
    create: XOR<OhelperCreateWithoutMethInput, OhelperUncheckedCreateWithoutMethInput>
  }

  export type OhelperCreateWithoutMediaInput = {
    id?: string
    type: OhelperType
    name: string
    tool?: ObjectiveCreateNestedManyWithoutToolInput
    mate?: ObjectiveCreateNestedManyWithoutMateInput
    meth?: ObjectiveCreateNestedManyWithoutMethInput
  }

  export type OhelperUncheckedCreateWithoutMediaInput = {
    id?: string
    type: OhelperType
    name: string
    toolIds?: OhelperCreatetoolIdsInput | Enumerable<string>
    mateIds?: OhelperCreatemateIdsInput | Enumerable<string>
    methIds?: OhelperCreatemethIdsInput | Enumerable<string>
    mediaIds?: OhelperCreatemediaIdsInput | Enumerable<string>
    tool?: ObjectiveUncheckedCreateNestedManyWithoutToolInput
    mate?: ObjectiveUncheckedCreateNestedManyWithoutMateInput
    meth?: ObjectiveUncheckedCreateNestedManyWithoutMethInput
  }

  export type OhelperCreateOrConnectWithoutMediaInput = {
    where: OhelperWhereUniqueInput
    create: XOR<OhelperCreateWithoutMediaInput, OhelperUncheckedCreateWithoutMediaInput>
  }

  export type OAssessmentCreateWithoutRefInput = {
    id?: string
    type: string
    techs?: OAssessmentCreatetechsInput | Enumerable<string>
  }

  export type OAssessmentUncheckedCreateWithoutRefInput = {
    id?: string
    type: string
    techs?: OAssessmentCreatetechsInput | Enumerable<string>
  }

  export type OAssessmentCreateOrConnectWithoutRefInput = {
    where: OAssessmentWhereUniqueInput
    create: XOR<OAssessmentCreateWithoutRefInput, OAssessmentUncheckedCreateWithoutRefInput>
  }

  export type OAssessmentCreateManyRefInputEnvelope = {
    data: Enumerable<OAssessmentCreateManyRefInput>
  }

  export type TDeviceDataCreateWithoutObjectiveInput = {
    id?: string
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    ref: TDeviceCreateNestedOneWithoutDataInput
  }

  export type TDeviceDataUncheckedCreateWithoutObjectiveInput = {
    id?: string
    refId: string
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type TDeviceDataCreateOrConnectWithoutObjectiveInput = {
    where: TDeviceDataWhereUniqueInput
    create: XOR<TDeviceDataCreateWithoutObjectiveInput, TDeviceDataUncheckedCreateWithoutObjectiveInput>
  }

  export type TDeviceDataCreateManyObjectiveInputEnvelope = {
    data: Enumerable<TDeviceDataCreateManyObjectiveInput>
  }

  export type UserUpsertWithoutObjectiveInput = {
    update: XOR<UserUpdateWithoutObjectiveInput, UserUncheckedUpdateWithoutObjectiveInput>
    create: XOR<UserCreateWithoutObjectiveInput, UserUncheckedCreateWithoutObjectiveInput>
  }

  export type UserUpdateWithoutObjectiveInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    google?: XOR<GoogleNullableUpdateEnvelopeInput, GoogleCreateInput> | null
    role?: RoleUpdateOneWithoutUsersNestedInput
    auth?: AuthUpdateOneWithoutUserNestedInput
    tracker?: TrackerUpdateManyWithoutUserNestedInput
    link?: LinkUpdateManyWithoutUserNestedInput
    tDevice?: TDeviceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutObjectiveInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    google?: XOR<GoogleNullableUpdateEnvelopeInput, GoogleCreateInput> | null
    auth?: AuthUncheckedUpdateOneWithoutUserNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutUserNestedInput
    link?: LinkUncheckedUpdateManyWithoutUserNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InstansiUpsertWithoutObjectiveInput = {
    update: XOR<InstansiUpdateWithoutObjectiveInput, InstansiUncheckedUpdateWithoutObjectiveInput>
    create: XOR<InstansiCreateWithoutObjectiveInput, InstansiUncheckedCreateWithoutObjectiveInput>
  }

  export type InstansiUpdateWithoutObjectiveInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    majors?: KonsentrasiKeahlianUpdateManyWithoutInstansiNestedInput
    role?: RoleUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUpdateManyWithoutInstansiNestedInput
    student?: StudentUpdateManyWithoutInstansiNestedInput
    tracker?: TrackerUpdateManyWithoutInstansiNestedInput
    history?: TrackerUpdateManyWithoutRefNestedInput
    unikMapels?: MataPelajaranUpdateManyWithoutInstansiNestedInput
    tDevice?: TDeviceUpdateManyWithoutInstansiNestedInput
    dudi?: DudiUpdateManyWithoutInstansiNestedInput
  }

  export type InstansiUncheckedUpdateWithoutObjectiveInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    majorIds?: InstansiUpdatemajorIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    majors?: KonsentrasiKeahlianUncheckedUpdateManyWithoutInstansiNestedInput
    role?: RoleUncheckedUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUncheckedUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutInstansiNestedInput
    student?: StudentUncheckedUpdateManyWithoutInstansiNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutInstansiNestedInput
    history?: TrackerUncheckedUpdateManyWithoutRefNestedInput
    unikMapels?: MataPelajaranUncheckedUpdateManyWithoutInstansiNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutInstansiNestedInput
    dudi?: DudiUncheckedUpdateManyWithoutInstansiNestedInput
  }

  export type SchoolYearUpsertWithoutObjectiveInput = {
    update: XOR<SchoolYearUpdateWithoutObjectiveInput, SchoolYearUncheckedUpdateWithoutObjectiveInput>
    create: XOR<SchoolYearCreateWithoutObjectiveInput, SchoolYearUncheckedCreateWithoutObjectiveInput>
  }

  export type SchoolYearUpdateWithoutObjectiveInput = {
    year?: IntFieldUpdateOperationsInput | number
    departments?: SchoolYearUpdatedepartmentsInput | Enumerable<string>
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    instansi?: InstansiUpdateOneRequiredWithoutSchoolYearNestedInput
    classRoom?: ClassRoomUpdateManyWithoutYearNestedInput
    students?: StudentUpdateManyWithoutStartYearNestedInput
    calendar?: CalendarUpdateManyWithoutRefNestedInput
    schedule?: ScheduleUpdateManyWithoutYearNestedInput
    tracker?: TrackerUpdateManyWithoutTpNestedInput
    TDevice?: TDeviceUpdateManyWithoutYearNestedInput
  }

  export type SchoolYearUncheckedUpdateWithoutObjectiveInput = {
    year?: IntFieldUpdateOperationsInput | number
    instansiId?: StringFieldUpdateOperationsInput | string
    departments?: SchoolYearUpdatedepartmentsInput | Enumerable<string>
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutYearNestedInput
    students?: StudentUncheckedUpdateManyWithoutStartYearNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutRefNestedInput
    schedule?: ScheduleUncheckedUpdateManyWithoutYearNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTpNestedInput
    TDevice?: TDeviceUncheckedUpdateManyWithoutYearNestedInput
  }

  export type MataPelajaranUpsertWithoutObjectiveInput = {
    update: XOR<MataPelajaranUpdateWithoutObjectiveInput, MataPelajaranUncheckedUpdateWithoutObjectiveInput>
    create: XOR<MataPelajaranCreateWithoutObjectiveInput, MataPelajaranUncheckedCreateWithoutObjectiveInput>
  }

  export type MataPelajaranUpdateWithoutObjectiveInput = {
    level?: NullableEnumLevelFieldUpdateOperationsInput | Level | null
    type?: EnumMataPelajaranTypeFieldUpdateOperationsInput | MataPelajaranType
    no?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    program?: ProgramKeahlianUpdateOneWithoutMapelNestedInput
    keahlian?: KonsentrasiKeahlianUpdateOneWithoutMapelNestedInput
    instansi?: InstansiUpdateOneWithoutUnikMapelsNestedInput
    element?: ElementUpdateManyWithoutMapelNestedInput
    schedule?: ScheduleUpdateManyWithoutMapelNestedInput
    tracker?: TrackerUpdateManyWithoutMapelNestedInput
    device?: TDeviceUpdateManyWithoutMapelNestedInput
  }

  export type MataPelajaranUncheckedUpdateWithoutObjectiveInput = {
    level?: NullableEnumLevelFieldUpdateOperationsInput | Level | null
    type?: EnumMataPelajaranTypeFieldUpdateOperationsInput | MataPelajaranType
    no?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    keahlianid?: NullableStringFieldUpdateOperationsInput | string | null
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    element?: ElementUncheckedUpdateManyWithoutMapelNestedInput
    schedule?: ScheduleUncheckedUpdateManyWithoutMapelNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutMapelNestedInput
    device?: TDeviceUncheckedUpdateManyWithoutMapelNestedInput
  }

  export type ElementUpsertWithoutObjectiveInput = {
    update: XOR<ElementUpdateWithoutObjectiveInput, ElementUncheckedUpdateWithoutObjectiveInput>
    create: XOR<ElementCreateWithoutObjectiveInput, ElementUncheckedCreateWithoutObjectiveInput>
  }

  export type ElementUpdateWithoutObjectiveInput = {
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    achievement?: AchievementUpdateManyWithoutElementNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutElementNestedInput
    tracker?: TrackerUpdateManyWithoutElemenNestedInput
    scheduleClass?: TeachingUpdateManyWithoutElemenNestedInput
  }

  export type ElementUncheckedUpdateWithoutObjectiveInput = {
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    scheduleClassIds?: ElementUpdatescheduleClassIdsInput | Enumerable<string>
    achievement?: AchievementUncheckedUpdateManyWithoutElementNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutElemenNestedInput
    scheduleClass?: TeachingUncheckedUpdateManyWithoutElemenNestedInput
  }

  export type AchievementUpsertWithoutObjectiveInput = {
    update: XOR<AchievementUpdateWithoutObjectiveInput, AchievementUncheckedUpdateWithoutObjectiveInput>
    create: XOR<AchievementCreateWithoutObjectiveInput, AchievementUncheckedCreateWithoutObjectiveInput>
  }

  export type AchievementUpdateWithoutObjectiveInput = {
    no?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    description?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    element?: ElementUpdateOneRequiredWithoutAchievementNestedInput
    tracker?: TrackerUpdateManyWithoutCpNestedInput
  }

  export type AchievementUncheckedUpdateWithoutObjectiveInput = {
    no?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    description?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    tracker?: TrackerUncheckedUpdateManyWithoutCpNestedInput
  }

  export type OMaterialUpsertWithWhereUniqueWithoutRefInput = {
    where: OMaterialWhereUniqueInput
    update: XOR<OMaterialUpdateWithoutRefInput, OMaterialUncheckedUpdateWithoutRefInput>
    create: XOR<OMaterialCreateWithoutRefInput, OMaterialUncheckedCreateWithoutRefInput>
  }

  export type OMaterialUpdateWithWhereUniqueWithoutRefInput = {
    where: OMaterialWhereUniqueInput
    data: XOR<OMaterialUpdateWithoutRefInput, OMaterialUncheckedUpdateWithoutRefInput>
  }

  export type OMaterialUpdateManyWithWhereWithoutRefInput = {
    where: OMaterialScalarWhereInput
    data: XOR<OMaterialUpdateManyMutationInput, OMaterialUncheckedUpdateManyWithoutMaterialInput>
  }

  export type OMaterialScalarWhereInput = {
    AND?: Enumerable<OMaterialScalarWhereInput>
    OR?: Enumerable<OMaterialScalarWhereInput>
    NOT?: Enumerable<OMaterialScalarWhereInput>
    id?: StringFilter | string
    refId?: StringFilter | string
    no?: IntFilter | number
    content?: StringFilter | string
    model?: EnumOMaterialModelFilter | OMaterialModel
  }

  export type TrackerUpsertWithWhereUniqueWithoutTujuanInput = {
    where: TrackerWhereUniqueInput
    update: XOR<TrackerUpdateWithoutTujuanInput, TrackerUncheckedUpdateWithoutTujuanInput>
    create: XOR<TrackerCreateWithoutTujuanInput, TrackerUncheckedCreateWithoutTujuanInput>
  }

  export type TrackerUpdateWithWhereUniqueWithoutTujuanInput = {
    where: TrackerWhereUniqueInput
    data: XOR<TrackerUpdateWithoutTujuanInput, TrackerUncheckedUpdateWithoutTujuanInput>
  }

  export type TrackerUpdateManyWithWhereWithoutTujuanInput = {
    where: TrackerScalarWhereInput
    data: XOR<TrackerUpdateManyMutationInput, TrackerUncheckedUpdateManyWithoutTrackerInput>
  }

  export type OresourceUpsertWithWhereUniqueWithoutRefInput = {
    where: OresourceWhereUniqueInput
    update: XOR<OresourceUpdateWithoutRefInput, OresourceUncheckedUpdateWithoutRefInput>
    create: XOR<OresourceCreateWithoutRefInput, OresourceUncheckedCreateWithoutRefInput>
  }

  export type OresourceUpdateWithWhereUniqueWithoutRefInput = {
    where: OresourceWhereUniqueInput
    data: XOR<OresourceUpdateWithoutRefInput, OresourceUncheckedUpdateWithoutRefInput>
  }

  export type OresourceUpdateManyWithWhereWithoutRefInput = {
    where: OresourceScalarWhereInput
    data: XOR<OresourceUpdateManyMutationInput, OresourceUncheckedUpdateManyWithoutResourseInput>
  }

  export type OpppUpsertWithWhereUniqueWithoutRefInput = {
    where: OpppWhereUniqueInput
    update: XOR<OpppUpdateWithoutRefInput, OpppUncheckedUpdateWithoutRefInput>
    create: XOR<OpppCreateWithoutRefInput, OpppUncheckedCreateWithoutRefInput>
  }

  export type OpppUpdateWithWhereUniqueWithoutRefInput = {
    where: OpppWhereUniqueInput
    data: XOR<OpppUpdateWithoutRefInput, OpppUncheckedUpdateWithoutRefInput>
  }

  export type OpppUpdateManyWithWhereWithoutRefInput = {
    where: OpppScalarWhereInput
    data: XOR<OpppUpdateManyMutationInput, OpppUncheckedUpdateManyWithoutPppInput>
  }

  export type OpppScalarWhereInput = {
    AND?: Enumerable<OpppScalarWhereInput>
    OR?: Enumerable<OpppScalarWhereInput>
    NOT?: Enumerable<OpppScalarWhereInput>
    id?: StringFilter | string
    refId?: StringFilter | string
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
  }

  export type OhelperUpsertWithWhereUniqueWithoutToolInput = {
    where: OhelperWhereUniqueInput
    update: XOR<OhelperUpdateWithoutToolInput, OhelperUncheckedUpdateWithoutToolInput>
    create: XOR<OhelperCreateWithoutToolInput, OhelperUncheckedCreateWithoutToolInput>
  }

  export type OhelperUpdateWithWhereUniqueWithoutToolInput = {
    where: OhelperWhereUniqueInput
    data: XOR<OhelperUpdateWithoutToolInput, OhelperUncheckedUpdateWithoutToolInput>
  }

  export type OhelperUpdateManyWithWhereWithoutToolInput = {
    where: OhelperScalarWhereInput
    data: XOR<OhelperUpdateManyMutationInput, OhelperUncheckedUpdateManyWithoutToolInput>
  }

  export type OhelperScalarWhereInput = {
    AND?: Enumerable<OhelperScalarWhereInput>
    OR?: Enumerable<OhelperScalarWhereInput>
    NOT?: Enumerable<OhelperScalarWhereInput>
    id?: StringFilter | string
    type?: EnumOhelperTypeFilter | OhelperType
    name?: StringFilter | string
    toolIds?: StringNullableListFilter
    mateIds?: StringNullableListFilter
    methIds?: StringNullableListFilter
    mediaIds?: StringNullableListFilter
  }

  export type OhelperUpsertWithWhereUniqueWithoutMateInput = {
    where: OhelperWhereUniqueInput
    update: XOR<OhelperUpdateWithoutMateInput, OhelperUncheckedUpdateWithoutMateInput>
    create: XOR<OhelperCreateWithoutMateInput, OhelperUncheckedCreateWithoutMateInput>
  }

  export type OhelperUpdateWithWhereUniqueWithoutMateInput = {
    where: OhelperWhereUniqueInput
    data: XOR<OhelperUpdateWithoutMateInput, OhelperUncheckedUpdateWithoutMateInput>
  }

  export type OhelperUpdateManyWithWhereWithoutMateInput = {
    where: OhelperScalarWhereInput
    data: XOR<OhelperUpdateManyMutationInput, OhelperUncheckedUpdateManyWithoutMateInput>
  }

  export type OhelperUpsertWithWhereUniqueWithoutMethInput = {
    where: OhelperWhereUniqueInput
    update: XOR<OhelperUpdateWithoutMethInput, OhelperUncheckedUpdateWithoutMethInput>
    create: XOR<OhelperCreateWithoutMethInput, OhelperUncheckedCreateWithoutMethInput>
  }

  export type OhelperUpdateWithWhereUniqueWithoutMethInput = {
    where: OhelperWhereUniqueInput
    data: XOR<OhelperUpdateWithoutMethInput, OhelperUncheckedUpdateWithoutMethInput>
  }

  export type OhelperUpdateManyWithWhereWithoutMethInput = {
    where: OhelperScalarWhereInput
    data: XOR<OhelperUpdateManyMutationInput, OhelperUncheckedUpdateManyWithoutMethInput>
  }

  export type OhelperUpsertWithWhereUniqueWithoutMediaInput = {
    where: OhelperWhereUniqueInput
    update: XOR<OhelperUpdateWithoutMediaInput, OhelperUncheckedUpdateWithoutMediaInput>
    create: XOR<OhelperCreateWithoutMediaInput, OhelperUncheckedCreateWithoutMediaInput>
  }

  export type OhelperUpdateWithWhereUniqueWithoutMediaInput = {
    where: OhelperWhereUniqueInput
    data: XOR<OhelperUpdateWithoutMediaInput, OhelperUncheckedUpdateWithoutMediaInput>
  }

  export type OhelperUpdateManyWithWhereWithoutMediaInput = {
    where: OhelperScalarWhereInput
    data: XOR<OhelperUpdateManyMutationInput, OhelperUncheckedUpdateManyWithoutMediaInput>
  }

  export type OAssessmentUpsertWithWhereUniqueWithoutRefInput = {
    where: OAssessmentWhereUniqueInput
    update: XOR<OAssessmentUpdateWithoutRefInput, OAssessmentUncheckedUpdateWithoutRefInput>
    create: XOR<OAssessmentCreateWithoutRefInput, OAssessmentUncheckedCreateWithoutRefInput>
  }

  export type OAssessmentUpdateWithWhereUniqueWithoutRefInput = {
    where: OAssessmentWhereUniqueInput
    data: XOR<OAssessmentUpdateWithoutRefInput, OAssessmentUncheckedUpdateWithoutRefInput>
  }

  export type OAssessmentUpdateManyWithWhereWithoutRefInput = {
    where: OAssessmentScalarWhereInput
    data: XOR<OAssessmentUpdateManyMutationInput, OAssessmentUncheckedUpdateManyWithoutAssessmentsInput>
  }

  export type OAssessmentScalarWhereInput = {
    AND?: Enumerable<OAssessmentScalarWhereInput>
    OR?: Enumerable<OAssessmentScalarWhereInput>
    NOT?: Enumerable<OAssessmentScalarWhereInput>
    id?: StringFilter | string
    refId?: StringFilter | string
    type?: StringFilter | string
    techs?: StringNullableListFilter
  }

  export type TDeviceDataUpsertWithWhereUniqueWithoutObjectiveInput = {
    where: TDeviceDataWhereUniqueInput
    update: XOR<TDeviceDataUpdateWithoutObjectiveInput, TDeviceDataUncheckedUpdateWithoutObjectiveInput>
    create: XOR<TDeviceDataCreateWithoutObjectiveInput, TDeviceDataUncheckedCreateWithoutObjectiveInput>
  }

  export type TDeviceDataUpdateWithWhereUniqueWithoutObjectiveInput = {
    where: TDeviceDataWhereUniqueInput
    data: XOR<TDeviceDataUpdateWithoutObjectiveInput, TDeviceDataUncheckedUpdateWithoutObjectiveInput>
  }

  export type TDeviceDataUpdateManyWithWhereWithoutObjectiveInput = {
    where: TDeviceDataScalarWhereInput
    data: XOR<TDeviceDataUpdateManyMutationInput, TDeviceDataUncheckedUpdateManyWithoutDevicesInput>
  }

  export type TDeviceDataScalarWhereInput = {
    AND?: Enumerable<TDeviceDataScalarWhereInput>
    OR?: Enumerable<TDeviceDataScalarWhereInput>
    NOT?: Enumerable<TDeviceDataScalarWhereInput>
    id?: StringFilter | string
    refId?: StringFilter | string
    objectiveId?: StringFilter | string
  }

  export type ObjectiveCreateWithoutMaterialInput = {
    id?: string
    level: number
    fase: Fase
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    user: UserCreateNestedOneWithoutObjectiveInput
    instansi: InstansiCreateNestedOneWithoutObjectiveInput
    year: SchoolYearCreateNestedOneWithoutObjectiveInput
    mapel: MataPelajaranCreateNestedOneWithoutObjectiveInput
    elemen: ElementCreateNestedOneWithoutObjectiveInput
    achievement: AchievementCreateNestedOneWithoutObjectiveInput
    tracker?: TrackerCreateNestedManyWithoutTujuanInput
    resourse?: OresourceCreateNestedManyWithoutRefInput
    ppp?: OpppCreateNestedManyWithoutRefInput
    tool?: OhelperCreateNestedManyWithoutToolInput
    mate?: OhelperCreateNestedManyWithoutMateInput
    meth?: OhelperCreateNestedManyWithoutMethInput
    media?: OhelperCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentCreateNestedManyWithoutRefInput
    devices?: TDeviceDataCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveUncheckedCreateWithoutMaterialInput = {
    id?: string
    level: number
    fase: Fase
    userId: string
    instansiId: string
    yearId: string
    mapelId: string
    elementId: string
    achievementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
    tracker?: TrackerUncheckedCreateNestedManyWithoutTujuanInput
    resourse?: OresourceUncheckedCreateNestedManyWithoutRefInput
    ppp?: OpppUncheckedCreateNestedManyWithoutRefInput
    tool?: OhelperUncheckedCreateNestedManyWithoutToolInput
    mate?: OhelperUncheckedCreateNestedManyWithoutMateInput
    meth?: OhelperUncheckedCreateNestedManyWithoutMethInput
    media?: OhelperUncheckedCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentUncheckedCreateNestedManyWithoutRefInput
    devices?: TDeviceDataUncheckedCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveCreateOrConnectWithoutMaterialInput = {
    where: ObjectiveWhereUniqueInput
    create: XOR<ObjectiveCreateWithoutMaterialInput, ObjectiveUncheckedCreateWithoutMaterialInput>
  }

  export type OLearningCreateWithoutRefInput = {
    id?: string
    no: number
    content: string
    taksonomi: Taksonomi
    sentence: string
  }

  export type OLearningUncheckedCreateWithoutRefInput = {
    id?: string
    no: number
    content: string
    taksonomi: Taksonomi
    sentence: string
  }

  export type OLearningCreateOrConnectWithoutRefInput = {
    where: OLearningWhereUniqueInput
    create: XOR<OLearningCreateWithoutRefInput, OLearningUncheckedCreateWithoutRefInput>
  }

  export type OLearningCreateManyRefInputEnvelope = {
    data: Enumerable<OLearningCreateManyRefInput>
  }

  export type ObjectiveUpsertWithoutMaterialInput = {
    update: XOR<ObjectiveUpdateWithoutMaterialInput, ObjectiveUncheckedUpdateWithoutMaterialInput>
    create: XOR<ObjectiveCreateWithoutMaterialInput, ObjectiveUncheckedCreateWithoutMaterialInput>
  }

  export type ObjectiveUpdateWithoutMaterialInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutObjectiveNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutObjectiveNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutObjectiveNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutObjectiveNestedInput
    elemen?: ElementUpdateOneRequiredWithoutObjectiveNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutObjectiveNestedInput
    tracker?: TrackerUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUpdateManyWithoutRefNestedInput
    ppp?: OpppUpdateManyWithoutRefNestedInput
    tool?: OhelperUpdateManyWithoutToolNestedInput
    mate?: OhelperUpdateManyWithoutMateNestedInput
    meth?: OhelperUpdateManyWithoutMethNestedInput
    media?: OhelperUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateWithoutMaterialInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    toolIds?: ObjectiveUpdatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveUpdatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveUpdatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveUpdatemediaIdsInput | Enumerable<string>
    tracker?: TrackerUncheckedUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUncheckedUpdateManyWithoutRefNestedInput
    ppp?: OpppUncheckedUpdateManyWithoutRefNestedInput
    tool?: OhelperUncheckedUpdateManyWithoutToolNestedInput
    mate?: OhelperUncheckedUpdateManyWithoutMateNestedInput
    meth?: OhelperUncheckedUpdateManyWithoutMethNestedInput
    media?: OhelperUncheckedUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUncheckedUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUncheckedUpdateManyWithoutObjectiveNestedInput
  }

  export type OLearningUpsertWithWhereUniqueWithoutRefInput = {
    where: OLearningWhereUniqueInput
    update: XOR<OLearningUpdateWithoutRefInput, OLearningUncheckedUpdateWithoutRefInput>
    create: XOR<OLearningCreateWithoutRefInput, OLearningUncheckedCreateWithoutRefInput>
  }

  export type OLearningUpdateWithWhereUniqueWithoutRefInput = {
    where: OLearningWhereUniqueInput
    data: XOR<OLearningUpdateWithoutRefInput, OLearningUncheckedUpdateWithoutRefInput>
  }

  export type OLearningUpdateManyWithWhereWithoutRefInput = {
    where: OLearningScalarWhereInput
    data: XOR<OLearningUpdateManyMutationInput, OLearningUncheckedUpdateManyWithoutLearningInput>
  }

  export type OLearningScalarWhereInput = {
    AND?: Enumerable<OLearningScalarWhereInput>
    OR?: Enumerable<OLearningScalarWhereInput>
    NOT?: Enumerable<OLearningScalarWhereInput>
    id?: StringFilter | string
    refId?: StringFilter | string
    no?: IntFilter | number
    content?: StringFilter | string
    taksonomi?: EnumTaksonomiFilter | Taksonomi
    sentence?: StringFilter | string
  }

  export type OMaterialCreateWithoutLearningInput = {
    id?: string
    no: number
    content: string
    model: OMaterialModel
    ref: ObjectiveCreateNestedOneWithoutMaterialInput
  }

  export type OMaterialUncheckedCreateWithoutLearningInput = {
    id?: string
    refId: string
    no: number
    content: string
    model: OMaterialModel
  }

  export type OMaterialCreateOrConnectWithoutLearningInput = {
    where: OMaterialWhereUniqueInput
    create: XOR<OMaterialCreateWithoutLearningInput, OMaterialUncheckedCreateWithoutLearningInput>
  }

  export type OMaterialUpsertWithoutLearningInput = {
    update: XOR<OMaterialUpdateWithoutLearningInput, OMaterialUncheckedUpdateWithoutLearningInput>
    create: XOR<OMaterialCreateWithoutLearningInput, OMaterialUncheckedCreateWithoutLearningInput>
  }

  export type OMaterialUpdateWithoutLearningInput = {
    no?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    model?: EnumOMaterialModelFieldUpdateOperationsInput | OMaterialModel
    ref?: ObjectiveUpdateOneRequiredWithoutMaterialNestedInput
  }

  export type OMaterialUncheckedUpdateWithoutLearningInput = {
    refId?: StringFieldUpdateOperationsInput | string
    no?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    model?: EnumOMaterialModelFieldUpdateOperationsInput | OMaterialModel
  }

  export type ObjectiveCreateWithoutToolInput = {
    id?: string
    level: number
    fase: Fase
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    user: UserCreateNestedOneWithoutObjectiveInput
    instansi: InstansiCreateNestedOneWithoutObjectiveInput
    year: SchoolYearCreateNestedOneWithoutObjectiveInput
    mapel: MataPelajaranCreateNestedOneWithoutObjectiveInput
    elemen: ElementCreateNestedOneWithoutObjectiveInput
    achievement: AchievementCreateNestedOneWithoutObjectiveInput
    material?: OMaterialCreateNestedManyWithoutRefInput
    tracker?: TrackerCreateNestedManyWithoutTujuanInput
    resourse?: OresourceCreateNestedManyWithoutRefInput
    ppp?: OpppCreateNestedManyWithoutRefInput
    mate?: OhelperCreateNestedManyWithoutMateInput
    meth?: OhelperCreateNestedManyWithoutMethInput
    media?: OhelperCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentCreateNestedManyWithoutRefInput
    devices?: TDeviceDataCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveUncheckedCreateWithoutToolInput = {
    id?: string
    level: number
    fase: Fase
    userId: string
    instansiId: string
    yearId: string
    mapelId: string
    elementId: string
    achievementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedCreateNestedManyWithoutRefInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTujuanInput
    resourse?: OresourceUncheckedCreateNestedManyWithoutRefInput
    ppp?: OpppUncheckedCreateNestedManyWithoutRefInput
    mate?: OhelperUncheckedCreateNestedManyWithoutMateInput
    meth?: OhelperUncheckedCreateNestedManyWithoutMethInput
    media?: OhelperUncheckedCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentUncheckedCreateNestedManyWithoutRefInput
    devices?: TDeviceDataUncheckedCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveCreateOrConnectWithoutToolInput = {
    where: ObjectiveWhereUniqueInput
    create: XOR<ObjectiveCreateWithoutToolInput, ObjectiveUncheckedCreateWithoutToolInput>
  }

  export type ObjectiveCreateWithoutMateInput = {
    id?: string
    level: number
    fase: Fase
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    user: UserCreateNestedOneWithoutObjectiveInput
    instansi: InstansiCreateNestedOneWithoutObjectiveInput
    year: SchoolYearCreateNestedOneWithoutObjectiveInput
    mapel: MataPelajaranCreateNestedOneWithoutObjectiveInput
    elemen: ElementCreateNestedOneWithoutObjectiveInput
    achievement: AchievementCreateNestedOneWithoutObjectiveInput
    material?: OMaterialCreateNestedManyWithoutRefInput
    tracker?: TrackerCreateNestedManyWithoutTujuanInput
    resourse?: OresourceCreateNestedManyWithoutRefInput
    ppp?: OpppCreateNestedManyWithoutRefInput
    tool?: OhelperCreateNestedManyWithoutToolInput
    meth?: OhelperCreateNestedManyWithoutMethInput
    media?: OhelperCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentCreateNestedManyWithoutRefInput
    devices?: TDeviceDataCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveUncheckedCreateWithoutMateInput = {
    id?: string
    level: number
    fase: Fase
    userId: string
    instansiId: string
    yearId: string
    mapelId: string
    elementId: string
    achievementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedCreateNestedManyWithoutRefInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTujuanInput
    resourse?: OresourceUncheckedCreateNestedManyWithoutRefInput
    ppp?: OpppUncheckedCreateNestedManyWithoutRefInput
    tool?: OhelperUncheckedCreateNestedManyWithoutToolInput
    meth?: OhelperUncheckedCreateNestedManyWithoutMethInput
    media?: OhelperUncheckedCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentUncheckedCreateNestedManyWithoutRefInput
    devices?: TDeviceDataUncheckedCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveCreateOrConnectWithoutMateInput = {
    where: ObjectiveWhereUniqueInput
    create: XOR<ObjectiveCreateWithoutMateInput, ObjectiveUncheckedCreateWithoutMateInput>
  }

  export type ObjectiveCreateWithoutMethInput = {
    id?: string
    level: number
    fase: Fase
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    user: UserCreateNestedOneWithoutObjectiveInput
    instansi: InstansiCreateNestedOneWithoutObjectiveInput
    year: SchoolYearCreateNestedOneWithoutObjectiveInput
    mapel: MataPelajaranCreateNestedOneWithoutObjectiveInput
    elemen: ElementCreateNestedOneWithoutObjectiveInput
    achievement: AchievementCreateNestedOneWithoutObjectiveInput
    material?: OMaterialCreateNestedManyWithoutRefInput
    tracker?: TrackerCreateNestedManyWithoutTujuanInput
    resourse?: OresourceCreateNestedManyWithoutRefInput
    ppp?: OpppCreateNestedManyWithoutRefInput
    tool?: OhelperCreateNestedManyWithoutToolInput
    mate?: OhelperCreateNestedManyWithoutMateInput
    media?: OhelperCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentCreateNestedManyWithoutRefInput
    devices?: TDeviceDataCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveUncheckedCreateWithoutMethInput = {
    id?: string
    level: number
    fase: Fase
    userId: string
    instansiId: string
    yearId: string
    mapelId: string
    elementId: string
    achievementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedCreateNestedManyWithoutRefInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTujuanInput
    resourse?: OresourceUncheckedCreateNestedManyWithoutRefInput
    ppp?: OpppUncheckedCreateNestedManyWithoutRefInput
    tool?: OhelperUncheckedCreateNestedManyWithoutToolInput
    mate?: OhelperUncheckedCreateNestedManyWithoutMateInput
    media?: OhelperUncheckedCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentUncheckedCreateNestedManyWithoutRefInput
    devices?: TDeviceDataUncheckedCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveCreateOrConnectWithoutMethInput = {
    where: ObjectiveWhereUniqueInput
    create: XOR<ObjectiveCreateWithoutMethInput, ObjectiveUncheckedCreateWithoutMethInput>
  }

  export type ObjectiveCreateWithoutMediaInput = {
    id?: string
    level: number
    fase: Fase
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    user: UserCreateNestedOneWithoutObjectiveInput
    instansi: InstansiCreateNestedOneWithoutObjectiveInput
    year: SchoolYearCreateNestedOneWithoutObjectiveInput
    mapel: MataPelajaranCreateNestedOneWithoutObjectiveInput
    elemen: ElementCreateNestedOneWithoutObjectiveInput
    achievement: AchievementCreateNestedOneWithoutObjectiveInput
    material?: OMaterialCreateNestedManyWithoutRefInput
    tracker?: TrackerCreateNestedManyWithoutTujuanInput
    resourse?: OresourceCreateNestedManyWithoutRefInput
    ppp?: OpppCreateNestedManyWithoutRefInput
    tool?: OhelperCreateNestedManyWithoutToolInput
    mate?: OhelperCreateNestedManyWithoutMateInput
    meth?: OhelperCreateNestedManyWithoutMethInput
    assessments?: OAssessmentCreateNestedManyWithoutRefInput
    devices?: TDeviceDataCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveUncheckedCreateWithoutMediaInput = {
    id?: string
    level: number
    fase: Fase
    userId: string
    instansiId: string
    yearId: string
    mapelId: string
    elementId: string
    achievementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedCreateNestedManyWithoutRefInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTujuanInput
    resourse?: OresourceUncheckedCreateNestedManyWithoutRefInput
    ppp?: OpppUncheckedCreateNestedManyWithoutRefInput
    tool?: OhelperUncheckedCreateNestedManyWithoutToolInput
    mate?: OhelperUncheckedCreateNestedManyWithoutMateInput
    meth?: OhelperUncheckedCreateNestedManyWithoutMethInput
    assessments?: OAssessmentUncheckedCreateNestedManyWithoutRefInput
    devices?: TDeviceDataUncheckedCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveCreateOrConnectWithoutMediaInput = {
    where: ObjectiveWhereUniqueInput
    create: XOR<ObjectiveCreateWithoutMediaInput, ObjectiveUncheckedCreateWithoutMediaInput>
  }

  export type ObjectiveUpsertWithWhereUniqueWithoutToolInput = {
    where: ObjectiveWhereUniqueInput
    update: XOR<ObjectiveUpdateWithoutToolInput, ObjectiveUncheckedUpdateWithoutToolInput>
    create: XOR<ObjectiveCreateWithoutToolInput, ObjectiveUncheckedCreateWithoutToolInput>
  }

  export type ObjectiveUpdateWithWhereUniqueWithoutToolInput = {
    where: ObjectiveWhereUniqueInput
    data: XOR<ObjectiveUpdateWithoutToolInput, ObjectiveUncheckedUpdateWithoutToolInput>
  }

  export type ObjectiveUpdateManyWithWhereWithoutToolInput = {
    where: ObjectiveScalarWhereInput
    data: XOR<ObjectiveUpdateManyMutationInput, ObjectiveUncheckedUpdateManyWithoutToolInput>
  }

  export type ObjectiveUpsertWithWhereUniqueWithoutMateInput = {
    where: ObjectiveWhereUniqueInput
    update: XOR<ObjectiveUpdateWithoutMateInput, ObjectiveUncheckedUpdateWithoutMateInput>
    create: XOR<ObjectiveCreateWithoutMateInput, ObjectiveUncheckedCreateWithoutMateInput>
  }

  export type ObjectiveUpdateWithWhereUniqueWithoutMateInput = {
    where: ObjectiveWhereUniqueInput
    data: XOR<ObjectiveUpdateWithoutMateInput, ObjectiveUncheckedUpdateWithoutMateInput>
  }

  export type ObjectiveUpdateManyWithWhereWithoutMateInput = {
    where: ObjectiveScalarWhereInput
    data: XOR<ObjectiveUpdateManyMutationInput, ObjectiveUncheckedUpdateManyWithoutMateInput>
  }

  export type ObjectiveUpsertWithWhereUniqueWithoutMethInput = {
    where: ObjectiveWhereUniqueInput
    update: XOR<ObjectiveUpdateWithoutMethInput, ObjectiveUncheckedUpdateWithoutMethInput>
    create: XOR<ObjectiveCreateWithoutMethInput, ObjectiveUncheckedCreateWithoutMethInput>
  }

  export type ObjectiveUpdateWithWhereUniqueWithoutMethInput = {
    where: ObjectiveWhereUniqueInput
    data: XOR<ObjectiveUpdateWithoutMethInput, ObjectiveUncheckedUpdateWithoutMethInput>
  }

  export type ObjectiveUpdateManyWithWhereWithoutMethInput = {
    where: ObjectiveScalarWhereInput
    data: XOR<ObjectiveUpdateManyMutationInput, ObjectiveUncheckedUpdateManyWithoutMethInput>
  }

  export type ObjectiveUpsertWithWhereUniqueWithoutMediaInput = {
    where: ObjectiveWhereUniqueInput
    update: XOR<ObjectiveUpdateWithoutMediaInput, ObjectiveUncheckedUpdateWithoutMediaInput>
    create: XOR<ObjectiveCreateWithoutMediaInput, ObjectiveUncheckedCreateWithoutMediaInput>
  }

  export type ObjectiveUpdateWithWhereUniqueWithoutMediaInput = {
    where: ObjectiveWhereUniqueInput
    data: XOR<ObjectiveUpdateWithoutMediaInput, ObjectiveUncheckedUpdateWithoutMediaInput>
  }

  export type ObjectiveUpdateManyWithWhereWithoutMediaInput = {
    where: ObjectiveScalarWhereInput
    data: XOR<ObjectiveUpdateManyMutationInput, ObjectiveUncheckedUpdateManyWithoutMediaInput>
  }

  export type ObjectiveCreateWithoutPppInput = {
    id?: string
    level: number
    fase: Fase
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    user: UserCreateNestedOneWithoutObjectiveInput
    instansi: InstansiCreateNestedOneWithoutObjectiveInput
    year: SchoolYearCreateNestedOneWithoutObjectiveInput
    mapel: MataPelajaranCreateNestedOneWithoutObjectiveInput
    elemen: ElementCreateNestedOneWithoutObjectiveInput
    achievement: AchievementCreateNestedOneWithoutObjectiveInput
    material?: OMaterialCreateNestedManyWithoutRefInput
    tracker?: TrackerCreateNestedManyWithoutTujuanInput
    resourse?: OresourceCreateNestedManyWithoutRefInput
    tool?: OhelperCreateNestedManyWithoutToolInput
    mate?: OhelperCreateNestedManyWithoutMateInput
    meth?: OhelperCreateNestedManyWithoutMethInput
    media?: OhelperCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentCreateNestedManyWithoutRefInput
    devices?: TDeviceDataCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveUncheckedCreateWithoutPppInput = {
    id?: string
    level: number
    fase: Fase
    userId: string
    instansiId: string
    yearId: string
    mapelId: string
    elementId: string
    achievementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedCreateNestedManyWithoutRefInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTujuanInput
    resourse?: OresourceUncheckedCreateNestedManyWithoutRefInput
    tool?: OhelperUncheckedCreateNestedManyWithoutToolInput
    mate?: OhelperUncheckedCreateNestedManyWithoutMateInput
    meth?: OhelperUncheckedCreateNestedManyWithoutMethInput
    media?: OhelperUncheckedCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentUncheckedCreateNestedManyWithoutRefInput
    devices?: TDeviceDataUncheckedCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveCreateOrConnectWithoutPppInput = {
    where: ObjectiveWhereUniqueInput
    create: XOR<ObjectiveCreateWithoutPppInput, ObjectiveUncheckedCreateWithoutPppInput>
  }

  export type ObjectiveUpsertWithoutPppInput = {
    update: XOR<ObjectiveUpdateWithoutPppInput, ObjectiveUncheckedUpdateWithoutPppInput>
    create: XOR<ObjectiveCreateWithoutPppInput, ObjectiveUncheckedCreateWithoutPppInput>
  }

  export type ObjectiveUpdateWithoutPppInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutObjectiveNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutObjectiveNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutObjectiveNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutObjectiveNestedInput
    elemen?: ElementUpdateOneRequiredWithoutObjectiveNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutObjectiveNestedInput
    material?: OMaterialUpdateManyWithoutRefNestedInput
    tracker?: TrackerUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUpdateManyWithoutRefNestedInput
    tool?: OhelperUpdateManyWithoutToolNestedInput
    mate?: OhelperUpdateManyWithoutMateNestedInput
    meth?: OhelperUpdateManyWithoutMethNestedInput
    media?: OhelperUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateWithoutPppInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    toolIds?: ObjectiveUpdatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveUpdatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveUpdatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveUpdatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedUpdateManyWithoutRefNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUncheckedUpdateManyWithoutRefNestedInput
    tool?: OhelperUncheckedUpdateManyWithoutToolNestedInput
    mate?: OhelperUncheckedUpdateManyWithoutMateNestedInput
    meth?: OhelperUncheckedUpdateManyWithoutMethNestedInput
    media?: OhelperUncheckedUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUncheckedUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUncheckedUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveCreateWithoutResourseInput = {
    id?: string
    level: number
    fase: Fase
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    user: UserCreateNestedOneWithoutObjectiveInput
    instansi: InstansiCreateNestedOneWithoutObjectiveInput
    year: SchoolYearCreateNestedOneWithoutObjectiveInput
    mapel: MataPelajaranCreateNestedOneWithoutObjectiveInput
    elemen: ElementCreateNestedOneWithoutObjectiveInput
    achievement: AchievementCreateNestedOneWithoutObjectiveInput
    material?: OMaterialCreateNestedManyWithoutRefInput
    tracker?: TrackerCreateNestedManyWithoutTujuanInput
    ppp?: OpppCreateNestedManyWithoutRefInput
    tool?: OhelperCreateNestedManyWithoutToolInput
    mate?: OhelperCreateNestedManyWithoutMateInput
    meth?: OhelperCreateNestedManyWithoutMethInput
    media?: OhelperCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentCreateNestedManyWithoutRefInput
    devices?: TDeviceDataCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveUncheckedCreateWithoutResourseInput = {
    id?: string
    level: number
    fase: Fase
    userId: string
    instansiId: string
    yearId: string
    mapelId: string
    elementId: string
    achievementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedCreateNestedManyWithoutRefInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTujuanInput
    ppp?: OpppUncheckedCreateNestedManyWithoutRefInput
    tool?: OhelperUncheckedCreateNestedManyWithoutToolInput
    mate?: OhelperUncheckedCreateNestedManyWithoutMateInput
    meth?: OhelperUncheckedCreateNestedManyWithoutMethInput
    media?: OhelperUncheckedCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentUncheckedCreateNestedManyWithoutRefInput
    devices?: TDeviceDataUncheckedCreateNestedManyWithoutObjectiveInput
  }

  export type ObjectiveCreateOrConnectWithoutResourseInput = {
    where: ObjectiveWhereUniqueInput
    create: XOR<ObjectiveCreateWithoutResourseInput, ObjectiveUncheckedCreateWithoutResourseInput>
  }

  export type LinkCreateWithoutObjResourceInput = {
    id?: string
    url?: string | null
    title: string
    description?: string | null
    image?: string | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLinkInput
  }

  export type LinkUncheckedCreateWithoutObjResourceInput = {
    id?: string
    url?: string | null
    title: string
    description?: string | null
    image?: string | null
    width?: number | null
    height?: number | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinkCreateOrConnectWithoutObjResourceInput = {
    where: LinkWhereUniqueInput
    create: XOR<LinkCreateWithoutObjResourceInput, LinkUncheckedCreateWithoutObjResourceInput>
  }

  export type ObjectiveUpsertWithoutResourseInput = {
    update: XOR<ObjectiveUpdateWithoutResourseInput, ObjectiveUncheckedUpdateWithoutResourseInput>
    create: XOR<ObjectiveCreateWithoutResourseInput, ObjectiveUncheckedCreateWithoutResourseInput>
  }

  export type ObjectiveUpdateWithoutResourseInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutObjectiveNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutObjectiveNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutObjectiveNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutObjectiveNestedInput
    elemen?: ElementUpdateOneRequiredWithoutObjectiveNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutObjectiveNestedInput
    material?: OMaterialUpdateManyWithoutRefNestedInput
    tracker?: TrackerUpdateManyWithoutTujuanNestedInput
    ppp?: OpppUpdateManyWithoutRefNestedInput
    tool?: OhelperUpdateManyWithoutToolNestedInput
    mate?: OhelperUpdateManyWithoutMateNestedInput
    meth?: OhelperUpdateManyWithoutMethNestedInput
    media?: OhelperUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateWithoutResourseInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    toolIds?: ObjectiveUpdatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveUpdatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveUpdatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveUpdatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedUpdateManyWithoutRefNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTujuanNestedInput
    ppp?: OpppUncheckedUpdateManyWithoutRefNestedInput
    tool?: OhelperUncheckedUpdateManyWithoutToolNestedInput
    mate?: OhelperUncheckedUpdateManyWithoutMateNestedInput
    meth?: OhelperUncheckedUpdateManyWithoutMethNestedInput
    media?: OhelperUncheckedUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUncheckedUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUncheckedUpdateManyWithoutObjectiveNestedInput
  }

  export type LinkUpsertWithoutObjResourceInput = {
    update: XOR<LinkUpdateWithoutObjResourceInput, LinkUncheckedUpdateWithoutObjResourceInput>
    create: XOR<LinkCreateWithoutObjResourceInput, LinkUncheckedCreateWithoutObjResourceInput>
  }

  export type LinkUpdateWithoutObjResourceInput = {
    url?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLinkNestedInput
  }

  export type LinkUncheckedUpdateWithoutObjResourceInput = {
    url?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeachingCreateWithoutTDeviceInput = {
    id?: string
    level: number
    hours: number
    semester: Semester
    disable?: boolean
    ref: ScheduleCreateNestedOneWithoutTeachingInput
    teacher: TeacherCreateNestedOneWithoutTeachingInput
    classRoom?: ClassRoomCreateNestedManyWithoutTeachingInput
    elemen?: ElementCreateNestedManyWithoutScheduleClassInput
    tracker?: TrackerCreateNestedManyWithoutMengajarInput
  }

  export type TeachingUncheckedCreateWithoutTDeviceInput = {
    id?: string
    refId: string
    level: number
    hours: number
    semester: Semester
    teacherId: string
    classRoomIds?: TeachingCreateclassRoomIdsInput | Enumerable<string>
    elemenIds?: TeachingCreateelemenIdsInput | Enumerable<string>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutTeachingInput
    elemen?: ElementUncheckedCreateNestedManyWithoutScheduleClassInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutMengajarInput
  }

  export type TeachingCreateOrConnectWithoutTDeviceInput = {
    where: TeachingWhereUniqueInput
    create: XOR<TeachingCreateWithoutTDeviceInput, TeachingUncheckedCreateWithoutTDeviceInput>
  }

  export type SchoolYearCreateWithoutTDeviceInput = {
    id?: string
    year: number
    departments?: SchoolYearCreatedepartmentsInput | Enumerable<string>
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    disable?: boolean
    instansi: InstansiCreateNestedOneWithoutSchoolYearInput
    classRoom?: ClassRoomCreateNestedManyWithoutYearInput
    students?: StudentCreateNestedManyWithoutStartYearInput
    calendar?: CalendarCreateNestedManyWithoutRefInput
    schedule?: ScheduleCreateNestedManyWithoutYearInput
    objective?: ObjectiveCreateNestedManyWithoutYearInput
    tracker?: TrackerCreateNestedManyWithoutTpInput
  }

  export type SchoolYearUncheckedCreateWithoutTDeviceInput = {
    id?: string
    year: number
    instansiId: string
    departments?: SchoolYearCreatedepartmentsInput | Enumerable<string>
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutYearInput
    students?: StudentUncheckedCreateNestedManyWithoutStartYearInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutRefInput
    schedule?: ScheduleUncheckedCreateNestedManyWithoutYearInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutYearInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTpInput
  }

  export type SchoolYearCreateOrConnectWithoutTDeviceInput = {
    where: SchoolYearWhereUniqueInput
    create: XOR<SchoolYearCreateWithoutTDeviceInput, SchoolYearUncheckedCreateWithoutTDeviceInput>
  }

  export type UserCreateWithoutTDeviceInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    disable?: boolean
    google?: XOR<GoogleNullableCreateEnvelopeInput, GoogleCreateInput> | null
    role?: RoleCreateNestedOneWithoutUsersInput
    auth?: AuthCreateNestedOneWithoutUserInput
    tracker?: TrackerCreateNestedManyWithoutUserInput
    objective?: ObjectiveCreateNestedManyWithoutUserInput
    link?: LinkCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTDeviceInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    roleId?: string | null
    disable?: boolean
    google?: XOR<GoogleNullableCreateEnvelopeInput, GoogleCreateInput> | null
    auth?: AuthUncheckedCreateNestedOneWithoutUserInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutUserInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutUserInput
    link?: LinkUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTDeviceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTDeviceInput, UserUncheckedCreateWithoutTDeviceInput>
  }

  export type InstansiCreateWithoutTDeviceInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    disable?: boolean
    majors?: KonsentrasiKeahlianCreateNestedManyWithoutInstansiInput
    role?: RoleCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearCreateNestedManyWithoutInstansiInput
    teacher?: TeacherCreateNestedManyWithoutInstansiInput
    student?: StudentCreateNestedManyWithoutInstansiInput
    tracker?: TrackerCreateNestedManyWithoutInstansiInput
    history?: TrackerCreateNestedManyWithoutRefInput
    unikMapels?: MataPelajaranCreateNestedManyWithoutInstansiInput
    objective?: ObjectiveCreateNestedManyWithoutInstansiInput
    dudi?: DudiCreateNestedManyWithoutInstansiInput
  }

  export type InstansiUncheckedCreateWithoutTDeviceInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    majorIds?: InstansiCreatemajorIdsInput | Enumerable<string>
    disable?: boolean
    majors?: KonsentrasiKeahlianUncheckedCreateNestedManyWithoutInstansiInput
    role?: RoleUncheckedCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearUncheckedCreateNestedManyWithoutInstansiInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutInstansiInput
    student?: StudentUncheckedCreateNestedManyWithoutInstansiInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutInstansiInput
    history?: TrackerUncheckedCreateNestedManyWithoutRefInput
    unikMapels?: MataPelajaranUncheckedCreateNestedManyWithoutInstansiInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutInstansiInput
    dudi?: DudiUncheckedCreateNestedManyWithoutInstansiInput
  }

  export type InstansiCreateOrConnectWithoutTDeviceInput = {
    where: InstansiWhereUniqueInput
    create: XOR<InstansiCreateWithoutTDeviceInput, InstansiUncheckedCreateWithoutTDeviceInput>
  }

  export type MataPelajaranCreateWithoutDeviceInput = {
    id?: string
    level?: Level | null
    type?: MataPelajaranType
    no: string
    code: string
    name: string
    religion?: Religion | null
    disable?: boolean
    program?: ProgramKeahlianCreateNestedOneWithoutMapelInput
    keahlian?: KonsentrasiKeahlianCreateNestedOneWithoutMapelInput
    instansi?: InstansiCreateNestedOneWithoutUnikMapelsInput
    element?: ElementCreateNestedManyWithoutMapelInput
    schedule?: ScheduleCreateNestedManyWithoutMapelInput
    tracker?: TrackerCreateNestedManyWithoutMapelInput
    objective?: ObjectiveCreateNestedManyWithoutMapelInput
  }

  export type MataPelajaranUncheckedCreateWithoutDeviceInput = {
    id?: string
    level?: Level | null
    type?: MataPelajaranType
    no: string
    code: string
    name: string
    religion?: Religion | null
    programId?: string | null
    keahlianid?: string | null
    instansiId?: string | null
    disable?: boolean
    element?: ElementUncheckedCreateNestedManyWithoutMapelInput
    schedule?: ScheduleUncheckedCreateNestedManyWithoutMapelInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutMapelInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutMapelInput
  }

  export type MataPelajaranCreateOrConnectWithoutDeviceInput = {
    where: MataPelajaranWhereUniqueInput
    create: XOR<MataPelajaranCreateWithoutDeviceInput, MataPelajaranUncheckedCreateWithoutDeviceInput>
  }

  export type ClassRoomCreateWithoutTDeviceInput = {
    id?: string
    name: string
    level: number
    property?: XOR<RoomPropertyNullableCreateEnvelopeInput, RoomPropertyCreateInput> | null
    disable?: boolean
    year: SchoolYearCreateNestedOneWithoutClassRoomInput
    wali: TeacherCreateNestedOneWithoutClassRoomInput
    major?: KonsentrasiKeahlianCreateNestedOneWithoutClassRoomInput
    students?: StudentCreateNestedManyWithoutClassRoomInput
    event?: CalendarCreateNestedManyWithoutClassRoomInput
    tracker?: TrackerCreateNestedManyWithoutKelasInput
    teaching?: TeachingCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomUncheckedCreateWithoutTDeviceInput = {
    id?: string
    name: string
    yearId: string
    waliId: string
    level: number
    property?: XOR<RoomPropertyNullableCreateEnvelopeInput, RoomPropertyCreateInput> | null
    majorId?: string | null
    studentIds?: ClassRoomCreatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomCreateeventIdsInput | Enumerable<string>
    disable?: boolean
    teachingIds?: ClassRoomCreateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomCreatetDeviceIdsInput | Enumerable<string>
    students?: StudentUncheckedCreateNestedManyWithoutClassRoomInput
    event?: CalendarUncheckedCreateNestedManyWithoutClassRoomInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutKelasInput
    teaching?: TeachingUncheckedCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomCreateOrConnectWithoutTDeviceInput = {
    where: ClassRoomWhereUniqueInput
    create: XOR<ClassRoomCreateWithoutTDeviceInput, ClassRoomUncheckedCreateWithoutTDeviceInput>
  }

  export type TrackerCreateWithoutPerangkatInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrackerInput
    ref: InstansiCreateNestedOneWithoutHistoryInput
    instansi?: InstansiCreateNestedOneWithoutTrackerInput
    mapel?: MataPelajaranCreateNestedOneWithoutTrackerInput
    elemen?: ElementCreateNestedOneWithoutTrackerInput
    cp?: AchievementCreateNestedOneWithoutTrackerInput
    bidang?: BidangKeahlianCreateNestedOneWithoutTrackerInput
    program?: ProgramKeahlianCreateNestedOneWithoutTrackerInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedOneWithoutTrackerInput
    tp?: SchoolYearCreateNestedOneWithoutTrackerInput
    teacher?: TeacherCreateNestedOneWithoutTrackerInput
    kelas?: ClassRoomCreateNestedOneWithoutTrackerInput
    murid?: StudentCreateNestedOneWithoutTrackerInput
    jadwal?: ScheduleCreateNestedOneWithoutTrackerInput
    mengajar?: TeachingCreateNestedOneWithoutTrackerInput
    tujuan?: ObjectiveCreateNestedOneWithoutTrackerInput
    kalender?: CalendarCreateNestedOneWithoutTrackerInput
    dudi?: DudiCreateNestedOneWithoutTrackerInput
    kkni?: KkniCreateNestedOneWithoutTrackerInput
  }

  export type TrackerUncheckedCreateWithoutPerangkatInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TrackerCreateOrConnectWithoutPerangkatInput = {
    where: TrackerWhereUniqueInput
    create: XOR<TrackerCreateWithoutPerangkatInput, TrackerUncheckedCreateWithoutPerangkatInput>
  }

  export type TrackerCreateManyPerangkatInputEnvelope = {
    data: Enumerable<TrackerCreateManyPerangkatInput>
  }

  export type TDeviceDataCreateWithoutRefInput = {
    id?: string
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    objective: ObjectiveCreateNestedOneWithoutDevicesInput
  }

  export type TDeviceDataUncheckedCreateWithoutRefInput = {
    id?: string
    objectiveId: string
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type TDeviceDataCreateOrConnectWithoutRefInput = {
    where: TDeviceDataWhereUniqueInput
    create: XOR<TDeviceDataCreateWithoutRefInput, TDeviceDataUncheckedCreateWithoutRefInput>
  }

  export type TDeviceDataCreateManyRefInputEnvelope = {
    data: Enumerable<TDeviceDataCreateManyRefInput>
  }

  export type TDeviceCreateWithoutParentInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    teaching: TeachingCreateNestedOneWithoutTDeviceInput
    year: SchoolYearCreateNestedOneWithoutTDeviceInput
    user: UserCreateNestedOneWithoutTDeviceInput
    instansi: InstansiCreateNestedOneWithoutTDeviceInput
    mapel: MataPelajaranCreateNestedOneWithoutDeviceInput
    classRoom?: ClassRoomCreateNestedManyWithoutTDeviceInput
    tracker?: TrackerCreateNestedManyWithoutPerangkatInput
    data?: TDeviceDataCreateNestedManyWithoutRefInput
    children?: TDeviceCreateNestedManyWithoutParentInput
  }

  export type TDeviceUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    teachingId: string
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    yearId: string
    userId: string
    instansiId: string
    mapelId: string
    classRoomIds?: TDeviceCreateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutTDeviceInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutPerangkatInput
    data?: TDeviceDataUncheckedCreateNestedManyWithoutRefInput
    children?: TDeviceUncheckedCreateNestedManyWithoutParentInput
  }

  export type TDeviceCreateOrConnectWithoutParentInput = {
    where: TDeviceWhereUniqueInput
    create: XOR<TDeviceCreateWithoutParentInput, TDeviceUncheckedCreateWithoutParentInput>
  }

  export type TDeviceCreateManyParentInputEnvelope = {
    data: Enumerable<TDeviceCreateManyParentInput>
  }

  export type TDeviceCreateWithoutChildrenInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    teaching: TeachingCreateNestedOneWithoutTDeviceInput
    year: SchoolYearCreateNestedOneWithoutTDeviceInput
    user: UserCreateNestedOneWithoutTDeviceInput
    instansi: InstansiCreateNestedOneWithoutTDeviceInput
    mapel: MataPelajaranCreateNestedOneWithoutDeviceInput
    classRoom?: ClassRoomCreateNestedManyWithoutTDeviceInput
    tracker?: TrackerCreateNestedManyWithoutPerangkatInput
    data?: TDeviceDataCreateNestedManyWithoutRefInput
    parent?: TDeviceCreateNestedOneWithoutChildrenInput
  }

  export type TDeviceUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    teachingId: string
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    yearId: string
    userId: string
    instansiId: string
    mapelId: string
    classRoomIds?: TDeviceCreateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    parentId?: string | null
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutTDeviceInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutPerangkatInput
    data?: TDeviceDataUncheckedCreateNestedManyWithoutRefInput
  }

  export type TDeviceCreateOrConnectWithoutChildrenInput = {
    where: TDeviceWhereUniqueInput
    create: XOR<TDeviceCreateWithoutChildrenInput, TDeviceUncheckedCreateWithoutChildrenInput>
  }

  export type TDevicePropsUpdateInput = {
    docDate?: DateTimeFieldUpdateOperationsInput | Date | string
    docAddr?: StringFieldUpdateOperationsInput | string
    kepText?: StringFieldUpdateOperationsInput | string
    kepUser?: StringFieldUpdateOperationsInput | string
    ke3Text?: StringFieldUpdateOperationsInput | string
    jabText?: StringFieldUpdateOperationsInput | string
    ke3User?: StringFieldUpdateOperationsInput | string
  }

  export type TDevicePosUpdateManyInput = {
    where: TDevicePosWhereInput
    data: TDevicePosUpdateInput
  }

  export type TDevicePosDeleteManyInput = {
    where: TDevicePosWhereInput
  }

  export type TeachingUpsertWithoutTDeviceInput = {
    update: XOR<TeachingUpdateWithoutTDeviceInput, TeachingUncheckedUpdateWithoutTDeviceInput>
    create: XOR<TeachingCreateWithoutTDeviceInput, TeachingUncheckedCreateWithoutTDeviceInput>
  }

  export type TeachingUpdateWithoutTDeviceInput = {
    level?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    semester?: EnumSemesterFieldUpdateOperationsInput | Semester
    disable?: BoolFieldUpdateOperationsInput | boolean
    ref?: ScheduleUpdateOneRequiredWithoutTeachingNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutTeachingNestedInput
    classRoom?: ClassRoomUpdateManyWithoutTeachingNestedInput
    elemen?: ElementUpdateManyWithoutScheduleClassNestedInput
    tracker?: TrackerUpdateManyWithoutMengajarNestedInput
  }

  export type TeachingUncheckedUpdateWithoutTDeviceInput = {
    refId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    semester?: EnumSemesterFieldUpdateOperationsInput | Semester
    teacherId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: TeachingUpdateclassRoomIdsInput | Enumerable<string>
    elemenIds?: TeachingUpdateelemenIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutTeachingNestedInput
    elemen?: ElementUncheckedUpdateManyWithoutScheduleClassNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutMengajarNestedInput
  }

  export type SchoolYearUpsertWithoutTDeviceInput = {
    update: XOR<SchoolYearUpdateWithoutTDeviceInput, SchoolYearUncheckedUpdateWithoutTDeviceInput>
    create: XOR<SchoolYearCreateWithoutTDeviceInput, SchoolYearUncheckedCreateWithoutTDeviceInput>
  }

  export type SchoolYearUpdateWithoutTDeviceInput = {
    year?: IntFieldUpdateOperationsInput | number
    departments?: SchoolYearUpdatedepartmentsInput | Enumerable<string>
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    instansi?: InstansiUpdateOneRequiredWithoutSchoolYearNestedInput
    classRoom?: ClassRoomUpdateManyWithoutYearNestedInput
    students?: StudentUpdateManyWithoutStartYearNestedInput
    calendar?: CalendarUpdateManyWithoutRefNestedInput
    schedule?: ScheduleUpdateManyWithoutYearNestedInput
    objective?: ObjectiveUpdateManyWithoutYearNestedInput
    tracker?: TrackerUpdateManyWithoutTpNestedInput
  }

  export type SchoolYearUncheckedUpdateWithoutTDeviceInput = {
    year?: IntFieldUpdateOperationsInput | number
    instansiId?: StringFieldUpdateOperationsInput | string
    departments?: SchoolYearUpdatedepartmentsInput | Enumerable<string>
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutYearNestedInput
    students?: StudentUncheckedUpdateManyWithoutStartYearNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutRefNestedInput
    schedule?: ScheduleUncheckedUpdateManyWithoutYearNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutYearNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTpNestedInput
  }

  export type UserUpsertWithoutTDeviceInput = {
    update: XOR<UserUpdateWithoutTDeviceInput, UserUncheckedUpdateWithoutTDeviceInput>
    create: XOR<UserCreateWithoutTDeviceInput, UserUncheckedCreateWithoutTDeviceInput>
  }

  export type UserUpdateWithoutTDeviceInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    google?: XOR<GoogleNullableUpdateEnvelopeInput, GoogleCreateInput> | null
    role?: RoleUpdateOneWithoutUsersNestedInput
    auth?: AuthUpdateOneWithoutUserNestedInput
    tracker?: TrackerUpdateManyWithoutUserNestedInput
    objective?: ObjectiveUpdateManyWithoutUserNestedInput
    link?: LinkUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTDeviceInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    google?: XOR<GoogleNullableUpdateEnvelopeInput, GoogleCreateInput> | null
    auth?: AuthUncheckedUpdateOneWithoutUserNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutUserNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutUserNestedInput
    link?: LinkUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InstansiUpsertWithoutTDeviceInput = {
    update: XOR<InstansiUpdateWithoutTDeviceInput, InstansiUncheckedUpdateWithoutTDeviceInput>
    create: XOR<InstansiCreateWithoutTDeviceInput, InstansiUncheckedCreateWithoutTDeviceInput>
  }

  export type InstansiUpdateWithoutTDeviceInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    majors?: KonsentrasiKeahlianUpdateManyWithoutInstansiNestedInput
    role?: RoleUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUpdateManyWithoutInstansiNestedInput
    student?: StudentUpdateManyWithoutInstansiNestedInput
    tracker?: TrackerUpdateManyWithoutInstansiNestedInput
    history?: TrackerUpdateManyWithoutRefNestedInput
    unikMapels?: MataPelajaranUpdateManyWithoutInstansiNestedInput
    objective?: ObjectiveUpdateManyWithoutInstansiNestedInput
    dudi?: DudiUpdateManyWithoutInstansiNestedInput
  }

  export type InstansiUncheckedUpdateWithoutTDeviceInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    majorIds?: InstansiUpdatemajorIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    majors?: KonsentrasiKeahlianUncheckedUpdateManyWithoutInstansiNestedInput
    role?: RoleUncheckedUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUncheckedUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutInstansiNestedInput
    student?: StudentUncheckedUpdateManyWithoutInstansiNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutInstansiNestedInput
    history?: TrackerUncheckedUpdateManyWithoutRefNestedInput
    unikMapels?: MataPelajaranUncheckedUpdateManyWithoutInstansiNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutInstansiNestedInput
    dudi?: DudiUncheckedUpdateManyWithoutInstansiNestedInput
  }

  export type MataPelajaranUpsertWithoutDeviceInput = {
    update: XOR<MataPelajaranUpdateWithoutDeviceInput, MataPelajaranUncheckedUpdateWithoutDeviceInput>
    create: XOR<MataPelajaranCreateWithoutDeviceInput, MataPelajaranUncheckedCreateWithoutDeviceInput>
  }

  export type MataPelajaranUpdateWithoutDeviceInput = {
    level?: NullableEnumLevelFieldUpdateOperationsInput | Level | null
    type?: EnumMataPelajaranTypeFieldUpdateOperationsInput | MataPelajaranType
    no?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    program?: ProgramKeahlianUpdateOneWithoutMapelNestedInput
    keahlian?: KonsentrasiKeahlianUpdateOneWithoutMapelNestedInput
    instansi?: InstansiUpdateOneWithoutUnikMapelsNestedInput
    element?: ElementUpdateManyWithoutMapelNestedInput
    schedule?: ScheduleUpdateManyWithoutMapelNestedInput
    tracker?: TrackerUpdateManyWithoutMapelNestedInput
    objective?: ObjectiveUpdateManyWithoutMapelNestedInput
  }

  export type MataPelajaranUncheckedUpdateWithoutDeviceInput = {
    level?: NullableEnumLevelFieldUpdateOperationsInput | Level | null
    type?: EnumMataPelajaranTypeFieldUpdateOperationsInput | MataPelajaranType
    no?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    keahlianid?: NullableStringFieldUpdateOperationsInput | string | null
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    element?: ElementUncheckedUpdateManyWithoutMapelNestedInput
    schedule?: ScheduleUncheckedUpdateManyWithoutMapelNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutMapelNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutMapelNestedInput
  }

  export type ClassRoomUpsertWithWhereUniqueWithoutTDeviceInput = {
    where: ClassRoomWhereUniqueInput
    update: XOR<ClassRoomUpdateWithoutTDeviceInput, ClassRoomUncheckedUpdateWithoutTDeviceInput>
    create: XOR<ClassRoomCreateWithoutTDeviceInput, ClassRoomUncheckedCreateWithoutTDeviceInput>
  }

  export type ClassRoomUpdateWithWhereUniqueWithoutTDeviceInput = {
    where: ClassRoomWhereUniqueInput
    data: XOR<ClassRoomUpdateWithoutTDeviceInput, ClassRoomUncheckedUpdateWithoutTDeviceInput>
  }

  export type ClassRoomUpdateManyWithWhereWithoutTDeviceInput = {
    where: ClassRoomScalarWhereInput
    data: XOR<ClassRoomUpdateManyMutationInput, ClassRoomUncheckedUpdateManyWithoutClassRoomInput>
  }

  export type TrackerUpsertWithWhereUniqueWithoutPerangkatInput = {
    where: TrackerWhereUniqueInput
    update: XOR<TrackerUpdateWithoutPerangkatInput, TrackerUncheckedUpdateWithoutPerangkatInput>
    create: XOR<TrackerCreateWithoutPerangkatInput, TrackerUncheckedCreateWithoutPerangkatInput>
  }

  export type TrackerUpdateWithWhereUniqueWithoutPerangkatInput = {
    where: TrackerWhereUniqueInput
    data: XOR<TrackerUpdateWithoutPerangkatInput, TrackerUncheckedUpdateWithoutPerangkatInput>
  }

  export type TrackerUpdateManyWithWhereWithoutPerangkatInput = {
    where: TrackerScalarWhereInput
    data: XOR<TrackerUpdateManyMutationInput, TrackerUncheckedUpdateManyWithoutTrackerInput>
  }

  export type TDeviceDataUpsertWithWhereUniqueWithoutRefInput = {
    where: TDeviceDataWhereUniqueInput
    update: XOR<TDeviceDataUpdateWithoutRefInput, TDeviceDataUncheckedUpdateWithoutRefInput>
    create: XOR<TDeviceDataCreateWithoutRefInput, TDeviceDataUncheckedCreateWithoutRefInput>
  }

  export type TDeviceDataUpdateWithWhereUniqueWithoutRefInput = {
    where: TDeviceDataWhereUniqueInput
    data: XOR<TDeviceDataUpdateWithoutRefInput, TDeviceDataUncheckedUpdateWithoutRefInput>
  }

  export type TDeviceDataUpdateManyWithWhereWithoutRefInput = {
    where: TDeviceDataScalarWhereInput
    data: XOR<TDeviceDataUpdateManyMutationInput, TDeviceDataUncheckedUpdateManyWithoutDataInput>
  }

  export type TDeviceUpsertWithWhereUniqueWithoutParentInput = {
    where: TDeviceWhereUniqueInput
    update: XOR<TDeviceUpdateWithoutParentInput, TDeviceUncheckedUpdateWithoutParentInput>
    create: XOR<TDeviceCreateWithoutParentInput, TDeviceUncheckedCreateWithoutParentInput>
  }

  export type TDeviceUpdateWithWhereUniqueWithoutParentInput = {
    where: TDeviceWhereUniqueInput
    data: XOR<TDeviceUpdateWithoutParentInput, TDeviceUncheckedUpdateWithoutParentInput>
  }

  export type TDeviceUpdateManyWithWhereWithoutParentInput = {
    where: TDeviceScalarWhereInput
    data: XOR<TDeviceUpdateManyMutationInput, TDeviceUncheckedUpdateManyWithoutChildrenInput>
  }

  export type TDeviceUpsertWithoutChildrenInput = {
    update: XOR<TDeviceUpdateWithoutChildrenInput, TDeviceUncheckedUpdateWithoutChildrenInput>
    create: XOR<TDeviceCreateWithoutChildrenInput, TDeviceUncheckedCreateWithoutChildrenInput>
  }

  export type TDeviceUpdateWithoutChildrenInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    teaching?: TeachingUpdateOneRequiredWithoutTDeviceNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutTDeviceNestedInput
    user?: UserUpdateOneRequiredWithoutTDeviceNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutTDeviceNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutDeviceNestedInput
    classRoom?: ClassRoomUpdateManyWithoutTDeviceNestedInput
    tracker?: TrackerUpdateManyWithoutPerangkatNestedInput
    data?: TDeviceDataUpdateManyWithoutRefNestedInput
    parent?: TDeviceUpdateOneWithoutChildrenNestedInput
  }

  export type TDeviceUncheckedUpdateWithoutChildrenInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    teachingId?: StringFieldUpdateOperationsInput | string
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    yearId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: TDeviceUpdateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutTDeviceNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutPerangkatNestedInput
    data?: TDeviceDataUncheckedUpdateManyWithoutRefNestedInput
  }

  export type TDeviceCreateWithoutDataInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    teaching: TeachingCreateNestedOneWithoutTDeviceInput
    year: SchoolYearCreateNestedOneWithoutTDeviceInput
    user: UserCreateNestedOneWithoutTDeviceInput
    instansi: InstansiCreateNestedOneWithoutTDeviceInput
    mapel: MataPelajaranCreateNestedOneWithoutDeviceInput
    classRoom?: ClassRoomCreateNestedManyWithoutTDeviceInput
    tracker?: TrackerCreateNestedManyWithoutPerangkatInput
    children?: TDeviceCreateNestedManyWithoutParentInput
    parent?: TDeviceCreateNestedOneWithoutChildrenInput
  }

  export type TDeviceUncheckedCreateWithoutDataInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    teachingId: string
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    yearId: string
    userId: string
    instansiId: string
    mapelId: string
    classRoomIds?: TDeviceCreateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    parentId?: string | null
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutTDeviceInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutPerangkatInput
    children?: TDeviceUncheckedCreateNestedManyWithoutParentInput
  }

  export type TDeviceCreateOrConnectWithoutDataInput = {
    where: TDeviceWhereUniqueInput
    create: XOR<TDeviceCreateWithoutDataInput, TDeviceUncheckedCreateWithoutDataInput>
  }

  export type ObjectiveCreateWithoutDevicesInput = {
    id?: string
    level: number
    fase: Fase
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    user: UserCreateNestedOneWithoutObjectiveInput
    instansi: InstansiCreateNestedOneWithoutObjectiveInput
    year: SchoolYearCreateNestedOneWithoutObjectiveInput
    mapel: MataPelajaranCreateNestedOneWithoutObjectiveInput
    elemen: ElementCreateNestedOneWithoutObjectiveInput
    achievement: AchievementCreateNestedOneWithoutObjectiveInput
    material?: OMaterialCreateNestedManyWithoutRefInput
    tracker?: TrackerCreateNestedManyWithoutTujuanInput
    resourse?: OresourceCreateNestedManyWithoutRefInput
    ppp?: OpppCreateNestedManyWithoutRefInput
    tool?: OhelperCreateNestedManyWithoutToolInput
    mate?: OhelperCreateNestedManyWithoutMateInput
    meth?: OhelperCreateNestedManyWithoutMethInput
    media?: OhelperCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentCreateNestedManyWithoutRefInput
  }

  export type ObjectiveUncheckedCreateWithoutDevicesInput = {
    id?: string
    level: number
    fase: Fase
    userId: string
    instansiId: string
    yearId: string
    mapelId: string
    elementId: string
    achievementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedCreateNestedManyWithoutRefInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTujuanInput
    resourse?: OresourceUncheckedCreateNestedManyWithoutRefInput
    ppp?: OpppUncheckedCreateNestedManyWithoutRefInput
    tool?: OhelperUncheckedCreateNestedManyWithoutToolInput
    mate?: OhelperUncheckedCreateNestedManyWithoutMateInput
    meth?: OhelperUncheckedCreateNestedManyWithoutMethInput
    media?: OhelperUncheckedCreateNestedManyWithoutMediaInput
    assessments?: OAssessmentUncheckedCreateNestedManyWithoutRefInput
  }

  export type ObjectiveCreateOrConnectWithoutDevicesInput = {
    where: ObjectiveWhereUniqueInput
    create: XOR<ObjectiveCreateWithoutDevicesInput, ObjectiveUncheckedCreateWithoutDevicesInput>
  }

  export type TDeviceUpsertWithoutDataInput = {
    update: XOR<TDeviceUpdateWithoutDataInput, TDeviceUncheckedUpdateWithoutDataInput>
    create: XOR<TDeviceCreateWithoutDataInput, TDeviceUncheckedCreateWithoutDataInput>
  }

  export type TDeviceUpdateWithoutDataInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    teaching?: TeachingUpdateOneRequiredWithoutTDeviceNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutTDeviceNestedInput
    user?: UserUpdateOneRequiredWithoutTDeviceNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutTDeviceNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutDeviceNestedInput
    classRoom?: ClassRoomUpdateManyWithoutTDeviceNestedInput
    tracker?: TrackerUpdateManyWithoutPerangkatNestedInput
    children?: TDeviceUpdateManyWithoutParentNestedInput
    parent?: TDeviceUpdateOneWithoutChildrenNestedInput
  }

  export type TDeviceUncheckedUpdateWithoutDataInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    teachingId?: StringFieldUpdateOperationsInput | string
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    yearId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: TDeviceUpdateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutTDeviceNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutPerangkatNestedInput
    children?: TDeviceUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ObjectiveUpsertWithoutDevicesInput = {
    update: XOR<ObjectiveUpdateWithoutDevicesInput, ObjectiveUncheckedUpdateWithoutDevicesInput>
    create: XOR<ObjectiveCreateWithoutDevicesInput, ObjectiveUncheckedCreateWithoutDevicesInput>
  }

  export type ObjectiveUpdateWithoutDevicesInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutObjectiveNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutObjectiveNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutObjectiveNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutObjectiveNestedInput
    elemen?: ElementUpdateOneRequiredWithoutObjectiveNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutObjectiveNestedInput
    material?: OMaterialUpdateManyWithoutRefNestedInput
    tracker?: TrackerUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUpdateManyWithoutRefNestedInput
    ppp?: OpppUpdateManyWithoutRefNestedInput
    tool?: OhelperUpdateManyWithoutToolNestedInput
    mate?: OhelperUpdateManyWithoutMateNestedInput
    meth?: OhelperUpdateManyWithoutMethNestedInput
    media?: OhelperUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUpdateManyWithoutRefNestedInput
  }

  export type ObjectiveUncheckedUpdateWithoutDevicesInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    toolIds?: ObjectiveUpdatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveUpdatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveUpdatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveUpdatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedUpdateManyWithoutRefNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUncheckedUpdateManyWithoutRefNestedInput
    ppp?: OpppUncheckedUpdateManyWithoutRefNestedInput
    tool?: OhelperUncheckedUpdateManyWithoutToolNestedInput
    mate?: OhelperUncheckedUpdateManyWithoutMateNestedInput
    meth?: OhelperUncheckedUpdateManyWithoutMethNestedInput
    media?: OhelperUncheckedUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUncheckedUpdateManyWithoutRefNestedInput
  }

  export type SchoolYearCreateWithoutCalendarInput = {
    id?: string
    year: number
    departments?: SchoolYearCreatedepartmentsInput | Enumerable<string>
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    disable?: boolean
    instansi: InstansiCreateNestedOneWithoutSchoolYearInput
    classRoom?: ClassRoomCreateNestedManyWithoutYearInput
    students?: StudentCreateNestedManyWithoutStartYearInput
    schedule?: ScheduleCreateNestedManyWithoutYearInput
    objective?: ObjectiveCreateNestedManyWithoutYearInput
    tracker?: TrackerCreateNestedManyWithoutTpInput
    TDevice?: TDeviceCreateNestedManyWithoutYearInput
  }

  export type SchoolYearUncheckedCreateWithoutCalendarInput = {
    id?: string
    year: number
    instansiId: string
    departments?: SchoolYearCreatedepartmentsInput | Enumerable<string>
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutYearInput
    students?: StudentUncheckedCreateNestedManyWithoutStartYearInput
    schedule?: ScheduleUncheckedCreateNestedManyWithoutYearInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutYearInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTpInput
    TDevice?: TDeviceUncheckedCreateNestedManyWithoutYearInput
  }

  export type SchoolYearCreateOrConnectWithoutCalendarInput = {
    where: SchoolYearWhereUniqueInput
    create: XOR<SchoolYearCreateWithoutCalendarInput, SchoolYearUncheckedCreateWithoutCalendarInput>
  }

  export type ClassRoomCreateWithoutEventInput = {
    id?: string
    name: string
    level: number
    property?: XOR<RoomPropertyNullableCreateEnvelopeInput, RoomPropertyCreateInput> | null
    disable?: boolean
    year: SchoolYearCreateNestedOneWithoutClassRoomInput
    wali: TeacherCreateNestedOneWithoutClassRoomInput
    major?: KonsentrasiKeahlianCreateNestedOneWithoutClassRoomInput
    students?: StudentCreateNestedManyWithoutClassRoomInput
    tracker?: TrackerCreateNestedManyWithoutKelasInput
    teaching?: TeachingCreateNestedManyWithoutClassRoomInput
    tDevice?: TDeviceCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomUncheckedCreateWithoutEventInput = {
    id?: string
    name: string
    yearId: string
    waliId: string
    level: number
    property?: XOR<RoomPropertyNullableCreateEnvelopeInput, RoomPropertyCreateInput> | null
    majorId?: string | null
    studentIds?: ClassRoomCreatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomCreateeventIdsInput | Enumerable<string>
    disable?: boolean
    teachingIds?: ClassRoomCreateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomCreatetDeviceIdsInput | Enumerable<string>
    students?: StudentUncheckedCreateNestedManyWithoutClassRoomInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutKelasInput
    teaching?: TeachingUncheckedCreateNestedManyWithoutClassRoomInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutClassRoomInput
  }

  export type ClassRoomCreateOrConnectWithoutEventInput = {
    where: ClassRoomWhereUniqueInput
    create: XOR<ClassRoomCreateWithoutEventInput, ClassRoomUncheckedCreateWithoutEventInput>
  }

  export type StudentCreateWithoutEventInput = {
    id?: string
    nis: string
    lastSchool: string
    disable?: boolean
    personal: PersonalCreateNestedOneWithoutStudentInput
    major?: KonsentrasiKeahlianCreateNestedOneWithoutStudentInput
    classRoom?: ClassRoomCreateNestedManyWithoutStudentsInput
    startYear: SchoolYearCreateNestedOneWithoutStudentsInput
    instansi: InstansiCreateNestedOneWithoutStudentInput
    tracker?: TrackerCreateNestedManyWithoutMuridInput
  }

  export type StudentUncheckedCreateWithoutEventInput = {
    id?: string
    nis: string
    lastSchool: string
    personalId: string
    majorId?: string | null
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    startYearId: string
    instansiId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutStudentsInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutMuridInput
  }

  export type StudentCreateOrConnectWithoutEventInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutEventInput, StudentUncheckedCreateWithoutEventInput>
  }

  export type TeacherCreateWithoutEventInput = {
    id?: string
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: Date | string | null
    tmtGol?: Date | string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    disable?: boolean
    personal: PersonalCreateNestedOneWithoutTeacherInput
    classRoom?: ClassRoomCreateNestedManyWithoutWaliInput
    instansi: InstansiCreateNestedOneWithoutTeacherInput
    tracker?: TrackerCreateNestedManyWithoutTeacherInput
    teaching?: TeachingCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutEventInput = {
    id?: string
    personalId: string
    instansiId: string
    eventIds?: TeacherCreateeventIdsInput | Enumerable<string>
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: Date | string | null
    tmtGol?: Date | string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    disable?: boolean
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutWaliInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutTeacherInput
    teaching?: TeachingUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutEventInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutEventInput, TeacherUncheckedCreateWithoutEventInput>
  }

  export type TrackerCreateWithoutKalenderInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrackerInput
    ref: InstansiCreateNestedOneWithoutHistoryInput
    instansi?: InstansiCreateNestedOneWithoutTrackerInput
    mapel?: MataPelajaranCreateNestedOneWithoutTrackerInput
    elemen?: ElementCreateNestedOneWithoutTrackerInput
    cp?: AchievementCreateNestedOneWithoutTrackerInput
    bidang?: BidangKeahlianCreateNestedOneWithoutTrackerInput
    program?: ProgramKeahlianCreateNestedOneWithoutTrackerInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedOneWithoutTrackerInput
    tp?: SchoolYearCreateNestedOneWithoutTrackerInput
    teacher?: TeacherCreateNestedOneWithoutTrackerInput
    kelas?: ClassRoomCreateNestedOneWithoutTrackerInput
    murid?: StudentCreateNestedOneWithoutTrackerInput
    jadwal?: ScheduleCreateNestedOneWithoutTrackerInput
    mengajar?: TeachingCreateNestedOneWithoutTrackerInput
    tujuan?: ObjectiveCreateNestedOneWithoutTrackerInput
    perangkat?: TDeviceCreateNestedOneWithoutTrackerInput
    dudi?: DudiCreateNestedOneWithoutTrackerInput
    kkni?: KkniCreateNestedOneWithoutTrackerInput
  }

  export type TrackerUncheckedCreateWithoutKalenderInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TrackerCreateOrConnectWithoutKalenderInput = {
    where: TrackerWhereUniqueInput
    create: XOR<TrackerCreateWithoutKalenderInput, TrackerUncheckedCreateWithoutKalenderInput>
  }

  export type TrackerCreateManyKalenderInputEnvelope = {
    data: Enumerable<TrackerCreateManyKalenderInput>
  }

  export type SchoolYearUpsertWithoutCalendarInput = {
    update: XOR<SchoolYearUpdateWithoutCalendarInput, SchoolYearUncheckedUpdateWithoutCalendarInput>
    create: XOR<SchoolYearCreateWithoutCalendarInput, SchoolYearUncheckedCreateWithoutCalendarInput>
  }

  export type SchoolYearUpdateWithoutCalendarInput = {
    year?: IntFieldUpdateOperationsInput | number
    departments?: SchoolYearUpdatedepartmentsInput | Enumerable<string>
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    instansi?: InstansiUpdateOneRequiredWithoutSchoolYearNestedInput
    classRoom?: ClassRoomUpdateManyWithoutYearNestedInput
    students?: StudentUpdateManyWithoutStartYearNestedInput
    schedule?: ScheduleUpdateManyWithoutYearNestedInput
    objective?: ObjectiveUpdateManyWithoutYearNestedInput
    tracker?: TrackerUpdateManyWithoutTpNestedInput
    TDevice?: TDeviceUpdateManyWithoutYearNestedInput
  }

  export type SchoolYearUncheckedUpdateWithoutCalendarInput = {
    year?: IntFieldUpdateOperationsInput | number
    instansiId?: StringFieldUpdateOperationsInput | string
    departments?: SchoolYearUpdatedepartmentsInput | Enumerable<string>
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutYearNestedInput
    students?: StudentUncheckedUpdateManyWithoutStartYearNestedInput
    schedule?: ScheduleUncheckedUpdateManyWithoutYearNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutYearNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTpNestedInput
    TDevice?: TDeviceUncheckedUpdateManyWithoutYearNestedInput
  }

  export type ClassRoomUpsertWithWhereUniqueWithoutEventInput = {
    where: ClassRoomWhereUniqueInput
    update: XOR<ClassRoomUpdateWithoutEventInput, ClassRoomUncheckedUpdateWithoutEventInput>
    create: XOR<ClassRoomCreateWithoutEventInput, ClassRoomUncheckedCreateWithoutEventInput>
  }

  export type ClassRoomUpdateWithWhereUniqueWithoutEventInput = {
    where: ClassRoomWhereUniqueInput
    data: XOR<ClassRoomUpdateWithoutEventInput, ClassRoomUncheckedUpdateWithoutEventInput>
  }

  export type ClassRoomUpdateManyWithWhereWithoutEventInput = {
    where: ClassRoomScalarWhereInput
    data: XOR<ClassRoomUpdateManyMutationInput, ClassRoomUncheckedUpdateManyWithoutClassRoomInput>
  }

  export type StudentUpsertWithWhereUniqueWithoutEventInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutEventInput, StudentUncheckedUpdateWithoutEventInput>
    create: XOR<StudentCreateWithoutEventInput, StudentUncheckedCreateWithoutEventInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutEventInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutEventInput, StudentUncheckedUpdateWithoutEventInput>
  }

  export type StudentUpdateManyWithWhereWithoutEventInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutStudentInput>
  }

  export type TeacherUpsertWithWhereUniqueWithoutEventInput = {
    where: TeacherWhereUniqueInput
    update: XOR<TeacherUpdateWithoutEventInput, TeacherUncheckedUpdateWithoutEventInput>
    create: XOR<TeacherCreateWithoutEventInput, TeacherUncheckedCreateWithoutEventInput>
  }

  export type TeacherUpdateWithWhereUniqueWithoutEventInput = {
    where: TeacherWhereUniqueInput
    data: XOR<TeacherUpdateWithoutEventInput, TeacherUncheckedUpdateWithoutEventInput>
  }

  export type TeacherUpdateManyWithWhereWithoutEventInput = {
    where: TeacherScalarWhereInput
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TrackerUpsertWithWhereUniqueWithoutKalenderInput = {
    where: TrackerWhereUniqueInput
    update: XOR<TrackerUpdateWithoutKalenderInput, TrackerUncheckedUpdateWithoutKalenderInput>
    create: XOR<TrackerCreateWithoutKalenderInput, TrackerUncheckedCreateWithoutKalenderInput>
  }

  export type TrackerUpdateWithWhereUniqueWithoutKalenderInput = {
    where: TrackerWhereUniqueInput
    data: XOR<TrackerUpdateWithoutKalenderInput, TrackerUncheckedUpdateWithoutKalenderInput>
  }

  export type TrackerUpdateManyWithWhereWithoutKalenderInput = {
    where: TrackerScalarWhereInput
    data: XOR<TrackerUpdateManyMutationInput, TrackerUncheckedUpdateManyWithoutTrackerInput>
  }

  export type DudiTimeWorkCreateholidaysInput = {
    set: Enumerable<string>
  }

  export type InstansiCreateWithoutDudiInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    disable?: boolean
    majors?: KonsentrasiKeahlianCreateNestedManyWithoutInstansiInput
    role?: RoleCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearCreateNestedManyWithoutInstansiInput
    teacher?: TeacherCreateNestedManyWithoutInstansiInput
    student?: StudentCreateNestedManyWithoutInstansiInput
    tracker?: TrackerCreateNestedManyWithoutInstansiInput
    history?: TrackerCreateNestedManyWithoutRefInput
    unikMapels?: MataPelajaranCreateNestedManyWithoutInstansiInput
    tDevice?: TDeviceCreateNestedManyWithoutInstansiInput
    objective?: ObjectiveCreateNestedManyWithoutInstansiInput
  }

  export type InstansiUncheckedCreateWithoutDudiInput = {
    id?: string
    npsn: string
    name: string
    isPrivate: boolean
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    level: Level
    religion?: Religion | null
    major?: boolean | null
    majorIds?: InstansiCreatemajorIdsInput | Enumerable<string>
    disable?: boolean
    majors?: KonsentrasiKeahlianUncheckedCreateNestedManyWithoutInstansiInput
    role?: RoleUncheckedCreateNestedManyWithoutInstansiInput
    schoolYear?: SchoolYearUncheckedCreateNestedManyWithoutInstansiInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutInstansiInput
    student?: StudentUncheckedCreateNestedManyWithoutInstansiInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutInstansiInput
    history?: TrackerUncheckedCreateNestedManyWithoutRefInput
    unikMapels?: MataPelajaranUncheckedCreateNestedManyWithoutInstansiInput
    tDevice?: TDeviceUncheckedCreateNestedManyWithoutInstansiInput
    objective?: ObjectiveUncheckedCreateNestedManyWithoutInstansiInput
  }

  export type InstansiCreateOrConnectWithoutDudiInput = {
    where: InstansiWhereUniqueInput
    create: XOR<InstansiCreateWithoutDudiInput, InstansiUncheckedCreateWithoutDudiInput>
  }

  export type KonsentrasiKeahlianCreateWithoutDudiInput = {
    id?: string
    code: string
    name: string
    tahun: number
    disable?: boolean
    program: ProgramKeahlianCreateNestedOneWithoutKonsentrasiInput
    student?: StudentCreateNestedManyWithoutMajorInput
    instansi?: InstansiCreateNestedManyWithoutMajorsInput
    classRoom?: ClassRoomCreateNestedManyWithoutMajorInput
    tracker?: TrackerCreateNestedManyWithoutKonsentrasiInput
    mapel?: MataPelajaranCreateNestedManyWithoutKeahlianInput
    kkni?: KkniCreateNestedManyWithoutKonsentrasiInput
  }

  export type KonsentrasiKeahlianUncheckedCreateWithoutDudiInput = {
    id?: string
    code: string
    name: string
    programId: string
    tahun: number
    instansiIds?: KonsentrasiKeahlianCreateinstansiIdsInput | Enumerable<string>
    disable?: boolean
    student?: StudentUncheckedCreateNestedManyWithoutMajorInput
    instansi?: InstansiUncheckedCreateNestedManyWithoutMajorsInput
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutMajorInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutKonsentrasiInput
    mapel?: MataPelajaranUncheckedCreateNestedManyWithoutKeahlianInput
    kkni?: KkniUncheckedCreateNestedManyWithoutKonsentrasiInput
  }

  export type KonsentrasiKeahlianCreateOrConnectWithoutDudiInput = {
    where: KonsentrasiKeahlianWhereUniqueInput
    create: XOR<KonsentrasiKeahlianCreateWithoutDudiInput, KonsentrasiKeahlianUncheckedCreateWithoutDudiInput>
  }

  export type DudiLearningCreateWithoutRefInput = {
    id?: string
    no: number
    code: string
    name: string
    indicator?: XOR<DudiIndicatorListCreateEnvelopeInput, Enumerable<DudiIndicatorCreateInput>>
  }

  export type DudiLearningUncheckedCreateWithoutRefInput = {
    id?: string
    no: number
    code: string
    name: string
    indicator?: XOR<DudiIndicatorListCreateEnvelopeInput, Enumerable<DudiIndicatorCreateInput>>
  }

  export type DudiLearningCreateOrConnectWithoutRefInput = {
    where: DudiLearningWhereUniqueInput
    create: XOR<DudiLearningCreateWithoutRefInput, DudiLearningUncheckedCreateWithoutRefInput>
  }

  export type DudiLearningCreateManyRefInputEnvelope = {
    data: Enumerable<DudiLearningCreateManyRefInput>
  }

  export type TrackerCreateWithoutDudiInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrackerInput
    ref: InstansiCreateNestedOneWithoutHistoryInput
    instansi?: InstansiCreateNestedOneWithoutTrackerInput
    mapel?: MataPelajaranCreateNestedOneWithoutTrackerInput
    elemen?: ElementCreateNestedOneWithoutTrackerInput
    cp?: AchievementCreateNestedOneWithoutTrackerInput
    bidang?: BidangKeahlianCreateNestedOneWithoutTrackerInput
    program?: ProgramKeahlianCreateNestedOneWithoutTrackerInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedOneWithoutTrackerInput
    tp?: SchoolYearCreateNestedOneWithoutTrackerInput
    teacher?: TeacherCreateNestedOneWithoutTrackerInput
    kelas?: ClassRoomCreateNestedOneWithoutTrackerInput
    murid?: StudentCreateNestedOneWithoutTrackerInput
    jadwal?: ScheduleCreateNestedOneWithoutTrackerInput
    mengajar?: TeachingCreateNestedOneWithoutTrackerInput
    tujuan?: ObjectiveCreateNestedOneWithoutTrackerInput
    perangkat?: TDeviceCreateNestedOneWithoutTrackerInput
    kalender?: CalendarCreateNestedOneWithoutTrackerInput
    kkni?: KkniCreateNestedOneWithoutTrackerInput
  }

  export type TrackerUncheckedCreateWithoutDudiInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    kkniId?: string | null
  }

  export type TrackerCreateOrConnectWithoutDudiInput = {
    where: TrackerWhereUniqueInput
    create: XOR<TrackerCreateWithoutDudiInput, TrackerUncheckedCreateWithoutDudiInput>
  }

  export type TrackerCreateManyDudiInputEnvelope = {
    data: Enumerable<TrackerCreateManyDudiInput>
  }

  export type KkniCreateWithoutDudiInput = {
    id?: string
    no: number
    code: string
    name: string
    description?: string | null
    disable?: boolean
    konsentrasi: KonsentrasiKeahlianCreateNestedOneWithoutKkniInput
    tracker?: TrackerCreateNestedManyWithoutKkniInput
  }

  export type KkniUncheckedCreateWithoutDudiInput = {
    id?: string
    konsentrasiId: string
    no: number
    code: string
    name: string
    description?: string | null
    disable?: boolean
    tracker?: TrackerUncheckedCreateNestedManyWithoutKkniInput
  }

  export type KkniCreateOrConnectWithoutDudiInput = {
    where: KkniWhereUniqueInput
    create: XOR<KkniCreateWithoutDudiInput, KkniUncheckedCreateWithoutDudiInput>
  }

  export type ContactDudiUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type DudiTimeWorkUpdateInput = {
    holidays?: DudiTimeWorkUpdateholidaysInput | Enumerable<string>
    timeIn?: StringFieldUpdateOperationsInput | string
    timeOut?: StringFieldUpdateOperationsInput | string
    actifity?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InstansiUpsertWithoutDudiInput = {
    update: XOR<InstansiUpdateWithoutDudiInput, InstansiUncheckedUpdateWithoutDudiInput>
    create: XOR<InstansiCreateWithoutDudiInput, InstansiUncheckedCreateWithoutDudiInput>
  }

  export type InstansiUpdateWithoutDudiInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    majors?: KonsentrasiKeahlianUpdateManyWithoutInstansiNestedInput
    role?: RoleUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUpdateManyWithoutInstansiNestedInput
    student?: StudentUpdateManyWithoutInstansiNestedInput
    tracker?: TrackerUpdateManyWithoutInstansiNestedInput
    history?: TrackerUpdateManyWithoutRefNestedInput
    unikMapels?: MataPelajaranUpdateManyWithoutInstansiNestedInput
    tDevice?: TDeviceUpdateManyWithoutInstansiNestedInput
    objective?: ObjectiveUpdateManyWithoutInstansiNestedInput
  }

  export type InstansiUncheckedUpdateWithoutDudiInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    majorIds?: InstansiUpdatemajorIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    majors?: KonsentrasiKeahlianUncheckedUpdateManyWithoutInstansiNestedInput
    role?: RoleUncheckedUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUncheckedUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutInstansiNestedInput
    student?: StudentUncheckedUpdateManyWithoutInstansiNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutInstansiNestedInput
    history?: TrackerUncheckedUpdateManyWithoutRefNestedInput
    unikMapels?: MataPelajaranUncheckedUpdateManyWithoutInstansiNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutInstansiNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutInstansiNestedInput
  }

  export type KonsentrasiKeahlianUpsertWithoutDudiInput = {
    update: XOR<KonsentrasiKeahlianUpdateWithoutDudiInput, KonsentrasiKeahlianUncheckedUpdateWithoutDudiInput>
    create: XOR<KonsentrasiKeahlianCreateWithoutDudiInput, KonsentrasiKeahlianUncheckedCreateWithoutDudiInput>
  }

  export type KonsentrasiKeahlianUpdateWithoutDudiInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    disable?: BoolFieldUpdateOperationsInput | boolean
    program?: ProgramKeahlianUpdateOneRequiredWithoutKonsentrasiNestedInput
    student?: StudentUpdateManyWithoutMajorNestedInput
    instansi?: InstansiUpdateManyWithoutMajorsNestedInput
    classRoom?: ClassRoomUpdateManyWithoutMajorNestedInput
    tracker?: TrackerUpdateManyWithoutKonsentrasiNestedInput
    mapel?: MataPelajaranUpdateManyWithoutKeahlianNestedInput
    kkni?: KkniUpdateManyWithoutKonsentrasiNestedInput
  }

  export type KonsentrasiKeahlianUncheckedUpdateWithoutDudiInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    instansiIds?: KonsentrasiKeahlianUpdateinstansiIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUncheckedUpdateManyWithoutMajorNestedInput
    instansi?: InstansiUncheckedUpdateManyWithoutMajorsNestedInput
    classRoom?: ClassRoomUncheckedUpdateManyWithoutMajorNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutKonsentrasiNestedInput
    mapel?: MataPelajaranUncheckedUpdateManyWithoutKeahlianNestedInput
    kkni?: KkniUncheckedUpdateManyWithoutKonsentrasiNestedInput
  }

  export type DudiLearningUpsertWithWhereUniqueWithoutRefInput = {
    where: DudiLearningWhereUniqueInput
    update: XOR<DudiLearningUpdateWithoutRefInput, DudiLearningUncheckedUpdateWithoutRefInput>
    create: XOR<DudiLearningCreateWithoutRefInput, DudiLearningUncheckedCreateWithoutRefInput>
  }

  export type DudiLearningUpdateWithWhereUniqueWithoutRefInput = {
    where: DudiLearningWhereUniqueInput
    data: XOR<DudiLearningUpdateWithoutRefInput, DudiLearningUncheckedUpdateWithoutRefInput>
  }

  export type DudiLearningUpdateManyWithWhereWithoutRefInput = {
    where: DudiLearningScalarWhereInput
    data: XOR<DudiLearningUpdateManyMutationInput, DudiLearningUncheckedUpdateManyWithoutLearningInput>
  }

  export type DudiLearningScalarWhereInput = {
    AND?: Enumerable<DudiLearningScalarWhereInput>
    OR?: Enumerable<DudiLearningScalarWhereInput>
    NOT?: Enumerable<DudiLearningScalarWhereInput>
    id?: StringFilter | string
    no?: IntFilter | number
    refId?: StringFilter | string
    code?: StringFilter | string
    name?: StringFilter | string
  }

  export type TrackerUpsertWithWhereUniqueWithoutDudiInput = {
    where: TrackerWhereUniqueInput
    update: XOR<TrackerUpdateWithoutDudiInput, TrackerUncheckedUpdateWithoutDudiInput>
    create: XOR<TrackerCreateWithoutDudiInput, TrackerUncheckedCreateWithoutDudiInput>
  }

  export type TrackerUpdateWithWhereUniqueWithoutDudiInput = {
    where: TrackerWhereUniqueInput
    data: XOR<TrackerUpdateWithoutDudiInput, TrackerUncheckedUpdateWithoutDudiInput>
  }

  export type TrackerUpdateManyWithWhereWithoutDudiInput = {
    where: TrackerScalarWhereInput
    data: XOR<TrackerUpdateManyMutationInput, TrackerUncheckedUpdateManyWithoutTrackerInput>
  }

  export type KkniUpsertWithoutDudiInput = {
    update: XOR<KkniUpdateWithoutDudiInput, KkniUncheckedUpdateWithoutDudiInput>
    create: XOR<KkniCreateWithoutDudiInput, KkniUncheckedCreateWithoutDudiInput>
  }

  export type KkniUpdateWithoutDudiInput = {
    no?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    konsentrasi?: KonsentrasiKeahlianUpdateOneRequiredWithoutKkniNestedInput
    tracker?: TrackerUpdateManyWithoutKkniNestedInput
  }

  export type KkniUncheckedUpdateWithoutDudiInput = {
    konsentrasiId?: StringFieldUpdateOperationsInput | string
    no?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    tracker?: TrackerUncheckedUpdateManyWithoutKkniNestedInput
  }

  export type DudiCreateWithoutLearningInput = {
    id?: string
    name: string
    street: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    contact: XOR<ContactDudiCreateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiCreatecollabsInput | Enumerable<string>
    timework: XOR<DudiTimeWorkCreateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: boolean
    instansi: InstansiCreateNestedOneWithoutDudiInput
    major: KonsentrasiKeahlianCreateNestedOneWithoutDudiInput
    tracker?: TrackerCreateNestedManyWithoutDudiInput
    kkni?: KkniCreateNestedOneWithoutDudiInput
  }

  export type DudiUncheckedCreateWithoutLearningInput = {
    id?: string
    name: string
    street: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    instansiId: string
    majorId: string
    contact: XOR<ContactDudiCreateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiCreatecollabsInput | Enumerable<string>
    timework: XOR<DudiTimeWorkCreateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: boolean
    kkniId?: string | null
    tracker?: TrackerUncheckedCreateNestedManyWithoutDudiInput
  }

  export type DudiCreateOrConnectWithoutLearningInput = {
    where: DudiWhereUniqueInput
    create: XOR<DudiCreateWithoutLearningInput, DudiUncheckedCreateWithoutLearningInput>
  }

  export type DudiIndicatorUpdateManyInput = {
    where: DudiIndicatorWhereInput
    data: DudiIndicatorUpdateInput
  }

  export type DudiIndicatorDeleteManyInput = {
    where: DudiIndicatorWhereInput
  }

  export type DudiUpsertWithoutLearningInput = {
    update: XOR<DudiUpdateWithoutLearningInput, DudiUncheckedUpdateWithoutLearningInput>
    create: XOR<DudiCreateWithoutLearningInput, DudiUncheckedCreateWithoutLearningInput>
  }

  export type DudiUpdateWithoutLearningInput = {
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    contact?: XOR<ContactDudiUpdateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiUpdatecollabsInput | Enumerable<string>
    timework?: XOR<DudiTimeWorkUpdateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    instansi?: InstansiUpdateOneRequiredWithoutDudiNestedInput
    major?: KonsentrasiKeahlianUpdateOneRequiredWithoutDudiNestedInput
    tracker?: TrackerUpdateManyWithoutDudiNestedInput
    kkni?: KkniUpdateOneWithoutDudiNestedInput
  }

  export type DudiUncheckedUpdateWithoutLearningInput = {
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    instansiId?: StringFieldUpdateOperationsInput | string
    majorId?: StringFieldUpdateOperationsInput | string
    contact?: XOR<ContactDudiUpdateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiUpdatecollabsInput | Enumerable<string>
    timework?: XOR<DudiTimeWorkUpdateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
    tracker?: TrackerUncheckedUpdateManyWithoutDudiNestedInput
  }

  export type KonsentrasiKeahlianCreateWithoutKkniInput = {
    id?: string
    code: string
    name: string
    tahun: number
    disable?: boolean
    program: ProgramKeahlianCreateNestedOneWithoutKonsentrasiInput
    student?: StudentCreateNestedManyWithoutMajorInput
    instansi?: InstansiCreateNestedManyWithoutMajorsInput
    classRoom?: ClassRoomCreateNestedManyWithoutMajorInput
    tracker?: TrackerCreateNestedManyWithoutKonsentrasiInput
    mapel?: MataPelajaranCreateNestedManyWithoutKeahlianInput
    dudi?: DudiCreateNestedManyWithoutMajorInput
  }

  export type KonsentrasiKeahlianUncheckedCreateWithoutKkniInput = {
    id?: string
    code: string
    name: string
    programId: string
    tahun: number
    instansiIds?: KonsentrasiKeahlianCreateinstansiIdsInput | Enumerable<string>
    disable?: boolean
    student?: StudentUncheckedCreateNestedManyWithoutMajorInput
    instansi?: InstansiUncheckedCreateNestedManyWithoutMajorsInput
    classRoom?: ClassRoomUncheckedCreateNestedManyWithoutMajorInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutKonsentrasiInput
    mapel?: MataPelajaranUncheckedCreateNestedManyWithoutKeahlianInput
    dudi?: DudiUncheckedCreateNestedManyWithoutMajorInput
  }

  export type KonsentrasiKeahlianCreateOrConnectWithoutKkniInput = {
    where: KonsentrasiKeahlianWhereUniqueInput
    create: XOR<KonsentrasiKeahlianCreateWithoutKkniInput, KonsentrasiKeahlianUncheckedCreateWithoutKkniInput>
  }

  export type DudiCreateWithoutKkniInput = {
    id?: string
    name: string
    street: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    contact: XOR<ContactDudiCreateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiCreatecollabsInput | Enumerable<string>
    timework: XOR<DudiTimeWorkCreateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: boolean
    instansi: InstansiCreateNestedOneWithoutDudiInput
    major: KonsentrasiKeahlianCreateNestedOneWithoutDudiInput
    learning?: DudiLearningCreateNestedManyWithoutRefInput
    tracker?: TrackerCreateNestedManyWithoutDudiInput
  }

  export type DudiUncheckedCreateWithoutKkniInput = {
    id?: string
    name: string
    street: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    instansiId: string
    majorId: string
    contact: XOR<ContactDudiCreateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiCreatecollabsInput | Enumerable<string>
    timework: XOR<DudiTimeWorkCreateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: boolean
    learning?: DudiLearningUncheckedCreateNestedManyWithoutRefInput
    tracker?: TrackerUncheckedCreateNestedManyWithoutDudiInput
  }

  export type DudiCreateOrConnectWithoutKkniInput = {
    where: DudiWhereUniqueInput
    create: XOR<DudiCreateWithoutKkniInput, DudiUncheckedCreateWithoutKkniInput>
  }

  export type DudiCreateManyKkniInputEnvelope = {
    data: Enumerable<DudiCreateManyKkniInput>
  }

  export type TrackerCreateWithoutKkniInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTrackerInput
    ref: InstansiCreateNestedOneWithoutHistoryInput
    instansi?: InstansiCreateNestedOneWithoutTrackerInput
    mapel?: MataPelajaranCreateNestedOneWithoutTrackerInput
    elemen?: ElementCreateNestedOneWithoutTrackerInput
    cp?: AchievementCreateNestedOneWithoutTrackerInput
    bidang?: BidangKeahlianCreateNestedOneWithoutTrackerInput
    program?: ProgramKeahlianCreateNestedOneWithoutTrackerInput
    konsentrasi?: KonsentrasiKeahlianCreateNestedOneWithoutTrackerInput
    tp?: SchoolYearCreateNestedOneWithoutTrackerInput
    teacher?: TeacherCreateNestedOneWithoutTrackerInput
    kelas?: ClassRoomCreateNestedOneWithoutTrackerInput
    murid?: StudentCreateNestedOneWithoutTrackerInput
    jadwal?: ScheduleCreateNestedOneWithoutTrackerInput
    mengajar?: TeachingCreateNestedOneWithoutTrackerInput
    tujuan?: ObjectiveCreateNestedOneWithoutTrackerInput
    perangkat?: TDeviceCreateNestedOneWithoutTrackerInput
    kalender?: CalendarCreateNestedOneWithoutTrackerInput
    dudi?: DudiCreateNestedOneWithoutTrackerInput
  }

  export type TrackerUncheckedCreateWithoutKkniInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
  }

  export type TrackerCreateOrConnectWithoutKkniInput = {
    where: TrackerWhereUniqueInput
    create: XOR<TrackerCreateWithoutKkniInput, TrackerUncheckedCreateWithoutKkniInput>
  }

  export type TrackerCreateManyKkniInputEnvelope = {
    data: Enumerable<TrackerCreateManyKkniInput>
  }

  export type KonsentrasiKeahlianUpsertWithoutKkniInput = {
    update: XOR<KonsentrasiKeahlianUpdateWithoutKkniInput, KonsentrasiKeahlianUncheckedUpdateWithoutKkniInput>
    create: XOR<KonsentrasiKeahlianCreateWithoutKkniInput, KonsentrasiKeahlianUncheckedCreateWithoutKkniInput>
  }

  export type KonsentrasiKeahlianUpdateWithoutKkniInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    disable?: BoolFieldUpdateOperationsInput | boolean
    program?: ProgramKeahlianUpdateOneRequiredWithoutKonsentrasiNestedInput
    student?: StudentUpdateManyWithoutMajorNestedInput
    instansi?: InstansiUpdateManyWithoutMajorsNestedInput
    classRoom?: ClassRoomUpdateManyWithoutMajorNestedInput
    tracker?: TrackerUpdateManyWithoutKonsentrasiNestedInput
    mapel?: MataPelajaranUpdateManyWithoutKeahlianNestedInput
    dudi?: DudiUpdateManyWithoutMajorNestedInput
  }

  export type KonsentrasiKeahlianUncheckedUpdateWithoutKkniInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    instansiIds?: KonsentrasiKeahlianUpdateinstansiIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUncheckedUpdateManyWithoutMajorNestedInput
    instansi?: InstansiUncheckedUpdateManyWithoutMajorsNestedInput
    classRoom?: ClassRoomUncheckedUpdateManyWithoutMajorNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutKonsentrasiNestedInput
    mapel?: MataPelajaranUncheckedUpdateManyWithoutKeahlianNestedInput
    dudi?: DudiUncheckedUpdateManyWithoutMajorNestedInput
  }

  export type DudiUpsertWithWhereUniqueWithoutKkniInput = {
    where: DudiWhereUniqueInput
    update: XOR<DudiUpdateWithoutKkniInput, DudiUncheckedUpdateWithoutKkniInput>
    create: XOR<DudiCreateWithoutKkniInput, DudiUncheckedCreateWithoutKkniInput>
  }

  export type DudiUpdateWithWhereUniqueWithoutKkniInput = {
    where: DudiWhereUniqueInput
    data: XOR<DudiUpdateWithoutKkniInput, DudiUncheckedUpdateWithoutKkniInput>
  }

  export type DudiUpdateManyWithWhereWithoutKkniInput = {
    where: DudiScalarWhereInput
    data: XOR<DudiUpdateManyMutationInput, DudiUncheckedUpdateManyWithoutDudiInput>
  }

  export type TrackerUpsertWithWhereUniqueWithoutKkniInput = {
    where: TrackerWhereUniqueInput
    update: XOR<TrackerUpdateWithoutKkniInput, TrackerUncheckedUpdateWithoutKkniInput>
    create: XOR<TrackerCreateWithoutKkniInput, TrackerUncheckedCreateWithoutKkniInput>
  }

  export type TrackerUpdateWithWhereUniqueWithoutKkniInput = {
    where: TrackerWhereUniqueInput
    data: XOR<TrackerUpdateWithoutKkniInput, TrackerUncheckedUpdateWithoutKkniInput>
  }

  export type TrackerUpdateManyWithWhereWithoutKkniInput = {
    where: TrackerScalarWhereInput
    data: XOR<TrackerUpdateManyMutationInput, TrackerUncheckedUpdateManyWithoutTrackerInput>
  }

  export type CoordinateCompositeFilter = {
    equals?: CoordinateObjectEqualityInput
    is?: CoordinateWhereInput
    isNot?: CoordinateWhereInput
  }
  export type JsonFilter = 
    | PatchUndefined<
        Either<Required<JsonFilterBase>, Exclude<keyof Required<JsonFilterBase>, 'path'>>,
        Required<JsonFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase>, 'path'>>

  export type JsonFilterBase = {
    equals?: InputJsonValue
    not?: InputJsonValue
  }

  export type EnumLevelEduFilter = {
    equals?: LevelEdu
    in?: Enumerable<LevelEdu>
    notIn?: Enumerable<LevelEdu>
    not?: NestedEnumLevelEduFilter | LevelEdu
  }

  export type RoleCreateManyInstansiInput = {
    id?: string
    key: Roles
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolYearCreateManyInstansiInput = {
    id?: string
    year: number
    departments?: SchoolYearCreatedepartmentsInput | Enumerable<string>
    organizational: XOR<OrganizationalCreateEnvelopeInput, OrganizationalCreateInput>
    disable?: boolean
  }

  export type TeacherCreateManyInstansiInput = {
    id?: string
    personalId: string
    eventIds?: TeacherCreateeventIdsInput | Enumerable<string>
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: Date | string | null
    tmtGol?: Date | string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    disable?: boolean
  }

  export type StudentCreateManyInstansiInput = {
    id?: string
    nis: string
    lastSchool: string
    personalId: string
    majorId?: string | null
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    startYearId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
    disable?: boolean
  }

  export type TrackerCreateManyInstansiInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TrackerCreateManyRefInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type MataPelajaranCreateManyInstansiInput = {
    id?: string
    level?: Level | null
    type?: MataPelajaranType
    no: string
    code: string
    name: string
    religion?: Religion | null
    programId?: string | null
    keahlianid?: string | null
    disable?: boolean
  }

  export type TDeviceCreateManyInstansiInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    teachingId: string
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    yearId: string
    userId: string
    mapelId: string
    classRoomIds?: TDeviceCreateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    parentId?: string | null
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type ObjectiveCreateManyInstansiInput = {
    id?: string
    level: number
    fase: Fase
    userId: string
    yearId: string
    mapelId: string
    elementId: string
    achievementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
  }

  export type DudiCreateManyInstansiInput = {
    id?: string
    name: string
    street: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    majorId: string
    contact: XOR<ContactDudiCreateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiCreatecollabsInput | Enumerable<string>
    timework: XOR<DudiTimeWorkCreateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: boolean
    kkniId?: string | null
  }

  export type CoordinateUpdateEnvelopeInput = {
    set?: CoordinateCreateInput
    update?: CoordinateUpdateInput
  }

  export type KonsentrasiKeahlianUpdateWithoutInstansiInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    disable?: BoolFieldUpdateOperationsInput | boolean
    program?: ProgramKeahlianUpdateOneRequiredWithoutKonsentrasiNestedInput
    student?: StudentUpdateManyWithoutMajorNestedInput
    classRoom?: ClassRoomUpdateManyWithoutMajorNestedInput
    tracker?: TrackerUpdateManyWithoutKonsentrasiNestedInput
    mapel?: MataPelajaranUpdateManyWithoutKeahlianNestedInput
    dudi?: DudiUpdateManyWithoutMajorNestedInput
    kkni?: KkniUpdateManyWithoutKonsentrasiNestedInput
  }

  export type KonsentrasiKeahlianUncheckedUpdateWithoutInstansiInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    instansiIds?: KonsentrasiKeahlianUpdateinstansiIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUncheckedUpdateManyWithoutMajorNestedInput
    classRoom?: ClassRoomUncheckedUpdateManyWithoutMajorNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutKonsentrasiNestedInput
    mapel?: MataPelajaranUncheckedUpdateManyWithoutKeahlianNestedInput
    dudi?: DudiUncheckedUpdateManyWithoutMajorNestedInput
    kkni?: KkniUncheckedUpdateManyWithoutKonsentrasiNestedInput
  }

  export type KonsentrasiKeahlianUncheckedUpdateManyWithoutMajorsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    instansiIds?: KonsentrasiKeahlianUpdateinstansiIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoleUpdateWithoutInstansiInput = {
    key?: EnumRolesFieldUpdateOperationsInput | Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutInstansiInput = {
    key?: EnumRolesFieldUpdateOperationsInput | Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateManyWithoutRoleInput = {
    key?: EnumRolesFieldUpdateOperationsInput | Roles
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolYearUpdateWithoutInstansiInput = {
    year?: IntFieldUpdateOperationsInput | number
    departments?: SchoolYearUpdatedepartmentsInput | Enumerable<string>
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUpdateManyWithoutYearNestedInput
    students?: StudentUpdateManyWithoutStartYearNestedInput
    calendar?: CalendarUpdateManyWithoutRefNestedInput
    schedule?: ScheduleUpdateManyWithoutYearNestedInput
    objective?: ObjectiveUpdateManyWithoutYearNestedInput
    tracker?: TrackerUpdateManyWithoutTpNestedInput
    TDevice?: TDeviceUpdateManyWithoutYearNestedInput
  }

  export type SchoolYearUncheckedUpdateWithoutInstansiInput = {
    year?: IntFieldUpdateOperationsInput | number
    departments?: SchoolYearUpdatedepartmentsInput | Enumerable<string>
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutYearNestedInput
    students?: StudentUncheckedUpdateManyWithoutStartYearNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutRefNestedInput
    schedule?: ScheduleUncheckedUpdateManyWithoutYearNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutYearNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTpNestedInput
    TDevice?: TDeviceUncheckedUpdateManyWithoutYearNestedInput
  }

  export type SchoolYearUncheckedUpdateManyWithoutSchoolYearInput = {
    year?: IntFieldUpdateOperationsInput | number
    departments?: SchoolYearUpdatedepartmentsInput | Enumerable<string>
    organizational?: XOR<OrganizationalUpdateEnvelopeInput, OrganizationalCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeacherUpdateWithoutInstansiInput = {
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tmtGol?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    personal?: PersonalUpdateOneRequiredWithoutTeacherNestedInput
    classRoom?: ClassRoomUpdateManyWithoutWaliNestedInput
    event?: CalendarUpdateManyWithoutTeacherNestedInput
    tracker?: TrackerUpdateManyWithoutTeacherNestedInput
    teaching?: TeachingUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutInstansiInput = {
    personalId?: StringFieldUpdateOperationsInput | string
    eventIds?: TeacherUpdateeventIdsInput | Enumerable<string>
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tmtGol?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutWaliNestedInput
    event?: CalendarUncheckedUpdateManyWithoutTeacherNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTeacherNestedInput
    teaching?: TeachingUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateManyWithoutTeacherInput = {
    personalId?: StringFieldUpdateOperationsInput | string
    eventIds?: TeacherUpdateeventIdsInput | Enumerable<string>
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tmtGol?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentUpdateWithoutInstansiInput = {
    nis?: StringFieldUpdateOperationsInput | string
    lastSchool?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    personal?: PersonalUpdateOneRequiredWithoutStudentNestedInput
    major?: KonsentrasiKeahlianUpdateOneWithoutStudentNestedInput
    classRoom?: ClassRoomUpdateManyWithoutStudentsNestedInput
    startYear?: SchoolYearUpdateOneRequiredWithoutStudentsNestedInput
    event?: CalendarUpdateManyWithoutStudentNestedInput
    tracker?: TrackerUpdateManyWithoutMuridNestedInput
  }

  export type StudentUncheckedUpdateWithoutInstansiInput = {
    nis?: StringFieldUpdateOperationsInput | string
    lastSchool?: StringFieldUpdateOperationsInput | string
    personalId?: StringFieldUpdateOperationsInput | string
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomIds?: StudentUpdateclassRoomIdsInput | Enumerable<string>
    startYearId?: StringFieldUpdateOperationsInput | string
    eventIds?: StudentUpdateeventIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutStudentsNestedInput
    event?: CalendarUncheckedUpdateManyWithoutStudentNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutMuridNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutStudentInput = {
    nis?: StringFieldUpdateOperationsInput | string
    lastSchool?: StringFieldUpdateOperationsInput | string
    personalId?: StringFieldUpdateOperationsInput | string
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomIds?: StudentUpdateclassRoomIdsInput | Enumerable<string>
    startYearId?: StringFieldUpdateOperationsInput | string
    eventIds?: StudentUpdateeventIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TrackerUpdateWithoutInstansiInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrackerNestedInput
    ref?: InstansiUpdateOneRequiredWithoutHistoryNestedInput
    mapel?: MataPelajaranUpdateOneWithoutTrackerNestedInput
    elemen?: ElementUpdateOneWithoutTrackerNestedInput
    cp?: AchievementUpdateOneWithoutTrackerNestedInput
    bidang?: BidangKeahlianUpdateOneWithoutTrackerNestedInput
    program?: ProgramKeahlianUpdateOneWithoutTrackerNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateOneWithoutTrackerNestedInput
    tp?: SchoolYearUpdateOneWithoutTrackerNestedInput
    teacher?: TeacherUpdateOneWithoutTrackerNestedInput
    kelas?: ClassRoomUpdateOneWithoutTrackerNestedInput
    murid?: StudentUpdateOneWithoutTrackerNestedInput
    jadwal?: ScheduleUpdateOneWithoutTrackerNestedInput
    mengajar?: TeachingUpdateOneWithoutTrackerNestedInput
    tujuan?: ObjectiveUpdateOneWithoutTrackerNestedInput
    perangkat?: TDeviceUpdateOneWithoutTrackerNestedInput
    kalender?: CalendarUpdateOneWithoutTrackerNestedInput
    dudi?: DudiUpdateOneWithoutTrackerNestedInput
    kkni?: KkniUpdateOneWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateWithoutInstansiInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    userId?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapelId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    cpId?: NullableStringFieldUpdateOperationsInput | string | null
    bidangId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    konsentrasiId?: NullableStringFieldUpdateOperationsInput | string | null
    tpId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    kelasId?: NullableStringFieldUpdateOperationsInput | string | null
    muridId?: NullableStringFieldUpdateOperationsInput | string | null
    jadwalId?: NullableStringFieldUpdateOperationsInput | string | null
    mengajarId?: NullableStringFieldUpdateOperationsInput | string | null
    tujuanId?: NullableStringFieldUpdateOperationsInput | string | null
    perangkatId?: NullableStringFieldUpdateOperationsInput | string | null
    kalenderId?: NullableStringFieldUpdateOperationsInput | string | null
    dudiId?: NullableStringFieldUpdateOperationsInput | string | null
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrackerUncheckedUpdateManyWithoutTrackerInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    userId?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapelId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    cpId?: NullableStringFieldUpdateOperationsInput | string | null
    bidangId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    konsentrasiId?: NullableStringFieldUpdateOperationsInput | string | null
    tpId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    kelasId?: NullableStringFieldUpdateOperationsInput | string | null
    muridId?: NullableStringFieldUpdateOperationsInput | string | null
    jadwalId?: NullableStringFieldUpdateOperationsInput | string | null
    mengajarId?: NullableStringFieldUpdateOperationsInput | string | null
    tujuanId?: NullableStringFieldUpdateOperationsInput | string | null
    perangkatId?: NullableStringFieldUpdateOperationsInput | string | null
    kalenderId?: NullableStringFieldUpdateOperationsInput | string | null
    dudiId?: NullableStringFieldUpdateOperationsInput | string | null
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrackerUpdateWithoutRefInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrackerNestedInput
    instansi?: InstansiUpdateOneWithoutTrackerNestedInput
    mapel?: MataPelajaranUpdateOneWithoutTrackerNestedInput
    elemen?: ElementUpdateOneWithoutTrackerNestedInput
    cp?: AchievementUpdateOneWithoutTrackerNestedInput
    bidang?: BidangKeahlianUpdateOneWithoutTrackerNestedInput
    program?: ProgramKeahlianUpdateOneWithoutTrackerNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateOneWithoutTrackerNestedInput
    tp?: SchoolYearUpdateOneWithoutTrackerNestedInput
    teacher?: TeacherUpdateOneWithoutTrackerNestedInput
    kelas?: ClassRoomUpdateOneWithoutTrackerNestedInput
    murid?: StudentUpdateOneWithoutTrackerNestedInput
    jadwal?: ScheduleUpdateOneWithoutTrackerNestedInput
    mengajar?: TeachingUpdateOneWithoutTrackerNestedInput
    tujuan?: ObjectiveUpdateOneWithoutTrackerNestedInput
    perangkat?: TDeviceUpdateOneWithoutTrackerNestedInput
    kalender?: CalendarUpdateOneWithoutTrackerNestedInput
    dudi?: DudiUpdateOneWithoutTrackerNestedInput
    kkni?: KkniUpdateOneWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateWithoutRefInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapelId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    cpId?: NullableStringFieldUpdateOperationsInput | string | null
    bidangId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    konsentrasiId?: NullableStringFieldUpdateOperationsInput | string | null
    tpId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    kelasId?: NullableStringFieldUpdateOperationsInput | string | null
    muridId?: NullableStringFieldUpdateOperationsInput | string | null
    jadwalId?: NullableStringFieldUpdateOperationsInput | string | null
    mengajarId?: NullableStringFieldUpdateOperationsInput | string | null
    tujuanId?: NullableStringFieldUpdateOperationsInput | string | null
    perangkatId?: NullableStringFieldUpdateOperationsInput | string | null
    kalenderId?: NullableStringFieldUpdateOperationsInput | string | null
    dudiId?: NullableStringFieldUpdateOperationsInput | string | null
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrackerUncheckedUpdateManyWithoutHistoryInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapelId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    cpId?: NullableStringFieldUpdateOperationsInput | string | null
    bidangId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    konsentrasiId?: NullableStringFieldUpdateOperationsInput | string | null
    tpId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    kelasId?: NullableStringFieldUpdateOperationsInput | string | null
    muridId?: NullableStringFieldUpdateOperationsInput | string | null
    jadwalId?: NullableStringFieldUpdateOperationsInput | string | null
    mengajarId?: NullableStringFieldUpdateOperationsInput | string | null
    tujuanId?: NullableStringFieldUpdateOperationsInput | string | null
    perangkatId?: NullableStringFieldUpdateOperationsInput | string | null
    kalenderId?: NullableStringFieldUpdateOperationsInput | string | null
    dudiId?: NullableStringFieldUpdateOperationsInput | string | null
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MataPelajaranUpdateWithoutInstansiInput = {
    level?: NullableEnumLevelFieldUpdateOperationsInput | Level | null
    type?: EnumMataPelajaranTypeFieldUpdateOperationsInput | MataPelajaranType
    no?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    program?: ProgramKeahlianUpdateOneWithoutMapelNestedInput
    keahlian?: KonsentrasiKeahlianUpdateOneWithoutMapelNestedInput
    element?: ElementUpdateManyWithoutMapelNestedInput
    schedule?: ScheduleUpdateManyWithoutMapelNestedInput
    tracker?: TrackerUpdateManyWithoutMapelNestedInput
    objective?: ObjectiveUpdateManyWithoutMapelNestedInput
    device?: TDeviceUpdateManyWithoutMapelNestedInput
  }

  export type MataPelajaranUncheckedUpdateWithoutInstansiInput = {
    level?: NullableEnumLevelFieldUpdateOperationsInput | Level | null
    type?: EnumMataPelajaranTypeFieldUpdateOperationsInput | MataPelajaranType
    no?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    keahlianid?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    element?: ElementUncheckedUpdateManyWithoutMapelNestedInput
    schedule?: ScheduleUncheckedUpdateManyWithoutMapelNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutMapelNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutMapelNestedInput
    device?: TDeviceUncheckedUpdateManyWithoutMapelNestedInput
  }

  export type MataPelajaranUncheckedUpdateManyWithoutUnikMapelsInput = {
    level?: NullableEnumLevelFieldUpdateOperationsInput | Level | null
    type?: EnumMataPelajaranTypeFieldUpdateOperationsInput | MataPelajaranType
    no?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    keahlianid?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TDeviceUpdateWithoutInstansiInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    teaching?: TeachingUpdateOneRequiredWithoutTDeviceNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutTDeviceNestedInput
    user?: UserUpdateOneRequiredWithoutTDeviceNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutDeviceNestedInput
    classRoom?: ClassRoomUpdateManyWithoutTDeviceNestedInput
    tracker?: TrackerUpdateManyWithoutPerangkatNestedInput
    data?: TDeviceDataUpdateManyWithoutRefNestedInput
    children?: TDeviceUpdateManyWithoutParentNestedInput
    parent?: TDeviceUpdateOneWithoutChildrenNestedInput
  }

  export type TDeviceUncheckedUpdateWithoutInstansiInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    teachingId?: StringFieldUpdateOperationsInput | string
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    yearId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: TDeviceUpdateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutTDeviceNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutPerangkatNestedInput
    data?: TDeviceDataUncheckedUpdateManyWithoutRefNestedInput
    children?: TDeviceUncheckedUpdateManyWithoutParentNestedInput
  }

  export type TDeviceUncheckedUpdateManyWithoutTDeviceInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    teachingId?: StringFieldUpdateOperationsInput | string
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    yearId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: TDeviceUpdateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type ObjectiveUpdateWithoutInstansiInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutObjectiveNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutObjectiveNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutObjectiveNestedInput
    elemen?: ElementUpdateOneRequiredWithoutObjectiveNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutObjectiveNestedInput
    material?: OMaterialUpdateManyWithoutRefNestedInput
    tracker?: TrackerUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUpdateManyWithoutRefNestedInput
    ppp?: OpppUpdateManyWithoutRefNestedInput
    tool?: OhelperUpdateManyWithoutToolNestedInput
    mate?: OhelperUpdateManyWithoutMateNestedInput
    meth?: OhelperUpdateManyWithoutMethNestedInput
    media?: OhelperUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateWithoutInstansiInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    userId?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    toolIds?: ObjectiveUpdatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveUpdatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveUpdatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveUpdatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedUpdateManyWithoutRefNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUncheckedUpdateManyWithoutRefNestedInput
    ppp?: OpppUncheckedUpdateManyWithoutRefNestedInput
    tool?: OhelperUncheckedUpdateManyWithoutToolNestedInput
    mate?: OhelperUncheckedUpdateManyWithoutMateNestedInput
    meth?: OhelperUncheckedUpdateManyWithoutMethNestedInput
    media?: OhelperUncheckedUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUncheckedUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUncheckedUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateManyWithoutObjectiveInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    userId?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    toolIds?: ObjectiveUpdatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveUpdatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveUpdatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveUpdatemediaIdsInput | Enumerable<string>
  }

  export type DudiUpdateWithoutInstansiInput = {
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    contact?: XOR<ContactDudiUpdateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiUpdatecollabsInput | Enumerable<string>
    timework?: XOR<DudiTimeWorkUpdateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    major?: KonsentrasiKeahlianUpdateOneRequiredWithoutDudiNestedInput
    learning?: DudiLearningUpdateManyWithoutRefNestedInput
    tracker?: TrackerUpdateManyWithoutDudiNestedInput
    kkni?: KkniUpdateOneWithoutDudiNestedInput
  }

  export type DudiUncheckedUpdateWithoutInstansiInput = {
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    majorId?: StringFieldUpdateOperationsInput | string
    contact?: XOR<ContactDudiUpdateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiUpdatecollabsInput | Enumerable<string>
    timework?: XOR<DudiTimeWorkUpdateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
    learning?: DudiLearningUncheckedUpdateManyWithoutRefNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutDudiNestedInput
  }

  export type DudiUncheckedUpdateManyWithoutDudiInput = {
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    majorId?: StringFieldUpdateOperationsInput | string
    contact?: XOR<ContactDudiUpdateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiUpdatecollabsInput | Enumerable<string>
    timework?: XOR<DudiTimeWorkUpdateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ElementCreateManyMapelInput = {
    id?: string
    no: number
    name: string
    description: string
    disable?: boolean
    scheduleClassIds?: ElementCreatescheduleClassIdsInput | Enumerable<string>
  }

  export type ScheduleCreateManyMapelInput = {
    id?: string
    yearId: string
    disable?: boolean
  }

  export type TrackerCreateManyMapelInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type ObjectiveCreateManyMapelInput = {
    id?: string
    level: number
    fase: Fase
    userId: string
    instansiId: string
    yearId: string
    elementId: string
    achievementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
  }

  export type TDeviceCreateManyMapelInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    teachingId: string
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    yearId: string
    userId: string
    instansiId: string
    classRoomIds?: TDeviceCreateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    parentId?: string | null
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type ElementUpdateWithoutMapelInput = {
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    achievement?: AchievementUpdateManyWithoutElementNestedInput
    tracker?: TrackerUpdateManyWithoutElemenNestedInput
    scheduleClass?: TeachingUpdateManyWithoutElemenNestedInput
    objective?: ObjectiveUpdateManyWithoutElemenNestedInput
  }

  export type ElementUncheckedUpdateWithoutMapelInput = {
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    scheduleClassIds?: ElementUpdatescheduleClassIdsInput | Enumerable<string>
    achievement?: AchievementUncheckedUpdateManyWithoutElementNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutElemenNestedInput
    scheduleClass?: TeachingUncheckedUpdateManyWithoutElemenNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutElemenNestedInput
  }

  export type ElementUncheckedUpdateManyWithoutElementInput = {
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    scheduleClassIds?: ElementUpdatescheduleClassIdsInput | Enumerable<string>
  }

  export type ScheduleUpdateWithoutMapelInput = {
    disable?: BoolFieldUpdateOperationsInput | boolean
    year?: SchoolYearUpdateOneRequiredWithoutScheduleNestedInput
    tracker?: TrackerUpdateManyWithoutJadwalNestedInput
    teaching?: TeachingUpdateManyWithoutRefNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutMapelInput = {
    yearId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    tracker?: TrackerUncheckedUpdateManyWithoutJadwalNestedInput
    teaching?: TeachingUncheckedUpdateManyWithoutRefNestedInput
  }

  export type ScheduleUncheckedUpdateManyWithoutScheduleInput = {
    yearId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TrackerUpdateWithoutMapelInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrackerNestedInput
    ref?: InstansiUpdateOneRequiredWithoutHistoryNestedInput
    instansi?: InstansiUpdateOneWithoutTrackerNestedInput
    elemen?: ElementUpdateOneWithoutTrackerNestedInput
    cp?: AchievementUpdateOneWithoutTrackerNestedInput
    bidang?: BidangKeahlianUpdateOneWithoutTrackerNestedInput
    program?: ProgramKeahlianUpdateOneWithoutTrackerNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateOneWithoutTrackerNestedInput
    tp?: SchoolYearUpdateOneWithoutTrackerNestedInput
    teacher?: TeacherUpdateOneWithoutTrackerNestedInput
    kelas?: ClassRoomUpdateOneWithoutTrackerNestedInput
    murid?: StudentUpdateOneWithoutTrackerNestedInput
    jadwal?: ScheduleUpdateOneWithoutTrackerNestedInput
    mengajar?: TeachingUpdateOneWithoutTrackerNestedInput
    tujuan?: ObjectiveUpdateOneWithoutTrackerNestedInput
    perangkat?: TDeviceUpdateOneWithoutTrackerNestedInput
    kalender?: CalendarUpdateOneWithoutTrackerNestedInput
    dudi?: DudiUpdateOneWithoutTrackerNestedInput
    kkni?: KkniUpdateOneWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateWithoutMapelInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    userId?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    cpId?: NullableStringFieldUpdateOperationsInput | string | null
    bidangId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    konsentrasiId?: NullableStringFieldUpdateOperationsInput | string | null
    tpId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    kelasId?: NullableStringFieldUpdateOperationsInput | string | null
    muridId?: NullableStringFieldUpdateOperationsInput | string | null
    jadwalId?: NullableStringFieldUpdateOperationsInput | string | null
    mengajarId?: NullableStringFieldUpdateOperationsInput | string | null
    tujuanId?: NullableStringFieldUpdateOperationsInput | string | null
    perangkatId?: NullableStringFieldUpdateOperationsInput | string | null
    kalenderId?: NullableStringFieldUpdateOperationsInput | string | null
    dudiId?: NullableStringFieldUpdateOperationsInput | string | null
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ObjectiveUpdateWithoutMapelInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutObjectiveNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutObjectiveNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutObjectiveNestedInput
    elemen?: ElementUpdateOneRequiredWithoutObjectiveNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutObjectiveNestedInput
    material?: OMaterialUpdateManyWithoutRefNestedInput
    tracker?: TrackerUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUpdateManyWithoutRefNestedInput
    ppp?: OpppUpdateManyWithoutRefNestedInput
    tool?: OhelperUpdateManyWithoutToolNestedInput
    mate?: OhelperUpdateManyWithoutMateNestedInput
    meth?: OhelperUpdateManyWithoutMethNestedInput
    media?: OhelperUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateWithoutMapelInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    toolIds?: ObjectiveUpdatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveUpdatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveUpdatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveUpdatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedUpdateManyWithoutRefNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUncheckedUpdateManyWithoutRefNestedInput
    ppp?: OpppUncheckedUpdateManyWithoutRefNestedInput
    tool?: OhelperUncheckedUpdateManyWithoutToolNestedInput
    mate?: OhelperUncheckedUpdateManyWithoutMateNestedInput
    meth?: OhelperUncheckedUpdateManyWithoutMethNestedInput
    media?: OhelperUncheckedUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUncheckedUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUncheckedUpdateManyWithoutObjectiveNestedInput
  }

  export type TDeviceUpdateWithoutMapelInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    teaching?: TeachingUpdateOneRequiredWithoutTDeviceNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutTDeviceNestedInput
    user?: UserUpdateOneRequiredWithoutTDeviceNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutTDeviceNestedInput
    classRoom?: ClassRoomUpdateManyWithoutTDeviceNestedInput
    tracker?: TrackerUpdateManyWithoutPerangkatNestedInput
    data?: TDeviceDataUpdateManyWithoutRefNestedInput
    children?: TDeviceUpdateManyWithoutParentNestedInput
    parent?: TDeviceUpdateOneWithoutChildrenNestedInput
  }

  export type TDeviceUncheckedUpdateWithoutMapelInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    teachingId?: StringFieldUpdateOperationsInput | string
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    yearId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: TDeviceUpdateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutTDeviceNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutPerangkatNestedInput
    data?: TDeviceDataUncheckedUpdateManyWithoutRefNestedInput
    children?: TDeviceUncheckedUpdateManyWithoutParentNestedInput
  }

  export type TDeviceUncheckedUpdateManyWithoutDeviceInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    teachingId?: StringFieldUpdateOperationsInput | string
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    yearId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: TDeviceUpdateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type AchievementCreateManyElementInput = {
    id?: string
    no: number
    fase?: Fase
    description: string
    disable?: boolean
  }

  export type TrackerCreateManyElemenInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type ObjectiveCreateManyElemenInput = {
    id?: string
    level: number
    fase: Fase
    userId: string
    instansiId: string
    yearId: string
    mapelId: string
    achievementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
  }

  export type AchievementUpdateWithoutElementInput = {
    no?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    description?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    objective?: ObjectiveUpdateManyWithoutAchievementNestedInput
    tracker?: TrackerUpdateManyWithoutCpNestedInput
  }

  export type AchievementUncheckedUpdateWithoutElementInput = {
    no?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    description?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    objective?: ObjectiveUncheckedUpdateManyWithoutAchievementNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutCpNestedInput
  }

  export type AchievementUncheckedUpdateManyWithoutAchievementInput = {
    no?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    description?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TrackerUpdateWithoutElemenInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrackerNestedInput
    ref?: InstansiUpdateOneRequiredWithoutHistoryNestedInput
    instansi?: InstansiUpdateOneWithoutTrackerNestedInput
    mapel?: MataPelajaranUpdateOneWithoutTrackerNestedInput
    cp?: AchievementUpdateOneWithoutTrackerNestedInput
    bidang?: BidangKeahlianUpdateOneWithoutTrackerNestedInput
    program?: ProgramKeahlianUpdateOneWithoutTrackerNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateOneWithoutTrackerNestedInput
    tp?: SchoolYearUpdateOneWithoutTrackerNestedInput
    teacher?: TeacherUpdateOneWithoutTrackerNestedInput
    kelas?: ClassRoomUpdateOneWithoutTrackerNestedInput
    murid?: StudentUpdateOneWithoutTrackerNestedInput
    jadwal?: ScheduleUpdateOneWithoutTrackerNestedInput
    mengajar?: TeachingUpdateOneWithoutTrackerNestedInput
    tujuan?: ObjectiveUpdateOneWithoutTrackerNestedInput
    perangkat?: TDeviceUpdateOneWithoutTrackerNestedInput
    kalender?: CalendarUpdateOneWithoutTrackerNestedInput
    dudi?: DudiUpdateOneWithoutTrackerNestedInput
    kkni?: KkniUpdateOneWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateWithoutElemenInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    userId?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapelId?: NullableStringFieldUpdateOperationsInput | string | null
    cpId?: NullableStringFieldUpdateOperationsInput | string | null
    bidangId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    konsentrasiId?: NullableStringFieldUpdateOperationsInput | string | null
    tpId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    kelasId?: NullableStringFieldUpdateOperationsInput | string | null
    muridId?: NullableStringFieldUpdateOperationsInput | string | null
    jadwalId?: NullableStringFieldUpdateOperationsInput | string | null
    mengajarId?: NullableStringFieldUpdateOperationsInput | string | null
    tujuanId?: NullableStringFieldUpdateOperationsInput | string | null
    perangkatId?: NullableStringFieldUpdateOperationsInput | string | null
    kalenderId?: NullableStringFieldUpdateOperationsInput | string | null
    dudiId?: NullableStringFieldUpdateOperationsInput | string | null
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeachingUpdateWithoutElemenInput = {
    level?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    semester?: EnumSemesterFieldUpdateOperationsInput | Semester
    disable?: BoolFieldUpdateOperationsInput | boolean
    ref?: ScheduleUpdateOneRequiredWithoutTeachingNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutTeachingNestedInput
    classRoom?: ClassRoomUpdateManyWithoutTeachingNestedInput
    tracker?: TrackerUpdateManyWithoutMengajarNestedInput
    tDevice?: TDeviceUpdateManyWithoutTeachingNestedInput
  }

  export type TeachingUncheckedUpdateWithoutElemenInput = {
    refId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    semester?: EnumSemesterFieldUpdateOperationsInput | Semester
    teacherId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: TeachingUpdateclassRoomIdsInput | Enumerable<string>
    elemenIds?: TeachingUpdateelemenIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutTeachingNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutMengajarNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutTeachingNestedInput
  }

  export type TeachingUncheckedUpdateManyWithoutScheduleClassInput = {
    refId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    semester?: EnumSemesterFieldUpdateOperationsInput | Semester
    teacherId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: TeachingUpdateclassRoomIdsInput | Enumerable<string>
    elemenIds?: TeachingUpdateelemenIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ObjectiveUpdateWithoutElemenInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutObjectiveNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutObjectiveNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutObjectiveNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutObjectiveNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutObjectiveNestedInput
    material?: OMaterialUpdateManyWithoutRefNestedInput
    tracker?: TrackerUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUpdateManyWithoutRefNestedInput
    ppp?: OpppUpdateManyWithoutRefNestedInput
    tool?: OhelperUpdateManyWithoutToolNestedInput
    mate?: OhelperUpdateManyWithoutMateNestedInput
    meth?: OhelperUpdateManyWithoutMethNestedInput
    media?: OhelperUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateWithoutElemenInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    toolIds?: ObjectiveUpdatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveUpdatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveUpdatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveUpdatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedUpdateManyWithoutRefNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUncheckedUpdateManyWithoutRefNestedInput
    ppp?: OpppUncheckedUpdateManyWithoutRefNestedInput
    tool?: OhelperUncheckedUpdateManyWithoutToolNestedInput
    mate?: OhelperUncheckedUpdateManyWithoutMateNestedInput
    meth?: OhelperUncheckedUpdateManyWithoutMethNestedInput
    media?: OhelperUncheckedUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUncheckedUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUncheckedUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveCreateManyAchievementInput = {
    id?: string
    level: number
    fase: Fase
    userId: string
    instansiId: string
    yearId: string
    mapelId: string
    elementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
  }

  export type TrackerCreateManyCpInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type ObjectiveUpdateWithoutAchievementInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutObjectiveNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutObjectiveNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutObjectiveNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutObjectiveNestedInput
    elemen?: ElementUpdateOneRequiredWithoutObjectiveNestedInput
    material?: OMaterialUpdateManyWithoutRefNestedInput
    tracker?: TrackerUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUpdateManyWithoutRefNestedInput
    ppp?: OpppUpdateManyWithoutRefNestedInput
    tool?: OhelperUpdateManyWithoutToolNestedInput
    mate?: OhelperUpdateManyWithoutMateNestedInput
    meth?: OhelperUpdateManyWithoutMethNestedInput
    media?: OhelperUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateWithoutAchievementInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    toolIds?: ObjectiveUpdatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveUpdatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveUpdatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveUpdatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedUpdateManyWithoutRefNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUncheckedUpdateManyWithoutRefNestedInput
    ppp?: OpppUncheckedUpdateManyWithoutRefNestedInput
    tool?: OhelperUncheckedUpdateManyWithoutToolNestedInput
    mate?: OhelperUncheckedUpdateManyWithoutMateNestedInput
    meth?: OhelperUncheckedUpdateManyWithoutMethNestedInput
    media?: OhelperUncheckedUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUncheckedUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUncheckedUpdateManyWithoutObjectiveNestedInput
  }

  export type TrackerUpdateWithoutCpInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrackerNestedInput
    ref?: InstansiUpdateOneRequiredWithoutHistoryNestedInput
    instansi?: InstansiUpdateOneWithoutTrackerNestedInput
    mapel?: MataPelajaranUpdateOneWithoutTrackerNestedInput
    elemen?: ElementUpdateOneWithoutTrackerNestedInput
    bidang?: BidangKeahlianUpdateOneWithoutTrackerNestedInput
    program?: ProgramKeahlianUpdateOneWithoutTrackerNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateOneWithoutTrackerNestedInput
    tp?: SchoolYearUpdateOneWithoutTrackerNestedInput
    teacher?: TeacherUpdateOneWithoutTrackerNestedInput
    kelas?: ClassRoomUpdateOneWithoutTrackerNestedInput
    murid?: StudentUpdateOneWithoutTrackerNestedInput
    jadwal?: ScheduleUpdateOneWithoutTrackerNestedInput
    mengajar?: TeachingUpdateOneWithoutTrackerNestedInput
    tujuan?: ObjectiveUpdateOneWithoutTrackerNestedInput
    perangkat?: TDeviceUpdateOneWithoutTrackerNestedInput
    kalender?: CalendarUpdateOneWithoutTrackerNestedInput
    dudi?: DudiUpdateOneWithoutTrackerNestedInput
    kkni?: KkniUpdateOneWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateWithoutCpInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    userId?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapelId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    bidangId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    konsentrasiId?: NullableStringFieldUpdateOperationsInput | string | null
    tpId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    kelasId?: NullableStringFieldUpdateOperationsInput | string | null
    muridId?: NullableStringFieldUpdateOperationsInput | string | null
    jadwalId?: NullableStringFieldUpdateOperationsInput | string | null
    mengajarId?: NullableStringFieldUpdateOperationsInput | string | null
    tujuanId?: NullableStringFieldUpdateOperationsInput | string | null
    perangkatId?: NullableStringFieldUpdateOperationsInput | string | null
    kalenderId?: NullableStringFieldUpdateOperationsInput | string | null
    dudiId?: NullableStringFieldUpdateOperationsInput | string | null
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProgramKeahlianCreateManyBidangInput = {
    id?: string
    code: string
    name: string
    disable?: boolean
  }

  export type TrackerCreateManyBidangInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type ProgramKeahlianUpdateWithoutBidangInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    konsentrasi?: KonsentrasiKeahlianUpdateManyWithoutProgramNestedInput
    tracker?: TrackerUpdateManyWithoutProgramNestedInput
    mapel?: MataPelajaranUpdateManyWithoutProgramNestedInput
  }

  export type ProgramKeahlianUncheckedUpdateWithoutBidangInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    konsentrasi?: KonsentrasiKeahlianUncheckedUpdateManyWithoutProgramNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutProgramNestedInput
    mapel?: MataPelajaranUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramKeahlianUncheckedUpdateManyWithoutProgramInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TrackerUpdateWithoutBidangInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrackerNestedInput
    ref?: InstansiUpdateOneRequiredWithoutHistoryNestedInput
    instansi?: InstansiUpdateOneWithoutTrackerNestedInput
    mapel?: MataPelajaranUpdateOneWithoutTrackerNestedInput
    elemen?: ElementUpdateOneWithoutTrackerNestedInput
    cp?: AchievementUpdateOneWithoutTrackerNestedInput
    program?: ProgramKeahlianUpdateOneWithoutTrackerNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateOneWithoutTrackerNestedInput
    tp?: SchoolYearUpdateOneWithoutTrackerNestedInput
    teacher?: TeacherUpdateOneWithoutTrackerNestedInput
    kelas?: ClassRoomUpdateOneWithoutTrackerNestedInput
    murid?: StudentUpdateOneWithoutTrackerNestedInput
    jadwal?: ScheduleUpdateOneWithoutTrackerNestedInput
    mengajar?: TeachingUpdateOneWithoutTrackerNestedInput
    tujuan?: ObjectiveUpdateOneWithoutTrackerNestedInput
    perangkat?: TDeviceUpdateOneWithoutTrackerNestedInput
    kalender?: CalendarUpdateOneWithoutTrackerNestedInput
    dudi?: DudiUpdateOneWithoutTrackerNestedInput
    kkni?: KkniUpdateOneWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateWithoutBidangInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    userId?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapelId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    cpId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    konsentrasiId?: NullableStringFieldUpdateOperationsInput | string | null
    tpId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    kelasId?: NullableStringFieldUpdateOperationsInput | string | null
    muridId?: NullableStringFieldUpdateOperationsInput | string | null
    jadwalId?: NullableStringFieldUpdateOperationsInput | string | null
    mengajarId?: NullableStringFieldUpdateOperationsInput | string | null
    tujuanId?: NullableStringFieldUpdateOperationsInput | string | null
    perangkatId?: NullableStringFieldUpdateOperationsInput | string | null
    kalenderId?: NullableStringFieldUpdateOperationsInput | string | null
    dudiId?: NullableStringFieldUpdateOperationsInput | string | null
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KonsentrasiKeahlianCreateManyProgramInput = {
    id?: string
    code: string
    name: string
    tahun: number
    instansiIds?: KonsentrasiKeahlianCreateinstansiIdsInput | Enumerable<string>
    disable?: boolean
  }

  export type TrackerCreateManyProgramInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type MataPelajaranCreateManyProgramInput = {
    id?: string
    level?: Level | null
    type?: MataPelajaranType
    no: string
    code: string
    name: string
    religion?: Religion | null
    keahlianid?: string | null
    instansiId?: string | null
    disable?: boolean
  }

  export type KonsentrasiKeahlianUpdateWithoutProgramInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    disable?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateManyWithoutMajorNestedInput
    instansi?: InstansiUpdateManyWithoutMajorsNestedInput
    classRoom?: ClassRoomUpdateManyWithoutMajorNestedInput
    tracker?: TrackerUpdateManyWithoutKonsentrasiNestedInput
    mapel?: MataPelajaranUpdateManyWithoutKeahlianNestedInput
    dudi?: DudiUpdateManyWithoutMajorNestedInput
    kkni?: KkniUpdateManyWithoutKonsentrasiNestedInput
  }

  export type KonsentrasiKeahlianUncheckedUpdateWithoutProgramInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    instansiIds?: KonsentrasiKeahlianUpdateinstansiIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUncheckedUpdateManyWithoutMajorNestedInput
    instansi?: InstansiUncheckedUpdateManyWithoutMajorsNestedInput
    classRoom?: ClassRoomUncheckedUpdateManyWithoutMajorNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutKonsentrasiNestedInput
    mapel?: MataPelajaranUncheckedUpdateManyWithoutKeahlianNestedInput
    dudi?: DudiUncheckedUpdateManyWithoutMajorNestedInput
    kkni?: KkniUncheckedUpdateManyWithoutKonsentrasiNestedInput
  }

  export type KonsentrasiKeahlianUncheckedUpdateManyWithoutKonsentrasiInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    instansiIds?: KonsentrasiKeahlianUpdateinstansiIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TrackerUpdateWithoutProgramInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrackerNestedInput
    ref?: InstansiUpdateOneRequiredWithoutHistoryNestedInput
    instansi?: InstansiUpdateOneWithoutTrackerNestedInput
    mapel?: MataPelajaranUpdateOneWithoutTrackerNestedInput
    elemen?: ElementUpdateOneWithoutTrackerNestedInput
    cp?: AchievementUpdateOneWithoutTrackerNestedInput
    bidang?: BidangKeahlianUpdateOneWithoutTrackerNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateOneWithoutTrackerNestedInput
    tp?: SchoolYearUpdateOneWithoutTrackerNestedInput
    teacher?: TeacherUpdateOneWithoutTrackerNestedInput
    kelas?: ClassRoomUpdateOneWithoutTrackerNestedInput
    murid?: StudentUpdateOneWithoutTrackerNestedInput
    jadwal?: ScheduleUpdateOneWithoutTrackerNestedInput
    mengajar?: TeachingUpdateOneWithoutTrackerNestedInput
    tujuan?: ObjectiveUpdateOneWithoutTrackerNestedInput
    perangkat?: TDeviceUpdateOneWithoutTrackerNestedInput
    kalender?: CalendarUpdateOneWithoutTrackerNestedInput
    dudi?: DudiUpdateOneWithoutTrackerNestedInput
    kkni?: KkniUpdateOneWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateWithoutProgramInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    userId?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapelId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    cpId?: NullableStringFieldUpdateOperationsInput | string | null
    bidangId?: NullableStringFieldUpdateOperationsInput | string | null
    konsentrasiId?: NullableStringFieldUpdateOperationsInput | string | null
    tpId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    kelasId?: NullableStringFieldUpdateOperationsInput | string | null
    muridId?: NullableStringFieldUpdateOperationsInput | string | null
    jadwalId?: NullableStringFieldUpdateOperationsInput | string | null
    mengajarId?: NullableStringFieldUpdateOperationsInput | string | null
    tujuanId?: NullableStringFieldUpdateOperationsInput | string | null
    perangkatId?: NullableStringFieldUpdateOperationsInput | string | null
    kalenderId?: NullableStringFieldUpdateOperationsInput | string | null
    dudiId?: NullableStringFieldUpdateOperationsInput | string | null
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MataPelajaranUpdateWithoutProgramInput = {
    level?: NullableEnumLevelFieldUpdateOperationsInput | Level | null
    type?: EnumMataPelajaranTypeFieldUpdateOperationsInput | MataPelajaranType
    no?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    keahlian?: KonsentrasiKeahlianUpdateOneWithoutMapelNestedInput
    instansi?: InstansiUpdateOneWithoutUnikMapelsNestedInput
    element?: ElementUpdateManyWithoutMapelNestedInput
    schedule?: ScheduleUpdateManyWithoutMapelNestedInput
    tracker?: TrackerUpdateManyWithoutMapelNestedInput
    objective?: ObjectiveUpdateManyWithoutMapelNestedInput
    device?: TDeviceUpdateManyWithoutMapelNestedInput
  }

  export type MataPelajaranUncheckedUpdateWithoutProgramInput = {
    level?: NullableEnumLevelFieldUpdateOperationsInput | Level | null
    type?: EnumMataPelajaranTypeFieldUpdateOperationsInput | MataPelajaranType
    no?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    keahlianid?: NullableStringFieldUpdateOperationsInput | string | null
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    element?: ElementUncheckedUpdateManyWithoutMapelNestedInput
    schedule?: ScheduleUncheckedUpdateManyWithoutMapelNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutMapelNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutMapelNestedInput
    device?: TDeviceUncheckedUpdateManyWithoutMapelNestedInput
  }

  export type MataPelajaranUncheckedUpdateManyWithoutMapelInput = {
    level?: NullableEnumLevelFieldUpdateOperationsInput | Level | null
    type?: EnumMataPelajaranTypeFieldUpdateOperationsInput | MataPelajaranType
    no?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    keahlianid?: NullableStringFieldUpdateOperationsInput | string | null
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentCreateManyMajorInput = {
    id?: string
    nis: string
    lastSchool: string
    personalId: string
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    startYearId: string
    instansiId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
    disable?: boolean
  }

  export type ClassRoomCreateManyMajorInput = {
    id?: string
    name: string
    yearId: string
    waliId: string
    level: number
    property?: XOR<RoomPropertyNullableCreateEnvelopeInput, RoomPropertyCreateInput> | null
    studentIds?: ClassRoomCreatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomCreateeventIdsInput | Enumerable<string>
    disable?: boolean
    teachingIds?: ClassRoomCreateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomCreatetDeviceIdsInput | Enumerable<string>
  }

  export type TrackerCreateManyKonsentrasiInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type MataPelajaranCreateManyKeahlianInput = {
    id?: string
    level?: Level | null
    type?: MataPelajaranType
    no: string
    code: string
    name: string
    religion?: Religion | null
    programId?: string | null
    instansiId?: string | null
    disable?: boolean
  }

  export type DudiCreateManyMajorInput = {
    id?: string
    name: string
    street: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    instansiId: string
    contact: XOR<ContactDudiCreateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiCreatecollabsInput | Enumerable<string>
    timework: XOR<DudiTimeWorkCreateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: boolean
    kkniId?: string | null
  }

  export type KkniCreateManyKonsentrasiInput = {
    id?: string
    no: number
    code: string
    name: string
    description?: string | null
    disable?: boolean
  }

  export type StudentUpdateWithoutMajorInput = {
    nis?: StringFieldUpdateOperationsInput | string
    lastSchool?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    personal?: PersonalUpdateOneRequiredWithoutStudentNestedInput
    classRoom?: ClassRoomUpdateManyWithoutStudentsNestedInput
    startYear?: SchoolYearUpdateOneRequiredWithoutStudentsNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutStudentNestedInput
    event?: CalendarUpdateManyWithoutStudentNestedInput
    tracker?: TrackerUpdateManyWithoutMuridNestedInput
  }

  export type StudentUncheckedUpdateWithoutMajorInput = {
    nis?: StringFieldUpdateOperationsInput | string
    lastSchool?: StringFieldUpdateOperationsInput | string
    personalId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: StudentUpdateclassRoomIdsInput | Enumerable<string>
    startYearId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: StudentUpdateeventIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutStudentsNestedInput
    event?: CalendarUncheckedUpdateManyWithoutStudentNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutMuridNestedInput
  }

  export type InstansiUpdateWithoutMajorsInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    role?: RoleUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUpdateManyWithoutInstansiNestedInput
    student?: StudentUpdateManyWithoutInstansiNestedInput
    tracker?: TrackerUpdateManyWithoutInstansiNestedInput
    history?: TrackerUpdateManyWithoutRefNestedInput
    unikMapels?: MataPelajaranUpdateManyWithoutInstansiNestedInput
    tDevice?: TDeviceUpdateManyWithoutInstansiNestedInput
    objective?: ObjectiveUpdateManyWithoutInstansiNestedInput
    dudi?: DudiUpdateManyWithoutInstansiNestedInput
  }

  export type InstansiUncheckedUpdateWithoutMajorsInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    majorIds?: InstansiUpdatemajorIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    role?: RoleUncheckedUpdateManyWithoutInstansiNestedInput
    schoolYear?: SchoolYearUncheckedUpdateManyWithoutInstansiNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutInstansiNestedInput
    student?: StudentUncheckedUpdateManyWithoutInstansiNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutInstansiNestedInput
    history?: TrackerUncheckedUpdateManyWithoutRefNestedInput
    unikMapels?: MataPelajaranUncheckedUpdateManyWithoutInstansiNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutInstansiNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutInstansiNestedInput
    dudi?: DudiUncheckedUpdateManyWithoutInstansiNestedInput
  }

  export type InstansiUncheckedUpdateManyWithoutInstansiInput = {
    npsn?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    level?: EnumLevelFieldUpdateOperationsInput | Level
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    major?: NullableBoolFieldUpdateOperationsInput | boolean | null
    majorIds?: InstansiUpdatemajorIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassRoomUpdateWithoutMajorInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    property?: XOR<RoomPropertyNullableUpdateEnvelopeInput, RoomPropertyCreateInput> | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    year?: SchoolYearUpdateOneRequiredWithoutClassRoomNestedInput
    wali?: TeacherUpdateOneRequiredWithoutClassRoomNestedInput
    students?: StudentUpdateManyWithoutClassRoomNestedInput
    event?: CalendarUpdateManyWithoutClassRoomNestedInput
    tracker?: TrackerUpdateManyWithoutKelasNestedInput
    teaching?: TeachingUpdateManyWithoutClassRoomNestedInput
    tDevice?: TDeviceUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomUncheckedUpdateWithoutMajorInput = {
    name?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    waliId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    property?: XOR<RoomPropertyNullableUpdateEnvelopeInput, RoomPropertyCreateInput> | null
    studentIds?: ClassRoomUpdatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomUpdateeventIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    teachingIds?: ClassRoomUpdateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomUpdatetDeviceIdsInput | Enumerable<string>
    students?: StudentUncheckedUpdateManyWithoutClassRoomNestedInput
    event?: CalendarUncheckedUpdateManyWithoutClassRoomNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutKelasNestedInput
    teaching?: TeachingUncheckedUpdateManyWithoutClassRoomNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomUncheckedUpdateManyWithoutClassRoomInput = {
    name?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    waliId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    property?: XOR<RoomPropertyNullableUpdateEnvelopeInput, RoomPropertyCreateInput> | null
    studentIds?: ClassRoomUpdatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomUpdateeventIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    teachingIds?: ClassRoomUpdateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomUpdatetDeviceIdsInput | Enumerable<string>
  }

  export type TrackerUpdateWithoutKonsentrasiInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrackerNestedInput
    ref?: InstansiUpdateOneRequiredWithoutHistoryNestedInput
    instansi?: InstansiUpdateOneWithoutTrackerNestedInput
    mapel?: MataPelajaranUpdateOneWithoutTrackerNestedInput
    elemen?: ElementUpdateOneWithoutTrackerNestedInput
    cp?: AchievementUpdateOneWithoutTrackerNestedInput
    bidang?: BidangKeahlianUpdateOneWithoutTrackerNestedInput
    program?: ProgramKeahlianUpdateOneWithoutTrackerNestedInput
    tp?: SchoolYearUpdateOneWithoutTrackerNestedInput
    teacher?: TeacherUpdateOneWithoutTrackerNestedInput
    kelas?: ClassRoomUpdateOneWithoutTrackerNestedInput
    murid?: StudentUpdateOneWithoutTrackerNestedInput
    jadwal?: ScheduleUpdateOneWithoutTrackerNestedInput
    mengajar?: TeachingUpdateOneWithoutTrackerNestedInput
    tujuan?: ObjectiveUpdateOneWithoutTrackerNestedInput
    perangkat?: TDeviceUpdateOneWithoutTrackerNestedInput
    kalender?: CalendarUpdateOneWithoutTrackerNestedInput
    dudi?: DudiUpdateOneWithoutTrackerNestedInput
    kkni?: KkniUpdateOneWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateWithoutKonsentrasiInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    userId?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapelId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    cpId?: NullableStringFieldUpdateOperationsInput | string | null
    bidangId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    tpId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    kelasId?: NullableStringFieldUpdateOperationsInput | string | null
    muridId?: NullableStringFieldUpdateOperationsInput | string | null
    jadwalId?: NullableStringFieldUpdateOperationsInput | string | null
    mengajarId?: NullableStringFieldUpdateOperationsInput | string | null
    tujuanId?: NullableStringFieldUpdateOperationsInput | string | null
    perangkatId?: NullableStringFieldUpdateOperationsInput | string | null
    kalenderId?: NullableStringFieldUpdateOperationsInput | string | null
    dudiId?: NullableStringFieldUpdateOperationsInput | string | null
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MataPelajaranUpdateWithoutKeahlianInput = {
    level?: NullableEnumLevelFieldUpdateOperationsInput | Level | null
    type?: EnumMataPelajaranTypeFieldUpdateOperationsInput | MataPelajaranType
    no?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    program?: ProgramKeahlianUpdateOneWithoutMapelNestedInput
    instansi?: InstansiUpdateOneWithoutUnikMapelsNestedInput
    element?: ElementUpdateManyWithoutMapelNestedInput
    schedule?: ScheduleUpdateManyWithoutMapelNestedInput
    tracker?: TrackerUpdateManyWithoutMapelNestedInput
    objective?: ObjectiveUpdateManyWithoutMapelNestedInput
    device?: TDeviceUpdateManyWithoutMapelNestedInput
  }

  export type MataPelajaranUncheckedUpdateWithoutKeahlianInput = {
    level?: NullableEnumLevelFieldUpdateOperationsInput | Level | null
    type?: EnumMataPelajaranTypeFieldUpdateOperationsInput | MataPelajaranType
    no?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    religion?: NullableEnumReligionFieldUpdateOperationsInput | Religion | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    element?: ElementUncheckedUpdateManyWithoutMapelNestedInput
    schedule?: ScheduleUncheckedUpdateManyWithoutMapelNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutMapelNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutMapelNestedInput
    device?: TDeviceUncheckedUpdateManyWithoutMapelNestedInput
  }

  export type DudiUpdateWithoutMajorInput = {
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    contact?: XOR<ContactDudiUpdateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiUpdatecollabsInput | Enumerable<string>
    timework?: XOR<DudiTimeWorkUpdateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    instansi?: InstansiUpdateOneRequiredWithoutDudiNestedInput
    learning?: DudiLearningUpdateManyWithoutRefNestedInput
    tracker?: TrackerUpdateManyWithoutDudiNestedInput
    kkni?: KkniUpdateOneWithoutDudiNestedInput
  }

  export type DudiUncheckedUpdateWithoutMajorInput = {
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    instansiId?: StringFieldUpdateOperationsInput | string
    contact?: XOR<ContactDudiUpdateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiUpdatecollabsInput | Enumerable<string>
    timework?: XOR<DudiTimeWorkUpdateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
    learning?: DudiLearningUncheckedUpdateManyWithoutRefNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutDudiNestedInput
  }

  export type KkniUpdateWithoutKonsentrasiInput = {
    no?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    dudi?: DudiUpdateManyWithoutKkniNestedInput
    tracker?: TrackerUpdateManyWithoutKkniNestedInput
  }

  export type KkniUncheckedUpdateWithoutKonsentrasiInput = {
    no?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    dudi?: DudiUncheckedUpdateManyWithoutKkniNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutKkniNestedInput
  }

  export type KkniUncheckedUpdateManyWithoutKkniInput = {
    no?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCreateManyRoleInput = {
    id?: string
    name: string
    picture?: string | null
    username: string
    active: boolean
    verify?: boolean
    password: string
    passhash: string
    disable?: boolean
    google?: XOR<GoogleNullableCreateEnvelopeInput, GoogleCreateInput> | null
  }

  export type UserUpdateWithoutRoleInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    google?: XOR<GoogleNullableUpdateEnvelopeInput, GoogleCreateInput> | null
    auth?: AuthUpdateOneWithoutUserNestedInput
    tracker?: TrackerUpdateManyWithoutUserNestedInput
    objective?: ObjectiveUpdateManyWithoutUserNestedInput
    link?: LinkUpdateManyWithoutUserNestedInput
    tDevice?: TDeviceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    google?: XOR<GoogleNullableUpdateEnvelopeInput, GoogleCreateInput> | null
    auth?: AuthUncheckedUpdateOneWithoutUserNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutUserNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutUserNestedInput
    link?: LinkUncheckedUpdateManyWithoutUserNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    verify?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    google?: XOR<GoogleNullableUpdateEnvelopeInput, GoogleCreateInput> | null
  }

  export type TrackerCreateManyUserInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type ObjectiveCreateManyUserInput = {
    id?: string
    level: number
    fase: Fase
    instansiId: string
    yearId: string
    mapelId: string
    elementId: string
    achievementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
  }

  export type LinkCreateManyUserInput = {
    id?: string
    url?: string | null
    title: string
    description?: string | null
    image?: string | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TDeviceCreateManyUserInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    teachingId: string
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    yearId: string
    instansiId: string
    mapelId: string
    classRoomIds?: TDeviceCreateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    parentId?: string | null
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type GoogleUpdateInput = {
    scopes?: GoogleUpdatescopesInput | Enumerable<string>
    tokens?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackerUpdateWithoutUserInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ref?: InstansiUpdateOneRequiredWithoutHistoryNestedInput
    instansi?: InstansiUpdateOneWithoutTrackerNestedInput
    mapel?: MataPelajaranUpdateOneWithoutTrackerNestedInput
    elemen?: ElementUpdateOneWithoutTrackerNestedInput
    cp?: AchievementUpdateOneWithoutTrackerNestedInput
    bidang?: BidangKeahlianUpdateOneWithoutTrackerNestedInput
    program?: ProgramKeahlianUpdateOneWithoutTrackerNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateOneWithoutTrackerNestedInput
    tp?: SchoolYearUpdateOneWithoutTrackerNestedInput
    teacher?: TeacherUpdateOneWithoutTrackerNestedInput
    kelas?: ClassRoomUpdateOneWithoutTrackerNestedInput
    murid?: StudentUpdateOneWithoutTrackerNestedInput
    jadwal?: ScheduleUpdateOneWithoutTrackerNestedInput
    mengajar?: TeachingUpdateOneWithoutTrackerNestedInput
    tujuan?: ObjectiveUpdateOneWithoutTrackerNestedInput
    perangkat?: TDeviceUpdateOneWithoutTrackerNestedInput
    kalender?: CalendarUpdateOneWithoutTrackerNestedInput
    dudi?: DudiUpdateOneWithoutTrackerNestedInput
    kkni?: KkniUpdateOneWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateWithoutUserInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    refId?: StringFieldUpdateOperationsInput | string
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapelId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    cpId?: NullableStringFieldUpdateOperationsInput | string | null
    bidangId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    konsentrasiId?: NullableStringFieldUpdateOperationsInput | string | null
    tpId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    kelasId?: NullableStringFieldUpdateOperationsInput | string | null
    muridId?: NullableStringFieldUpdateOperationsInput | string | null
    jadwalId?: NullableStringFieldUpdateOperationsInput | string | null
    mengajarId?: NullableStringFieldUpdateOperationsInput | string | null
    tujuanId?: NullableStringFieldUpdateOperationsInput | string | null
    perangkatId?: NullableStringFieldUpdateOperationsInput | string | null
    kalenderId?: NullableStringFieldUpdateOperationsInput | string | null
    dudiId?: NullableStringFieldUpdateOperationsInput | string | null
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ObjectiveUpdateWithoutUserInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    instansi?: InstansiUpdateOneRequiredWithoutObjectiveNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutObjectiveNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutObjectiveNestedInput
    elemen?: ElementUpdateOneRequiredWithoutObjectiveNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutObjectiveNestedInput
    material?: OMaterialUpdateManyWithoutRefNestedInput
    tracker?: TrackerUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUpdateManyWithoutRefNestedInput
    ppp?: OpppUpdateManyWithoutRefNestedInput
    tool?: OhelperUpdateManyWithoutToolNestedInput
    mate?: OhelperUpdateManyWithoutMateNestedInput
    meth?: OhelperUpdateManyWithoutMethNestedInput
    media?: OhelperUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateWithoutUserInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    instansiId?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    toolIds?: ObjectiveUpdatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveUpdatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveUpdatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveUpdatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedUpdateManyWithoutRefNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUncheckedUpdateManyWithoutRefNestedInput
    ppp?: OpppUncheckedUpdateManyWithoutRefNestedInput
    tool?: OhelperUncheckedUpdateManyWithoutToolNestedInput
    mate?: OhelperUncheckedUpdateManyWithoutMateNestedInput
    meth?: OhelperUncheckedUpdateManyWithoutMethNestedInput
    media?: OhelperUncheckedUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUncheckedUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUncheckedUpdateManyWithoutObjectiveNestedInput
  }

  export type LinkUpdateWithoutUserInput = {
    url?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    objResource?: OresourceUpdateManyWithoutLinkNestedInput
  }

  export type LinkUncheckedUpdateWithoutUserInput = {
    url?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    objResource?: OresourceUncheckedUpdateManyWithoutLinkNestedInput
  }

  export type LinkUncheckedUpdateManyWithoutLinkInput = {
    url?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TDeviceUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    teaching?: TeachingUpdateOneRequiredWithoutTDeviceNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutTDeviceNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutTDeviceNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutDeviceNestedInput
    classRoom?: ClassRoomUpdateManyWithoutTDeviceNestedInput
    tracker?: TrackerUpdateManyWithoutPerangkatNestedInput
    data?: TDeviceDataUpdateManyWithoutRefNestedInput
    children?: TDeviceUpdateManyWithoutParentNestedInput
    parent?: TDeviceUpdateOneWithoutChildrenNestedInput
  }

  export type TDeviceUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    teachingId?: StringFieldUpdateOperationsInput | string
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    yearId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: TDeviceUpdateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutTDeviceNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutPerangkatNestedInput
    data?: TDeviceDataUncheckedUpdateManyWithoutRefNestedInput
    children?: TDeviceUncheckedUpdateManyWithoutParentNestedInput
  }

  export type FamilyTreeCreateManyFatherInput = {
    id?: string
    nokk: string
    motherId?: string | null
    waliId?: string | null
    coupleId?: string | null
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
  }

  export type FamilyTreeCreateManyMotherInput = {
    id?: string
    nokk: string
    fatherId?: string | null
    waliId?: string | null
    coupleId?: string | null
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
  }

  export type FamilyTreeCreateManyWaliInput = {
    id?: string
    nokk: string
    fatherId?: string | null
    motherId?: string | null
    coupleId?: string | null
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
  }

  export type FamilyTreeCreateManyCoupleInput = {
    id?: string
    nokk: string
    fatherId?: string | null
    motherId?: string | null
    waliId?: string | null
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
  }

  export type StudentCreateManyPersonalInput = {
    id?: string
    nis: string
    lastSchool: string
    majorId?: string | null
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    startYearId: string
    instansiId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
    disable?: boolean
  }

  export type TeacherCreateManyPersonalInput = {
    id?: string
    instansiId: string
    eventIds?: TeacherCreateeventIdsInput | Enumerable<string>
    nip?: string | null
    nrg?: string | null
    noKarpeg?: string | null
    tmtTugas?: Date | string | null
    tmtGol?: Date | string | null
    position?: string | null
    rank?: string | null
    period?: string | null
    certificate?: string | null
    disable?: boolean
  }

  export type EducationUpdateInput = {
    instansi?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelEduFieldUpdateOperationsInput | LevelEdu
    major?: NullableStringFieldUpdateOperationsInput | string | null
    year?: IntFieldUpdateOperationsInput | number
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrainingUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    instansi?: StringFieldUpdateOperationsInput | string
    long?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    place?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmploymentUpdateInput = {
    position?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    place?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfessionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    instansi?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OverseasUpdateInput = {
    country?: StringFieldUpdateOperationsInput | string
    instansi?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    long?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScientificUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    instansi?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    place?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    leader?: StringFieldUpdateOperationsInput | string
    place?: StringFieldUpdateOperationsInput | string
  }

  export type PapersUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    published?: StringFieldUpdateOperationsInput | string
  }

  export type InnovationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    patent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AwardUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    instansi?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SourcePersonUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    instansi?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContestUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    instansi?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    instansi?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdditionalUpdateInput = {
    position?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    instansi?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FamilyTreeUpdateWithoutFatherInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    mother?: PersonalUpdateOneWithoutMotherNestedInput
    wali?: PersonalUpdateOneWithoutWaliNestedInput
    couple?: PersonalUpdateOneWithoutCoupleNestedInput
    childs?: FamilyTreeChildUpdateManyWithoutKkNestedInput
  }

  export type FamilyTreeUncheckedUpdateWithoutFatherInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    motherId?: NullableStringFieldUpdateOperationsInput | string | null
    waliId?: NullableStringFieldUpdateOperationsInput | string | null
    coupleId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    childs?: FamilyTreeChildUncheckedUpdateManyWithoutKkNestedInput
  }

  export type FamilyTreeUncheckedUpdateManyWithoutFatherInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    motherId?: NullableStringFieldUpdateOperationsInput | string | null
    waliId?: NullableStringFieldUpdateOperationsInput | string | null
    coupleId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
  }

  export type FamilyTreeUpdateWithoutMotherInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    father?: PersonalUpdateOneWithoutFatherNestedInput
    wali?: PersonalUpdateOneWithoutWaliNestedInput
    couple?: PersonalUpdateOneWithoutCoupleNestedInput
    childs?: FamilyTreeChildUpdateManyWithoutKkNestedInput
  }

  export type FamilyTreeUncheckedUpdateWithoutMotherInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    fatherId?: NullableStringFieldUpdateOperationsInput | string | null
    waliId?: NullableStringFieldUpdateOperationsInput | string | null
    coupleId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    childs?: FamilyTreeChildUncheckedUpdateManyWithoutKkNestedInput
  }

  export type FamilyTreeUncheckedUpdateManyWithoutMotherInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    fatherId?: NullableStringFieldUpdateOperationsInput | string | null
    waliId?: NullableStringFieldUpdateOperationsInput | string | null
    coupleId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
  }

  export type FamilyTreeUpdateWithoutWaliInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    father?: PersonalUpdateOneWithoutFatherNestedInput
    mother?: PersonalUpdateOneWithoutMotherNestedInput
    couple?: PersonalUpdateOneWithoutCoupleNestedInput
    childs?: FamilyTreeChildUpdateManyWithoutKkNestedInput
  }

  export type FamilyTreeUncheckedUpdateWithoutWaliInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    fatherId?: NullableStringFieldUpdateOperationsInput | string | null
    motherId?: NullableStringFieldUpdateOperationsInput | string | null
    coupleId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    childs?: FamilyTreeChildUncheckedUpdateManyWithoutKkNestedInput
  }

  export type FamilyTreeUncheckedUpdateManyWithoutWaliInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    fatherId?: NullableStringFieldUpdateOperationsInput | string | null
    motherId?: NullableStringFieldUpdateOperationsInput | string | null
    coupleId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
  }

  export type FamilyTreeUpdateWithoutCoupleInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    father?: PersonalUpdateOneWithoutFatherNestedInput
    mother?: PersonalUpdateOneWithoutMotherNestedInput
    wali?: PersonalUpdateOneWithoutWaliNestedInput
    childs?: FamilyTreeChildUpdateManyWithoutKkNestedInput
  }

  export type FamilyTreeUncheckedUpdateWithoutCoupleInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    fatherId?: NullableStringFieldUpdateOperationsInput | string | null
    motherId?: NullableStringFieldUpdateOperationsInput | string | null
    waliId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    childs?: FamilyTreeChildUncheckedUpdateManyWithoutKkNestedInput
  }

  export type FamilyTreeUncheckedUpdateManyWithoutCoupleInput = {
    nokk?: StringFieldUpdateOperationsInput | string
    fatherId?: NullableStringFieldUpdateOperationsInput | string | null
    motherId?: NullableStringFieldUpdateOperationsInput | string | null
    waliId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
  }

  export type StudentUpdateWithoutPersonalInput = {
    nis?: StringFieldUpdateOperationsInput | string
    lastSchool?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    major?: KonsentrasiKeahlianUpdateOneWithoutStudentNestedInput
    classRoom?: ClassRoomUpdateManyWithoutStudentsNestedInput
    startYear?: SchoolYearUpdateOneRequiredWithoutStudentsNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutStudentNestedInput
    event?: CalendarUpdateManyWithoutStudentNestedInput
    tracker?: TrackerUpdateManyWithoutMuridNestedInput
  }

  export type StudentUncheckedUpdateWithoutPersonalInput = {
    nis?: StringFieldUpdateOperationsInput | string
    lastSchool?: StringFieldUpdateOperationsInput | string
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomIds?: StudentUpdateclassRoomIdsInput | Enumerable<string>
    startYearId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: StudentUpdateeventIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutStudentsNestedInput
    event?: CalendarUncheckedUpdateManyWithoutStudentNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutMuridNestedInput
  }

  export type TeacherUpdateWithoutPersonalInput = {
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tmtGol?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUpdateManyWithoutWaliNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutTeacherNestedInput
    event?: CalendarUpdateManyWithoutTeacherNestedInput
    tracker?: TrackerUpdateManyWithoutTeacherNestedInput
    teaching?: TeachingUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutPersonalInput = {
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: TeacherUpdateeventIdsInput | Enumerable<string>
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tmtGol?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutWaliNestedInput
    event?: CalendarUncheckedUpdateManyWithoutTeacherNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTeacherNestedInput
    teaching?: TeachingUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type FamilyTreeChildCreateManyKkInput = {
    id?: string
    no: number
    type: ChildType
    personalId: string
  }

  export type FamilyTreeChildUpdateWithoutKkInput = {
    no?: IntFieldUpdateOperationsInput | number
    type?: EnumChildTypeFieldUpdateOperationsInput | ChildType
    personal?: PersonalUpdateOneRequiredWithoutChildNestedInput
  }

  export type FamilyTreeChildUncheckedUpdateWithoutKkInput = {
    no?: IntFieldUpdateOperationsInput | number
    type?: EnumChildTypeFieldUpdateOperationsInput | ChildType
    personalId?: StringFieldUpdateOperationsInput | string
  }

  export type FamilyTreeChildUncheckedUpdateManyWithoutChildsInput = {
    no?: IntFieldUpdateOperationsInput | number
    type?: EnumChildTypeFieldUpdateOperationsInput | ChildType
    personalId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassRoomCreateManyYearInput = {
    id?: string
    name: string
    waliId: string
    level: number
    property?: XOR<RoomPropertyNullableCreateEnvelopeInput, RoomPropertyCreateInput> | null
    majorId?: string | null
    studentIds?: ClassRoomCreatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomCreateeventIdsInput | Enumerable<string>
    disable?: boolean
    teachingIds?: ClassRoomCreateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomCreatetDeviceIdsInput | Enumerable<string>
  }

  export type StudentCreateManyStartYearInput = {
    id?: string
    nis: string
    lastSchool: string
    personalId: string
    majorId?: string | null
    classRoomIds?: StudentCreateclassRoomIdsInput | Enumerable<string>
    instansiId: string
    eventIds?: StudentCreateeventIdsInput | Enumerable<string>
    disable?: boolean
  }

  export type CalendarCreateManyRefInput = {
    id?: string
    name: string
    description?: string | null
    start: Date | string
    end?: Date | string | null
    color: string
    classRoomIds?: CalendarCreateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarCreatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarCreateteacherIdsInput | Enumerable<string>
    disable?: boolean
  }

  export type ScheduleCreateManyYearInput = {
    id?: string
    mapelId: string
    disable?: boolean
  }

  export type ObjectiveCreateManyYearInput = {
    id?: string
    level: number
    fase: Fase
    userId: string
    instansiId: string
    mapelId: string
    elementId: string
    achievementId: string
    code: string
    kkm: number
    steps?: number
    subjectMatter: string
    competencie?: ObjectiveCreatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveCreatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveCreatetriggerQuestInput | Enumerable<string>
    disable?: boolean
    toolIds?: ObjectiveCreatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveCreatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveCreatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveCreatemediaIdsInput | Enumerable<string>
  }

  export type TrackerCreateManyTpInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TDeviceCreateManyYearInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    teachingId: string
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    userId: string
    instansiId: string
    mapelId: string
    classRoomIds?: TDeviceCreateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    parentId?: string | null
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type ClassRoomUpdateWithoutYearInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    property?: XOR<RoomPropertyNullableUpdateEnvelopeInput, RoomPropertyCreateInput> | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    wali?: TeacherUpdateOneRequiredWithoutClassRoomNestedInput
    major?: KonsentrasiKeahlianUpdateOneWithoutClassRoomNestedInput
    students?: StudentUpdateManyWithoutClassRoomNestedInput
    event?: CalendarUpdateManyWithoutClassRoomNestedInput
    tracker?: TrackerUpdateManyWithoutKelasNestedInput
    teaching?: TeachingUpdateManyWithoutClassRoomNestedInput
    tDevice?: TDeviceUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomUncheckedUpdateWithoutYearInput = {
    name?: StringFieldUpdateOperationsInput | string
    waliId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    property?: XOR<RoomPropertyNullableUpdateEnvelopeInput, RoomPropertyCreateInput> | null
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    studentIds?: ClassRoomUpdatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomUpdateeventIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    teachingIds?: ClassRoomUpdateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomUpdatetDeviceIdsInput | Enumerable<string>
    students?: StudentUncheckedUpdateManyWithoutClassRoomNestedInput
    event?: CalendarUncheckedUpdateManyWithoutClassRoomNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutKelasNestedInput
    teaching?: TeachingUncheckedUpdateManyWithoutClassRoomNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutClassRoomNestedInput
  }

  export type StudentUpdateWithoutStartYearInput = {
    nis?: StringFieldUpdateOperationsInput | string
    lastSchool?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    personal?: PersonalUpdateOneRequiredWithoutStudentNestedInput
    major?: KonsentrasiKeahlianUpdateOneWithoutStudentNestedInput
    classRoom?: ClassRoomUpdateManyWithoutStudentsNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutStudentNestedInput
    event?: CalendarUpdateManyWithoutStudentNestedInput
    tracker?: TrackerUpdateManyWithoutMuridNestedInput
  }

  export type StudentUncheckedUpdateWithoutStartYearInput = {
    nis?: StringFieldUpdateOperationsInput | string
    lastSchool?: StringFieldUpdateOperationsInput | string
    personalId?: StringFieldUpdateOperationsInput | string
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomIds?: StudentUpdateclassRoomIdsInput | Enumerable<string>
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: StudentUpdateeventIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutStudentsNestedInput
    event?: CalendarUncheckedUpdateManyWithoutStudentNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutMuridNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutStudentsInput = {
    nis?: StringFieldUpdateOperationsInput | string
    lastSchool?: StringFieldUpdateOperationsInput | string
    personalId?: StringFieldUpdateOperationsInput | string
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomIds?: StudentUpdateclassRoomIdsInput | Enumerable<string>
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: StudentUpdateeventIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CalendarUpdateWithoutRefInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUpdateManyWithoutEventNestedInput
    student?: StudentUpdateManyWithoutEventNestedInput
    teacher?: TeacherUpdateManyWithoutEventNestedInput
    tracker?: TrackerUpdateManyWithoutKalenderNestedInput
  }

  export type CalendarUncheckedUpdateWithoutRefInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    classRoomIds?: CalendarUpdateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarUpdatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarUpdateteacherIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutEventNestedInput
    student?: StudentUncheckedUpdateManyWithoutEventNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutEventNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutKalenderNestedInput
  }

  export type CalendarUncheckedUpdateManyWithoutCalendarInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    classRoomIds?: CalendarUpdateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarUpdatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarUpdateteacherIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ScheduleUpdateWithoutYearInput = {
    disable?: BoolFieldUpdateOperationsInput | boolean
    mapel?: MataPelajaranUpdateOneRequiredWithoutScheduleNestedInput
    tracker?: TrackerUpdateManyWithoutJadwalNestedInput
    teaching?: TeachingUpdateManyWithoutRefNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutYearInput = {
    mapelId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    tracker?: TrackerUncheckedUpdateManyWithoutJadwalNestedInput
    teaching?: TeachingUncheckedUpdateManyWithoutRefNestedInput
  }

  export type ObjectiveUpdateWithoutYearInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutObjectiveNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutObjectiveNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutObjectiveNestedInput
    elemen?: ElementUpdateOneRequiredWithoutObjectiveNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutObjectiveNestedInput
    material?: OMaterialUpdateManyWithoutRefNestedInput
    tracker?: TrackerUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUpdateManyWithoutRefNestedInput
    ppp?: OpppUpdateManyWithoutRefNestedInput
    tool?: OhelperUpdateManyWithoutToolNestedInput
    mate?: OhelperUpdateManyWithoutMateNestedInput
    meth?: OhelperUpdateManyWithoutMethNestedInput
    media?: OhelperUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateWithoutYearInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    toolIds?: ObjectiveUpdatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveUpdatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveUpdatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveUpdatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedUpdateManyWithoutRefNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUncheckedUpdateManyWithoutRefNestedInput
    ppp?: OpppUncheckedUpdateManyWithoutRefNestedInput
    tool?: OhelperUncheckedUpdateManyWithoutToolNestedInput
    mate?: OhelperUncheckedUpdateManyWithoutMateNestedInput
    meth?: OhelperUncheckedUpdateManyWithoutMethNestedInput
    media?: OhelperUncheckedUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUncheckedUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUncheckedUpdateManyWithoutObjectiveNestedInput
  }

  export type TrackerUpdateWithoutTpInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrackerNestedInput
    ref?: InstansiUpdateOneRequiredWithoutHistoryNestedInput
    instansi?: InstansiUpdateOneWithoutTrackerNestedInput
    mapel?: MataPelajaranUpdateOneWithoutTrackerNestedInput
    elemen?: ElementUpdateOneWithoutTrackerNestedInput
    cp?: AchievementUpdateOneWithoutTrackerNestedInput
    bidang?: BidangKeahlianUpdateOneWithoutTrackerNestedInput
    program?: ProgramKeahlianUpdateOneWithoutTrackerNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateOneWithoutTrackerNestedInput
    teacher?: TeacherUpdateOneWithoutTrackerNestedInput
    kelas?: ClassRoomUpdateOneWithoutTrackerNestedInput
    murid?: StudentUpdateOneWithoutTrackerNestedInput
    jadwal?: ScheduleUpdateOneWithoutTrackerNestedInput
    mengajar?: TeachingUpdateOneWithoutTrackerNestedInput
    tujuan?: ObjectiveUpdateOneWithoutTrackerNestedInput
    perangkat?: TDeviceUpdateOneWithoutTrackerNestedInput
    kalender?: CalendarUpdateOneWithoutTrackerNestedInput
    dudi?: DudiUpdateOneWithoutTrackerNestedInput
    kkni?: KkniUpdateOneWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateWithoutTpInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    userId?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapelId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    cpId?: NullableStringFieldUpdateOperationsInput | string | null
    bidangId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    konsentrasiId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    kelasId?: NullableStringFieldUpdateOperationsInput | string | null
    muridId?: NullableStringFieldUpdateOperationsInput | string | null
    jadwalId?: NullableStringFieldUpdateOperationsInput | string | null
    mengajarId?: NullableStringFieldUpdateOperationsInput | string | null
    tujuanId?: NullableStringFieldUpdateOperationsInput | string | null
    perangkatId?: NullableStringFieldUpdateOperationsInput | string | null
    kalenderId?: NullableStringFieldUpdateOperationsInput | string | null
    dudiId?: NullableStringFieldUpdateOperationsInput | string | null
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TDeviceUpdateWithoutYearInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    teaching?: TeachingUpdateOneRequiredWithoutTDeviceNestedInput
    user?: UserUpdateOneRequiredWithoutTDeviceNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutTDeviceNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutDeviceNestedInput
    classRoom?: ClassRoomUpdateManyWithoutTDeviceNestedInput
    tracker?: TrackerUpdateManyWithoutPerangkatNestedInput
    data?: TDeviceDataUpdateManyWithoutRefNestedInput
    children?: TDeviceUpdateManyWithoutParentNestedInput
    parent?: TDeviceUpdateOneWithoutChildrenNestedInput
  }

  export type TDeviceUncheckedUpdateWithoutYearInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    teachingId?: StringFieldUpdateOperationsInput | string
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: TDeviceUpdateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutTDeviceNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutPerangkatNestedInput
    data?: TDeviceDataUncheckedUpdateManyWithoutRefNestedInput
    children?: TDeviceUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ClassRoomCreateManyWaliInput = {
    id?: string
    name: string
    yearId: string
    level: number
    property?: XOR<RoomPropertyNullableCreateEnvelopeInput, RoomPropertyCreateInput> | null
    majorId?: string | null
    studentIds?: ClassRoomCreatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomCreateeventIdsInput | Enumerable<string>
    disable?: boolean
    teachingIds?: ClassRoomCreateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomCreatetDeviceIdsInput | Enumerable<string>
  }

  export type TrackerCreateManyTeacherInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TeachingCreateManyTeacherInput = {
    id?: string
    refId: string
    level: number
    hours: number
    semester: Semester
    classRoomIds?: TeachingCreateclassRoomIdsInput | Enumerable<string>
    elemenIds?: TeachingCreateelemenIdsInput | Enumerable<string>
    disable?: boolean
  }

  export type ClassRoomUpdateWithoutWaliInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    property?: XOR<RoomPropertyNullableUpdateEnvelopeInput, RoomPropertyCreateInput> | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    year?: SchoolYearUpdateOneRequiredWithoutClassRoomNestedInput
    major?: KonsentrasiKeahlianUpdateOneWithoutClassRoomNestedInput
    students?: StudentUpdateManyWithoutClassRoomNestedInput
    event?: CalendarUpdateManyWithoutClassRoomNestedInput
    tracker?: TrackerUpdateManyWithoutKelasNestedInput
    teaching?: TeachingUpdateManyWithoutClassRoomNestedInput
    tDevice?: TDeviceUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomUncheckedUpdateWithoutWaliInput = {
    name?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    property?: XOR<RoomPropertyNullableUpdateEnvelopeInput, RoomPropertyCreateInput> | null
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    studentIds?: ClassRoomUpdatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomUpdateeventIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    teachingIds?: ClassRoomUpdateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomUpdatetDeviceIdsInput | Enumerable<string>
    students?: StudentUncheckedUpdateManyWithoutClassRoomNestedInput
    event?: CalendarUncheckedUpdateManyWithoutClassRoomNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutKelasNestedInput
    teaching?: TeachingUncheckedUpdateManyWithoutClassRoomNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutClassRoomNestedInput
  }

  export type CalendarUpdateWithoutTeacherInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    ref?: SchoolYearUpdateOneRequiredWithoutCalendarNestedInput
    classRoom?: ClassRoomUpdateManyWithoutEventNestedInput
    student?: StudentUpdateManyWithoutEventNestedInput
    tracker?: TrackerUpdateManyWithoutKalenderNestedInput
  }

  export type CalendarUncheckedUpdateWithoutTeacherInput = {
    refId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    classRoomIds?: CalendarUpdateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarUpdatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarUpdateteacherIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutEventNestedInput
    student?: StudentUncheckedUpdateManyWithoutEventNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutKalenderNestedInput
  }

  export type CalendarUncheckedUpdateManyWithoutEventInput = {
    refId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    classRoomIds?: CalendarUpdateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarUpdatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarUpdateteacherIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TrackerUpdateWithoutTeacherInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrackerNestedInput
    ref?: InstansiUpdateOneRequiredWithoutHistoryNestedInput
    instansi?: InstansiUpdateOneWithoutTrackerNestedInput
    mapel?: MataPelajaranUpdateOneWithoutTrackerNestedInput
    elemen?: ElementUpdateOneWithoutTrackerNestedInput
    cp?: AchievementUpdateOneWithoutTrackerNestedInput
    bidang?: BidangKeahlianUpdateOneWithoutTrackerNestedInput
    program?: ProgramKeahlianUpdateOneWithoutTrackerNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateOneWithoutTrackerNestedInput
    tp?: SchoolYearUpdateOneWithoutTrackerNestedInput
    kelas?: ClassRoomUpdateOneWithoutTrackerNestedInput
    murid?: StudentUpdateOneWithoutTrackerNestedInput
    jadwal?: ScheduleUpdateOneWithoutTrackerNestedInput
    mengajar?: TeachingUpdateOneWithoutTrackerNestedInput
    tujuan?: ObjectiveUpdateOneWithoutTrackerNestedInput
    perangkat?: TDeviceUpdateOneWithoutTrackerNestedInput
    kalender?: CalendarUpdateOneWithoutTrackerNestedInput
    dudi?: DudiUpdateOneWithoutTrackerNestedInput
    kkni?: KkniUpdateOneWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateWithoutTeacherInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    userId?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapelId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    cpId?: NullableStringFieldUpdateOperationsInput | string | null
    bidangId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    konsentrasiId?: NullableStringFieldUpdateOperationsInput | string | null
    tpId?: NullableStringFieldUpdateOperationsInput | string | null
    kelasId?: NullableStringFieldUpdateOperationsInput | string | null
    muridId?: NullableStringFieldUpdateOperationsInput | string | null
    jadwalId?: NullableStringFieldUpdateOperationsInput | string | null
    mengajarId?: NullableStringFieldUpdateOperationsInput | string | null
    tujuanId?: NullableStringFieldUpdateOperationsInput | string | null
    perangkatId?: NullableStringFieldUpdateOperationsInput | string | null
    kalenderId?: NullableStringFieldUpdateOperationsInput | string | null
    dudiId?: NullableStringFieldUpdateOperationsInput | string | null
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeachingUpdateWithoutTeacherInput = {
    level?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    semester?: EnumSemesterFieldUpdateOperationsInput | Semester
    disable?: BoolFieldUpdateOperationsInput | boolean
    ref?: ScheduleUpdateOneRequiredWithoutTeachingNestedInput
    classRoom?: ClassRoomUpdateManyWithoutTeachingNestedInput
    elemen?: ElementUpdateManyWithoutScheduleClassNestedInput
    tracker?: TrackerUpdateManyWithoutMengajarNestedInput
    tDevice?: TDeviceUpdateManyWithoutTeachingNestedInput
  }

  export type TeachingUncheckedUpdateWithoutTeacherInput = {
    refId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    semester?: EnumSemesterFieldUpdateOperationsInput | Semester
    classRoomIds?: TeachingUpdateclassRoomIdsInput | Enumerable<string>
    elemenIds?: TeachingUpdateelemenIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutTeachingNestedInput
    elemen?: ElementUncheckedUpdateManyWithoutScheduleClassNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutMengajarNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutTeachingNestedInput
  }

  export type TeachingUncheckedUpdateManyWithoutTeachingInput = {
    refId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    semester?: EnumSemesterFieldUpdateOperationsInput | Semester
    classRoomIds?: TeachingUpdateclassRoomIdsInput | Enumerable<string>
    elemenIds?: TeachingUpdateelemenIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TrackerCreateManyKelasInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type RoomPropertyUpdateInput = {
    pkl?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type StudentUpdateWithoutClassRoomInput = {
    nis?: StringFieldUpdateOperationsInput | string
    lastSchool?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    personal?: PersonalUpdateOneRequiredWithoutStudentNestedInput
    major?: KonsentrasiKeahlianUpdateOneWithoutStudentNestedInput
    startYear?: SchoolYearUpdateOneRequiredWithoutStudentsNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutStudentNestedInput
    event?: CalendarUpdateManyWithoutStudentNestedInput
    tracker?: TrackerUpdateManyWithoutMuridNestedInput
  }

  export type StudentUncheckedUpdateWithoutClassRoomInput = {
    nis?: StringFieldUpdateOperationsInput | string
    lastSchool?: StringFieldUpdateOperationsInput | string
    personalId?: StringFieldUpdateOperationsInput | string
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomIds?: StudentUpdateclassRoomIdsInput | Enumerable<string>
    startYearId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: StudentUpdateeventIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    event?: CalendarUncheckedUpdateManyWithoutStudentNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutMuridNestedInput
  }

  export type CalendarUpdateWithoutClassRoomInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    ref?: SchoolYearUpdateOneRequiredWithoutCalendarNestedInput
    student?: StudentUpdateManyWithoutEventNestedInput
    teacher?: TeacherUpdateManyWithoutEventNestedInput
    tracker?: TrackerUpdateManyWithoutKalenderNestedInput
  }

  export type CalendarUncheckedUpdateWithoutClassRoomInput = {
    refId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    classRoomIds?: CalendarUpdateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarUpdatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarUpdateteacherIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUncheckedUpdateManyWithoutEventNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutEventNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutKalenderNestedInput
  }

  export type TrackerUpdateWithoutKelasInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrackerNestedInput
    ref?: InstansiUpdateOneRequiredWithoutHistoryNestedInput
    instansi?: InstansiUpdateOneWithoutTrackerNestedInput
    mapel?: MataPelajaranUpdateOneWithoutTrackerNestedInput
    elemen?: ElementUpdateOneWithoutTrackerNestedInput
    cp?: AchievementUpdateOneWithoutTrackerNestedInput
    bidang?: BidangKeahlianUpdateOneWithoutTrackerNestedInput
    program?: ProgramKeahlianUpdateOneWithoutTrackerNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateOneWithoutTrackerNestedInput
    tp?: SchoolYearUpdateOneWithoutTrackerNestedInput
    teacher?: TeacherUpdateOneWithoutTrackerNestedInput
    murid?: StudentUpdateOneWithoutTrackerNestedInput
    jadwal?: ScheduleUpdateOneWithoutTrackerNestedInput
    mengajar?: TeachingUpdateOneWithoutTrackerNestedInput
    tujuan?: ObjectiveUpdateOneWithoutTrackerNestedInput
    perangkat?: TDeviceUpdateOneWithoutTrackerNestedInput
    kalender?: CalendarUpdateOneWithoutTrackerNestedInput
    dudi?: DudiUpdateOneWithoutTrackerNestedInput
    kkni?: KkniUpdateOneWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateWithoutKelasInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    userId?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapelId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    cpId?: NullableStringFieldUpdateOperationsInput | string | null
    bidangId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    konsentrasiId?: NullableStringFieldUpdateOperationsInput | string | null
    tpId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    muridId?: NullableStringFieldUpdateOperationsInput | string | null
    jadwalId?: NullableStringFieldUpdateOperationsInput | string | null
    mengajarId?: NullableStringFieldUpdateOperationsInput | string | null
    tujuanId?: NullableStringFieldUpdateOperationsInput | string | null
    perangkatId?: NullableStringFieldUpdateOperationsInput | string | null
    kalenderId?: NullableStringFieldUpdateOperationsInput | string | null
    dudiId?: NullableStringFieldUpdateOperationsInput | string | null
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeachingUpdateWithoutClassRoomInput = {
    level?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    semester?: EnumSemesterFieldUpdateOperationsInput | Semester
    disable?: BoolFieldUpdateOperationsInput | boolean
    ref?: ScheduleUpdateOneRequiredWithoutTeachingNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutTeachingNestedInput
    elemen?: ElementUpdateManyWithoutScheduleClassNestedInput
    tracker?: TrackerUpdateManyWithoutMengajarNestedInput
    tDevice?: TDeviceUpdateManyWithoutTeachingNestedInput
  }

  export type TeachingUncheckedUpdateWithoutClassRoomInput = {
    refId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    semester?: EnumSemesterFieldUpdateOperationsInput | Semester
    teacherId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: TeachingUpdateclassRoomIdsInput | Enumerable<string>
    elemenIds?: TeachingUpdateelemenIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    elemen?: ElementUncheckedUpdateManyWithoutScheduleClassNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutMengajarNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutTeachingNestedInput
  }

  export type TDeviceUpdateWithoutClassRoomInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    teaching?: TeachingUpdateOneRequiredWithoutTDeviceNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutTDeviceNestedInput
    user?: UserUpdateOneRequiredWithoutTDeviceNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutTDeviceNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutDeviceNestedInput
    tracker?: TrackerUpdateManyWithoutPerangkatNestedInput
    data?: TDeviceDataUpdateManyWithoutRefNestedInput
    children?: TDeviceUpdateManyWithoutParentNestedInput
    parent?: TDeviceUpdateOneWithoutChildrenNestedInput
  }

  export type TDeviceUncheckedUpdateWithoutClassRoomInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    teachingId?: StringFieldUpdateOperationsInput | string
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    yearId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: TDeviceUpdateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    tracker?: TrackerUncheckedUpdateManyWithoutPerangkatNestedInput
    data?: TDeviceDataUncheckedUpdateManyWithoutRefNestedInput
    children?: TDeviceUncheckedUpdateManyWithoutParentNestedInput
  }

  export type TrackerCreateManyMuridInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type ClassRoomUpdateWithoutStudentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    property?: XOR<RoomPropertyNullableUpdateEnvelopeInput, RoomPropertyCreateInput> | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    year?: SchoolYearUpdateOneRequiredWithoutClassRoomNestedInput
    wali?: TeacherUpdateOneRequiredWithoutClassRoomNestedInput
    major?: KonsentrasiKeahlianUpdateOneWithoutClassRoomNestedInput
    event?: CalendarUpdateManyWithoutClassRoomNestedInput
    tracker?: TrackerUpdateManyWithoutKelasNestedInput
    teaching?: TeachingUpdateManyWithoutClassRoomNestedInput
    tDevice?: TDeviceUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomUncheckedUpdateWithoutStudentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    waliId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    property?: XOR<RoomPropertyNullableUpdateEnvelopeInput, RoomPropertyCreateInput> | null
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    studentIds?: ClassRoomUpdatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomUpdateeventIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    teachingIds?: ClassRoomUpdateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomUpdatetDeviceIdsInput | Enumerable<string>
    event?: CalendarUncheckedUpdateManyWithoutClassRoomNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutKelasNestedInput
    teaching?: TeachingUncheckedUpdateManyWithoutClassRoomNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutClassRoomNestedInput
  }

  export type CalendarUpdateWithoutStudentInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    ref?: SchoolYearUpdateOneRequiredWithoutCalendarNestedInput
    classRoom?: ClassRoomUpdateManyWithoutEventNestedInput
    teacher?: TeacherUpdateManyWithoutEventNestedInput
    tracker?: TrackerUpdateManyWithoutKalenderNestedInput
  }

  export type CalendarUncheckedUpdateWithoutStudentInput = {
    refId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: StringFieldUpdateOperationsInput | string
    classRoomIds?: CalendarUpdateclassRoomIdsInput | Enumerable<string>
    studentIds?: CalendarUpdatestudentIdsInput | Enumerable<string>
    teacherIds?: CalendarUpdateteacherIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutEventNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutEventNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutKalenderNestedInput
  }

  export type TrackerUpdateWithoutMuridInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrackerNestedInput
    ref?: InstansiUpdateOneRequiredWithoutHistoryNestedInput
    instansi?: InstansiUpdateOneWithoutTrackerNestedInput
    mapel?: MataPelajaranUpdateOneWithoutTrackerNestedInput
    elemen?: ElementUpdateOneWithoutTrackerNestedInput
    cp?: AchievementUpdateOneWithoutTrackerNestedInput
    bidang?: BidangKeahlianUpdateOneWithoutTrackerNestedInput
    program?: ProgramKeahlianUpdateOneWithoutTrackerNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateOneWithoutTrackerNestedInput
    tp?: SchoolYearUpdateOneWithoutTrackerNestedInput
    teacher?: TeacherUpdateOneWithoutTrackerNestedInput
    kelas?: ClassRoomUpdateOneWithoutTrackerNestedInput
    jadwal?: ScheduleUpdateOneWithoutTrackerNestedInput
    mengajar?: TeachingUpdateOneWithoutTrackerNestedInput
    tujuan?: ObjectiveUpdateOneWithoutTrackerNestedInput
    perangkat?: TDeviceUpdateOneWithoutTrackerNestedInput
    kalender?: CalendarUpdateOneWithoutTrackerNestedInput
    dudi?: DudiUpdateOneWithoutTrackerNestedInput
    kkni?: KkniUpdateOneWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateWithoutMuridInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    userId?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapelId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    cpId?: NullableStringFieldUpdateOperationsInput | string | null
    bidangId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    konsentrasiId?: NullableStringFieldUpdateOperationsInput | string | null
    tpId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    kelasId?: NullableStringFieldUpdateOperationsInput | string | null
    jadwalId?: NullableStringFieldUpdateOperationsInput | string | null
    mengajarId?: NullableStringFieldUpdateOperationsInput | string | null
    tujuanId?: NullableStringFieldUpdateOperationsInput | string | null
    perangkatId?: NullableStringFieldUpdateOperationsInput | string | null
    kalenderId?: NullableStringFieldUpdateOperationsInput | string | null
    dudiId?: NullableStringFieldUpdateOperationsInput | string | null
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrackerCreateManyJadwalInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TeachingCreateManyRefInput = {
    id?: string
    level: number
    hours: number
    semester: Semester
    teacherId: string
    classRoomIds?: TeachingCreateclassRoomIdsInput | Enumerable<string>
    elemenIds?: TeachingCreateelemenIdsInput | Enumerable<string>
    disable?: boolean
  }

  export type TrackerUpdateWithoutJadwalInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrackerNestedInput
    ref?: InstansiUpdateOneRequiredWithoutHistoryNestedInput
    instansi?: InstansiUpdateOneWithoutTrackerNestedInput
    mapel?: MataPelajaranUpdateOneWithoutTrackerNestedInput
    elemen?: ElementUpdateOneWithoutTrackerNestedInput
    cp?: AchievementUpdateOneWithoutTrackerNestedInput
    bidang?: BidangKeahlianUpdateOneWithoutTrackerNestedInput
    program?: ProgramKeahlianUpdateOneWithoutTrackerNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateOneWithoutTrackerNestedInput
    tp?: SchoolYearUpdateOneWithoutTrackerNestedInput
    teacher?: TeacherUpdateOneWithoutTrackerNestedInput
    kelas?: ClassRoomUpdateOneWithoutTrackerNestedInput
    murid?: StudentUpdateOneWithoutTrackerNestedInput
    mengajar?: TeachingUpdateOneWithoutTrackerNestedInput
    tujuan?: ObjectiveUpdateOneWithoutTrackerNestedInput
    perangkat?: TDeviceUpdateOneWithoutTrackerNestedInput
    kalender?: CalendarUpdateOneWithoutTrackerNestedInput
    dudi?: DudiUpdateOneWithoutTrackerNestedInput
    kkni?: KkniUpdateOneWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateWithoutJadwalInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    userId?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapelId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    cpId?: NullableStringFieldUpdateOperationsInput | string | null
    bidangId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    konsentrasiId?: NullableStringFieldUpdateOperationsInput | string | null
    tpId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    kelasId?: NullableStringFieldUpdateOperationsInput | string | null
    muridId?: NullableStringFieldUpdateOperationsInput | string | null
    mengajarId?: NullableStringFieldUpdateOperationsInput | string | null
    tujuanId?: NullableStringFieldUpdateOperationsInput | string | null
    perangkatId?: NullableStringFieldUpdateOperationsInput | string | null
    kalenderId?: NullableStringFieldUpdateOperationsInput | string | null
    dudiId?: NullableStringFieldUpdateOperationsInput | string | null
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeachingUpdateWithoutRefInput = {
    level?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    semester?: EnumSemesterFieldUpdateOperationsInput | Semester
    disable?: BoolFieldUpdateOperationsInput | boolean
    teacher?: TeacherUpdateOneRequiredWithoutTeachingNestedInput
    classRoom?: ClassRoomUpdateManyWithoutTeachingNestedInput
    elemen?: ElementUpdateManyWithoutScheduleClassNestedInput
    tracker?: TrackerUpdateManyWithoutMengajarNestedInput
    tDevice?: TDeviceUpdateManyWithoutTeachingNestedInput
  }

  export type TeachingUncheckedUpdateWithoutRefInput = {
    level?: IntFieldUpdateOperationsInput | number
    hours?: IntFieldUpdateOperationsInput | number
    semester?: EnumSemesterFieldUpdateOperationsInput | Semester
    teacherId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: TeachingUpdateclassRoomIdsInput | Enumerable<string>
    elemenIds?: TeachingUpdateelemenIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutTeachingNestedInput
    elemen?: ElementUncheckedUpdateManyWithoutScheduleClassNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutMengajarNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutTeachingNestedInput
  }

  export type TrackerCreateManyMengajarInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TDeviceCreateManyTeachingInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    yearId: string
    userId: string
    instansiId: string
    mapelId: string
    classRoomIds?: TDeviceCreateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    parentId?: string | null
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type ClassRoomUpdateWithoutTeachingInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    property?: XOR<RoomPropertyNullableUpdateEnvelopeInput, RoomPropertyCreateInput> | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    year?: SchoolYearUpdateOneRequiredWithoutClassRoomNestedInput
    wali?: TeacherUpdateOneRequiredWithoutClassRoomNestedInput
    major?: KonsentrasiKeahlianUpdateOneWithoutClassRoomNestedInput
    students?: StudentUpdateManyWithoutClassRoomNestedInput
    event?: CalendarUpdateManyWithoutClassRoomNestedInput
    tracker?: TrackerUpdateManyWithoutKelasNestedInput
    tDevice?: TDeviceUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomUncheckedUpdateWithoutTeachingInput = {
    name?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    waliId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    property?: XOR<RoomPropertyNullableUpdateEnvelopeInput, RoomPropertyCreateInput> | null
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    studentIds?: ClassRoomUpdatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomUpdateeventIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    teachingIds?: ClassRoomUpdateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomUpdatetDeviceIdsInput | Enumerable<string>
    students?: StudentUncheckedUpdateManyWithoutClassRoomNestedInput
    event?: CalendarUncheckedUpdateManyWithoutClassRoomNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutKelasNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutClassRoomNestedInput
  }

  export type ElementUpdateWithoutScheduleClassInput = {
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    achievement?: AchievementUpdateManyWithoutElementNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutElementNestedInput
    tracker?: TrackerUpdateManyWithoutElemenNestedInput
    objective?: ObjectiveUpdateManyWithoutElemenNestedInput
  }

  export type ElementUncheckedUpdateWithoutScheduleClassInput = {
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    scheduleClassIds?: ElementUpdatescheduleClassIdsInput | Enumerable<string>
    achievement?: AchievementUncheckedUpdateManyWithoutElementNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutElemenNestedInput
    objective?: ObjectiveUncheckedUpdateManyWithoutElemenNestedInput
  }

  export type ElementUncheckedUpdateManyWithoutElemenInput = {
    no?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    scheduleClassIds?: ElementUpdatescheduleClassIdsInput | Enumerable<string>
  }

  export type TrackerUpdateWithoutMengajarInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrackerNestedInput
    ref?: InstansiUpdateOneRequiredWithoutHistoryNestedInput
    instansi?: InstansiUpdateOneWithoutTrackerNestedInput
    mapel?: MataPelajaranUpdateOneWithoutTrackerNestedInput
    elemen?: ElementUpdateOneWithoutTrackerNestedInput
    cp?: AchievementUpdateOneWithoutTrackerNestedInput
    bidang?: BidangKeahlianUpdateOneWithoutTrackerNestedInput
    program?: ProgramKeahlianUpdateOneWithoutTrackerNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateOneWithoutTrackerNestedInput
    tp?: SchoolYearUpdateOneWithoutTrackerNestedInput
    teacher?: TeacherUpdateOneWithoutTrackerNestedInput
    kelas?: ClassRoomUpdateOneWithoutTrackerNestedInput
    murid?: StudentUpdateOneWithoutTrackerNestedInput
    jadwal?: ScheduleUpdateOneWithoutTrackerNestedInput
    tujuan?: ObjectiveUpdateOneWithoutTrackerNestedInput
    perangkat?: TDeviceUpdateOneWithoutTrackerNestedInput
    kalender?: CalendarUpdateOneWithoutTrackerNestedInput
    dudi?: DudiUpdateOneWithoutTrackerNestedInput
    kkni?: KkniUpdateOneWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateWithoutMengajarInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    userId?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapelId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    cpId?: NullableStringFieldUpdateOperationsInput | string | null
    bidangId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    konsentrasiId?: NullableStringFieldUpdateOperationsInput | string | null
    tpId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    kelasId?: NullableStringFieldUpdateOperationsInput | string | null
    muridId?: NullableStringFieldUpdateOperationsInput | string | null
    jadwalId?: NullableStringFieldUpdateOperationsInput | string | null
    tujuanId?: NullableStringFieldUpdateOperationsInput | string | null
    perangkatId?: NullableStringFieldUpdateOperationsInput | string | null
    kalenderId?: NullableStringFieldUpdateOperationsInput | string | null
    dudiId?: NullableStringFieldUpdateOperationsInput | string | null
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TDeviceUpdateWithoutTeachingInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    year?: SchoolYearUpdateOneRequiredWithoutTDeviceNestedInput
    user?: UserUpdateOneRequiredWithoutTDeviceNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutTDeviceNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutDeviceNestedInput
    classRoom?: ClassRoomUpdateManyWithoutTDeviceNestedInput
    tracker?: TrackerUpdateManyWithoutPerangkatNestedInput
    data?: TDeviceDataUpdateManyWithoutRefNestedInput
    children?: TDeviceUpdateManyWithoutParentNestedInput
    parent?: TDeviceUpdateOneWithoutChildrenNestedInput
  }

  export type TDeviceUncheckedUpdateWithoutTeachingInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    yearId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: TDeviceUpdateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutTDeviceNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutPerangkatNestedInput
    data?: TDeviceDataUncheckedUpdateManyWithoutRefNestedInput
    children?: TDeviceUncheckedUpdateManyWithoutParentNestedInput
  }

  export type OresourceCreateManyLinkInput = {
    id?: string
    name: string
    type: OresourceType
    refId: string
  }

  export type OresourceUpdateWithoutLinkInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumOresourceTypeFieldUpdateOperationsInput | OresourceType
    ref?: ObjectiveUpdateOneRequiredWithoutResourseNestedInput
  }

  export type OresourceUncheckedUpdateWithoutLinkInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumOresourceTypeFieldUpdateOperationsInput | OresourceType
    refId?: StringFieldUpdateOperationsInput | string
  }

  export type OresourceUncheckedUpdateManyWithoutObjResourceInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumOresourceTypeFieldUpdateOperationsInput | OresourceType
    refId?: StringFieldUpdateOperationsInput | string
  }

  export type OMaterialCreateManyRefInput = {
    id?: string
    no: number
    content: string
    model: OMaterialModel
  }

  export type TrackerCreateManyTujuanInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type OresourceCreateManyRefInput = {
    id?: string
    name: string
    type: OresourceType
    linkId?: string | null
  }

  export type OpppCreateManyRefInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type OAssessmentCreateManyRefInput = {
    id?: string
    type: string
    techs?: OAssessmentCreatetechsInput | Enumerable<string>
  }

  export type TDeviceDataCreateManyObjectiveInput = {
    id?: string
    refId: string
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type OMaterialUpdateWithoutRefInput = {
    no?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    model?: EnumOMaterialModelFieldUpdateOperationsInput | OMaterialModel
    learning?: OLearningUpdateManyWithoutRefNestedInput
  }

  export type OMaterialUncheckedUpdateWithoutRefInput = {
    no?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    model?: EnumOMaterialModelFieldUpdateOperationsInput | OMaterialModel
    learning?: OLearningUncheckedUpdateManyWithoutRefNestedInput
  }

  export type OMaterialUncheckedUpdateManyWithoutMaterialInput = {
    no?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    model?: EnumOMaterialModelFieldUpdateOperationsInput | OMaterialModel
  }

  export type TrackerUpdateWithoutTujuanInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrackerNestedInput
    ref?: InstansiUpdateOneRequiredWithoutHistoryNestedInput
    instansi?: InstansiUpdateOneWithoutTrackerNestedInput
    mapel?: MataPelajaranUpdateOneWithoutTrackerNestedInput
    elemen?: ElementUpdateOneWithoutTrackerNestedInput
    cp?: AchievementUpdateOneWithoutTrackerNestedInput
    bidang?: BidangKeahlianUpdateOneWithoutTrackerNestedInput
    program?: ProgramKeahlianUpdateOneWithoutTrackerNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateOneWithoutTrackerNestedInput
    tp?: SchoolYearUpdateOneWithoutTrackerNestedInput
    teacher?: TeacherUpdateOneWithoutTrackerNestedInput
    kelas?: ClassRoomUpdateOneWithoutTrackerNestedInput
    murid?: StudentUpdateOneWithoutTrackerNestedInput
    jadwal?: ScheduleUpdateOneWithoutTrackerNestedInput
    mengajar?: TeachingUpdateOneWithoutTrackerNestedInput
    perangkat?: TDeviceUpdateOneWithoutTrackerNestedInput
    kalender?: CalendarUpdateOneWithoutTrackerNestedInput
    dudi?: DudiUpdateOneWithoutTrackerNestedInput
    kkni?: KkniUpdateOneWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateWithoutTujuanInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    userId?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapelId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    cpId?: NullableStringFieldUpdateOperationsInput | string | null
    bidangId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    konsentrasiId?: NullableStringFieldUpdateOperationsInput | string | null
    tpId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    kelasId?: NullableStringFieldUpdateOperationsInput | string | null
    muridId?: NullableStringFieldUpdateOperationsInput | string | null
    jadwalId?: NullableStringFieldUpdateOperationsInput | string | null
    mengajarId?: NullableStringFieldUpdateOperationsInput | string | null
    perangkatId?: NullableStringFieldUpdateOperationsInput | string | null
    kalenderId?: NullableStringFieldUpdateOperationsInput | string | null
    dudiId?: NullableStringFieldUpdateOperationsInput | string | null
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OresourceUpdateWithoutRefInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumOresourceTypeFieldUpdateOperationsInput | OresourceType
    link?: LinkUpdateOneWithoutObjResourceNestedInput
  }

  export type OresourceUncheckedUpdateWithoutRefInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumOresourceTypeFieldUpdateOperationsInput | OresourceType
    linkId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OresourceUncheckedUpdateManyWithoutResourseInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumOresourceTypeFieldUpdateOperationsInput | OresourceType
    linkId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OpppUpdateWithoutRefInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OpppUncheckedUpdateWithoutRefInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OpppUncheckedUpdateManyWithoutPppInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OhelperUpdateWithoutToolInput = {
    type?: EnumOhelperTypeFieldUpdateOperationsInput | OhelperType
    name?: StringFieldUpdateOperationsInput | string
    mate?: ObjectiveUpdateManyWithoutMateNestedInput
    meth?: ObjectiveUpdateManyWithoutMethNestedInput
    media?: ObjectiveUpdateManyWithoutMediaNestedInput
  }

  export type OhelperUncheckedUpdateWithoutToolInput = {
    type?: EnumOhelperTypeFieldUpdateOperationsInput | OhelperType
    name?: StringFieldUpdateOperationsInput | string
    toolIds?: OhelperUpdatetoolIdsInput | Enumerable<string>
    mateIds?: OhelperUpdatemateIdsInput | Enumerable<string>
    methIds?: OhelperUpdatemethIdsInput | Enumerable<string>
    mediaIds?: OhelperUpdatemediaIdsInput | Enumerable<string>
    mate?: ObjectiveUncheckedUpdateManyWithoutMateNestedInput
    meth?: ObjectiveUncheckedUpdateManyWithoutMethNestedInput
    media?: ObjectiveUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type OhelperUncheckedUpdateManyWithoutToolInput = {
    type?: EnumOhelperTypeFieldUpdateOperationsInput | OhelperType
    name?: StringFieldUpdateOperationsInput | string
    toolIds?: OhelperUpdatetoolIdsInput | Enumerable<string>
    mateIds?: OhelperUpdatemateIdsInput | Enumerable<string>
    methIds?: OhelperUpdatemethIdsInput | Enumerable<string>
    mediaIds?: OhelperUpdatemediaIdsInput | Enumerable<string>
  }

  export type OhelperUpdateWithoutMateInput = {
    type?: EnumOhelperTypeFieldUpdateOperationsInput | OhelperType
    name?: StringFieldUpdateOperationsInput | string
    tool?: ObjectiveUpdateManyWithoutToolNestedInput
    meth?: ObjectiveUpdateManyWithoutMethNestedInput
    media?: ObjectiveUpdateManyWithoutMediaNestedInput
  }

  export type OhelperUncheckedUpdateWithoutMateInput = {
    type?: EnumOhelperTypeFieldUpdateOperationsInput | OhelperType
    name?: StringFieldUpdateOperationsInput | string
    toolIds?: OhelperUpdatetoolIdsInput | Enumerable<string>
    mateIds?: OhelperUpdatemateIdsInput | Enumerable<string>
    methIds?: OhelperUpdatemethIdsInput | Enumerable<string>
    mediaIds?: OhelperUpdatemediaIdsInput | Enumerable<string>
    tool?: ObjectiveUncheckedUpdateManyWithoutToolNestedInput
    meth?: ObjectiveUncheckedUpdateManyWithoutMethNestedInput
    media?: ObjectiveUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type OhelperUncheckedUpdateManyWithoutMateInput = {
    type?: EnumOhelperTypeFieldUpdateOperationsInput | OhelperType
    name?: StringFieldUpdateOperationsInput | string
    toolIds?: OhelperUpdatetoolIdsInput | Enumerable<string>
    mateIds?: OhelperUpdatemateIdsInput | Enumerable<string>
    methIds?: OhelperUpdatemethIdsInput | Enumerable<string>
    mediaIds?: OhelperUpdatemediaIdsInput | Enumerable<string>
  }

  export type OhelperUpdateWithoutMethInput = {
    type?: EnumOhelperTypeFieldUpdateOperationsInput | OhelperType
    name?: StringFieldUpdateOperationsInput | string
    tool?: ObjectiveUpdateManyWithoutToolNestedInput
    mate?: ObjectiveUpdateManyWithoutMateNestedInput
    media?: ObjectiveUpdateManyWithoutMediaNestedInput
  }

  export type OhelperUncheckedUpdateWithoutMethInput = {
    type?: EnumOhelperTypeFieldUpdateOperationsInput | OhelperType
    name?: StringFieldUpdateOperationsInput | string
    toolIds?: OhelperUpdatetoolIdsInput | Enumerable<string>
    mateIds?: OhelperUpdatemateIdsInput | Enumerable<string>
    methIds?: OhelperUpdatemethIdsInput | Enumerable<string>
    mediaIds?: OhelperUpdatemediaIdsInput | Enumerable<string>
    tool?: ObjectiveUncheckedUpdateManyWithoutToolNestedInput
    mate?: ObjectiveUncheckedUpdateManyWithoutMateNestedInput
    media?: ObjectiveUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type OhelperUncheckedUpdateManyWithoutMethInput = {
    type?: EnumOhelperTypeFieldUpdateOperationsInput | OhelperType
    name?: StringFieldUpdateOperationsInput | string
    toolIds?: OhelperUpdatetoolIdsInput | Enumerable<string>
    mateIds?: OhelperUpdatemateIdsInput | Enumerable<string>
    methIds?: OhelperUpdatemethIdsInput | Enumerable<string>
    mediaIds?: OhelperUpdatemediaIdsInput | Enumerable<string>
  }

  export type OhelperUpdateWithoutMediaInput = {
    type?: EnumOhelperTypeFieldUpdateOperationsInput | OhelperType
    name?: StringFieldUpdateOperationsInput | string
    tool?: ObjectiveUpdateManyWithoutToolNestedInput
    mate?: ObjectiveUpdateManyWithoutMateNestedInput
    meth?: ObjectiveUpdateManyWithoutMethNestedInput
  }

  export type OhelperUncheckedUpdateWithoutMediaInput = {
    type?: EnumOhelperTypeFieldUpdateOperationsInput | OhelperType
    name?: StringFieldUpdateOperationsInput | string
    toolIds?: OhelperUpdatetoolIdsInput | Enumerable<string>
    mateIds?: OhelperUpdatemateIdsInput | Enumerable<string>
    methIds?: OhelperUpdatemethIdsInput | Enumerable<string>
    mediaIds?: OhelperUpdatemediaIdsInput | Enumerable<string>
    tool?: ObjectiveUncheckedUpdateManyWithoutToolNestedInput
    mate?: ObjectiveUncheckedUpdateManyWithoutMateNestedInput
    meth?: ObjectiveUncheckedUpdateManyWithoutMethNestedInput
  }

  export type OhelperUncheckedUpdateManyWithoutMediaInput = {
    type?: EnumOhelperTypeFieldUpdateOperationsInput | OhelperType
    name?: StringFieldUpdateOperationsInput | string
    toolIds?: OhelperUpdatetoolIdsInput | Enumerable<string>
    mateIds?: OhelperUpdatemateIdsInput | Enumerable<string>
    methIds?: OhelperUpdatemethIdsInput | Enumerable<string>
    mediaIds?: OhelperUpdatemediaIdsInput | Enumerable<string>
  }

  export type OAssessmentUpdateWithoutRefInput = {
    type?: StringFieldUpdateOperationsInput | string
    techs?: OAssessmentUpdatetechsInput | Enumerable<string>
  }

  export type OAssessmentUncheckedUpdateWithoutRefInput = {
    type?: StringFieldUpdateOperationsInput | string
    techs?: OAssessmentUpdatetechsInput | Enumerable<string>
  }

  export type OAssessmentUncheckedUpdateManyWithoutAssessmentsInput = {
    type?: StringFieldUpdateOperationsInput | string
    techs?: OAssessmentUpdatetechsInput | Enumerable<string>
  }

  export type TDeviceDataUpdateWithoutObjectiveInput = {
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    ref?: TDeviceUpdateOneRequiredWithoutDataNestedInput
  }

  export type TDeviceDataUncheckedUpdateWithoutObjectiveInput = {
    refId?: StringFieldUpdateOperationsInput | string
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type TDeviceDataUncheckedUpdateManyWithoutDevicesInput = {
    refId?: StringFieldUpdateOperationsInput | string
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type OLearningCreateManyRefInput = {
    id?: string
    no: number
    content: string
    taksonomi: Taksonomi
    sentence: string
  }

  export type OLearningUpdateWithoutRefInput = {
    no?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    taksonomi?: EnumTaksonomiFieldUpdateOperationsInput | Taksonomi
    sentence?: StringFieldUpdateOperationsInput | string
  }

  export type OLearningUncheckedUpdateWithoutRefInput = {
    no?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    taksonomi?: EnumTaksonomiFieldUpdateOperationsInput | Taksonomi
    sentence?: StringFieldUpdateOperationsInput | string
  }

  export type OLearningUncheckedUpdateManyWithoutLearningInput = {
    no?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    taksonomi?: EnumTaksonomiFieldUpdateOperationsInput | Taksonomi
    sentence?: StringFieldUpdateOperationsInput | string
  }

  export type ObjectiveUpdateWithoutToolInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutObjectiveNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutObjectiveNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutObjectiveNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutObjectiveNestedInput
    elemen?: ElementUpdateOneRequiredWithoutObjectiveNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutObjectiveNestedInput
    material?: OMaterialUpdateManyWithoutRefNestedInput
    tracker?: TrackerUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUpdateManyWithoutRefNestedInput
    ppp?: OpppUpdateManyWithoutRefNestedInput
    mate?: OhelperUpdateManyWithoutMateNestedInput
    meth?: OhelperUpdateManyWithoutMethNestedInput
    media?: OhelperUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateWithoutToolInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    toolIds?: ObjectiveUpdatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveUpdatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveUpdatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveUpdatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedUpdateManyWithoutRefNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUncheckedUpdateManyWithoutRefNestedInput
    ppp?: OpppUncheckedUpdateManyWithoutRefNestedInput
    mate?: OhelperUncheckedUpdateManyWithoutMateNestedInput
    meth?: OhelperUncheckedUpdateManyWithoutMethNestedInput
    media?: OhelperUncheckedUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUncheckedUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUncheckedUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateManyWithoutToolInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    toolIds?: ObjectiveUpdatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveUpdatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveUpdatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveUpdatemediaIdsInput | Enumerable<string>
  }

  export type ObjectiveUpdateWithoutMateInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutObjectiveNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutObjectiveNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutObjectiveNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutObjectiveNestedInput
    elemen?: ElementUpdateOneRequiredWithoutObjectiveNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutObjectiveNestedInput
    material?: OMaterialUpdateManyWithoutRefNestedInput
    tracker?: TrackerUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUpdateManyWithoutRefNestedInput
    ppp?: OpppUpdateManyWithoutRefNestedInput
    tool?: OhelperUpdateManyWithoutToolNestedInput
    meth?: OhelperUpdateManyWithoutMethNestedInput
    media?: OhelperUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateWithoutMateInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    toolIds?: ObjectiveUpdatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveUpdatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveUpdatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveUpdatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedUpdateManyWithoutRefNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUncheckedUpdateManyWithoutRefNestedInput
    ppp?: OpppUncheckedUpdateManyWithoutRefNestedInput
    tool?: OhelperUncheckedUpdateManyWithoutToolNestedInput
    meth?: OhelperUncheckedUpdateManyWithoutMethNestedInput
    media?: OhelperUncheckedUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUncheckedUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUncheckedUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateManyWithoutMateInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    toolIds?: ObjectiveUpdatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveUpdatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveUpdatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveUpdatemediaIdsInput | Enumerable<string>
  }

  export type ObjectiveUpdateWithoutMethInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutObjectiveNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutObjectiveNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutObjectiveNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutObjectiveNestedInput
    elemen?: ElementUpdateOneRequiredWithoutObjectiveNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutObjectiveNestedInput
    material?: OMaterialUpdateManyWithoutRefNestedInput
    tracker?: TrackerUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUpdateManyWithoutRefNestedInput
    ppp?: OpppUpdateManyWithoutRefNestedInput
    tool?: OhelperUpdateManyWithoutToolNestedInput
    mate?: OhelperUpdateManyWithoutMateNestedInput
    media?: OhelperUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateWithoutMethInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    toolIds?: ObjectiveUpdatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveUpdatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveUpdatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveUpdatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedUpdateManyWithoutRefNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUncheckedUpdateManyWithoutRefNestedInput
    ppp?: OpppUncheckedUpdateManyWithoutRefNestedInput
    tool?: OhelperUncheckedUpdateManyWithoutToolNestedInput
    mate?: OhelperUncheckedUpdateManyWithoutMateNestedInput
    media?: OhelperUncheckedUpdateManyWithoutMediaNestedInput
    assessments?: OAssessmentUncheckedUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUncheckedUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateManyWithoutMethInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    toolIds?: ObjectiveUpdatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveUpdatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveUpdatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveUpdatemediaIdsInput | Enumerable<string>
  }

  export type ObjectiveUpdateWithoutMediaInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutObjectiveNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutObjectiveNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutObjectiveNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutObjectiveNestedInput
    elemen?: ElementUpdateOneRequiredWithoutObjectiveNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutObjectiveNestedInput
    material?: OMaterialUpdateManyWithoutRefNestedInput
    tracker?: TrackerUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUpdateManyWithoutRefNestedInput
    ppp?: OpppUpdateManyWithoutRefNestedInput
    tool?: OhelperUpdateManyWithoutToolNestedInput
    mate?: OhelperUpdateManyWithoutMateNestedInput
    meth?: OhelperUpdateManyWithoutMethNestedInput
    assessments?: OAssessmentUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateWithoutMediaInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    toolIds?: ObjectiveUpdatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveUpdatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveUpdatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveUpdatemediaIdsInput | Enumerable<string>
    material?: OMaterialUncheckedUpdateManyWithoutRefNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTujuanNestedInput
    resourse?: OresourceUncheckedUpdateManyWithoutRefNestedInput
    ppp?: OpppUncheckedUpdateManyWithoutRefNestedInput
    tool?: OhelperUncheckedUpdateManyWithoutToolNestedInput
    mate?: OhelperUncheckedUpdateManyWithoutMateNestedInput
    meth?: OhelperUncheckedUpdateManyWithoutMethNestedInput
    assessments?: OAssessmentUncheckedUpdateManyWithoutRefNestedInput
    devices?: TDeviceDataUncheckedUpdateManyWithoutObjectiveNestedInput
  }

  export type ObjectiveUncheckedUpdateManyWithoutMediaInput = {
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    elementId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    kkm?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    subjectMatter?: StringFieldUpdateOperationsInput | string
    competencie?: ObjectiveUpdatecompetencieInput | Enumerable<string>
    firstSkill?: ObjectiveUpdatefirstSkillInput | Enumerable<string>
    triggerQuest?: ObjectiveUpdatetriggerQuestInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    toolIds?: ObjectiveUpdatetoolIdsInput | Enumerable<string>
    mateIds?: ObjectiveUpdatemateIdsInput | Enumerable<string>
    methIds?: ObjectiveUpdatemethIdsInput | Enumerable<string>
    mediaIds?: ObjectiveUpdatemediaIdsInput | Enumerable<string>
  }

  export type TrackerCreateManyPerangkatInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type TDeviceDataCreateManyRefInput = {
    id?: string
    objectiveId: string
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type TDeviceCreateManyParentInput = {
    id?: string
    name: string
    level: number
    fase: Fase
    teachingId: string
    property: XOR<TDevicePropsCreateEnvelopeInput, TDevicePropsCreateInput>
    yearId: string
    userId: string
    instansiId: string
    mapelId: string
    classRoomIds?: TDeviceCreateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceCreateelemenInput | Enumerable<string>
    disable?: boolean
    positions?: XOR<TDevicePosListCreateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type TDevicePosUpdateInput = {
    mouth?: IntFieldUpdateOperationsInput | number
    week?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassRoomUpdateWithoutTDeviceInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    property?: XOR<RoomPropertyNullableUpdateEnvelopeInput, RoomPropertyCreateInput> | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    year?: SchoolYearUpdateOneRequiredWithoutClassRoomNestedInput
    wali?: TeacherUpdateOneRequiredWithoutClassRoomNestedInput
    major?: KonsentrasiKeahlianUpdateOneWithoutClassRoomNestedInput
    students?: StudentUpdateManyWithoutClassRoomNestedInput
    event?: CalendarUpdateManyWithoutClassRoomNestedInput
    tracker?: TrackerUpdateManyWithoutKelasNestedInput
    teaching?: TeachingUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomUncheckedUpdateWithoutTDeviceInput = {
    name?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    waliId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    property?: XOR<RoomPropertyNullableUpdateEnvelopeInput, RoomPropertyCreateInput> | null
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    studentIds?: ClassRoomUpdatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomUpdateeventIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    teachingIds?: ClassRoomUpdateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomUpdatetDeviceIdsInput | Enumerable<string>
    students?: StudentUncheckedUpdateManyWithoutClassRoomNestedInput
    event?: CalendarUncheckedUpdateManyWithoutClassRoomNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutKelasNestedInput
    teaching?: TeachingUncheckedUpdateManyWithoutClassRoomNestedInput
  }

  export type TrackerUpdateWithoutPerangkatInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrackerNestedInput
    ref?: InstansiUpdateOneRequiredWithoutHistoryNestedInput
    instansi?: InstansiUpdateOneWithoutTrackerNestedInput
    mapel?: MataPelajaranUpdateOneWithoutTrackerNestedInput
    elemen?: ElementUpdateOneWithoutTrackerNestedInput
    cp?: AchievementUpdateOneWithoutTrackerNestedInput
    bidang?: BidangKeahlianUpdateOneWithoutTrackerNestedInput
    program?: ProgramKeahlianUpdateOneWithoutTrackerNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateOneWithoutTrackerNestedInput
    tp?: SchoolYearUpdateOneWithoutTrackerNestedInput
    teacher?: TeacherUpdateOneWithoutTrackerNestedInput
    kelas?: ClassRoomUpdateOneWithoutTrackerNestedInput
    murid?: StudentUpdateOneWithoutTrackerNestedInput
    jadwal?: ScheduleUpdateOneWithoutTrackerNestedInput
    mengajar?: TeachingUpdateOneWithoutTrackerNestedInput
    tujuan?: ObjectiveUpdateOneWithoutTrackerNestedInput
    kalender?: CalendarUpdateOneWithoutTrackerNestedInput
    dudi?: DudiUpdateOneWithoutTrackerNestedInput
    kkni?: KkniUpdateOneWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateWithoutPerangkatInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    userId?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapelId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    cpId?: NullableStringFieldUpdateOperationsInput | string | null
    bidangId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    konsentrasiId?: NullableStringFieldUpdateOperationsInput | string | null
    tpId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    kelasId?: NullableStringFieldUpdateOperationsInput | string | null
    muridId?: NullableStringFieldUpdateOperationsInput | string | null
    jadwalId?: NullableStringFieldUpdateOperationsInput | string | null
    mengajarId?: NullableStringFieldUpdateOperationsInput | string | null
    tujuanId?: NullableStringFieldUpdateOperationsInput | string | null
    kalenderId?: NullableStringFieldUpdateOperationsInput | string | null
    dudiId?: NullableStringFieldUpdateOperationsInput | string | null
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TDeviceDataUpdateWithoutRefInput = {
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    objective?: ObjectiveUpdateOneRequiredWithoutDevicesNestedInput
  }

  export type TDeviceDataUncheckedUpdateWithoutRefInput = {
    objectiveId?: StringFieldUpdateOperationsInput | string
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type TDeviceDataUncheckedUpdateManyWithoutDataInput = {
    objectiveId?: StringFieldUpdateOperationsInput | string
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type TDeviceUpdateWithoutParentInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    teaching?: TeachingUpdateOneRequiredWithoutTDeviceNestedInput
    year?: SchoolYearUpdateOneRequiredWithoutTDeviceNestedInput
    user?: UserUpdateOneRequiredWithoutTDeviceNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutTDeviceNestedInput
    mapel?: MataPelajaranUpdateOneRequiredWithoutDeviceNestedInput
    classRoom?: ClassRoomUpdateManyWithoutTDeviceNestedInput
    tracker?: TrackerUpdateManyWithoutPerangkatNestedInput
    data?: TDeviceDataUpdateManyWithoutRefNestedInput
    children?: TDeviceUpdateManyWithoutParentNestedInput
  }

  export type TDeviceUncheckedUpdateWithoutParentInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    teachingId?: StringFieldUpdateOperationsInput | string
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    yearId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: TDeviceUpdateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
    classRoom?: ClassRoomUncheckedUpdateManyWithoutTDeviceNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutPerangkatNestedInput
    data?: TDeviceDataUncheckedUpdateManyWithoutRefNestedInput
    children?: TDeviceUncheckedUpdateManyWithoutParentNestedInput
  }

  export type TDeviceUncheckedUpdateManyWithoutChildrenInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    fase?: EnumFaseFieldUpdateOperationsInput | Fase
    teachingId?: StringFieldUpdateOperationsInput | string
    property?: XOR<TDevicePropsUpdateEnvelopeInput, TDevicePropsCreateInput>
    yearId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    mapelId?: StringFieldUpdateOperationsInput | string
    classRoomIds?: TDeviceUpdateclassRoomIdsInput | Enumerable<string>
    elemen?: TDeviceUpdateelemenInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    positions?: XOR<TDevicePosListUpdateEnvelopeInput, Enumerable<TDevicePosCreateInput>>
  }

  export type TrackerCreateManyKalenderInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    dudiId?: string | null
    kkniId?: string | null
  }

  export type ClassRoomUpdateWithoutEventInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    property?: XOR<RoomPropertyNullableUpdateEnvelopeInput, RoomPropertyCreateInput> | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    year?: SchoolYearUpdateOneRequiredWithoutClassRoomNestedInput
    wali?: TeacherUpdateOneRequiredWithoutClassRoomNestedInput
    major?: KonsentrasiKeahlianUpdateOneWithoutClassRoomNestedInput
    students?: StudentUpdateManyWithoutClassRoomNestedInput
    tracker?: TrackerUpdateManyWithoutKelasNestedInput
    teaching?: TeachingUpdateManyWithoutClassRoomNestedInput
    tDevice?: TDeviceUpdateManyWithoutClassRoomNestedInput
  }

  export type ClassRoomUncheckedUpdateWithoutEventInput = {
    name?: StringFieldUpdateOperationsInput | string
    yearId?: StringFieldUpdateOperationsInput | string
    waliId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    property?: XOR<RoomPropertyNullableUpdateEnvelopeInput, RoomPropertyCreateInput> | null
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    studentIds?: ClassRoomUpdatestudentIdsInput | Enumerable<string>
    eventIds?: ClassRoomUpdateeventIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    teachingIds?: ClassRoomUpdateteachingIdsInput | Enumerable<string>
    tDeviceIds?: ClassRoomUpdatetDeviceIdsInput | Enumerable<string>
    students?: StudentUncheckedUpdateManyWithoutClassRoomNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutKelasNestedInput
    teaching?: TeachingUncheckedUpdateManyWithoutClassRoomNestedInput
    tDevice?: TDeviceUncheckedUpdateManyWithoutClassRoomNestedInput
  }

  export type StudentUpdateWithoutEventInput = {
    nis?: StringFieldUpdateOperationsInput | string
    lastSchool?: StringFieldUpdateOperationsInput | string
    disable?: BoolFieldUpdateOperationsInput | boolean
    personal?: PersonalUpdateOneRequiredWithoutStudentNestedInput
    major?: KonsentrasiKeahlianUpdateOneWithoutStudentNestedInput
    classRoom?: ClassRoomUpdateManyWithoutStudentsNestedInput
    startYear?: SchoolYearUpdateOneRequiredWithoutStudentsNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutStudentNestedInput
    tracker?: TrackerUpdateManyWithoutMuridNestedInput
  }

  export type StudentUncheckedUpdateWithoutEventInput = {
    nis?: StringFieldUpdateOperationsInput | string
    lastSchool?: StringFieldUpdateOperationsInput | string
    personalId?: StringFieldUpdateOperationsInput | string
    majorId?: NullableStringFieldUpdateOperationsInput | string | null
    classRoomIds?: StudentUpdateclassRoomIdsInput | Enumerable<string>
    startYearId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: StudentUpdateeventIdsInput | Enumerable<string>
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutStudentsNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutMuridNestedInput
  }

  export type TeacherUpdateWithoutEventInput = {
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tmtGol?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    personal?: PersonalUpdateOneRequiredWithoutTeacherNestedInput
    classRoom?: ClassRoomUpdateManyWithoutWaliNestedInput
    instansi?: InstansiUpdateOneRequiredWithoutTeacherNestedInput
    tracker?: TrackerUpdateManyWithoutTeacherNestedInput
    teaching?: TeachingUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutEventInput = {
    personalId?: StringFieldUpdateOperationsInput | string
    instansiId?: StringFieldUpdateOperationsInput | string
    eventIds?: TeacherUpdateeventIdsInput | Enumerable<string>
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    nrg?: NullableStringFieldUpdateOperationsInput | string | null
    noKarpeg?: NullableStringFieldUpdateOperationsInput | string | null
    tmtTugas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tmtGol?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    disable?: BoolFieldUpdateOperationsInput | boolean
    classRoom?: ClassRoomUncheckedUpdateManyWithoutWaliNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutTeacherNestedInput
    teaching?: TeachingUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TrackerUpdateWithoutKalenderInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrackerNestedInput
    ref?: InstansiUpdateOneRequiredWithoutHistoryNestedInput
    instansi?: InstansiUpdateOneWithoutTrackerNestedInput
    mapel?: MataPelajaranUpdateOneWithoutTrackerNestedInput
    elemen?: ElementUpdateOneWithoutTrackerNestedInput
    cp?: AchievementUpdateOneWithoutTrackerNestedInput
    bidang?: BidangKeahlianUpdateOneWithoutTrackerNestedInput
    program?: ProgramKeahlianUpdateOneWithoutTrackerNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateOneWithoutTrackerNestedInput
    tp?: SchoolYearUpdateOneWithoutTrackerNestedInput
    teacher?: TeacherUpdateOneWithoutTrackerNestedInput
    kelas?: ClassRoomUpdateOneWithoutTrackerNestedInput
    murid?: StudentUpdateOneWithoutTrackerNestedInput
    jadwal?: ScheduleUpdateOneWithoutTrackerNestedInput
    mengajar?: TeachingUpdateOneWithoutTrackerNestedInput
    tujuan?: ObjectiveUpdateOneWithoutTrackerNestedInput
    perangkat?: TDeviceUpdateOneWithoutTrackerNestedInput
    dudi?: DudiUpdateOneWithoutTrackerNestedInput
    kkni?: KkniUpdateOneWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateWithoutKalenderInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    userId?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapelId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    cpId?: NullableStringFieldUpdateOperationsInput | string | null
    bidangId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    konsentrasiId?: NullableStringFieldUpdateOperationsInput | string | null
    tpId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    kelasId?: NullableStringFieldUpdateOperationsInput | string | null
    muridId?: NullableStringFieldUpdateOperationsInput | string | null
    jadwalId?: NullableStringFieldUpdateOperationsInput | string | null
    mengajarId?: NullableStringFieldUpdateOperationsInput | string | null
    tujuanId?: NullableStringFieldUpdateOperationsInput | string | null
    perangkatId?: NullableStringFieldUpdateOperationsInput | string | null
    dudiId?: NullableStringFieldUpdateOperationsInput | string | null
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DudiLearningCreateManyRefInput = {
    id?: string
    no: number
    code: string
    name: string
    indicator?: XOR<DudiIndicatorListCreateEnvelopeInput, Enumerable<DudiIndicatorCreateInput>>
  }

  export type TrackerCreateManyDudiInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    kkniId?: string | null
  }

  export type DudiTimeWorkUpdateholidaysInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type DudiLearningUpdateWithoutRefInput = {
    no?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    indicator?: XOR<DudiIndicatorListUpdateEnvelopeInput, Enumerable<DudiIndicatorCreateInput>>
  }

  export type DudiLearningUncheckedUpdateWithoutRefInput = {
    no?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    indicator?: XOR<DudiIndicatorListUpdateEnvelopeInput, Enumerable<DudiIndicatorCreateInput>>
  }

  export type DudiLearningUncheckedUpdateManyWithoutLearningInput = {
    no?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    indicator?: XOR<DudiIndicatorListUpdateEnvelopeInput, Enumerable<DudiIndicatorCreateInput>>
  }

  export type TrackerUpdateWithoutDudiInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrackerNestedInput
    ref?: InstansiUpdateOneRequiredWithoutHistoryNestedInput
    instansi?: InstansiUpdateOneWithoutTrackerNestedInput
    mapel?: MataPelajaranUpdateOneWithoutTrackerNestedInput
    elemen?: ElementUpdateOneWithoutTrackerNestedInput
    cp?: AchievementUpdateOneWithoutTrackerNestedInput
    bidang?: BidangKeahlianUpdateOneWithoutTrackerNestedInput
    program?: ProgramKeahlianUpdateOneWithoutTrackerNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateOneWithoutTrackerNestedInput
    tp?: SchoolYearUpdateOneWithoutTrackerNestedInput
    teacher?: TeacherUpdateOneWithoutTrackerNestedInput
    kelas?: ClassRoomUpdateOneWithoutTrackerNestedInput
    murid?: StudentUpdateOneWithoutTrackerNestedInput
    jadwal?: ScheduleUpdateOneWithoutTrackerNestedInput
    mengajar?: TeachingUpdateOneWithoutTrackerNestedInput
    tujuan?: ObjectiveUpdateOneWithoutTrackerNestedInput
    perangkat?: TDeviceUpdateOneWithoutTrackerNestedInput
    kalender?: CalendarUpdateOneWithoutTrackerNestedInput
    kkni?: KkniUpdateOneWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateWithoutDudiInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    userId?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapelId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    cpId?: NullableStringFieldUpdateOperationsInput | string | null
    bidangId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    konsentrasiId?: NullableStringFieldUpdateOperationsInput | string | null
    tpId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    kelasId?: NullableStringFieldUpdateOperationsInput | string | null
    muridId?: NullableStringFieldUpdateOperationsInput | string | null
    jadwalId?: NullableStringFieldUpdateOperationsInput | string | null
    mengajarId?: NullableStringFieldUpdateOperationsInput | string | null
    tujuanId?: NullableStringFieldUpdateOperationsInput | string | null
    perangkatId?: NullableStringFieldUpdateOperationsInput | string | null
    kalenderId?: NullableStringFieldUpdateOperationsInput | string | null
    kkniId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DudiIndicatorUpdateInput = {
    no?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DudiCreateManyKkniInput = {
    id?: string
    name: string
    street: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    instansiId: string
    majorId: string
    contact: XOR<ContactDudiCreateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiCreatecollabsInput | Enumerable<string>
    timework: XOR<DudiTimeWorkCreateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: boolean
  }

  export type TrackerCreateManyKkniInput = {
    id?: string
    point: PointTracker
    type: TypeTracker
    userId: string
    refId: string
    instansiId?: string | null
    createdAt?: Date | string
    mapelId?: string | null
    elementId?: string | null
    cpId?: string | null
    bidangId?: string | null
    programId?: string | null
    konsentrasiId?: string | null
    tpId?: string | null
    teacherId?: string | null
    kelasId?: string | null
    muridId?: string | null
    jadwalId?: string | null
    mengajarId?: string | null
    tujuanId?: string | null
    perangkatId?: string | null
    kalenderId?: string | null
    dudiId?: string | null
  }

  export type DudiUpdateWithoutKkniInput = {
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    contact?: XOR<ContactDudiUpdateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiUpdatecollabsInput | Enumerable<string>
    timework?: XOR<DudiTimeWorkUpdateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    instansi?: InstansiUpdateOneRequiredWithoutDudiNestedInput
    major?: KonsentrasiKeahlianUpdateOneRequiredWithoutDudiNestedInput
    learning?: DudiLearningUpdateManyWithoutRefNestedInput
    tracker?: TrackerUpdateManyWithoutDudiNestedInput
  }

  export type DudiUncheckedUpdateWithoutKkniInput = {
    name?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    instansiId?: StringFieldUpdateOperationsInput | string
    majorId?: StringFieldUpdateOperationsInput | string
    contact?: XOR<ContactDudiUpdateEnvelopeInput, ContactDudiCreateInput>
    collabs?: DudiUpdatecollabsInput | Enumerable<string>
    timework?: XOR<DudiTimeWorkUpdateEnvelopeInput, DudiTimeWorkCreateInput>
    disable?: BoolFieldUpdateOperationsInput | boolean
    learning?: DudiLearningUncheckedUpdateManyWithoutRefNestedInput
    tracker?: TrackerUncheckedUpdateManyWithoutDudiNestedInput
  }

  export type TrackerUpdateWithoutKkniInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrackerNestedInput
    ref?: InstansiUpdateOneRequiredWithoutHistoryNestedInput
    instansi?: InstansiUpdateOneWithoutTrackerNestedInput
    mapel?: MataPelajaranUpdateOneWithoutTrackerNestedInput
    elemen?: ElementUpdateOneWithoutTrackerNestedInput
    cp?: AchievementUpdateOneWithoutTrackerNestedInput
    bidang?: BidangKeahlianUpdateOneWithoutTrackerNestedInput
    program?: ProgramKeahlianUpdateOneWithoutTrackerNestedInput
    konsentrasi?: KonsentrasiKeahlianUpdateOneWithoutTrackerNestedInput
    tp?: SchoolYearUpdateOneWithoutTrackerNestedInput
    teacher?: TeacherUpdateOneWithoutTrackerNestedInput
    kelas?: ClassRoomUpdateOneWithoutTrackerNestedInput
    murid?: StudentUpdateOneWithoutTrackerNestedInput
    jadwal?: ScheduleUpdateOneWithoutTrackerNestedInput
    mengajar?: TeachingUpdateOneWithoutTrackerNestedInput
    tujuan?: ObjectiveUpdateOneWithoutTrackerNestedInput
    perangkat?: TDeviceUpdateOneWithoutTrackerNestedInput
    kalender?: CalendarUpdateOneWithoutTrackerNestedInput
    dudi?: DudiUpdateOneWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateWithoutKkniInput = {
    point?: EnumPointTrackerFieldUpdateOperationsInput | PointTracker
    type?: EnumTypeTrackerFieldUpdateOperationsInput | TypeTracker
    userId?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    instansiId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapelId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    cpId?: NullableStringFieldUpdateOperationsInput | string | null
    bidangId?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableStringFieldUpdateOperationsInput | string | null
    konsentrasiId?: NullableStringFieldUpdateOperationsInput | string | null
    tpId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    kelasId?: NullableStringFieldUpdateOperationsInput | string | null
    muridId?: NullableStringFieldUpdateOperationsInput | string | null
    jadwalId?: NullableStringFieldUpdateOperationsInput | string | null
    mengajarId?: NullableStringFieldUpdateOperationsInput | string | null
    tujuanId?: NullableStringFieldUpdateOperationsInput | string | null
    perangkatId?: NullableStringFieldUpdateOperationsInput | string | null
    kalenderId?: NullableStringFieldUpdateOperationsInput | string | null
    dudiId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CoordinateWhereInput = {
    AND?: Enumerable<CoordinateWhereInput>
    OR?: Enumerable<CoordinateWhereInput>
    NOT?: Enumerable<CoordinateWhereInput>
    longitude?: FloatFilter | number
    latitude?: FloatFilter | number
  }

  export type NestedEnumLevelEduFilter = {
    equals?: LevelEdu
    in?: Enumerable<LevelEdu>
    notIn?: Enumerable<LevelEdu>
    not?: NestedEnumLevelEduFilter | LevelEdu
  }

  export type CoordinateUpdateInput = {
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
  }

  export type GoogleUpdatescopesInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type EnumLevelEduFieldUpdateOperationsInput = {
    set?: LevelEdu
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}